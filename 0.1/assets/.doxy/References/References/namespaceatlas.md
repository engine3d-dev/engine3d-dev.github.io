

# Namespace atlas



[**Namespace List**](namespaces.md) **>** [**atlas**](namespaceatlas.md)


















## Namespaces

| Type | Name |
| ---: | :--- |
| namespace | [**event**](namespaceatlas_1_1event.md) <br> |
| namespace | [**filesystem**](namespaceatlas_1_1filesystem.md) <br> |
| namespace | [**physics**](namespaceatlas_1_1physics.md) <br> |
| namespace | [**sync\_update**](namespaceatlas_1_1sync__update.md) <br> |
| namespace | [**ui**](namespaceatlas_1_1ui.md) <br> |
| namespace | [**vk**](namespaceatlas_1_1vk.md) <br> |


## Classes

| Type | Name |
| ---: | :--- |
| struct | [**DescriptorSet**](classatlas_1_1DescriptorSet.md) <br> |
| struct | [**DescriptorSetLayout**](structatlas_1_1DescriptorSetLayout.md) <br> |
| struct | [**DirectionalLightUbo**](structatlas_1_1DirectionalLightUbo.md) <br> |
| class | [**Framebuffer**](classatlas_1_1Framebuffer.md) <br> |
| class | [**Image**](classatlas_1_1Image.md) <br> |
| struct | [**ImageSampler**](structatlas_1_1ImageSampler.md) <br> |
| class | [**ParallelUpdateManager**](classatlas_1_1ParallelUpdateManager.md) <br> |
| class | [**Pipeline**](classatlas_1_1Pipeline.md) <br> |
| struct | [**PointLightUbo**](structatlas_1_1PointLightUbo.md) <br> |
| struct | [**SpotLightUbo**](structatlas_1_1SpotLightUbo.md) <br> |
| class | [**UniformBuffer**](classatlas_1_1UniformBuffer.md) <br> |
| class | [**VulkanImGui**](classatlas_1_1VulkanImGui.md) <br> |
| class | [**application**](classatlas_1_1application.md) <br> |
| struct | [**application\_settings**](structatlas_1_1application__settings.md) <br> |
| struct | [**box\_collider3d**](structatlas_1_1box__collider3d.md) <br> |
| class | [**camera**](classatlas_1_1camera.md) <br> |
| struct | [**camera\_ubo**](structatlas_1_1camera__ubo.md) <br> |
| class | [**console\_log\_manager**](classatlas_1_1console__log__manager.md) <br> |
| class | [**entity\_t**](classatlas_1_1entity__t.md) <br> |
| class | [**imgui\_backend**](classatlas_1_1imgui__backend.md) <br> |
| class | [**index\_buffer**](classatlas_1_1index__buffer.md) <br> |
| class | [**interpolation**](classatlas_1_1interpolation.md) <br> |
| struct | [**light**](structatlas_1_1light.md) <br>_TODO: Make this better (when we do lighting)_  |
| struct | [**math\_generic**](structatlas_1_1math__generic.md) &lt;typename T&gt;<br> |
| struct | [**matrix2**](structatlas_1_1matrix2.md) &lt;typename T&gt;<br> |
| struct | [**matrix3**](structatlas_1_1matrix3.md) &lt;typename T&gt;<br> |
| struct | [**matrix4**](structatlas_1_1matrix4.md) &lt;typename T&gt;<br> |
| class | [**mesh**](classatlas_1_1mesh.md) <br> |
| class | [**render\_context**](classatlas_1_1render__context.md) <br> |
| class | [**renderer**](classatlas_1_1renderer.md) <br> |
| class | [**renderpass**](classatlas_1_1renderpass.md) <br> |
| struct | [**renderpass\_properties**](structatlas_1_1renderpass__properties.md) <br> |
| struct | [**rendertarget3d**](structatlas_1_1rendertarget3d.md) <br> |
| struct | [**rigidbody3d**](structatlas_1_1rigidbody3d.md) <br> |
| class | [**scene\_object**](classatlas_1_1scene__object.md) <br> |
| class | [**scene\_scope**](classatlas_1_1scene__scope.md) <br> |
| class | [**serializer**](classatlas_1_1serializer.md) <br> |
| class | [**shader**](classatlas_1_1shader.md) <br> |
| class | [**swapchain**](classatlas_1_1swapchain.md) <br> |
| class | [**system\_registry**](classatlas_1_1system__registry.md) <br> |
| struct | [**tag**](structatlas_1_1tag.md) <br> |
| class | [**thread**](classatlas_1_1thread.md) <br> |
| class | [**timer**](classatlas_1_1timer.md) <br> |
| struct | [**transform**](structatlas_1_1transform.md) <br> |
| struct | [**vector2**](structatlas_1_1vector2.md) &lt;typename T&gt;<br> |
| struct | [**vector2&lt; glm::highp\_vec2 &gt;**](structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4.md) &lt;&gt;<br> |
| struct | [**vector3**](structatlas_1_1vector3.md) &lt;typename T&gt;<br> |
| struct | [**vector3&lt; JPH::Vec3 &gt;**](structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4.md) &lt;&gt;<br> |
| struct | [**vector3&lt; glm::highp\_vec3 &gt;**](structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4.md) &lt;&gt;<br> |
| struct | [**vector4**](structatlas_1_1vector4.md) &lt;typename T&gt;<br> |
| struct | [**vector4&lt; glm::highp\_vec4 &gt;**](structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4.md) &lt;&gt;<br> |
| struct | [**vertex**](structatlas_1_1vertex.md) <br> |
| class | [**vertex\_buffer**](classatlas_1_1vertex__buffer.md) <br> |
| class | [**window**](classatlas_1_1window.md) <br> |
| class | [**world\_scope**](classatlas_1_1world__scope.md) <br>_Lets rethink how_ [_**world\_scope**_](classatlas_1_1world__scope.md) _gets created._ |


## Public Types

| Type | Name |
| ---: | :--- |
| enum  | [**API**](#enum-api)  <br> |
| enum  | [**CameraMovement**](#enum-cameramovement)  <br> |
| enum  | [**ImageFormat**](#enum-imageformat)  <br> |
| enum  | [**ImageLayout**](#enum-imagelayout)  <br> |
| enum  | [**PipelineStageFlags**](#enum-pipelinestageflags)  <br> |
| enum  | [**ShaderAccessOperation**](#enum-shaderaccessoperation)  <br> |
| enum int | [**SubpassContents**](#enum-subpasscontents)  <br> |
| typedef [**vector2**](structatlas_1_1vector2.md)&lt; glm::highp\_vec2 &gt; | [**highp\_vec2**](#typedef-highp_vec2)  <br> |
| typedef [**vector3**](structatlas_1_1vector3.md)&lt; glm::highp\_vec3 &gt; | [**highp\_vec3**](#typedef-highp_vec3)  <br> |
| typedef [**vector4**](structatlas_1_1vector4.md)&lt; glm::highp\_vec4 &gt; | [**highp\_vec4**](#typedef-highp_vec4)  <br> |
| typedef [**math\_generic**](structatlas_1_1math__generic.md)&lt; glm::mat&lt; C, R, T &gt; &gt; | [**mat**](#typedef-mat)  <br> |
| typedef [**matrix2**](structatlas_1_1matrix2.md)&lt; glm::mat2 &gt; | [**mat2**](#typedef-mat2)  <br> |
| typedef [**matrix3**](structatlas_1_1matrix3.md)&lt; glm::mat3 &gt; | [**mat3**](#typedef-mat3)  <br> |
| typedef [**matrix4**](structatlas_1_1matrix4.md)&lt; glm::mat4 &gt; | [**mat4**](#typedef-mat4)  <br> |
| typedef std::shared\_ptr&lt; T &gt; | [**ref**](#typedef-ref)  <br> |
| typedef std::unique\_ptr&lt; T &gt; | [**scope**](#typedef-scope)  <br> |
| typedef [**math\_generic**](structatlas_1_1math__generic.md)&lt; glm::vec&lt; Size, T &gt; &gt; | [**vec**](#typedef-vec)  <br> |
| typedef [**vector2**](structatlas_1_1vector2.md)&lt; glm::vec2 &gt; | [**vec2**](#typedef-vec2)  <br> |
| typedef [**vector3**](structatlas_1_1vector3.md)&lt; glm::vec3 &gt; | [**vec3**](#typedef-vec3)  <br> |
| typedef [**vector4**](structatlas_1_1vector4.md)&lt; glm::vec4 &gt; | [**vec4**](#typedef-vec4)  <br> |
| typedef std::weak\_ptr&lt; T &gt; | [**weak\_ptr**](#typedef-weak_ptr)  <br> |




















## Public Functions

| Type | Name |
| ---: | :--- |
|  void | [**attach**](#function-attach) (UObject \* p\_instance, const UCallable & p\_callable) <br> |
|  constexpr ref&lt; T &gt; | [**create\_ref**](#function-create_ref) (Args &&... args) <br> |
|  constexpr scope&lt; T &gt; | [**create\_scope**](#function-create_scope) (Args &&... args) <br> |
|  constexpr weak\_ptr&lt; T &gt; | [**create\_weak\_ptr**](#function-create_weak_ptr) (Args &&... args) <br> |
|  uint32\_t | [**get\_thread\_count**](#function-get_thread_count) () <br> |
|  void | [**hash\_combine**](#function-hash_combine) (size\_t & seed, const T & v, const Rest &... rest) <br> |
|  ref&lt; [**application**](classatlas_1_1application.md) &gt; | [**initialize\_application**](#function-initialize_application) () <br> |
|  void | [**post**](#function-post) (UObject \* p\_instance, const UCallable & p\_callable) <br> |
|  void | [**sync**](#function-sync) (UObject \* p\_instance, const UCallable & p\_callable) <br> |
|  void | [**sync\_physics**](#function-sync_physics) (UObject \* p\_instance, const UCallable & p\_callable) <br> |
|  weak\_ptr&lt; T &gt; | [**to\_weak\_ptr**](#function-to_weak_ptr) (const U & p\_value) <br> |


## Public Static Functions

| Type | Name |
| ---: | :--- |
|  void | [**core\_assert**](#function-core_assert) (bool x, T &&... args) <br> |


























## Public Types Documentation




### enum API 

```C++
enum atlas::API {
    VULKAN,
    DIRECTX11,
    DIRECTX12,
    UNSPECIFIED
};
```




<hr>



### enum CameraMovement 

```C++
enum atlas::CameraMovement {
    Forward,
    Backward,
    Left,
    Right,
    Up,
    Down
};
```




<hr>



### enum ImageFormat 

```C++
enum atlas::ImageFormat {
    RED,
    RGBA8,
    RGBA16,
    DEPTH24_STENCIL8,
    DEFAULT = DEPTH24_STENCIL8
};
```





**Note:**

Used to specify what attachment type for per render pass 




**Note:**

Usage: Format that is defaulted to throughout the vulkan abstraction 




**Note:**

Meaning not just used for attachment formats, also image formats 





        

<hr>



### enum ImageLayout 

```C++
enum atlas::ImageLayout {
    UNDEFINED,
    IMAGE_OPTIMAL,
    COLOR_ATTACHMENT,
    DEPTH_STENCIL_ATTACHMENT_READ_WRITE,
    DEPTH_STENCIL_READ,
    TRANSFER_SRC,
    TRANSFER_DST,
    PREINITIALIZED,
    STENCIL_READ_WRITE_DEPTH_READ_ONLY,
    DEPTH_READ_WRITE_STENCIL_READ_ONLY
};
```





**Note:**

Used for specifying the type of image layout for getting accessed 





        

<hr>



### enum PipelineStageFlags 

```C++
enum atlas::PipelineStageFlags {
    COLOR_ATTACHMENT
};
```




<hr>



### enum ShaderAccessOperation 

```C++
enum atlas::ShaderAccessOperation {
    DONT_CARE,
    LOAD,
    STORE,
    DEFAULT = DONT_CARE
};
```





**Note:**

Enum for indicating state of what access shaders have 




**Note:**

Usage: as a bitfield 





        

<hr>



### enum SubpassContents 

```C++
enum atlas::SubpassContents {
    INLINE = 0,
    SECONDARY_COMMAND_BUFFERS = 1,
    INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR = 2,
    INLINE_AND_COMMAND_BUFFERS_EXT = 3
};
```




<hr>



### typedef highp\_vec2 

```C++
using atlas::highp_vec2 = typedef vector2<glm::highp_vec2>;
```




<hr>



### typedef highp\_vec3 

```C++
using atlas::highp_vec3 = typedef vector3<glm::highp_vec3>;
```




<hr>



### typedef highp\_vec4 

```C++
using atlas::highp_vec4 = typedef vector4<glm::highp_vec4>;
```




<hr>



### typedef mat 

```C++
using atlas::mat = typedef math_generic<glm::mat<C, R, T> >;
```




<hr>



### typedef mat2 

```C++
using atlas::mat2 = typedef matrix2<glm::mat2>;
```




<hr>



### typedef mat3 

```C++
using atlas::mat3 = typedef matrix3<glm::mat3>;
```




<hr>



### typedef mat4 

```C++
using atlas::mat4 = typedef matrix4<glm::mat4>;
```




<hr>



### typedef ref 

```C++
using atlas::ref = typedef std::shared_ptr<T>;
```





**Note:**

Some aliases for the smart pointers 





        

<hr>



### typedef scope 

```C++
using atlas::scope = typedef std::unique_ptr<T>;
```




<hr>



### typedef vec 

```C++
using atlas::vec = typedef math_generic<glm::vec<Size, T> >;
```





**Note:**

By default we use glm 





        

<hr>



### typedef vec2 

```C++
using atlas::vec2 = typedef vector2<glm::vec2>;
```




<hr>



### typedef vec3 

```C++
using atlas::vec3 = typedef vector3<glm::vec3>;
```




<hr>



### typedef vec4 

```C++
using atlas::vec4 = typedef vector4<glm::vec4>;
```




<hr>



### typedef weak\_ptr 

```C++
using atlas::weak_ptr = typedef std::weak_ptr<T>;
```




<hr>
## Public Functions Documentation




### function attach 

```C++
template<typename UObject, typename UCallable>
void atlas::attach (
    UObject * p_instance,
    const UCallable & p_callable
) 
```




<hr>



### function create\_ref 

```C++
template<typename T, typename... Args>
constexpr ref< T > atlas::create_ref (
    Args &&... args
) 
```




<hr>



### function create\_scope 

```C++
template<typename T, typename... Args>
constexpr scope< T > atlas::create_scope (
    Args &&... args
) 
```




<hr>



### function create\_weak\_ptr 

```C++
template<typename T, typename... Args>
constexpr weak_ptr< T > atlas::create_weak_ptr (
    Args &&... args
) 
```




<hr>



### function get\_thread\_count 

```C++
uint32_t atlas::get_thread_count () 
```




<hr>



### function hash\_combine 

```C++
template<typename T, typename... Rest>
void atlas::hash_combine (
    size_t & seed,
    const T & v,
    const Rest &... rest
) 
```




<hr>



### function initialize\_application 

```C++
ref< application > atlas::initialize_application () 
```




<hr>



### function post 

```C++
template<typename UObject, typename UCallable>
void atlas::post (
    UObject * p_instance,
    const UCallable & p_callable
) 
```




<hr>



### function sync 

```C++
template<typename UObject, typename UCallable>
void atlas::sync (
    UObject * p_instance,
    const UCallable & p_callable
) 
```





**Note:**

These are public functions that users can utilize 




**Note:**

If users are using anything within the sync\_update namespace. They shouldn't 





        

<hr>



### function sync\_physics 

```C++
template<typename UObject, typename UCallable>
void atlas::sync_physics (
    UObject * p_instance,
    const UCallable & p_callable
) 
```




<hr>



### function to\_weak\_ptr 

```C++
template<typename T, typename U>
weak_ptr< T > atlas::to_weak_ptr (
    const U & p_value
) 
```




<hr>
## Public Static Functions Documentation




### function core\_assert 

```C++
template<typename... T>
static void atlas::core_assert (
    bool x,
    T &&... args
) 
```




<hr>

------------------------------
The documentation for this class was generated from the following file `TheAtlasEngine/atlas/core/api.hpp`

