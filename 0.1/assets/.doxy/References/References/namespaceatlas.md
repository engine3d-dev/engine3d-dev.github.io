

# Namespace atlas



[**Namespace List**](namespaces.md) **>** [**atlas**](namespaceatlas.md)



[More...](#detailed-description)














## Namespaces

| Type | Name |
| ---: | :--- |
| namespace | [**event**](namespaceatlas_1_1event.md) <br> |
| namespace | [**filesystem**](namespaceatlas_1_1filesystem.md) <br> |
| namespace | [**physics**](namespaceatlas_1_1physics.md) <br>_Handles error handling with in jolt._  |
| namespace | [**sync\_update**](namespaceatlas_1_1sync__update.md) <br> |
| namespace | [**ui**](namespaceatlas_1_1ui.md) <br> |
| namespace | [**vk**](namespaceatlas_1_1vk.md) <br> |


## Classes

| Type | Name |
| ---: | :--- |
| class | [**application**](classatlas_1_1application.md) <br> |
| struct | [**application\_settings**](structatlas_1_1application__settings.md) <br> |
| struct | [**box\_collider3d**](structatlas_1_1box__collider3d.md) <br> |
| class | [**camera**](classatlas_1_1camera.md) <br> |
| class | [**console\_log\_manager**](classatlas_1_1console__log__manager.md) <br> |
| class | [**entity\_t**](classatlas_1_1entity__t.md) <br> |
| class | [**graphics\_context**](classatlas_1_1graphics__context.md) <br> |
| class | [**interpolation**](classatlas_1_1interpolation.md) <br> |
| struct | [**light**](structatlas_1_1light.md) <br>_TODO: Make this better (when we do lighting)_  |
| struct | [**material**](structatlas_1_1material.md) <br> |
| struct | [**math\_generic**](structatlas_1_1math__generic.md) &lt;typename T&gt;<br> |
| struct | [**matrix2**](structatlas_1_1matrix2.md) &lt;typename T&gt;<br> |
| struct | [**matrix3**](structatlas_1_1matrix3.md) &lt;typename T&gt;<br> |
| struct | [**matrix4**](structatlas_1_1matrix4.md) &lt;typename T&gt;<br> |
| class | [**mesh**](classatlas_1_1mesh.md) <br> |
| struct | [**reload**](structatlas_1_1reload.md) <br>_Actually might do a query for this along with rendertarget3d._  |
| class | [**render\_context**](classatlas_1_1render__context.md) <br> |
| class | [**renderer**](classatlas_1_1renderer.md) <br> |
| struct | [**rigidbody3d**](structatlas_1_1rigidbody3d.md) <br> |
| class | [**scene\_object**](classatlas_1_1scene__object.md) <br> |
| class | [**scene\_scope**](classatlas_1_1scene__scope.md) <br> |
| class | [**serializer**](classatlas_1_1serializer.md) <br> |
| class | [**system\_registry**](classatlas_1_1system__registry.md) <br> |
| struct | [**tag**](structatlas_1_1tag.md) <br> |
| class | [**thread**](classatlas_1_1thread.md) <br> |
| class | [**timer**](classatlas_1_1timer.md) <br> |
| struct | [**transform**](structatlas_1_1transform.md) <br> |
| struct | [**transform\_physics**](structatlas_1_1transform__physics.md) <br> |
| struct | [**vector2**](structatlas_1_1vector2.md) &lt;typename T&gt;<br> |
| struct | [**vector2&lt; glm::highp\_vec2 &gt;**](structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4.md) &lt;&gt;<br> |
| struct | [**vector3**](structatlas_1_1vector3.md) &lt;typename T&gt;<br> |
| struct | [**vector3&lt; JPH::Vec3 &gt;**](structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4.md) &lt;&gt;<br> |
| struct | [**vector3&lt; glm::highp\_vec3 &gt;**](structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4.md) &lt;&gt;<br> |
| struct | [**vector4**](structatlas_1_1vector4.md) &lt;typename T&gt;<br> |
| struct | [**vector4&lt; glm::highp\_vec4 &gt;**](structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4.md) &lt;&gt;<br> |
| class | [**window**](classatlas_1_1window.md) <br> |
| struct | [**window\_settings**](structatlas_1_1window__settings.md) <br>_Specific settings to the window configuration._  |
| class | [**world\_scope**](classatlas_1_1world__scope.md) <br>_Lets rethink how_ [_**world\_scope**_](classatlas_1_1world__scope.md) _gets created._ |


## Public Types

| Type | Name |
| ---: | :--- |
| enum  | [**CameraMovement**](#enum-cameramovement)  <br> |
| enum  | [**api**](#enum-api)  <br> |
| typedef [**vector2**](structatlas_1_1vector2.md)&lt; glm::highp\_vec2 &gt; | [**highp\_vec2**](#typedef-highp_vec2)  <br> |
| typedef [**vector3**](structatlas_1_1vector3.md)&lt; glm::highp\_vec3 &gt; | [**highp\_vec3**](#typedef-highp_vec3)  <br> |
| typedef [**vector4**](structatlas_1_1vector4.md)&lt; glm::highp\_vec4 &gt; | [**highp\_vec4**](#typedef-highp_vec4)  <br> |
| typedef [**math\_generic**](structatlas_1_1math__generic.md)&lt; glm::mat&lt; C, R, T &gt; &gt; | [**mat**](#typedef-mat)  <br> |
| typedef [**matrix2**](structatlas_1_1matrix2.md)&lt; glm::mat2 &gt; | [**mat2**](#typedef-mat2)  <br> |
| typedef [**matrix3**](structatlas_1_1matrix3.md)&lt; glm::mat3 &gt; | [**mat3**](#typedef-mat3)  <br> |
| typedef [**matrix4**](structatlas_1_1matrix4.md)&lt; glm::mat4 &gt; | [**mat4**](#typedef-mat4)  <br> |
| typedef std::shared\_ptr&lt; T &gt; | [**ref**](#typedef-ref)  <br> |
| typedef std::unique\_ptr&lt; T &gt; | [**scope**](#typedef-scope)  <br> |
| typedef [**math\_generic**](structatlas_1_1math__generic.md)&lt; glm::vec&lt; Size, T &gt; &gt; | [**vec**](#typedef-vec)  <br> |
| typedef [**vector2**](structatlas_1_1vector2.md)&lt; glm::vec2 &gt; | [**vec2**](#typedef-vec2)  <br> |
| typedef [**vector3**](structatlas_1_1vector3.md)&lt; glm::vec3 &gt; | [**vec3**](#typedef-vec3)  <br> |
| typedef [**vector4**](structatlas_1_1vector4.md)&lt; glm::vec4 &gt; | [**vec4**](#typedef-vec4)  <br> |
| typedef std::weak\_ptr&lt; T &gt; | [**weak\_ptr**](#typedef-weak_ptr)  <br> |




















## Public Functions

| Type | Name |
| ---: | :--- |
|  void | [**attach**](#function-attach) (UObject \* p\_instance, const UCallable & p\_callable) <br> |
|  constexpr [**ref**](namespaceatlas.md#typedef-ref)&lt; T &gt; | [**create\_ref**](#function-create_ref) (Args &&... args) <br> |
|  constexpr scope&lt; T &gt; | [**create\_scope**](#function-create_scope) (Args &&... args) <br> |
|  constexpr weak\_ptr&lt; T &gt; | [**create\_weak\_ptr**](#function-create_weak_ptr) (Args &&... args) <br> |
|  [**ref**](namespaceatlas.md#typedef-ref)&lt; [**window**](classatlas_1_1window.md) &gt; | [**create\_window**](#function-create_window) (const [**window\_settings**](structatlas_1_1window__settings.md) & p\_settings) <br> |
|  uint32\_t | [**get\_thread\_count**](#function-get_thread_count) () <br> |
|  void | [**hash\_combine**](#function-hash_combine) (size\_t & seed, const T & v, const Rest &... rest) <br> |
|  [**ref**](namespaceatlas.md#typedef-ref)&lt; [**application**](classatlas_1_1application.md) &gt; | [**initialize\_application**](#function-initialize_application) () <br> |
|  [**ref**](namespaceatlas.md#typedef-ref)&lt; [**graphics\_context**](classatlas_1_1graphics__context.md) &gt; | [**initialize\_context**](#function-initialize_context) (const std::string & p\_tag) <br> |
|  scope&lt; [**render\_context**](classatlas_1_1render__context.md) &gt; | [**initialize\_renderer**](#function-initialize_renderer) (const [**vk::vk\_swapchain**](classatlas_1_1vk_1_1vk__swapchain.md) & p\_swapchain, const std::string & p\_tag) <br> |
|  void | [**post**](#function-post) (UObject \* p\_instance, const UCallable & p\_callable) <br> |
|  void | [**sync**](#function-sync) (UObject \* p\_instance, const UCallable & p\_callable) <br> |
|  void | [**sync\_physics**](#function-sync_physics) (UObject \* p\_instance, const UCallable & p\_callable) <br> |
|  weak\_ptr&lt; T &gt; | [**to\_weak\_ptr**](#function-to_weak_ptr) (const U & p\_value) <br> |


## Public Static Functions

| Type | Name |
| ---: | :--- |
|  void | [**core\_assert**](#function-core_assert) (bool x, T &&... args) <br> |


























## Detailed Description




**Note:**

This is just a class abstraction idea


class swapchain { public: virtual ~swapchain();


uint32\_t read\_acquired\_next\_image();


private: virtual uint32\_t swapchain\_read\_acquried\_image() = 0; };


Here are responsibilities I want the renderer/vk\_renderer to have Task graph for command buffer submission/execution API's are going to be using defer\_submit API's are potentially (with ???) using immediate\_submit 


    
## Public Types Documentation




### enum CameraMovement 

```C++
enum atlas::CameraMovement {
    forward,
    backward,
    left,
    right,
    up,
    down
};
```




<hr>



### enum api 

```C++
enum atlas::api {
    vulkan,
    dx11,
    fx12,
    undefined
};
```




<hr>



### typedef highp\_vec2 

```C++
using atlas::highp_vec2 = typedef vector2<glm::highp_vec2>;
```




<hr>



### typedef highp\_vec3 

```C++
using atlas::highp_vec3 = typedef vector3<glm::highp_vec3>;
```




<hr>



### typedef highp\_vec4 

```C++
using atlas::highp_vec4 = typedef vector4<glm::highp_vec4>;
```




<hr>



### typedef mat 

```C++
using atlas::mat = typedef math_generic<glm::mat<C, R, T> >;
```




<hr>



### typedef mat2 

```C++
using atlas::mat2 = typedef matrix2<glm::mat2>;
```




<hr>



### typedef mat3 

```C++
using atlas::mat3 = typedef matrix3<glm::mat3>;
```




<hr>



### typedef mat4 

```C++
using atlas::mat4 = typedef matrix4<glm::mat4>;
```




<hr>



### typedef ref 

```C++
using atlas::ref = typedef std::shared_ptr<T>;
```





**Note:**

Some aliases for the smart pointers 





        

<hr>



### typedef scope 

```C++
using atlas::scope = typedef std::unique_ptr<T>;
```




<hr>



### typedef vec 

```C++
using atlas::vec = typedef math_generic<glm::vec<Size, T> >;
```





**Note:**

By default we use glm 





        

<hr>



### typedef vec2 

```C++
using atlas::vec2 = typedef vector2<glm::vec2>;
```




<hr>



### typedef vec3 

```C++
using atlas::vec3 = typedef vector3<glm::vec3>;
```




<hr>



### typedef vec4 

```C++
using atlas::vec4 = typedef vector4<glm::vec4>;
```




<hr>



### typedef weak\_ptr 

```C++
using atlas::weak_ptr = typedef std::weak_ptr<T>;
```




<hr>
## Public Functions Documentation




### function attach 

```C++
template<typename UObject, typename UCallable>
void atlas::attach (
    UObject * p_instance,
    const UCallable & p_callable
) 
```




<hr>



### function create\_ref 

```C++
template<typename T, typename... Args>
constexpr ref < T > atlas::create_ref (
    Args &&... args
) 
```




<hr>



### function create\_scope 

```C++
template<typename T, typename... Args>
constexpr scope< T > atlas::create_scope (
    Args &&... args
) 
```




<hr>



### function create\_weak\_ptr 

```C++
template<typename T, typename... Args>
constexpr weak_ptr< T > atlas::create_weak_ptr (
    Args &&... args
) 
```




<hr>



### function create\_window 

```C++
ref < window > atlas::create_window (
    const window_settings & p_settings
) 
```




<hr>



### function get\_thread\_count 

```C++
uint32_t atlas::get_thread_count () 
```




<hr>



### function hash\_combine 

```C++
template<typename T, typename... Rest>
void atlas::hash_combine (
    size_t & seed,
    const T & v,
    const Rest &... rest
) 
```




<hr>



### function initialize\_application 

```C++
ref < application > atlas::initialize_application () 
```




<hr>



### function initialize\_context 

```C++
ref < graphics_context > atlas::initialize_context (
    const std::string & p_tag
) 
```




<hr>



### function initialize\_renderer 

```C++
scope< render_context > atlas::initialize_renderer (
    const vk::vk_swapchain & p_swapchain,
    const std::string & p_tag
) 
```




<hr>



### function post 

```C++
template<typename UObject, typename UCallable>
void atlas::post (
    UObject * p_instance,
    const UCallable & p_callable
) 
```




<hr>



### function sync 

```C++
template<typename UObject, typename UCallable>
void atlas::sync (
    UObject * p_instance,
    const UCallable & p_callable
) 
```





**Note:**

These are public functions that users can utilize 




**Note:**

If users are using anything within the sync\_update namespace. They shouldn't 





        

<hr>



### function sync\_physics 

```C++
template<typename UObject, typename UCallable>
void atlas::sync_physics (
    UObject * p_instance,
    const UCallable & p_callable
) 
```




<hr>



### function to\_weak\_ptr 

```C++
template<typename T, typename U>
weak_ptr< T > atlas::to_weak_ptr (
    const U & p_value
) 
```




<hr>
## Public Static Functions Documentation




### function core\_assert 

```C++
template<typename... T>
static void atlas::core_assert (
    bool x,
    T &&... args
) 
```




<hr>

------------------------------
The documentation for this class was generated from the following file `TheAtlasEngine/atlas/components/transform.hpp`

