<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TheAtlasEngine: atlas::memory::strong_ptr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TheAtlasEngine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classatlas_1_1memory_1_1strong__ptr.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classatlas_1_1memory_1_1strong__ptr-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">atlas::memory::strong_ptr&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A non-nullable strong reference counted pointer.  
 <a href="classatlas_1_1memory_1_1strong__ptr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="memory_8hpp_source.html">memory.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae21ac4ad53d0fc88dc122e65265c3408" id="r_ae21ac4ad53d0fc88dc122e65265c3408"><td class="memItemLeft" align="right" valign="top"><a id="ae21ac4ad53d0fc88dc122e65265c3408" name="ae21ac4ad53d0fc88dc122e65265c3408"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>element_type</b> = T</td></tr>
<tr class="separator:ae21ac4ad53d0fc88dc122e65265c3408"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a457299ac75294e39ec406ca18e729509" id="r_a457299ac75294e39ec406ca18e729509"><td class="memItemLeft" align="right" valign="top"><a id="a457299ac75294e39ec406ca18e729509" name="a457299ac75294e39ec406ca18e729509"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>strong_ptr</b> ()=delete</td></tr>
<tr class="memdesc:a457299ac75294e39ec406ca18e729509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete default constructor - <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> must always be valid. <br /></td></tr>
<tr class="separator:a457299ac75294e39ec406ca18e729509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119dc39a666c02f546566ef6703f6196" id="r_a119dc39a666c02f546566ef6703f6196"><td class="memItemLeft" align="right" valign="top"><a id="a119dc39a666c02f546566ef6703f6196" name="a119dc39a666c02f546566ef6703f6196"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>strong_ptr</b> (std::nullptr_t)=delete</td></tr>
<tr class="memdesc:a119dc39a666c02f546566ef6703f6196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete nullptr constructor - <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> must always be valid. <br /></td></tr>
<tr class="separator:a119dc39a666c02f546566ef6703f6196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a50e5bf1c45851321f5c628d2d8b4d0" id="r_a0a50e5bf1c45851321f5c628d2d8b4d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html#a0a50e5bf1c45851321f5c628d2d8b4d0">strong_ptr</a> (<a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a> const &amp;p_other) noexcept</td></tr>
<tr class="memdesc:a0a50e5bf1c45851321f5c628d2d8b4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a0a50e5bf1c45851321f5c628d2d8b4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f42c9f919cecf36d7ac8f7dc13e752" id="r_a01f42c9f919cecf36d7ac8f7dc13e752"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; <br />
requires (std::is_convertible_v&lt;U*, T*&gt;)</td></tr>
<tr class="memitem:a01f42c9f919cecf36d7ac8f7dc13e752"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html#a01f42c9f919cecf36d7ac8f7dc13e752">strong_ptr</a> (<a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; U &gt; const &amp;p_other) noexcept</td></tr>
<tr class="memdesc:a01f42c9f919cecf36d7ac8f7dc13e752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting copy constructor.  <br /></td></tr>
<tr class="separator:a01f42c9f919cecf36d7ac8f7dc13e752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703548f935b3ed9a4d49997808a3f0ed" id="r_a703548f935b3ed9a4d49997808a3f0ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html#a703548f935b3ed9a4d49997808a3f0ed">strong_ptr</a> (<a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a> &amp;&amp;p_other) noexcept</td></tr>
<tr class="memdesc:a703548f935b3ed9a4d49997808a3f0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor that intentionally behaves like a copy constructor for safety.  <br /></td></tr>
<tr class="separator:a703548f935b3ed9a4d49997808a3f0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4b2f2a0b1e9f18b1b8e9f5dad58da3" id="r_a5e4b2f2a0b1e9f18b1b8e9f5dad58da3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html#a5e4b2f2a0b1e9f18b1b8e9f5dad58da3">operator=</a> (<a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a> &amp;&amp;p_other) noexcept</td></tr>
<tr class="memdesc:a5e4b2f2a0b1e9f18b1b8e9f5dad58da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator that behaves like a copy assignment for safety.  <br /></td></tr>
<tr class="separator:a5e4b2f2a0b1e9f18b1b8e9f5dad58da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59b0bae4f96f6a6a0011bc481f315f8" id="r_ae59b0bae4f96f6a6a0011bc481f315f8"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ae59b0bae4f96f6a6a0011bc481f315f8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html#ae59b0bae4f96f6a6a0011bc481f315f8">strong_ptr</a> (<a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; U &gt; const &amp;, void const *) noexcept</td></tr>
<tr class="memdesc:ae59b0bae4f96f6a6a0011bc481f315f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time error message for bad alias value.  <br /></td></tr>
<tr class="separator:ae59b0bae4f96f6a6a0011bc481f315f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599a198281c5a42fe24cc424f4fac253" id="r_a599a198281c5a42fe24cc424f4fac253"><td class="memTemplParams" colspan="2">template&lt;typename U , detail::non_array_like M&gt; </td></tr>
<tr class="memitem:a599a198281c5a42fe24cc424f4fac253"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html#a599a198281c5a42fe24cc424f4fac253">strong_ptr</a> (<a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; U &gt; const &amp;p_other, M U::*p_member_ptr) noexcept</td></tr>
<tr class="memdesc:a599a198281c5a42fe24cc424f4fac253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe aliasing constructor for object members.  <br /></td></tr>
<tr class="separator:a599a198281c5a42fe24cc424f4fac253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ad4305b4bdbe911bf94b0a6ba4992c" id="r_af7ad4305b4bdbe911bf94b0a6ba4992c"><td class="memTemplParams" colspan="2">template&lt;typename U , typename E , std::size_t N&gt; </td></tr>
<tr class="memitem:af7ad4305b4bdbe911bf94b0a6ba4992c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html#af7ad4305b4bdbe911bf94b0a6ba4992c">strong_ptr</a> (<a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; U &gt; const &amp;p_other, std::array&lt; E, N &gt; U::*p_array_ptr, std::size_t p_index)</td></tr>
<tr class="memdesc:af7ad4305b4bdbe911bf94b0a6ba4992c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe aliasing constructor for std::array members.  <br /></td></tr>
<tr class="separator:af7ad4305b4bdbe911bf94b0a6ba4992c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eae419923ef20585e3801722beb5f26" id="r_a1eae419923ef20585e3801722beb5f26"><td class="memTemplParams" colspan="2">template&lt;typename U , typename E , std::size_t N&gt; </td></tr>
<tr class="memitem:a1eae419923ef20585e3801722beb5f26"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html#a1eae419923ef20585e3801722beb5f26">strong_ptr</a> (<a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; U &gt; const &amp;p_other, E(U::*p_array_ptr)[N], std::size_t p_index)</td></tr>
<tr class="memdesc:a1eae419923ef20585e3801722beb5f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe aliasing constructor for C-array members.  <br /></td></tr>
<tr class="separator:a1eae419923ef20585e3801722beb5f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d455a65337152be1ad552d947b83ed9" id="r_a7d455a65337152be1ad552d947b83ed9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html#a7d455a65337152be1ad552d947b83ed9">~strong_ptr</a> ()</td></tr>
<tr class="memdesc:a7d455a65337152be1ad552d947b83ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a7d455a65337152be1ad552d947b83ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e3f86ddb69f8608e786249efbc35a3" id="r_ab9e3f86ddb69f8608e786249efbc35a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html#ab9e3f86ddb69f8608e786249efbc35a3">operator=</a> (<a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a> const &amp;p_other) noexcept</td></tr>
<tr class="memdesc:ab9e3f86ddb69f8608e786249efbc35a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <br /></td></tr>
<tr class="separator:ab9e3f86ddb69f8608e786249efbc35a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b92a9b111160da2deee0245cc397937" id="r_a5b92a9b111160da2deee0245cc397937"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; <br />
requires (std::is_convertible_v&lt;U*, T*&gt;)</td></tr>
<tr class="memitem:a5b92a9b111160da2deee0245cc397937"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html#a5b92a9b111160da2deee0245cc397937">operator=</a> (<a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; U &gt; const &amp;p_other) noexcept</td></tr>
<tr class="memdesc:a5b92a9b111160da2deee0245cc397937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting copy assignment operator.  <br /></td></tr>
<tr class="separator:a5b92a9b111160da2deee0245cc397937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0cce03441682e823055ad5bdefbf5c" id="r_adb0cce03441682e823055ad5bdefbf5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html#adb0cce03441682e823055ad5bdefbf5c">swap</a> (<a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a> &amp;p_other) noexcept</td></tr>
<tr class="memdesc:adb0cce03441682e823055ad5bdefbf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of this <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> with another.  <br /></td></tr>
<tr class="separator:adb0cce03441682e823055ad5bdefbf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf26123075de73b4d12cda303b684b8" id="r_abdf26123075de73b4d12cda303b684b8"><td class="memItemLeft" align="right" valign="top"><a id="abdf26123075de73b4d12cda303b684b8" name="abdf26123075de73b4d12cda303b684b8"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> () &amp;&amp;=delete</td></tr>
<tr class="memdesc:abdf26123075de73b4d12cda303b684b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable dereferencing for r-values (temporaries) <br /></td></tr>
<tr class="separator:abdf26123075de73b4d12cda303b684b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31a4b2a996a7e092e3d70879356d385" id="r_ac31a4b2a996a7e092e3d70879356d385"><td class="memItemLeft" align="right" valign="top"><a id="ac31a4b2a996a7e092e3d70879356d385" name="ac31a4b2a996a7e092e3d70879356d385"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><b>operator-&gt;</b> () &amp;&amp;=delete</td></tr>
<tr class="memdesc:ac31a4b2a996a7e092e3d70879356d385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable member access for r-values (temporaries) <br /></td></tr>
<tr class="separator:ac31a4b2a996a7e092e3d70879356d385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ce9eded4c3a3e389d5aa6f93b39124" id="r_a29ce9eded4c3a3e389d5aa6f93b39124"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html#a29ce9eded4c3a3e389d5aa6f93b39124">operator*</a> () const &amp;noexcept</td></tr>
<tr class="memdesc:a29ce9eded4c3a3e389d5aa6f93b39124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference operator to access the managed object.  <br /></td></tr>
<tr class="separator:a29ce9eded4c3a3e389d5aa6f93b39124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51de63790829740e5336fa233a21c936" id="r_a51de63790829740e5336fa233a21c936"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html#a51de63790829740e5336fa233a21c936">operator-&gt;</a> () const &amp;noexcept</td></tr>
<tr class="memdesc:a51de63790829740e5336fa233a21c936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member access operator to access the managed object.  <br /></td></tr>
<tr class="separator:a51de63790829740e5336fa233a21c936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f372421c79abe277743df9a25f958b9" id="r_a7f372421c79abe277743df9a25f958b9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html#a7f372421c79abe277743df9a25f958b9">use_count</a> () const noexcept</td></tr>
<tr class="memdesc:a7f372421c79abe277743df9a25f958b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current reference count.  <br /></td></tr>
<tr class="separator:a7f372421c79abe277743df9a25f958b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a27df6e2a1650d985bdeda33f0303c83f" id="r_a27df6e2a1650d985bdeda33f0303c83f"><td class="memTemplParams" colspan="2"><a id="a27df6e2a1650d985bdeda33f0303c83f" name="a27df6e2a1650d985bdeda33f0303c83f"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a27df6e2a1650d985bdeda33f0303c83f"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>weak_ptr</b></td></tr>
<tr class="separator:a27df6e2a1650d985bdeda33f0303c83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fc84c673c901da70d12e5e31014344" id="r_a44fc84c673c901da70d12e5e31014344"><td class="memTemplParams" colspan="2"><a id="a44fc84c673c901da70d12e5e31014344" name="a44fc84c673c901da70d12e5e31014344"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a44fc84c673c901da70d12e5e31014344"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>optional_ptr</b></td></tr>
<tr class="separator:a44fc84c673c901da70d12e5e31014344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86a34f711c9adda333ad83f629a3eed" id="r_ae86a34f711c9adda333ad83f629a3eed"><td class="memTemplParams" colspan="2"><a id="ae86a34f711c9adda333ad83f629a3eed" name="ae86a34f711c9adda333ad83f629a3eed"></a>
template&lt;class U , typename... Args&gt; </td></tr>
<tr class="memitem:ae86a34f711c9adda333ad83f629a3eed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_strong_ptr</b> (std::pmr::polymorphic_allocator&lt;&gt;, Args &amp;&amp;...)</td></tr>
<tr class="separator:ae86a34f711c9adda333ad83f629a3eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class atlas::memory::strong_ptr&lt; T &gt;</div><p>A non-nullable strong reference counted pointer. </p>
<p><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> is a smart pointer that maintains shared ownership of an object through a reference count. It is similar to std::shared_ptr but with these key differences:</p>
<ol type="1">
<li>Cannot be null - must always point to a valid object</li>
<li>Can only be created via make_strong_ptr, not from raw pointers</li>
<li>More memory efficient implementation</li>
</ol>
<p>Use <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> when you need shared ownership semantics and can guarantee the pointer will never be null. For nullable references, use <a class="el" href="classatlas_1_1memory_1_1optional__ptr.html" title="Optional, nullable, smart pointer that works with hal::strong_ptr.">optional_ptr</a>.</p>
<p>Example usage:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// Create a strong_ptr to an object</span></div>
<div class="line"><span class="keyword">auto</span> ptr = hal::make_strong_ptr&lt;my_i2c_driver&gt;(allocator, arg1, arg2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use the object using dereference (*) operator</span></div>
<div class="line">(*ptr).configure({ .clock_rate = 250_kHz });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// OR use the object using arrow (-&gt;) operator</span></div>
<div class="line">ptr-&gt;configure({ .clock_rate = 250_kHz });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Share ownership with another driver or object</span></div>
<div class="line"><span class="keyword">auto</span> my_imu = hal::make_strong_ptr&lt;my_driver&gt;(allocator, ptr, 0x13);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the managed object </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0a50e5bf1c45851321f5c628d2d8b4d0" name="a0a50e5bf1c45851321f5c628d2d8b4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a50e5bf1c45851321f5c628d2d8b4d0">&#9670;&#160;</a></span>strong_ptr() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">atlas::memory::strong_ptr</a>&lt; T &gt;::strong_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Creates a new strong reference to the same object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01f42c9f919cecf36d7ac8f7dc13e752" name="a01f42c9f919cecf36d7ac8f7dc13e752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f42c9f919cecf36d7ac8f7dc13e752">&#9670;&#160;</a></span>strong_ptr() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; <br />
requires (std::is_convertible_v&lt;U*, T*&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">atlas::memory::strong_ptr</a>&lt; T &gt;::strong_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting copy constructor. </p>
<p>Creates a new strong reference to the same object, converting from a derived type U to base type T.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>A type convertible to T </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a703548f935b3ed9a4d49997808a3f0ed" name="a703548f935b3ed9a4d49997808a3f0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703548f935b3ed9a4d49997808a3f0ed">&#9670;&#160;</a></span>strong_ptr() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">atlas::memory::strong_ptr</a>&lt; T &gt;::strong_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor that intentionally behaves like a copy constructor for safety. </p>
<p>This move constructor deliberately performs a full copy operation rather than transferring ownership. This is a safety feature to prevent potential undefined behavior that could occur if code accidentally accessed a moved-from <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a>.</p>
<p>After this operation, both the source and destination objects remain in valid states, and the reference count is incremented by 1. This ensures that even if code incorrectly continues to use the source object after a move, no undefined behavior will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> to "move" from (actually copied for safety) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae59b0bae4f96f6a6a0011bc481f315f8" name="ae59b0bae4f96f6a6a0011bc481f315f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59b0bae4f96f6a6a0011bc481f315f8">&#9670;&#160;</a></span>strong_ptr() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">atlas::memory::strong_ptr</a>&lt; T &gt;::strong_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time error message for bad alias value. </p>
<p><code>std::shared_ptr</code> provides an alias constructor that accepts any <code>void*</code> which is UB if that <code>void*</code> doesn't have the same lifetime as the object referenced by the <code>std::shared_ptr</code>. Users attempting to do this will get a list of constructors that failed to fit. This is not a good error message for users. Instead, we provide a static_assert message in plain english that explains why this overload fails at compile time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>- some type for the <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a599a198281c5a42fe24cc424f4fac253" name="a599a198281c5a42fe24cc424f4fac253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599a198281c5a42fe24cc424f4fac253">&#9670;&#160;</a></span>strong_ptr() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U , detail::non_array_like M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">atlas::memory::strong_ptr</a>&lt; T &gt;::strong_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M U::*&#160;</td>
          <td class="paramname"><em>p_member_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safe aliasing constructor for object members. </p>
<p>This constructor creates a <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> that points to a member of an object managed by another <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a>. The resulting <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> shares ownership with the original <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a>, keeping the entire parent object alive.</p>
<p>This version is only enabled for non-array members to prevent potential undefined behavior when accessing array elements directly. Use the array-specific versions instead.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>container {</div>
<div class="line">  component part;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a strong_ptr to the container</span></div>
<div class="line"><span class="keyword">auto</span> container_ptr = make_strong_ptr&lt;container&gt;(allocator);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a strong_ptr to just the component</span></div>
<div class="line"><span class="keyword">auto</span> component_ptr = <a class="code hl_class" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr&lt;component&gt;</a>(container_ptr,</div>
<div class="line">&amp;container::part);</div>
<div class="ttc" id="aclassatlas_1_1memory_1_1strong__ptr_html"><div class="ttname"><a href="classatlas_1_1memory_1_1strong__ptr.html">atlas::memory::strong_ptr</a></div><div class="ttdoc">A non-nullable strong reference counted pointer.</div><div class="ttdef"><b>Definition</b> memory.hpp:223</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>Type of the parent object </td></tr>
    <tr><td class="paramname">M</td><td>Type of the member </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> to the parent object </td></tr>
    <tr><td class="paramname">p_member_ptr</td><td>Pointer-to-member identifying which member to reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7ad4305b4bdbe911bf94b0a6ba4992c" name="af7ad4305b4bdbe911bf94b0a6ba4992c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ad4305b4bdbe911bf94b0a6ba4992c">&#9670;&#160;</a></span>strong_ptr() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename E , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">atlas::memory::strong_ptr</a>&lt; T &gt;::strong_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; E, N &gt; U::*&#160;</td>
          <td class="paramname"><em>p_array_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>p_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safe aliasing constructor for std::array members. </p>
<p>This constructor creates a <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> that points to an element of an array member in an object managed by another <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a>. It performs bounds checking to ensure the index is valid.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>array_container {</div>
<div class="line">  std::array&lt;element, 5&gt; elements;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> container_ptr = make_strong_ptr&lt;array_container&gt;(allocator);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get strong_ptr to the 2nd element</span></div>
<div class="line"><span class="keyword">auto</span> element_ptr = <a class="code hl_class" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr&lt;element&gt;</a>(</div>
<div class="line">  container_ptr,</div>
<div class="line">  &amp;array_container::elements,</div>
<div class="line">  2 <span class="comment">// Index to access</span></div>
<div class="line">);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>Type of the parent object </td></tr>
    <tr><td class="paramname">E</td><td>Type of the array element </td></tr>
    <tr><td class="paramname">N</td><td>Size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> to the parent object </td></tr>
    <tr><td class="paramname">p_array_ptr</td><td>Pointer-to-member identifying the array member </td></tr>
    <tr><td class="paramname">p_index</td><td>Index of the element to reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hal::out_of_range</td><td>if index is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1eae419923ef20585e3801722beb5f26" name="a1eae419923ef20585e3801722beb5f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eae419923ef20585e3801722beb5f26">&#9670;&#160;</a></span>strong_ptr() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename E , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">atlas::memory::strong_ptr</a>&lt; T &gt;::strong_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E(U::*)&#160;</td>
          <td class="paramname"><em>p_array_ptr</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>p_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safe aliasing constructor for C-array members. </p>
<p>This constructor creates a <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> that points to an element of a C-style array member in an object managed by another <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a>. It performs bounds checking to ensure the index is valid.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>c_array_container {</div>
<div class="line">  element elements[5];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> container_ptr = make_strong_ptr&lt;c_array_container&gt;(allocator);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get strong_ptr to the 2nd element</span></div>
<div class="line"><span class="keyword">auto</span> element_ptr = <a class="code hl_class" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr&lt;element&gt;</a>(</div>
<div class="line">  container_ptr,</div>
<div class="line">  &amp;c_array_container::elements,</div>
<div class="line">  2 <span class="comment">// Index to access</span></div>
<div class="line">);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>Type of the parent object </td></tr>
    <tr><td class="paramname">E</td><td>Type of the array element </td></tr>
    <tr><td class="paramname">N</td><td>Size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> to the parent object </td></tr>
    <tr><td class="paramname">p_array_ptr</td><td>Pointer-to-member identifying the array member </td></tr>
    <tr><td class="paramname">p_index</td><td>Index of the element to reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hal::out_of_range</td><td>if index is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d455a65337152be1ad552d947b83ed9" name="a7d455a65337152be1ad552d947b83ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d455a65337152be1ad552d947b83ed9">&#9670;&#160;</a></span>~strong_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">atlas::memory::strong_ptr</a>&lt; T &gt;::~<a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Decrements the reference count and destroys the managed object if this was the last strong reference. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a29ce9eded4c3a3e389d5aa6f93b39124" name="a29ce9eded4c3a3e389d5aa6f93b39124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ce9eded4c3a3e389d5aa6f93b39124">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">atlas::memory::strong_ptr</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereference operator to access the managed object. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the managed object </dd></dl>

</div>
</div>
<a id="a51de63790829740e5336fa233a21c936" name="a51de63790829740e5336fa233a21c936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51de63790829740e5336fa233a21c936">&#9670;&#160;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">atlas::memory::strong_ptr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Member access operator to access the managed object. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the managed object </dd></dl>

</div>
</div>
<a id="a5e4b2f2a0b1e9f18b1b8e9f5dad58da3" name="a5e4b2f2a0b1e9f18b1b8e9f5dad58da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4b2f2a0b1e9f18b1b8e9f5dad58da3">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a> &amp; <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">atlas::memory::strong_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator that behaves like a copy assignment for safety. </p>
<p>This move assignment operator deliberately performs a full copy operation rather than transferring ownership. This is a safety feature to prevent potential undefined behavior that could occur if code accidentally accessed a moved-from <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a>.</p>
<p>After this operation, both the source and destination objects remain in valid states, and the reference count is incremented by 1. This ensures that even if code incorrectly continues to use the source object after a move, no undefined behavior will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> to "move" from (actually copied for safety) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to *this </dd></dl>

</div>
</div>
<a id="ab9e3f86ddb69f8608e786249efbc35a3" name="ab9e3f86ddb69f8608e786249efbc35a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e3f86ddb69f8608e786249efbc35a3">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a> &amp; <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">atlas::memory::strong_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Replaces the managed object with the one managed by p_other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to *this </dd></dl>

</div>
</div>
<a id="a5b92a9b111160da2deee0245cc397937" name="a5b92a9b111160da2deee0245cc397937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b92a9b111160da2deee0245cc397937">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; <br />
requires (std::is_convertible_v&lt;U*, T*&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a> &amp; <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">atlas::memory::strong_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting copy assignment operator. </p>
<p>Replaces the managed object with the one managed by p_other, converting from type U to type T.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>A type convertible to T </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to *this </dd></dl>

</div>
</div>
<a id="adb0cce03441682e823055ad5bdefbf5c" name="adb0cce03441682e823055ad5bdefbf5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0cce03441682e823055ad5bdefbf5c">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">atlas::memory::strong_ptr</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the contents of this <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> with another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html" title="A non-nullable strong reference counted pointer.">strong_ptr</a> to swap with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f372421c79abe277743df9a25f958b9" name="a7f372421c79abe277743df9a25f958b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f372421c79abe277743df9a25f958b9">&#9670;&#160;</a></span>use_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">atlas::memory::strong_ptr</a>&lt; T &gt;::use_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current reference count. </p>
<p>This is primarily for testing purposes.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of strong references to the managed object </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>TheAtlasEngine/atlas/core/utilities/<a class="el" href="memory_8hpp_source.html">memory.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>atlas</b></li><li class="navelem"><b>memory</b></li><li class="navelem"><a class="el" href="classatlas_1_1memory_1_1strong__ptr.html">strong_ptr</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
