{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udfe0 Home","text":"Welcome to Atlas's Home Page"},{"location":"#overview","title":"Overview","text":"<p>TheAtlasEngine is a cross-platform 3D game engine. That strives to be powerful with no restrictions to the user. Allowing to be used for educational, creative, and commerical purpose games.</p>"},{"location":"#the-basics","title":"The Basics","text":"<p>TheAtlasEngine is a 3D game engine that is comprised of variety of different systems. The engine aims to have the ability to make games and build cool projects with. The engine is built fully in C++. With an inetractive application that enables users to think of a different and creative way to making games.</p>"},{"location":"about/","title":"About TheAtlasEngine","text":"<p>Still in progress \ud83d\udea7</p> <p>Atlas started as a 2D interactive game engine that was built just for fun and to have a fun way of seeing how game engines are made. Using them to build fun games.</p> <p>Then Aaron (creator) of the project decided to on making this project now focused in 3D. Where it gives students the opportunities to work on a cool project. Then being able to seeing some great results and using them during game jam events.</p> <p>One of the most satisfying factors of building this project is being able to use them during game jams and submitting games developed by this engine. That is the feeling he wants to share with other students.</p>"},{"location":"api/","title":"TheAtlasEngine API Documentation","text":"<p>Welcome to TheAtlasEngine documentaiton</p> <p>This section provides a detailed documentation for classes, files, namespace, and other API's from the atlas project.</p>"},{"location":"api/#contents","title":"Contents","text":"<p>Here are the main entry points to the generated documentation:</p> <ul> <li>Annotated Index: A comprehensive, alphabetically sorted list of all documented entities.</li> <li>Files: Browse documentation by source file.</li> <li>Namespaces: Explore the engine's structure through its namespaces.</li> <li>Classes: A direct list of all documented classes.</li> <li>Hierarchy: View the class inheritance hierarchy.</li> <li>Modules: Organized groups of related entities (if defined in Doxygen).</li> <li>Related Pages: Additional informational pages (if defined in Doxygen).</li> </ul>"},{"location":"api/#detailed-references","title":"Detailed References","text":"<p>Below is a detailed breakdown of individual components within the engine, organized by type.</p>"},{"location":"api/#classes-and-structs","title":"Classes and Structs","text":"<ul> <li>DescriptorSet</li> <li>DescriptorSetLayout</li> <li>DirectionalLightUbo</li> <li>Framebuffer</li> <li>Image</li> <li>ImageSampler</li> <li>ParallelUpdateManager</li> <li>Pipeline</li> <li>PointLightUbo</li> <li>SpotLightUbo</li> <li>UniformBuffer</li> <li>VulkanImGui</li> <li>application</li> <li>application_settings</li> <li>box_collider3d</li> <li>camera</li> <li>camera_ubo</li> <li>console_log_manager</li> <li>entity_t</li> <li>joystick_button</li> <li>joystick_info</li> <li>imgui_backend</li> <li>index_buffer</li> <li>interpolation</li> <li>light</li> <li>math_generic</li> <li>matrix2</li> <li>matrix3</li> <li>matrix4</li> <li>mesh</li> <li>JoltPhysicBody</li> <li>jolt_config</li> <li>jolt_settings</li> <li>physics_engine</li> <li>render_context</li> <li>renderer</li> <li>renderpass</li> <li>renderpass_properties</li> <li>rendertarget3d</li> <li>rigidbody3d</li> <li>scene_object</li> <li>scene_scope</li> <li>serializer</li> <li>shader</li> <li>swapchain</li> <li>system_registry</li> <li>tag</li> <li>thread</li> <li>timer</li> <li>transform</li> <li>vector2</li> <li>vector3</li> <li>vector3&lt; JPH::Vec3 &gt;</li> <li>vector4</li> <li>vertex</li> <li>vertex_buffer</li> <li>BufferTutorial</li> <li>VulkanDescriptorSets</li> <li>VulkanPipeline</li> <li>VulkanRenderPass</li> <li>VulkanUniformBuffer</li> <li>descriptor_pool</li> <li>descriptor_pool::builder</li> <li>descriptor_set_layout</li> <li>descriptor_set_layout::builder</li> <li>descriptor_writer</li> <li>shader_pipeline_config</li> <li>vk_context</li> <li>vk_driver</li> <li>vk_index_buffer</li> <li>vk_physical_driver</li> <li>vk_physical_driver::queue_family_indices</li> <li>vk_renderer</li> <li>vk_shader</li> <li>vk_swapchain</li> <li>vk_vertex_buffer</li> <li>vk_window</li> <li>window</li> <li>world_scope</li> <li>vk_swapchain::swapchain_depth_image</li> <li>vk_swapchain::swapchain_image</li> </ul>"},{"location":"api/#namespaces","title":"Namespaces","text":"<ul> <li>atlas::event</li> <li>atlas::filesystem</li> <li>atlas::physics</li> <li>atlas::sync_update</li> <li>atlas::ui</li> <li>atlas::vk</li> <li>std</li> </ul>"},{"location":"api/#files","title":"Files","text":"<ul> <li>event.hpp</li> <li>event.hpp Source</li> <li>joystick_codes.hpp</li> <li>joystick_codes.hpp Source</li> <li>key_codes.hpp</li> <li>key_codes.hpp Source</li> <li>mouse_codes.hpp</li> <li>mouse_codes.hpp Source</li> <li>file_dialog.hpp</li> <li>file_dialog.hpp Source</li> <li>mesh.hpp</li> <li>mesh.hpp Source</li> <li>stb_image.hpp</li> <li>stb_image.hpp Source</li> <li>math.hpp</li> <li>math.hpp Source</li> <li>core/math/types.hpp</li> <li>core/math/types.hpp Source</li> <li>components.hpp</li> <li>components.hpp Source</li> <li>entity.hpp</li> <li>entity.hpp Source</li> <li>scene.hpp</li> <li>scene.hpp Source</li> <li>scene_object.hpp</li> <li>scene_object.hpp Source</li> <li>world.hpp</li> <li>world.hpp Source</li> <li>serializer.hpp</li> <li>serializer.hpp Source</li> <li>system_registry.hpp</li> <li>system_registry.hpp Source</li> <li>core/threads/thread.hpp</li> <li>core/threads/thread.hpp Source</li> <li>widgets.hpp</li> <li>widgets.hpp Source</li> <li>global_update.hpp</li> <li>global_update.hpp Source</li> <li>parallel_update_manager.hpp</li> <li>parallel_update_manager.hpp Source</li> <li>sync_update.hpp</li> <li>sync_update.hpp Source</li> <li>thread_manager.hpp</li> <li>thread_manager.hpp Source</li> <li>update_handlers/timer.hpp</li> <li>update_handlers/timer.hpp Source</li> <li>hash.hpp</li> <li>hash.hpp Source</li> <li>api.hpp</li> <li>api.hpp Source</li> <li>application.hpp</li> <li>application.hpp Source</li> <li>core.hpp</li> <li>core.hpp Source</li> <li>engine_logger.hpp</li> <li>engine_logger.hpp Source</li> <li>timer.hpp</li> <li>timer.hpp Source</li> <li>window.hpp</li> <li>window.hpp Source</li> <li>imgui_backend.hpp</li> <li>imgui_backend.hpp Source</li> <li>vulkan_shader.hpp</li> <li>vulkan_shader.hpp Source</li> <li>vulkan_shader_pipeline_config.hpp</li> <li>vulkan_shader_pipeline_config.hpp Source</li> <li>buffer_tutorial.hpp</li> <li>buffer_tutorial.hpp Source</li> <li>descriptor_tutorial.hpp</li> <li>descriptor_tutorial.hpp Source</li> <li>drivers/vulkan/helper_functions.hpp</li> <li>drivers/vulkan/helper_functions.hpp Source</li> <li>drivers/vulkan/types.hpp</li> <li>drivers/vulkan/types.hpp Source</li> <li>utility.hpp</li> <li>utility.hpp Source</li> <li>vulkan-imports.hpp</li> <li>vulkan-imports.hpp Source</li> <li>vulkan_context.hpp</li> <li>vulkan_context.hpp Source</li> <li>vulkan_core.hpp</li> <li>vulkan_core.hpp Source</li> <li>vulkan_descriptors.hpp</li> <li>vulkan_descriptors.hpp Source</li> <li>vulkan_driver.hpp</li> <li>vulkan_driver.hpp Source</li> <li>vulkan_gpu.hpp</li> <li>vulkan_gpu.hpp Source</li> <li>vulkan_imgui.hpp</li> <li>vulkan_imgui.hpp Source</li> <li>vulkan_index_buffer.hpp</li> <li>vulkan_index_buffer.hpp Source</li> <li>vulkan_physical_driver.hpp</li> <li>vulkan_physical_driver.hpp Source</li> <li>vulkan_pipeline.hpp</li> <li>vulkan_pipeline.hpp Source</li> <li>vulkan_renderer.hpp</li> <li>vulkan_renderer.hpp Source</li> <li>vulkan_renderpass.hpp</li> <li>vulkan_renderpass.hpp Source</li> <li>vulkan_swapchain.hpp</li> <li>vulkan_swapchain.hpp Source</li> <li>vulkan_uniform_buffer.hpp</li> <li>vulkan_uniform_buffer.hpp Source</li> <li>vulkan_vertex_buffer.hpp</li> <li>vulkan_vertex_buffer.hpp Source</li> <li>vulkan_window.hpp</li> <li>vulkan_window.hpp Source</li> <li>descriptor_sets.hpp</li> <li>descriptor_sets.hpp Source</li> <li>frame_buffer.hpp</li> <li>frame_buffer.hpp Source</li> <li>image.hpp</li> <li>image.hpp Source</li> <li>index_buffer.hpp</li> <li>index_buffer.hpp Source</li> <li>pipeline.hpp</li> <li>pipeline.hpp Source</li> <li>render_pass.hpp</li> <li>render_pass.hpp Source</li> <li>renderer_backend.hpp</li> <li>renderer_backend.hpp Source</li> <li>shader.hpp</li> <li>shader.hpp Source</li> <li>swapchain.hpp</li> <li>swapchain.hpp Source</li> <li>uniform.hpp</li> <li>uniform.hpp Source</li> <li>uniform_buffer.hpp</li> <li>uniform_buffer.hpp Source</li> <li>vertex_buffer.hpp</li> <li>vertex_buffer.hpp Source</li> <li>physics/jolt-cpp/helper_functions.hpp</li> <li>physics/jolt-cpp/helper_functions.hpp Source</li> <li>jolt-imports.hpp</li> <li>jolt-imports.hpp Source</li> <li>jolt-cpp/jolt_api.hpp</li> <li>jolt-cpp/jolt_api.hpp Source</li> <li>jolt_body.hpp</li> <li>jolt_body.hpp Source</li> <li>jolt_config.hpp</li> <li>jolt_config.hpp Source</li> <li>jolt_settings.hpp</li> <li>jolt_settings.hpp Source</li> <li>physics_3d/jolt/jolt_api.hpp</li> <li>physics_3d/jolt/jolt_api.hpp Source</li> <li>jolt_physics_engine.hpp</li> <li>jolt_physics_engine.hpp Source</li> <li>physics_api.hpp</li> <li>physics_api.hpp Source</li> <li>physics_engine.hpp</li> <li>physics_engine.hpp Source</li> <li>physics/types.hpp</li> <li>physics/types.hpp Source</li> <li>renderer.hpp</li> <li>renderer.hpp Source</li> <li>thread_utils/thread.hpp</li> <li>thread_utils/thread.hpp Source</li> <li>thread_utils.hpp</li> <li>thread_utils.hpp Source</li> </ul>"},{"location":"api/#other-appendices","title":"Other Appendices","text":"<ul> <li>Class Members: A combined index of all class members.<ul> <li>Functions</li> <li>Variables</li> <li>Typedefs</li> <li>Enums</li> </ul> </li> <li>Namespace Members: A combined index of all namespace members.<ul> <li>Functions</li> <li>Variables</li> <li>Typedefs</li> <li>Enums</li> </ul> </li> <li>Global Functions</li> <li>Global Macros</li> <li>Global Variables</li> <li>Source Code Links (if generated)</li> </ul>"},{"location":"getting_started/","title":"\ud83d\udcda Getting Started","text":""},{"location":"getting_started/#prerequisites","title":"\ud83d\udca5 Prerequisites","text":"<p>These are needed before working to get TheAtlasEngine building successfully on your platform.</p> <ul> <li><code>python</code>: 3.12 or above</li> <li><code>conan</code>: 2.10.0 or above</li> <li><code>llvm</code>: 17 or above</li> <li><code>CMake</code> Build tool for the project</li> <li><code>git</code>: Version control</li> </ul> WindowsUbuntu 20.0+MacOS X <p>Info</p> <p>Needs to install Visual Studio's installer before using the <code>winget</code> command</p> <p>Visual studio is required only on Windows for getting C++ to work</p> <p>Run this <code>winget</code> command to setup C++ with Visual Studio installer in powershell (in admin mode)</p> <pre><code>winget install Microsoft.VisualStudio.2022.BuildTools --override \"--add Microsoft.VisualStudio.Workload.VCTools --includeRecommended -p --installWhileDownloading\"\n</code></pre> <p>It is recommended to use Choco for an easy installation process on Windows.</p> <p>To install <code>choco</code>, open powershell with admin access and run the following command in your terminal (powershell must be admin):</p> <pre><code>Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n</code></pre> <p>Tip</p> <p>If <code>choco</code> command does not work after running this script try closing and reopening powershell again. When <code>choco</code> prompts you to run install scripts from the commands below, enter <code>all</code> so it can install everything.</p> <p>Install <code>git</code> (powershell must be admin): <pre><code>choco install git\n</code></pre></p> <p>Install <code>python</code> (powershell must be admin): <pre><code>choco install python --version=3.12.0\n</code></pre></p> <p>Install <code>llvm</code> (powershell must be admin):</p> <p>Error</p> <p>If you get this error make sure that your environment variable is set to LLVM's clang.exe and clang++.exe filepath.</p> <p>While also making sure </p> <pre><code>CMake Error at CMakeLists.txt:2 (project):\nThe CMAKE_CXX_COMPILER:\n\n    C:/Program Files/LLVM/bin/clang++.exe\n\nis not a full path to an existing compiler tool.\n</code></pre> <pre><code>choco install llvm\n</code></pre> <p>Install <code>conan</code> (powershell must be admin) <pre><code>pip install \"conan&gt;=2.10.2\"\n</code></pre></p> <p>Install cmake and make</p> <p>Error</p> <p>you can get this error if you DO NOT have 'make' installed via choco</p> <pre><code>CMake Error: CMake was unable to find a build program corresponding to \"Unix Makefiles\".  CMAKE_MAKE_PROGRAM is not set.  You probably need to select a different build tool.\n</code></pre> <p>Error</p> <p>you can get this error if you DO NOT have 'mingw' installed via choco</p> <p>CMake Error: CMake was unable to find a build program corresponding to \"MinGW Makefiles\".  CMAKE_MAKE_PROGRAM is not set.  You probably need to select a different build tool.</p> <pre><code>choco install make cmake\n</code></pre> <p>Info</p> <p>mingw is installed because we need <code>mingw32-make.exe</code> as dependencies will default to using \"MinGW Makefiles\" generator specified. which means that their CMake will look for <code>mingw32-make.exe</code> specific make executables instead of <code>make.exe</code></p> <p>Install mingw <pre><code>choco install mingw\n</code></pre></p> <p>Info</p> <p>Using this <code>winget</code> command will install Vulkan's installer, set it up for you, and set the environment path variable.</p> <p>Installing Vulkan's installer from the terminal in powershell. (in admin mode) <pre><code>winget install --id=KhronosGroup.VulkanSDK -e\n</code></pre></p> <p>Tip</p> <p>Once you have completely finish installing. DONT FORGET to refresh your powershell before building the TheAtlasEngine project.</p> <p>Install wget if it isn't already on your system</p> <p><code>sudo apt-get install wget</code></p> <p>Install the latest version of <code>llvm</code></p> <pre><code>wget https://apt.llvm.org/llvm.sh\nchmod +x llvm.sh\nsudo ./llvm.sh\n</code></pre> <p>Install LLVM's C+ standard library (this will use the llvm apt repos)</p> <pre><code>sudo apt install libc++-17-dev libc++abi-17-dev\n</code></pre> <p>Installing Linux Prerequisites</p> <pre><code>sudo apt install -y lsb-release wget software-properties-common gnupg libgtk2.0-dev libgl1-mesa-dev\nsudo apt-get install -y libx11-dev libx11-xcb-dev libfontenc-dev libice-dev libsm-dev libxau-dev libxaw7-dev libxt-dev libxtst-dev libxrender-dev libxrandr-dev libxi-dev\nsudo apt install -y software-properties-common\nsudo add-apt-repository ppa:deadsnakes/ppa\n</code></pre> <p>Info</p> <p>If your using 20.04, you have to upgrade Python to 3.10</p> <pre><code>sudo apt update\nsudo apt install software-properties-common -y\nsudo add-apt-repository ppa:deadsnakes/ppa\nsudo apt install Python3.10\n</code></pre> <p>Install pipx which is used to install conan</p> <pre><code>sudo apt install pipx\n</code></pre> <p>Installing conan</p> <pre><code>pipx install \"conan&gt;=2.10.1\"\n</code></pre> <p>Tip</p> <p>On linux vulkan is not needed to be installed, conan handles that</p> <p>Install Homebrew:</p> <p><pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> Install latest version of Python &amp;&amp; llvm:</p> <pre><code>brew install python pipx llvm@17\n</code></pre> <p>Install conan:</p> <pre><code>pipx install \"conan&gt;=2.10.2\"\n</code></pre> <p>Make <code>clang-tidy</code> available on the command line:</p> <pre><code>sudo ln -s $(brew --prefix llvm)/bin/clang-tidy /usr/local/bin/\n</code></pre> <p>Install Rosetta (only required for M1 macs):</p> <pre><code>/usr/sbin/softwareupdate --install-rosetta --agree-to-license\n</code></pre> <p>Info</p> <p>metal-cpp does not need to be installed because conan handles this for you</p>"},{"location":"getting_started/#setting-up-conan","title":"\ud83d\udce6 Setting up Conan","text":"<p>Install host profiles for your specific platforms</p> WindowsX86 LinuxM1 Mac <p>If you are on an x86 architecture for Windows.</p> <pre><code>conan config install -sf profiles/x86_64/Windows/ -tf profiles https://github.com/engine3d-dev/conan-config.git\n</code></pre> <p>If you are on a linux platform that uses an x86 architecture.</p> <pre><code>conan config install -sf profiles/x86_64/linux/ -tf profiles https://github.com/engine3d-dev/conan-config.git\n</code></pre> <p>If you are on an M1 Mac OS.</p> <pre><code>conan config install -sf profiles/armv8/mac/ -tf profiles https://github.com/engine3d-dev/conan-config.git\n</code></pre>"},{"location":"getting_started/#getting-project-repositories-from-artifactory","title":"\ud83d\udce5 Getting project repositories from Artifactory","text":"<p>Add the engine3d-conan repository to your system. This repository holds all of the TheAtlasEngine packages.</p> <pre><code>conan remote add engine3d-conan https://libhal.jfrog.io/artifactory/api/conan/engine3d-conan\n</code></pre>"},{"location":"getting_started/#development-environment-completed","title":"\u2705 Development Environment Completed!!","text":"<p>Once the development environment is completed. Then go to the repos to see the list of repositories that you plan to contribute to.</p>"},{"location":"getting_started/#changing-build-type","title":"Changing Build Type","text":"<p>The build type determines level of optimizations for the project you are building for. TheAtlasEngine by default is Release is because performance is one of the most important aspects of the project.</p> <p>You can change <code>build_type</code> to the following types:</p> <ul> <li> <p><code>Debug</code>: Turns on some optimizations to reduce binary size and improve performance while still maintaining the structure to make debugging easier. Recommended for testing and prototyping.</p> </li> <li> <p><code>Release</code>: Turns on optimizations and favors high-performance optimizations over space-saving optimizations.</p> </li> <li> <p><code>MinSizeRel</code>: Turns on optimizations and favor higher space saving optimizations over higher-performance.</p> </li> </ul> <p>Tip</p> <p>-b missing is only used during your first build.</p> <pre><code>conan build . -b missing -s build_type=Debug\n</code></pre> <p>This is how you can specify build types when building with conan:</p> <pre><code>conan build . -s build_type=Debug\n</code></pre>"},{"location":"summary/","title":"Summary","text":"<ul> <li>\ud83c\udfe0 Home</li> <li>\ud83d\udcda Getting Started</li> <li>\ud83d\udd79\ufe0f User Guide</li> <li>\ud83d\ude80 Contributor Guides</li> <li>\ud83c\udfa8 Style Guide</li> <li>\ud83d\udcdd Code Design</li> <li>\ud83d\udcdc Project Information</li> <li>About</li> <li>\ud83d\udcd6 Documentation</li> </ul>"},{"location":"contributor_guide/code_design/","title":"\ud83d\udcdd Core Engine Design","text":""},{"location":"contributor_guide/code_design/#interfaces","title":"Interfaces","text":"<p>Interfaces are the foundation of how the api-agnostic API's may work if they have vary defined backends. They present a generalized ideal of a particular aspect of computing.</p> <p>For example, a graphics API such as vulkan, directX, and metal. They both contain their own varied version of a command buffer. In Vulkan it is referred to as VkCommandBuffer, DirectX referred to as ID3D12GraphicsCommandList, and metal it is referred to as MTLCommandBuffer.</p> <p>Which each of this implementation may be operated differently that is widely dependent on their API's.</p> <p>This following guideline should be kept in mind when creating interfaces.</p> <p>Here is an example of some interfaces in libhal. It is recommended to look at these to get an idea of how the interfaces could be written.</p> <ul> <li>atlas::render_context</li> </ul>"},{"location":"contributor_guide/code_design/#designing-and-making-interfaces","title":"Designing and Making Interfaces","text":"<p>Using vtables are quite small and only require a single pointer lookup. The initial idea that comes to mind with vtables is minimize least number of lookups that needs to be made to virtual functions if possible.</p> <p>why?</p> <p>Each virtual function in an interface will require a v-table entry (a pointer) in the v-table of each implementation of an interface. Specific sections of the binary. More you have to store in space.</p> <p>Consider</p> <p>Having an interface for graphics for supporting multiple graphics API called <code>render_context</code>. This render_context could be an interface that may be used for implement the different graphics-api backends such as Vulkan, Metal, and DirectX3D.</p> <p>These are implementations that will have common API's to do equivalent operations. The interface will have common API's for operations such as writing data to a vertex, index, or uniform buffer.</p> <p>The fundamental idea is interfaces should be used to allow a generalized API that internal state of the engine could interact without touching or using any api-dependent code within the engine. That should be completely handle and communicated via those abstraction layers around those API's.</p>"},{"location":"contributor_guide/code_design/#inheritance-not-used-for-game-objects","title":"Inheritance Not Used for Game Objects","text":"<p>Why are we not using inheritance to express game object state?</p> <p>As game objects grow more complex, especially in modern game engines. Inheritance in game engines have been used to determine a variety of states game objects could be in. Including using virtual functions and inheritance to express relationships between the variety of complex states game objects can go into.</p> <p>What are the issues that comes from this design?</p> <p>To further learn why I went with a data-oriented design approach in atlas. It is because</p>"},{"location":"contributor_guide/code_design/#interfaces-not-used-for-actorsobjects","title":"Interfaces Not Used for Actors/Objects","text":"<p>Typically it is seen natural to have scene objects inherit from some virtual class to define a <code>UActor</code> (like unreal). As other engines will have their own variation of this.</p> <p>In this engine, I wanted to have a different look at building games, using a completely different approach in making games that does not have users by default be binded to a contract having them inherit a base class.</p> <p>These are caveuats I should mention below.</p> <ul> <li> <p>One of the biggest issue isn't just the binded contract devs have to make every time they need to make a new actor. Its also the size each actor now carries. What does this mean?</p> <ul> <li>This means that if you look at Unreal's and other engines they have their own variation of how they handle actors. Usually when creating custom actors that inherit, they carry the size of the objects they not only inherit of even if those functions do not get used.</li> <li>Which means bloated in class size in bytes.</li> </ul> </li> <li> <p>Amount of lookups in the vtable is quite high because lets look at particles for example.</p> <ul> <li>If we have particles that may vary in different aspects of geometry, mesh, assets, etc. The amount of difference in data can actually be widely expansive. What initially would happen is we'd have to lookup the vtable entry to get information about the actor every time we need something</li> <li>When we already know its memory location and where this scene object is located, we could minimize these caveuts and initially minimizing code bloatware of binary sizes because we are not creating actors through inheritance.</li> </ul> </li> </ul> <p>Given this example.</p> <p>In game engines today, you will have some variation following this approach.</p> <pre><code>class MyActor : public AActor {\npublic:\n    /* do other pre-init state initialization needed in implementation */\nprotected:\n    virtual void BeginPlay() override { /* do stuff when begin play ticked */ }\n};\n</code></pre>"},{"location":"contributor_guide/code_design/#different-perspective-creating-game-objects","title":"Different Perspective Creating Game Objects","text":"<p>As game object state grows more complex. TheAtlasEngine strives to allow game object to contain the data associated with. Rather the game objects themselves contain state. It is because game object state can be widely complex and making an attempt to try expressing these state for the objects in the form of inheritance and virtual functions can lead to caveauts that I want to research into.</p> <p>These caveauts involve code bloat, complex and high increase of vtables, complex contracts users are by default signed into when trying to make their own game objects.</p> <p>Approaching with a data-oriented design in mind. This way it could simplify what users need has to do for setting up a game object. Simplifying means of how these objects get created, lifetime managements of these objects, when these objects get updated. As time update frequency matters and giving users that control when their objects state get update is direct.</p> <p>Concerns Removed When Creating Objects <pre><code>// Creating custom scene to contain user-defined game objects in this given scene\nclass level_scene : public scene_scope{\npublic:\n    level_scene(const std::string&amp; p_tag) : scene_scope(p_tag) {\n        // Creating entity \"Camera Entity\" to this scene while setting the lifetime of this object to be managed by scene_scope\n        m_camera = this-&gt;create_new_entity(\"Camera Entity\");\n\n        // Creating entity \"Sphere Entity\" to this scene while setting the lifetime of this object to be managed by scene_scope\n        m_sphere = this-&gt;create_new_entity(\"Sphere Entity\");\n\n\n        // This registers our update callable and associates the address of our current scene\n        // then calling this function\n        atlas::sync(this, &amp;level_scene::update);\n\n        // physics() gets called during the interval of physics steps since the timing\n        // for physics can be different compared to logic during update\n        atlas::sync_physics(this, &amp;level_scene::physics);\n    }\n\n\n    void update() {\n        // Running our update logic for being called\n    }\n\n    void physics() {\n        // Running physics logic at the right time interval physics should run at.\n    }\n\nprivate:\n    atlas::ref&lt;atlas::scene_object&gt; m_camera;\n    atlas::ref&lt;atlas::scene_object&gt; m_sphere;\n};\n</code></pre></p>"},{"location":"contributor_guide/philosophy/","title":"Code Design","text":"<p>The core design tenets of <code>atlas</code> and libraries extending must seek to achieve every design choice, line written, and architecture made.</p> <p>D.0. General</p> <p><code>atlas</code> abstraction API's such as <code>engine-audio</code> should focus on enabling configurational settings that does not have users directly writing backend code. If users decide to use <code>engine-audio</code> they should not be touching any piece of code or API of miniaudio.</p> <p>D.1 Minimalist</p> <p><code>atlas</code> aims to be as simple as possible and no simpler. Libraries, Classes, implementation, and features should be implemented to handle currend edge cases. Then focus on expanding afterwards.</p> <p>D.2 Safe &amp; Reliable</p> <p><code>atlas</code> and its style guide uses patterns, techniques, and documentation to reduce safety issues and improve reliability throught out its codebases.</p> <p>D.3 Tested &amp; Testable</p> <p><code>atlas</code> codebases should be as testable and unit tested.</p> <p>D.4 Portable</p> <p>NOTE: In-progress</p> <p>As of this current moment in the early development of <code>atlas</code>, we only support windows.</p> <p><code>atlas</code> will aim to support multiple OS's backends. Such as for Linux and Mac.</p>"},{"location":"contributor_guide/style/","title":"\ud83c\udfa8 Style Guide","text":""},{"location":"contributor_guide/style/#s0-code-guidelines","title":"S.0 Code Guidelines","text":"<p>All guides follow the C++ Core Guidelines.</p>"},{"location":"contributor_guide/style/#s1-code-guidelines","title":"S.1. Code Guidelines","text":"<ul> <li> <p>Code in the atlas organization will follow the <code>.clang-format</code> file, which uses the Mozilla's</p> </li> <li> <p>Code will follow the atlas organization's <code>.naming.style</code> file, which are similar to the standard library's naming convention.</p> </li> <li> <p>CAP_CASE for MACROs (avoid MACROs in general).</p> </li> <li> <p>CamelCase used for template parameters</p> </li> <li>lowercase snake_case for everything else</li> <li>prefix <code>p_</code> for function parameters</li> <li> <p>prefix <code>m_</code> for private/protected class members</p> </li> <li> <p>Refrain from abbreviated variable name. Don't do <code>m_cnt</code> and just write out <code>m_count</code>.</p> </li> <li>Every file must end with a newline character.</li> <li>Every line in a file must stay within 80 character limit.</li> <li>Include C++ header versions of C headers such as <code>&lt;cstdint&gt;</code> vs <code>&lt;stdint.h&gt;</code></li> </ul>"},{"location":"contributor_guide/style/#s2-refrain-from-using-macros","title":"S.2. Refrain from using MACROS","text":"<p>Usually macros are replaced with <code>constexpr</code> or const variables or function calls.</p> <p>Only use preprocessors <code>#if</code> and the like if it is impossible to use <code>if constexpr</code> to achieve the same behavior.</p>"},{"location":"contributor_guide/style/#s3-interfaces-should-follow-the-public-private-api-scheme","title":"S.3. Interfaces should follow the public private API scheme.","text":"<p>See private virtual methods for more details. Rationale can be found with that link as well.</p>"},{"location":"contributor_guide/style/#s4-avoid-using-bool-as","title":"S.4. Avoid using <code>bool</code> as","text":"<p>NOTE: This is still in-progress</p>"},{"location":"contributor_guide/style/#s5-include-guards","title":"S.5. Include guards","text":"<p>For ease of usage, use <code>#pragma once</code> as your include guard. Usage of classic include guards like:</p> <pre><code>#ifndef FOO\n#define FOO\n\n#endif // FOO\n</code></pre> <p>Are annoying and error prone. Do not use these!</p> <p>S.6. Include Ordering</p> <p>Headers should be included in your header and source files in the following order:</p> <ul> <li> <p>C standard library headers. Include using chevrons: <code>&lt;&gt;</code></p> </li> <li> <p>C++ 3rd party library packages. Include using chevrons: <code>&lt;&gt;</code></p> </li> <li> <p>C++ Standard library headers. Include using chevrons: <code>&lt;&gt;</code></p> </li> <li> <p>Local Header/Project Headers. Include using quotes <code>\"\"</code></p> </li> </ul> <p>For standard C headers use C++ <code>&lt;cstdio&gt;</code> style over the C <code>&lt;stdio.h&gt;</code> style.</p> <p>Example of how this should look:</p> <pre><code>#pragma once\n\n// C header first\n#include &lt;cstdio&gt;\n#include &lt;cstdint&gt;\n\n// C++ headers\n#include &lt;string_view&gt;\n#include &lt;span&gt;\n\n// C++ library header s\n#include &lt;atlas/application.hpp&gt;\n#include &lt;atlas/core/event/event.hpp&gt;\n\n// Local project\n#include \"game-template/content/custom_scene.hpp\"\n#include \"game-template/content/custom_actor.hpp\"\n\n// actual code goes here\n</code></pre> <p>Exception: <code>boost.ut</code> must ALWAYS be the last include in your code in order to allow <code>ostream operator&lt;&lt;</code> overloading to work.</p>"},{"location":"contributor_guide/style/#s6-classes","title":"S.6. Classes","text":""},{"location":"contributor_guide/style/#s61-declaration-order","title":"S.6.1. Declaration Order","text":"<p>Class's visibility specifiers and member sections should appear in the following order.</p> <ol> <li> <p>Public.</p> </li> <li> <p>Protected.</p> </li> <li> <p>Private.</p> </li> </ol> <p>Omit any sections that would be empty.</p> <p>Within each section, group similar declarations together this order and follow this order:</p> <ol> <li> <p>Types and type aliases</p> <ul> <li> <p>Using directives (<code>using</code>)</p> </li> <li> <p>Enum Classes</p> </li> <li> <p>Nested structs and classes</p> </li> <li> <p>Friend classes and structs</p> </li> </ul> </li> <li> <p>Static constants</p> </li> <li>Factory functions (if applicable)</li> <li>Constructors and assignment operators</li> <li>Destructor</li> <li>All other member functions (static and non static member functions, as well as friend functions)</li> <li>All other data members (static and non-static)</li> </ol> <p>Do not put large method definitions inline within the class definition. Typically only trivial or performance critical methods \\ that are very short may be defined inline. If the class as a template, then all functions must be defined inline in the\\ header file.</p> <p>Note</p> <p>if a friend is a class or class function, then the friend should appear under the same visibility \\ specifier as a friend. For example, if you are friending a private class function, then the friend \\ function delcaration should also appear in the private section of the friending class.</p>"},{"location":"contributor_guide/style/#s62-storing-references","title":"S.6.2. Storing References","text":"<p>Class within the project should not have reference member variables like so:</p> <pre><code>class my_scene {\npublic:\n    my_scene(flecs::registry&amp; p_registry) : m_registry(p_registry) {}\n\nprivate:\n    flecs::registry&amp; m_registry;\n};\n</code></pre> <p>Reference members implicitly delete copy constructors of a class they are within because they are themselves are not copyable. You cannot reassign a reference after it's made.</p> <p>Instead take the parameter as a reference but save its address as a pointer.</p> <pre><code>class my_scene {\npublic:\n    my_scene(flecs::registry&amp; p_registry) : m_registry(&amp;p_registry) {}\n\nprivate:\n    flecs::registry* m_registry;\n};\n</code></pre>"},{"location":"user_guide/setup_vscode/","title":"\ud83d\udd79\ufe0f Setting VSCode w/ <code>clangd</code>","text":"<p>The majority of the contributors and users uses Visual Studio Code. These guidelines should also help with non-vscoders as well.</p>"},{"location":"user_guide/setup_vscode/#setup-vscode-configuration","title":"Setup VSCode Configuration","text":"<p>Make sure you already install clang via getting started.</p> <ol> <li>Install VSCode if you haven't already done so.</li> <li>Go to the \"Extensions\" section on left-side of the bar. It looks like 4 blocks with the upper right-hand block disconnected from the other 3. Hover over the icons to get their name.</li> <li>Search for \"C/C++\" and disable the Windows intellisense extension if it is already installed and enabled.</li> <li>Search for the extension <code>clangd</code> and install the extension.</li> <li>Go to the <code>clangd</code> extension settings page. Find <code>clangd</code> extension and press the GEAR \u2699\ufe0f icon to open in settings.</li> <li>Find the settings <code>clangd: Arguments</code> and add:<ol> <li>In <code>Clangd: Arguments</code> input <code>--header-insertion=never</code></li> </ol> </li> </ol>"},{"location":"user_guide/setup_vscode/#disable-vscode-default-intellisense","title":"Disable VSCode Default Intellisense","text":"<p>When using <code>clangd</code> it will conflict with Visual Studio Code's default intellisense. This is how you can disable it.</p> <p>Follow the same setups above. In the intellisense sections in the extensions for \"C/C++\".</p> <p>Check the disable checkbox as shown below</p> <p></p>"},{"location":"user_guide/setup_vscode/#disable-auto-include-headers","title":"Disable auto-include headers","text":"<p>If you do not want auto-imported headers and are already including them if you have precompiled headers setup. This is how you can disable them.</p> <p>Clangd arguments should look like this:</p> <p></p>"},{"location":"user_guide/setup_vscode/#used-in-your-own-project","title":"Used in your own project","text":"<p>You can either add a <code>self.requires(\"engine3d-cmake-utils/3.0\")</code> to your project or add the following lines to your <code>CMakeLists.txt</code></p> <pre><code># Generate compile commands for anyone using our libraries.\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n\n# Always run this custom target by making it depend on ALL\nadd_custom_target(copy_compile_commands ALL\n    COMMAND ${CMAKE_COMMAND} -E copy_if_different\n    ${CMAKE_BINARY_DIR}/compile_commands.json\n    ${CMAKE_SOURCE_DIR}/compile_commands.json\n    DEPENDS ${CMAKE_BINARY_DIR}/compile_commands.json)\n</code></pre> <p>Run <code>conan build .</code> (where <code>.</code> is the path to your project/library) and it should generate the <code>compile_commands.json</code> file.</p> <p>To ensure that the dependencies in your <code>conanfile.py</code> file that uses <code>self.requires</code>.</p> <p>You can also run with <code>-b missing</code> (where <code>-b missing</code> indicates that to install any missing binary into the conan cache)</p> <pre><code>conan build . -b missing\n</code></pre>"},{"location":"user_guide/setup_vscode/#how-clangd-works","title":"How <code>clangd</code> works","text":"<p>Once you get <code>clangd</code> setup. Let me tell you how clangd works. Your workspace needs <code>compile_commands.json</code> file to be present or using <code>.clangd</code> in the root of your project's directory to be configured to know where to look for the location the <code>compile_commands.json</code> is located.</p> <p><code>compile_commands.json</code> tells <code>clangd</code> what commands you are using in order to determine exactly how your files are build and whjat commands are used to build them. Which provides the following benefits:</p> <ol> <li>More accurate warnings and error messages within your IDE.</li> <li>Faster response time because only the necessary includes for the specific version you are targeted will be used when evaluated.</li> </ol>"},{"location":"References/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace JPH </li> <li>namespace atlas <ul> <li>class application </li> <li>struct application_settings </li> <li>struct box_collider3d </li> <li>class camera </li> <li>class console_log_manager </li> <li>class entity_t </li> <li>namespace event <ul> <li>struct joystick_button </li> <li>struct joystick_info </li> </ul> </li> <li>namespace filesystem </li> <li>class graphics_context </li> <li>class interpolation </li> <li>struct light TODO: Make this better (when we do lighting) </li> <li>struct material </li> <li>struct math_generic </li> <li>struct matrix2 </li> <li>struct matrix3 </li> <li>struct matrix4 </li> <li>class mesh </li> <li>namespace physics Handles error handling with in jolt. <ul> <li>class broad_phase_layer_interface This class is made to control the broadphase layer. Filters can be added to it to create a better and more organized broadphase. Ass well as giving some control to the user on how the broadphase should be organized. This requires dynamic masking however, which is not currently running. </li> <li>struct collider_body </li> <li>struct collider_event This is a replacement for an event system to handle collider. It will be replaced by an event system once we have functional one up and running. </li> <li>struct contact_event </li> <li>class contact_listener This is the glue between contact events and jolts contact listener. It takes the calls from jolt through virtual functions and allows users to create children for jolt collision. </li> <li>class jolt_api </li> <li>class jolt_collision This is the collision api. It allows users to create children of this collision handler and write their own functions over the virtual ones. Then they can assign it to the engine. </li> <li>class jolt_collision_manager This allows users to make thier own version of jolt collition and run them their own way. It allows users to interact with the calls by creating a child class of jolt_collision and run whatever action they want. </li> <li>struct jolt_config Used to keep global data for player access and use. Tells how physics bodies should act within a given scene by default. </li> <li>class jolt_context This class is made to be 1 of three api wrappers for jolt. Jolt context is specifically for engine only use of the api. It wraps the inititialization, the physics step and the clean up. Allow use not to have to write batching algorithms for each time we want to change the settings of jolt physics. </li> <li>struct jolt_settings This includes global configs for each scene and how the physics engine will behave in a paticular scene. </li> <li>struct matrix4 </li> <li>struct matrix4&lt; JPH::Mat44 &gt; </li> <li>class object_layer_pair_filter This goes into more detailed ways of filtering, where the object collisions may be defined be what the other object is. In this case a static setup allows static object to trigger collision only when it is touched by a dynamic target. </li> <li>class object_vs_broadphase_layer This is used to tell Jolt what can or cannot collide. As of right now the list is static therfore the layers do not need a dynamic set up. This will change when the object layers become user definable. </li> <li>class physics_api </li> <li>struct physics_body </li> <li>class physics_context The context is the way to interact with only the engine. It is the api for all the background funcitons and information that the user shouldn not see. It is a virtual based type erasure class so thatmany engines can implement the same functions. Specifically realted to backend engine creation like batching, starting runtime, etc... </li> <li>class physics_engine The manager class for all physics engines. Manages the physics contexts and the collision engines. </li> <li>struct quaternion </li> <li>struct vector3 </li> <li>struct vector3&lt; JPH::DVec3 &gt; </li> <li>struct vector3&lt; JPH::Double3 &gt; </li> <li>struct vector3&lt; JPH::Float3 &gt; </li> <li>struct vector3&lt; JPH::Vec3 &gt; </li> <li>struct vector4 </li> <li>struct vector4&lt; JPH::Float4 &gt; </li> <li>struct vector4&lt; JPH::Vec4 &gt; </li> </ul> </li> <li>struct reload Actually might do a query for this along with rendertarget3d. </li> <li>class render_context </li> <li>class renderer </li> <li>struct rigidbody3d </li> <li>class scene_object </li> <li>class scene_scope </li> <li>class serializer </li> <li>namespace sync_update </li> <li>class system_registry </li> <li>struct tag </li> <li>class thread </li> <li>class timer </li> <li>struct transform </li> <li>struct transform_physics </li> <li>namespace ui </li> <li>struct vector2 </li> <li>struct vector2&lt; glm::highp_vec2 &gt; </li> <li>struct vector3 </li> <li>struct vector3&lt; JPH::Vec3 &gt; </li> <li>struct vector3&lt; glm::highp_vec3 &gt; </li> <li>struct vector4 </li> <li>struct vector4&lt; glm::highp_vec4 &gt; </li> <li>namespace vk <ul> <li>struct camera_ubo Going to remove this. </li> <li>struct command_buffer_settings settings for specifying command buffers to construct </li> <li>struct descriptor_binding_entry </li> <li>struct descriptor_binding_point </li> <li>class descriptor_set </li> <li>struct descriptor_set_layout </li> <li>struct global_ubo Just for testing purposes for sending this struct over to the shader. </li> <li>struct hud_data </li> <li>struct image_extent </li> <li>class imgui_context </li> <li>struct material_uniform material is going to define properties about how a scene object itself gets rendered </li> <li>class mesh mesh class specifically defined with vulkan implementations for specific primitives TODO: Whenever we load in a texture that will be laucnhed asyncronously </li> <li>struct renderpass_attachment </li> <li>struct renderpass_options </li> <li>struct shader_info </li> <li>struct surface_properties </li> <li>class texture </li> <li>struct texture_extent </li> <li>struct texture_properties </li> <li>struct vertex_attribute </li> <li>struct vertex_attribute_entry </li> <li>struct vertex_input </li> <li>struct vk_buffer vulkan buffer struct to define the handlers and memory specifications required for buffer handlers in vulkan </li> <li>struct vk_buffer_info Specifications of the vulkan buffer handlers and the use and memory bits associated with the buffer handlers. </li> <li>class vk_command_buffer Vulkan Command Buffers. </li> <li>class vk_context </li> <li>class vk_driver vulkan implementation of extracting a logical device </li> <li>struct vk_filter_range Range between min and max for the VkFilter. </li> <li>class vk_graphics_queue graphics queue mainly used for submitting to the graphics family specific queue </li> <li>struct vk_image vulkan image handler with resources; used when handling textures </li> <li>struct vk_image_handle </li> <li>class vk_index_buffer </li> <li>class vk_physical_driver </li> <li>class vk_pipeline </li> <li>class vk_present_queue Handles submissions to the specific queue for presentation. </li> <li>struct vk_queue_options </li> <li>class vk_renderer Something to consider for mesh loading. </li> <li>class vk_renderpass defines a renderpass operation </li> <li>struct vk_renderpass_options Renderpass specifictations for VkRenderpass. </li> <li>class vk_shader_group </li> <li>struct vk_shader_module </li> <li>class vk_swapchain </li> <li>class vk_uniform_buffer </li> <li>class vk_vertex_buffer </li> <li>class vk_window </li> </ul> </li> <li>class window </li> <li>struct window_settings Specific settings to the window configuration. </li> <li>class world_scope Lets rethink how world_scope gets created. </li> </ul> </li> <li>struct device_queue_family </li> <li>struct queue_family_indices </li> <li>namespace std <ul> <li>struct hash&lt; atlas::vk::vertex_input &gt; </li> </ul> </li> </ul>"},{"location":"References/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir TheAtlasEngine <ul> <li>dir atlas <ul> <li>dir components <ul> <li>file transform.hpp </li> </ul> </li> <li>dir core <ul> <li>dir event <ul> <li>file event.hpp </li> <li>file joystick_codes.hpp </li> <li>file key_codes.hpp </li> <li>file mouse_codes.hpp </li> </ul> </li> <li>dir filesystem <ul> <li>file file_dialog.hpp </li> </ul> </li> <li>dir geometry <ul> <li>file mesh.hpp </li> </ul> </li> <li>dir image <ul> <li>file stb_image.hpp </li> </ul> </li> <li>dir math <ul> <li>file math.hpp </li> <li>file types.hpp </li> </ul> </li> <li>dir scene <ul> <li>file components.hpp </li> <li>file entity.hpp </li> <li>file scene.hpp </li> <li>file scene_object.hpp </li> <li>file world.hpp </li> </ul> </li> <li>dir serialize <ul> <li>file serializer.hpp </li> </ul> </li> <li>dir system_framework <ul> <li>file system_registry.hpp </li> </ul> </li> <li>dir threads <ul> <li>file thread.hpp </li> </ul> </li> <li>dir ui <ul> <li>file widgets.hpp </li> </ul> </li> <li>dir update_handlers <ul> <li>file sync_update.hpp </li> <li>file timer.hpp </li> </ul> </li> <li>dir utilities <ul> <li>file hash.hpp </li> <li>file types.hpp </li> </ul> </li> <li>file api.hpp </li> <li>file application.hpp </li> <li>file core.hpp </li> <li>file engine_logger.hpp </li> <li>file timer.hpp </li> <li>file window.hpp </li> </ul> </li> <li>dir drivers <ul> <li>dir vulkan-cpp <ul> <li>dir utilties <ul> <li>file utils.hpp </li> </ul> </li> <li>file hash.hpp </li> <li>file helper_functions.hpp </li> <li>file mesh.hpp </li> <li>file vk_command_buffer.hpp </li> <li>file vk_context.hpp </li> <li>file vk_descriptor_set.hpp </li> <li>file vk_driver.hpp </li> <li>file vk_graphics_queue.hpp </li> <li>file vk_imgui.hpp </li> <li>file vk_index_buffer.hpp </li> <li>file vk_physical_driver.hpp </li> <li>file vk_pipeline.hpp </li> <li>file vk_present_queue.hpp </li> <li>file vk_renderer.hpp </li> <li>file vk_renderpass.hpp </li> <li>file vk_shader_group.hpp </li> <li>file vk_swapchain.hpp </li> <li>file vk_texture.hpp </li> <li>file vk_types.hpp </li> <li>file vk_uniform_buffer.hpp </li> <li>file vk_vertex_buffer.hpp </li> <li>file vk_window.hpp </li> <li>file vulkan-imports.hpp </li> </ul> </li> <li>file graphics_context.hpp </li> <li>file renderer_context.hpp </li> </ul> </li> <li>dir physics <ul> <li>dir jolt-cpp <ul> <li>file jolt-imports.hpp </li> <li>file jolt_api.hpp </li> <li>file jolt_collision.hpp </li> <li>file jolt_collision_manager.hpp </li> <li>file jolt_components.hpp </li> <li>file jolt_contact_listener.hpp </li> <li>file jolt_error_handler.hpp </li> </ul> </li> <li>dir physics_3d <ul> <li>dir jolt <ul> <li>dir interface <ul> <li>file jolt_broad_phase.hpp </li> </ul> </li> <li>file jolt_api.hpp </li> <li>file jolt_context.hpp </li> <li>file jolt_helper.hpp </li> </ul> </li> <li>file physics.hpp </li> <li>file physics_api.hpp </li> <li>file physics_context.hpp </li> <li>file physics_engine.hpp </li> </ul> </li> <li>file types.hpp </li> </ul> </li> <li>dir renderer <ul> <li>file renderer.hpp </li> </ul> </li> <li>dir thread_utils <ul> <li>file thread.hpp </li> <li>file thread_utils.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"References/namespaceJPH/","title":"Namespace JPH","text":"<p>Namespace List &gt; JPH</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"References/namespaceatlas/","title":"Namespace atlas","text":"<p>Namespace List &gt; atlas</p> <p>More...</p>"},{"location":"References/namespaceatlas/#namespaces","title":"Namespaces","text":"Type Name namespace event namespace filesystem namespace physics Handles error handling with in jolt. namespace sync_update namespace ui namespace vk"},{"location":"References/namespaceatlas/#classes","title":"Classes","text":"Type Name class application struct application_settings struct box_collider3d class camera class console_log_manager class entity_t class graphics_context class interpolation struct light TODO: Make this better (when we do lighting) struct material struct math_generic &lt;typename T&gt; struct matrix2 &lt;typename T&gt; struct matrix3 &lt;typename T&gt; struct matrix4 &lt;typename T&gt; class mesh struct reload Actually might do a query for this along with rendertarget3d. class render_context class renderer struct rigidbody3d class scene_object class scene_scope class serializer class system_registry struct tag class thread class timer struct transform struct transform_physics struct vector2 &lt;typename T&gt; struct vector2&lt; glm::highp_vec2 &gt; &lt;&gt; struct vector3 &lt;typename T&gt; struct vector3&lt; JPH::Vec3 &gt; &lt;&gt; struct vector3&lt; glm::highp_vec3 &gt; &lt;&gt; struct vector4 &lt;typename T&gt; struct vector4&lt; glm::highp_vec4 &gt; &lt;&gt; class window struct window_settings Specific settings to the window configuration. class world_scope Lets rethink how world_scope gets created."},{"location":"References/namespaceatlas/#public-types","title":"Public Types","text":"Type Name enum CameraMovement enum api typedef vector2&lt; glm::highp_vec2 &gt; highp_vec2 typedef vector3&lt; glm::highp_vec3 &gt; highp_vec3 typedef vector4&lt; glm::highp_vec4 &gt; highp_vec4 typedef math_generic&lt; glm::mat&lt; C, R, T &gt; &gt; mat typedef matrix2&lt; glm::mat2 &gt; mat2 typedef matrix3&lt; glm::mat3 &gt; mat3 typedef matrix4&lt; glm::mat4 &gt; mat4 typedef std::shared_ptr&lt; T &gt; ref typedef std::unique_ptr&lt; T &gt; scope typedef math_generic&lt; glm::vec&lt; Size, T &gt; &gt; vec typedef vector2&lt; glm::vec2 &gt; vec2 typedef vector3&lt; glm::vec3 &gt; vec3 typedef vector4&lt; glm::vec4 &gt; vec4 typedef std::weak_ptr&lt; T &gt; weak_ptr"},{"location":"References/namespaceatlas/#public-functions","title":"Public Functions","text":"Type Name void attach (UObject * p_instance, const UCallable &amp; p_callable)  constexpr ref&lt; T &gt; create_ref (Args &amp;&amp;... args)  constexpr scope&lt; T &gt; create_scope (Args &amp;&amp;... args)  constexpr weak_ptr&lt; T &gt; create_weak_ptr (Args &amp;&amp;... args)  ref&lt; window &gt; create_window (const window_settings &amp; p_settings)  uint32_t get_thread_count ()  void hash_combine (size_t &amp; seed, const T &amp; v, const Rest &amp;... rest)  ref&lt; application &gt; initialize_application ()  ref&lt; graphics_context &gt; initialize_context (const std::string &amp; p_tag)  scope&lt; render_context &gt; initialize_renderer (const vk::vk_swapchain &amp; p_swapchain, const std::string &amp; p_tag)  void post (UObject * p_instance, const UCallable &amp; p_callable)  void sync (UObject * p_instance, const UCallable &amp; p_callable)  void sync_physics (UObject * p_instance, const UCallable &amp; p_callable)  weak_ptr&lt; T &gt; to_weak_ptr (const U &amp; p_value)"},{"location":"References/namespaceatlas/#public-static-functions","title":"Public Static Functions","text":"Type Name void core_assert (bool x, T &amp;&amp;... args)"},{"location":"References/namespaceatlas/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>This is just a class abstraction idea</p> <p>class swapchain { public: virtual ~swapchain();</p> <p>uint32_t read_acquired_next_image();</p> <p>private: virtual uint32_t swapchain_read_acquried_image() = 0; };</p> <p>Here are responsibilities I want the renderer/vk_renderer to have Task graph for command buffer submission/execution API's are going to be using defer_submit API's are potentially (with ???) using immediate_submit </p>"},{"location":"References/namespaceatlas/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"References/namespaceatlas/#enum-cameramovement","title":"enum CameraMovement","text":"<pre><code>enum atlas::CameraMovement {\n    forward,\n    backward,\n    left,\n    right,\n    up,\n    down\n};\n</code></pre>"},{"location":"References/namespaceatlas/#enum-api","title":"enum api","text":"<pre><code>enum atlas::api {\n    vulkan,\n    dx11,\n    fx12,\n    undefined\n};\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-highp_vec2","title":"typedef highp_vec2","text":"<pre><code>using atlas::highp_vec2 = typedef vector2&lt;glm::highp_vec2&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-highp_vec3","title":"typedef highp_vec3","text":"<pre><code>using atlas::highp_vec3 = typedef vector3&lt;glm::highp_vec3&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-highp_vec4","title":"typedef highp_vec4","text":"<pre><code>using atlas::highp_vec4 = typedef vector4&lt;glm::highp_vec4&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-mat","title":"typedef mat","text":"<pre><code>using atlas::mat = typedef math_generic&lt;glm::mat&lt;C, R, T&gt; &gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-mat2","title":"typedef mat2","text":"<pre><code>using atlas::mat2 = typedef matrix2&lt;glm::mat2&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-mat3","title":"typedef mat3","text":"<pre><code>using atlas::mat3 = typedef matrix3&lt;glm::mat3&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-mat4","title":"typedef mat4","text":"<pre><code>using atlas::mat4 = typedef matrix4&lt;glm::mat4&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-ref","title":"typedef ref","text":"<pre><code>using atlas::ref = typedef std::shared_ptr&lt;T&gt;;\n</code></pre> <p>Note:</p> <p>Some aliases for the smart pointers </p>"},{"location":"References/namespaceatlas/#typedef-scope","title":"typedef scope","text":"<pre><code>using atlas::scope = typedef std::unique_ptr&lt;T&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-vec","title":"typedef vec","text":"<pre><code>using atlas::vec = typedef math_generic&lt;glm::vec&lt;Size, T&gt; &gt;;\n</code></pre> <p>Note:</p> <p>By default we use glm </p>"},{"location":"References/namespaceatlas/#typedef-vec2","title":"typedef vec2","text":"<pre><code>using atlas::vec2 = typedef vector2&lt;glm::vec2&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-vec3","title":"typedef vec3","text":"<pre><code>using atlas::vec3 = typedef vector3&lt;glm::vec3&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-vec4","title":"typedef vec4","text":"<pre><code>using atlas::vec4 = typedef vector4&lt;glm::vec4&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-weak_ptr","title":"typedef weak_ptr","text":"<pre><code>using atlas::weak_ptr = typedef std::weak_ptr&lt;T&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas/#function-attach","title":"function attach","text":"<pre><code>template&lt;typename UObject, typename UCallable&gt;\nvoid atlas::attach (\n    UObject * p_instance,\n    const UCallable &amp; p_callable\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-create_ref","title":"function create_ref","text":"<pre><code>template&lt;typename T, typename... Args&gt;\nconstexpr ref &lt; T &gt; atlas::create_ref (\n    Args &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-create_scope","title":"function create_scope","text":"<pre><code>template&lt;typename T, typename... Args&gt;\nconstexpr scope&lt; T &gt; atlas::create_scope (\n    Args &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-create_weak_ptr","title":"function create_weak_ptr","text":"<pre><code>template&lt;typename T, typename... Args&gt;\nconstexpr weak_ptr&lt; T &gt; atlas::create_weak_ptr (\n    Args &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-create_window","title":"function create_window","text":"<pre><code>ref &lt; window &gt; atlas::create_window (\n    const window_settings &amp; p_settings\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-get_thread_count","title":"function get_thread_count","text":"<pre><code>uint32_t atlas::get_thread_count () \n</code></pre>"},{"location":"References/namespaceatlas/#function-hash_combine","title":"function hash_combine","text":"<pre><code>template&lt;typename T, typename... Rest&gt;\nvoid atlas::hash_combine (\n    size_t &amp; seed,\n    const T &amp; v,\n    const Rest &amp;... rest\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-initialize_application","title":"function initialize_application","text":"<pre><code>ref &lt; application &gt; atlas::initialize_application () \n</code></pre>"},{"location":"References/namespaceatlas/#function-initialize_context","title":"function initialize_context","text":"<pre><code>ref &lt; graphics_context &gt; atlas::initialize_context (\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-initialize_renderer","title":"function initialize_renderer","text":"<pre><code>scope&lt; render_context &gt; atlas::initialize_renderer (\n    const vk::vk_swapchain &amp; p_swapchain,\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-post","title":"function post","text":"<pre><code>template&lt;typename UObject, typename UCallable&gt;\nvoid atlas::post (\n    UObject * p_instance,\n    const UCallable &amp; p_callable\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-sync","title":"function sync","text":"<pre><code>template&lt;typename UObject, typename UCallable&gt;\nvoid atlas::sync (\n    UObject * p_instance,\n    const UCallable &amp; p_callable\n) \n</code></pre> <p>Note:</p> <p>These are public functions that users can utilize </p> <p>Note:</p> <p>If users are using anything within the sync_update namespace. They shouldn't </p>"},{"location":"References/namespaceatlas/#function-sync_physics","title":"function sync_physics","text":"<pre><code>template&lt;typename UObject, typename UCallable&gt;\nvoid atlas::sync_physics (\n    UObject * p_instance,\n    const UCallable &amp; p_callable\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-to_weak_ptr","title":"function to_weak_ptr","text":"<pre><code>template&lt;typename T, typename U&gt;\nweak_ptr&lt; T &gt; atlas::to_weak_ptr (\n    const U &amp; p_value\n) \n</code></pre>"},{"location":"References/namespaceatlas/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/namespaceatlas/#function-core_assert","title":"function core_assert","text":"<pre><code>template&lt;typename... T&gt;\nstatic void atlas::core_assert (\n    bool x,\n    T &amp;&amp;... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/components/transform.hpp</code></p>"},{"location":"References/classatlas_1_1application/","title":"Class atlas::application","text":"<p>ClassList &gt; atlas &gt; application</p>"},{"location":"References/classatlas_1_1application/#public-functions","title":"Public Functions","text":"Type Name application (const application_settings &amp; p_settings)  void execute ()  VkSwapchainKHR get_current_swapchain ()  void post_destroy ()  ~application ()"},{"location":"References/classatlas_1_1application/#public-static-functions","title":"Public Static Functions","text":"Type Name float aspect_ratio ()  api current_api ()  uint32_t current_frame ()  float delta_time ()  void destroy ()  window &amp; get_window ()  uint32_t image_size () Returns uint32_t the size of images the swapchain accepts. float physics_step ()"},{"location":"References/classatlas_1_1application/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1application/#function-application","title":"function application","text":"<pre><code>atlas::application::application (\n    const application_settings &amp; p_settings\n) \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-execute","title":"function execute","text":"<pre><code>void atlas::application::execute () \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-get_current_swapchain","title":"function get_current_swapchain","text":"<pre><code>VkSwapchainKHR atlas::application::get_current_swapchain () \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-post_destroy","title":"function post_destroy","text":"<pre><code>void atlas::application::post_destroy () \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-application_1","title":"function ~application","text":"<pre><code>atlas::application::~application () \n</code></pre>"},{"location":"References/classatlas_1_1application/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1application/#function-aspect_ratio","title":"function aspect_ratio","text":"<pre><code>static float atlas::application::aspect_ratio () \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-current_api","title":"function current_api","text":"<pre><code>static api atlas::application::current_api () \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-current_frame","title":"function current_frame","text":"<pre><code>static uint32_t atlas::application::current_frame () \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-delta_time","title":"function delta_time","text":"<pre><code>static float atlas::application::delta_time () \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-destroy","title":"function destroy","text":"<pre><code>static void atlas::application::destroy () \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-get_window","title":"function get_window","text":"<pre><code>static inline window &amp; atlas::application::get_window () \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-image_size","title":"function image_size","text":"<p>Returns uint32_t the size of images the swapchain accepts. <pre><code>static uint32_t atlas::application::image_size () \n</code></pre></p>"},{"location":"References/classatlas_1_1application/#function-physics_step","title":"function physics_step","text":"<pre><code>static float atlas::application::physics_step () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/application.hpp</code></p>"},{"location":"References/structatlas_1_1application__settings/","title":"Struct atlas::application_settings","text":"<p>ClassList &gt; atlas &gt; application_settings</p>"},{"location":"References/structatlas_1_1application__settings/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t Height   = <code>0</code> std::string Name   = <code>\"Undefined\"</code> uint32_t Width   = <code>0</code>"},{"location":"References/structatlas_1_1application__settings/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1application__settings/#variable-height","title":"variable Height","text":"<pre><code>uint32_t atlas::application_settings::Height;\n</code></pre>"},{"location":"References/structatlas_1_1application__settings/#variable-name","title":"variable Name","text":"<pre><code>std::string atlas::application_settings::Name;\n</code></pre>"},{"location":"References/structatlas_1_1application__settings/#variable-width","title":"variable Width","text":"<pre><code>uint32_t atlas::application_settings::Width;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/application.hpp</code></p>"},{"location":"References/structatlas_1_1box__collider3d/","title":"Struct atlas::box_collider3d","text":"<p>ClassList &gt; atlas &gt; box_collider3d</p> <p>More...</p> <ul> <li><code>#include &lt;components.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1box__collider3d/#public-attributes","title":"Public Attributes","text":"Type Name float density   = <code>1.0f</code> float friction   = <code>0.5f</code> glm::vec3 offset   = <code>{ 0.f, 0.f, 0.f }</code> float restitution   = <code>0.0f</code> float restitutionThreshold   = <code>0.5f</code> glm::vec3 size   = <code>{ 0.5f, 0.5f, 0.5f }</code>"},{"location":"References/structatlas_1_1box__collider3d/#public-functions","title":"Public Functions","text":"Type Name box_collider3d () = default box_collider3d (const box_collider3d &amp;) = default"},{"location":"References/structatlas_1_1box__collider3d/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Our interpretation of the BoxCollider that will get interpreted based on physics API's enabled </p>"},{"location":"References/structatlas_1_1box__collider3d/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1box__collider3d/#variable-density","title":"variable density","text":"<pre><code>float atlas::box_collider3d::density;\n</code></pre>"},{"location":"References/structatlas_1_1box__collider3d/#variable-friction","title":"variable friction","text":"<pre><code>float atlas::box_collider3d::friction;\n</code></pre>"},{"location":"References/structatlas_1_1box__collider3d/#variable-offset","title":"variable offset","text":"<pre><code>glm::vec3 atlas::box_collider3d::offset;\n</code></pre>"},{"location":"References/structatlas_1_1box__collider3d/#variable-restitution","title":"variable restitution","text":"<pre><code>float atlas::box_collider3d::restitution;\n</code></pre>"},{"location":"References/structatlas_1_1box__collider3d/#variable-restitutionthreshold","title":"variable restitutionThreshold","text":"<pre><code>float atlas::box_collider3d::restitutionThreshold;\n</code></pre>"},{"location":"References/structatlas_1_1box__collider3d/#variable-size","title":"variable size","text":"<pre><code>glm::vec3 atlas::box_collider3d::size;\n</code></pre>"},{"location":"References/structatlas_1_1box__collider3d/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1box__collider3d/#function-box_collider3d-12","title":"function box_collider3d [1/2]","text":"<pre><code>atlas::box_collider3d::box_collider3d () = default\n</code></pre>"},{"location":"References/structatlas_1_1box__collider3d/#function-box_collider3d-22","title":"function box_collider3d [2/2]","text":"<pre><code>atlas::box_collider3d::box_collider3d (\n    const box_collider3d &amp;\n) = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/components.hpp</code></p>"},{"location":"References/classatlas_1_1camera/","title":"Class atlas::camera","text":"<p>ClassList &gt; atlas &gt; camera</p> <p>More...</p> <ul> <li><code>#include &lt;components.hpp&gt;</code></li> </ul>"},{"location":"References/classatlas_1_1camera/#public-attributes","title":"Public Attributes","text":"Type Name float AspectRatio   = <code>0.f</code> glm::vec3 Down glm::vec3 EulerRotation bool IsMainCamera   = <code>false</code> glm::vec3 Left float MouseSensitivity   = <code>{}</code> float MovementSpeed   = <code>{}</code> glm::vec3 Position glm::mat4 Projection glm::vec3 Right glm::vec3 Up glm::mat4 View glm::vec3 WorldUp float Zoom   = <code>{}</code> float camera_mouse_sensitivity   = <code>2.5f</code> float camera_movement_sensitivity   = <code>2.5f</code>"},{"location":"References/classatlas_1_1camera/#public-functions","title":"Public Functions","text":"Type Name camera () = default camera (float p_aspect_ratio, glm::vec3 position=glm::vec3(0.0f, 1.50f, 0.0f), glm::vec3 up=glm::vec3(0.0f, -1.0f, 0.0f), float yaw=-90.0f, float pitch=0.0f)  float camera_sensitivity () const glm::vec3 get_front () const glm::mat4 get_projection () const glm::mat4 get_view () const void process_keyboard (CameraMovement p_direction, float p_delta_time)  void process_mouse_movement (float p_x, float p_y, bool p_constraint_pitch=true)  void process_mouse_scroll (float yoffset)  void set_mouse_speed (float p_sensitivity)  void set_movement_speed (float p_sensitivity) TODO: REMOVE THESE these should be user-defined. void update_proj_view ()"},{"location":"References/classatlas_1_1camera/#detailed-description","title":"Detailed Description","text":"<p>TODO: Camera class needs to strip out the following properties</p> <ul> <li>Zoom</li> </ul> <p>TODO: Camera should contain</p> <ul> <li>Position </li> </ul>"},{"location":"References/classatlas_1_1camera/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/classatlas_1_1camera/#variable-aspectratio","title":"variable AspectRatio","text":"<pre><code>float atlas::camera::AspectRatio;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-down","title":"variable Down","text":"<pre><code>glm::vec3 atlas::camera::Down;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-eulerrotation","title":"variable EulerRotation","text":"<pre><code>glm::vec3 atlas::camera::EulerRotation;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-ismaincamera","title":"variable IsMainCamera","text":"<pre><code>bool atlas::camera::IsMainCamera;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-left","title":"variable Left","text":"<pre><code>glm::vec3 atlas::camera::Left;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-mousesensitivity","title":"variable MouseSensitivity","text":"<pre><code>float atlas::camera::MouseSensitivity;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-movementspeed","title":"variable MovementSpeed","text":"<pre><code>float atlas::camera::MovementSpeed;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-position","title":"variable Position","text":"<pre><code>glm::vec3 atlas::camera::Position;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-projection","title":"variable Projection","text":"<pre><code>glm::mat4 atlas::camera::Projection;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-right","title":"variable Right","text":"<pre><code>glm::vec3 atlas::camera::Right;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-up","title":"variable Up","text":"<pre><code>glm::vec3 atlas::camera::Up;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-view","title":"variable View","text":"<pre><code>glm::mat4 atlas::camera::View;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-worldup","title":"variable WorldUp","text":"<pre><code>glm::vec3 atlas::camera::WorldUp;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-zoom","title":"variable Zoom","text":"<pre><code>float atlas::camera::Zoom;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-camera_mouse_sensitivity","title":"variable camera_mouse_sensitivity","text":"<pre><code>float atlas::camera::camera_mouse_sensitivity;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-camera_movement_sensitivity","title":"variable camera_movement_sensitivity","text":"<pre><code>float atlas::camera::camera_movement_sensitivity;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1camera/#function-camera-12","title":"function camera [1/2]","text":"<pre><code>atlas::camera::camera () = default\n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-camera-22","title":"function camera [2/2]","text":"<pre><code>inline atlas::camera::camera (\n    float p_aspect_ratio,\n    glm::vec3 position=glm::vec3(0.0f, 1.50f, 0.0f),\n    glm::vec3 up=glm::vec3(0.0f, -1.0f, 0.0f),\n    float yaw=-90.0f,\n    float pitch=0.0f\n) \n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-camera_sensitivity","title":"function camera_sensitivity","text":"<pre><code>inline float atlas::camera::camera_sensitivity () const\n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-get_front","title":"function get_front","text":"<pre><code>inline glm::vec3 atlas::camera::get_front () const\n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-get_projection","title":"function get_projection","text":"<pre><code>inline glm::mat4 atlas::camera::get_projection () const\n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-get_view","title":"function get_view","text":"<pre><code>inline glm::mat4 atlas::camera::get_view () const\n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-process_keyboard","title":"function process_keyboard","text":"<pre><code>inline void atlas::camera::process_keyboard (\n    CameraMovement p_direction,\n    float p_delta_time\n) \n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-process_mouse_movement","title":"function process_mouse_movement","text":"<pre><code>inline void atlas::camera::process_mouse_movement (\n    float p_x,\n    float p_y,\n    bool p_constraint_pitch=true\n) \n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-process_mouse_scroll","title":"function process_mouse_scroll","text":"<pre><code>inline void atlas::camera::process_mouse_scroll (\n    float yoffset\n) \n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-set_mouse_speed","title":"function set_mouse_speed","text":"<pre><code>inline void atlas::camera::set_mouse_speed (\n    float p_sensitivity\n) \n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-set_movement_speed","title":"function set_movement_speed","text":"<p>TODO: REMOVE THESE these should be user-defined. <pre><code>inline void atlas::camera::set_movement_speed (\n    float p_sensitivity\n) \n</code></pre></p>"},{"location":"References/classatlas_1_1camera/#function-update_proj_view","title":"function update_proj_view","text":"<pre><code>inline void atlas::camera::update_proj_view () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/components.hpp</code></p>"},{"location":"References/classatlas_1_1console__log__manager/","title":"Class atlas::console_log_manager","text":"<p>ClassList &gt; atlas &gt; console_log_manager</p>"},{"location":"References/classatlas_1_1console__log__manager/#public-static-functions","title":"Public Static Functions","text":"Type Name void create_new_logger (const std::string &amp; p_tag=\"Undefined Tag\")  ref&lt; spdlog::logger &gt; get (const std::string &amp; p_tag)  void initialize_logger_manager (const std::string &amp; pattern=\"%^[%T] %n: %v%$\")  void set_current_logger (const std::string &amp; p_tag=\"Undefined g_Tag in console_logger\")"},{"location":"References/classatlas_1_1console__log__manager/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1console__log__manager/#function-create_new_logger","title":"function create_new_logger","text":"<pre><code>static void atlas::console_log_manager::create_new_logger (\n    const std::string &amp; p_tag=\"Undefined Tag\"\n) \n</code></pre>"},{"location":"References/classatlas_1_1console__log__manager/#function-get","title":"function get","text":"<pre><code>static ref &lt; spdlog::logger &gt; atlas::console_log_manager::get (\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1console__log__manager/#function-initialize_logger_manager","title":"function initialize_logger_manager","text":"<pre><code>static void atlas::console_log_manager::initialize_logger_manager (\n    const std::string &amp; pattern=\"%^[%T] %n: %v%$\"\n) \n</code></pre> <p>Note:</p> <p>Used for initiating this console logger across engine3d supplying the pattern and application to dedicate log messages to </p>"},{"location":"References/classatlas_1_1console__log__manager/#function-set_current_logger","title":"function set_current_logger","text":"<pre><code>static void atlas::console_log_manager::set_current_logger (\n    const std::string &amp; p_tag=\"Undefined g_Tag in console_logger\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/engine_logger.hpp</code></p>"},{"location":"References/classatlas_1_1entity__t/","title":"Class atlas::entity_t","text":"<p>ClassList &gt; atlas &gt; entity_t</p>"},{"location":"References/classatlas_1_1entity__t/#public-functions","title":"Public Functions","text":"Type Name void add ()  entity_t () = default entity_t (flecs::world * p_registry, const std::string &amp; p_tag)  entity_t (const flecs::entity &amp; p_entity)  const UComponent * get () const UComponent * get_mut () const bool has () const bool is_alive () const void on_destruction ()  entity () const entity ()  void remove ()  void set (const UComponent &amp; p_component)  void set (const UComponent1 &amp; p_component1, const UComponent2 &amp; p_component2)  ~entity_t ()"},{"location":"References/classatlas_1_1entity__t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1entity__t/#function-add","title":"function add","text":"<pre><code>template&lt;typename UComponent&gt;\ninline void atlas::entity_t::add () \n</code></pre> <p>Note:</p> <p>Creates component in the ECS storage but does not assign it with a value. </p>"},{"location":"References/classatlas_1_1entity__t/#function-entity_t-13","title":"function entity_t [1/3]","text":"<pre><code>atlas::entity_t::entity_t () = default\n</code></pre>"},{"location":"References/classatlas_1_1entity__t/#function-entity_t-23","title":"function entity_t [2/3]","text":"<pre><code>atlas::entity_t::entity_t (\n    flecs::world * p_registry,\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1entity__t/#function-entity_t-33","title":"function entity_t [3/3]","text":"<pre><code>inline atlas::entity_t::entity_t (\n    const flecs::entity &amp; p_entity\n) \n</code></pre>"},{"location":"References/classatlas_1_1entity__t/#function-get","title":"function get","text":"<pre><code>template&lt;typename UComponent&gt;\ninline const UComponent * atlas::entity_t::get () const\n</code></pre> <p>Note:</p> <p>Returns the component from the entity </p> <p>Note:</p> <p>Flecs has you return a pointer for checking if the component is found </p> <p>Note:</p> <p>If not found will return nullptr </p>"},{"location":"References/classatlas_1_1entity__t/#function-get_mut","title":"function get_mut","text":"<pre><code>template&lt;typename UComponent&gt;\ninline UComponent * atlas::entity_t::get_mut () const\n</code></pre>"},{"location":"References/classatlas_1_1entity__t/#function-has","title":"function has","text":"<pre><code>template&lt;typename UComponent&gt;\ninline bool atlas::entity_t::has () const\n</code></pre> <p>Note:</p> <p>Checks if specific component of type UComponent is provided to this entity </p>"},{"location":"References/classatlas_1_1entity__t/#function-is_alive","title":"function is_alive","text":"<pre><code>inline bool atlas::entity_t::is_alive () const\n</code></pre> <p>Note:</p> <p>Flecs allows to check when an entity has been created </p> <p>Note:</p> <p>Knowing when this entity lifecyle's ended </p>"},{"location":"References/classatlas_1_1entity__t/#function-on_destruction","title":"function on_destruction","text":"<pre><code>inline void atlas::entity_t::on_destruction () \n</code></pre>"},{"location":"References/classatlas_1_1entity__t/#function-entity-12","title":"function entity [1/2]","text":"<pre><code>inline atlas::entity_t::entity () const\n</code></pre>"},{"location":"References/classatlas_1_1entity__t/#function-entity-22","title":"function entity [2/2]","text":"<pre><code>inline atlas::entity_t::entity () \n</code></pre>"},{"location":"References/classatlas_1_1entity__t/#function-remove","title":"function remove","text":"<pre><code>template&lt;typename UComponent&gt;\ninline void atlas::entity_t::remove () \n</code></pre>"},{"location":"References/classatlas_1_1entity__t/#function-set-12","title":"function set [1/2]","text":"<pre><code>template&lt;typename UComponent&gt;\ninline void atlas::entity_t::set (\n    const UComponent &amp; p_component\n) \n</code></pre> <p>Note:</p> <p>Setting a component TODO: Try to allow the set component to be set to its initial value Initial value should be set when the component that is set is empty </p>"},{"location":"References/classatlas_1_1entity__t/#function-set-22","title":"function set [2/2]","text":"<pre><code>template&lt;typename UComponent1, typename UComponent2&gt;\ninline void atlas::entity_t::set (\n    const UComponent1 &amp; p_component1,\n    const UComponent2 &amp; p_component2\n) \n</code></pre> <p>Note:</p> <p>Set value for position and velocity component </p> <p>Note:</p> <p>Flecs set component will be added if entity doesn't the component </p> <p>Note:</p> <p>This is for setting multiple different components to be stored into the entity </p>"},{"location":"References/classatlas_1_1entity__t/#function-entity_t","title":"function ~entity_t","text":"<pre><code>atlas::entity_t::~entity_t () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/entity.hpp</code></p>"},{"location":"References/namespaceatlas_1_1event/","title":"Namespace atlas::event","text":"<p>Namespace List &gt; atlas &gt; event</p>"},{"location":"References/namespaceatlas_1_1event/#classes","title":"Classes","text":"Type Name struct joystick_button struct joystick_info"},{"location":"References/namespaceatlas_1_1event/#public-types","title":"Public Types","text":"Type Name enum int JoystickCodes enum uint32_t Key enum uint32_t Mouse enum input_state"},{"location":"References/namespaceatlas_1_1event/#public-functions","title":"Public Functions","text":"Type Name glm::vec2 cursor_position ()  float get_joystic_axis (int p_controller_id, int p_button)  bool is_joystic_present (int p_controller_id)  bool is_joystick_button_pressed (int p_button)  bool is_joystick_button_released (int p_button)  const char * is_joystick_guid (int p_controller_id)  bool is_key_pressed (int p_key)  bool is_key_released (int p_key)  bool is_mouse_pressed (int p_mouse_code)  bool is_mouse_released (int p_mouse_code)  void update_events ()  void wait_for_events ()"},{"location":"References/namespaceatlas_1_1event/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"References/namespaceatlas_1_1event/#enum-joystickcodes","title":"enum JoystickCodes","text":"<pre><code>enum atlas::event::JoystickCodes {\n    Joystick1 = 0,\n    Joystick2 = 1,\n    Joystick3 = 2,\n    Joystick4 = 3,\n    Joystick5 = 4,\n    Joystick6 = 5,\n    Joystick7 = 6,\n    Joystick8 = 7,\n    Joystick9 = 8,\n    Joystick10 = 9,\n    Joystick11 = 10,\n    Joystick12 = 11,\n    Joystick13 = 12,\n    Joystick14 = 13,\n    Joystick15 = 14,\n    Joystick16 = 15,\n    JoystickLAST = Joystick16\n};\n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#enum-key","title":"enum Key","text":"<pre><code>enum atlas::event::Key {\n    Space = 32,\n    Apostrophe = 39,\n    Comma = 44,\n    Minus = 45,\n    Period = 46,\n    Slash = 47,\n    D0 = 48,\n    D1 = 49,\n    D2 = 50,\n    D3 = 51,\n    D4 = 52,\n    D5 = 53,\n    D6 = 54,\n    D7 = 55,\n    D8 = 56,\n    D9 = 57,\n    Semicolon = 59,\n    Equal = 61,\n    A = 65,\n    B = 66,\n    C = 67,\n    D = 68,\n    E = 69,\n    F = 70,\n    G = 71,\n    H = 72,\n    I = 73,\n    J = 74,\n    K = 75,\n    L = 76,\n    M = 77,\n    N = 78,\n    O = 79,\n    P = 80,\n    Q = 81,\n    R = 82,\n    S = 83,\n    T = 84,\n    U = 85,\n    V = 86,\n    W = 87,\n    X = 88,\n    Y = 89,\n    Z = 90,\n    LeftBracket = 91,\n    Backslash = 92,\n    RightBracket = 93,\n    GraveAccent = 96,\n    World1 = 161,\n    World2 = 162,\n    Escape = 256,\n    Enter = 257,\n    Tab = 258,\n    Backspace = 259,\n    Insert = 260,\n    Delete = 261,\n    Right = 262,\n    Left = 263,\n    Down = 264,\n    Up = 265,\n    PageUp = 266,\n    PageDown = 267,\n    Home = 268,\n    End = 269,\n    CapsLock = 280,\n    ScrollLock = 281,\n    NumLock = 282,\n    PrintScreen = 283,\n    Pause = 284,\n    F1 = 290,\n    F2 = 291,\n    F3 = 292,\n    F4 = 293,\n    F5 = 294,\n    F6 = 295,\n    F7 = 296,\n    F8 = 297,\n    F9 = 298,\n    F10 = 299,\n    F11 = 300,\n    F12 = 301,\n    F13 = 302,\n    F14 = 303,\n    F15 = 304,\n    F16 = 305,\n    F17 = 306,\n    F18 = 307,\n    F19 = 308,\n    F20 = 309,\n    F21 = 310,\n    F22 = 311,\n    F23 = 312,\n    F24 = 313,\n    F25 = 314,\n    KP0 = 320,\n    KP1 = 321,\n    KP2 = 322,\n    KP3 = 323,\n    KP4 = 324,\n    KP5 = 325,\n    KP6 = 326,\n    KP7 = 327,\n    KP8 = 328,\n    KP9 = 329,\n    KPDecimal = 330,\n    KPDivide = 331,\n    KPMultiply = 332,\n    KPSubtract = 333,\n    KPAdd = 334,\n    KPEnter = 335,\n    KPEqual = 336,\n    LeftShift = 340,\n    LeftControl = 341,\n    LeftAlt = 342,\n    Leftsuper = 343,\n    RightShift = 344,\n    RightControl = 345,\n    RightAlt = 346,\n    Rightsuper = 347,\n    Menu = 348\n};\n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#enum-mouse","title":"enum Mouse","text":"<pre><code>enum atlas::event::Mouse {\n    Button0 = 0,\n    Button1 = 1,\n    Button2 = 2,\n    Button3 = 3,\n    Button4 = 4,\n    Button5 = 5,\n    Button6 = 6,\n    Button7 = 7,\n    ButtonLast = Button7,\n    ButtonLeft = Button0,\n    ButtonRight = Button1,\n    ButtonMiddle = Button2\n};\n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#enum-input_state","title":"enum input_state","text":"<pre><code>enum atlas::event::input_state {\n    None,\n    Idle,\n    Pressed,\n    Released\n};\n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1event/#function-cursor_position","title":"function cursor_position","text":"<pre><code>glm::vec2 atlas::event::cursor_position () \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-get_joystic_axis","title":"function get_joystic_axis","text":"<pre><code>float atlas::event::get_joystic_axis (\n    int p_controller_id,\n    int p_button\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_joystic_present","title":"function is_joystic_present","text":"<pre><code>bool atlas::event::is_joystic_present (\n    int p_controller_id\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_joystick_button_pressed","title":"function is_joystick_button_pressed","text":"<pre><code>bool atlas::event::is_joystick_button_pressed (\n    int p_button\n) \n</code></pre> <p>Note:</p> <p>FIXME: Make button later </p>"},{"location":"References/namespaceatlas_1_1event/#function-is_joystick_button_released","title":"function is_joystick_button_released","text":"<pre><code>bool atlas::event::is_joystick_button_released (\n    int p_button\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_joystick_guid","title":"function is_joystick_guid","text":"<pre><code>const char * atlas::event::is_joystick_guid (\n    int p_controller_id\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_key_pressed","title":"function is_key_pressed","text":"<pre><code>bool atlas::event::is_key_pressed (\n    int p_key\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_key_released","title":"function is_key_released","text":"<pre><code>bool atlas::event::is_key_released (\n    int p_key\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_mouse_pressed","title":"function is_mouse_pressed","text":"<pre><code>bool atlas::event::is_mouse_pressed (\n    int p_mouse_code\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_mouse_released","title":"function is_mouse_released","text":"<pre><code>bool atlas::event::is_mouse_released (\n    int p_mouse_code\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-update_events","title":"function update_events","text":"<pre><code>void atlas::event::update_events () \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-wait_for_events","title":"function wait_for_events","text":"<pre><code>void atlas::event::wait_for_events () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/event/event.hpp</code></p>"},{"location":"References/structatlas_1_1event_1_1joystick__button/","title":"Struct atlas::event::joystick_button","text":"<p>ClassList &gt; atlas &gt; event &gt; joystick_button</p>"},{"location":"References/structatlas_1_1event_1_1joystick__button/#public-attributes","title":"Public Attributes","text":"Type Name input_state ButtonState   = <code>input\\_state::None</code> int ID   = <code>-1</code> std::string Name   = <code>\"\"</code> input_state PreviousButtonState   = <code>input\\_state::None</code>"},{"location":"References/structatlas_1_1event_1_1joystick__button/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1event_1_1joystick__button/#variable-buttonstate","title":"variable ButtonState","text":"<pre><code>input_state atlas::event::joystick_button::ButtonState;\n</code></pre>"},{"location":"References/structatlas_1_1event_1_1joystick__button/#variable-id","title":"variable ID","text":"<pre><code>int atlas::event::joystick_button::ID;\n</code></pre>"},{"location":"References/structatlas_1_1event_1_1joystick__button/#variable-name","title":"variable Name","text":"<pre><code>std::string atlas::event::joystick_button::Name;\n</code></pre>"},{"location":"References/structatlas_1_1event_1_1joystick__button/#variable-previousbuttonstate","title":"variable PreviousButtonState","text":"<pre><code>input_state atlas::event::joystick_button::PreviousButtonState;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/event/event.hpp</code></p>"},{"location":"References/structatlas_1_1event_1_1joystick__info/","title":"Struct atlas::event::joystick_info","text":"<p>ClassList &gt; atlas &gt; event &gt; joystick_info</p>"},{"location":"References/structatlas_1_1event_1_1joystick__info/#public-attributes","title":"Public Attributes","text":"Type Name std::map&lt; int, const float * &gt; AxesOfController std::map&lt; int, joystick_button &gt; Buttons std::map&lt; int, bool &gt; ButtonsDown int ID   = <code>-1</code> std::string JoystickName   = <code>\"Default\"</code>"},{"location":"References/structatlas_1_1event_1_1joystick__info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1event_1_1joystick__info/#variable-axesofcontroller","title":"variable AxesOfController","text":"<pre><code>std::map&lt;int, const float*&gt; atlas::event::joystick_info::AxesOfController;\n</code></pre>"},{"location":"References/structatlas_1_1event_1_1joystick__info/#variable-buttons","title":"variable Buttons","text":"<pre><code>std::map&lt;int, joystick_button&gt; atlas::event::joystick_info::Buttons;\n</code></pre>"},{"location":"References/structatlas_1_1event_1_1joystick__info/#variable-buttonsdown","title":"variable ButtonsDown","text":"<pre><code>std::map&lt;int, bool&gt; atlas::event::joystick_info::ButtonsDown;\n</code></pre>"},{"location":"References/structatlas_1_1event_1_1joystick__info/#variable-id","title":"variable ID","text":"<pre><code>int atlas::event::joystick_info::ID;\n</code></pre>"},{"location":"References/structatlas_1_1event_1_1joystick__info/#variable-joystickname","title":"variable JoystickName","text":"<pre><code>std::string atlas::event::joystick_info::JoystickName;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/event/event.hpp</code></p>"},{"location":"References/namespaceatlas_1_1filesystem/","title":"Namespace atlas::filesystem","text":"<p>Namespace List &gt; atlas &gt; filesystem</p>"},{"location":"References/namespaceatlas_1_1filesystem/#public-functions","title":"Public Functions","text":"Type Name std::string load_from_file_dialog (const std::string &amp; p_filter)  std::string save_to_file (const std::string &amp; p_filter)"},{"location":"References/namespaceatlas_1_1filesystem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1filesystem/#function-load_from_file_dialog","title":"function load_from_file_dialog","text":"<pre><code>std::string atlas::filesystem::load_from_file_dialog (\n    const std::string &amp; p_filter\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1filesystem/#function-save_to_file","title":"function save_to_file","text":"<pre><code>std::string atlas::filesystem::save_to_file (\n    const std::string &amp; p_filter\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/filesystem/file_dialog.hpp</code></p>"},{"location":"References/classatlas_1_1graphics__context/","title":"Class atlas::graphics_context","text":"<p>ClassList &gt; atlas &gt; graphics_context</p> <p>Inherited by the following classes: atlas::vk::vk_context</p>"},{"location":"References/classatlas_1_1graphics__context/#public-functions","title":"Public Functions","text":"Type Name void destroy ()  virtual ~graphics_context () = default"},{"location":"References/classatlas_1_1graphics__context/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1graphics__context/#function-destroy","title":"function destroy","text":"<pre><code>inline void atlas::graphics_context::destroy () \n</code></pre>"},{"location":"References/classatlas_1_1graphics__context/#function-graphics_context","title":"function ~graphics_context","text":"<pre><code>virtual atlas::graphics_context::~graphics_context () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/graphics_context.hpp</code></p>"},{"location":"References/classatlas_1_1interpolation/","title":"Class atlas::interpolation","text":"<p>ClassList &gt; atlas &gt; interpolation</p>"},{"location":"References/classatlas_1_1interpolation/#public-static-functions","title":"Public Static Functions","text":"Type Name T linear_interpolate (T start, T end, const std::function&lt; float(float)&gt; &amp; function, float t)"},{"location":"References/classatlas_1_1interpolation/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1interpolation/#function-linear_interpolate","title":"function linear_interpolate","text":"<pre><code>template&lt;typename T&gt;\nstatic inline T atlas::interpolation::linear_interpolate (\n    T start,\n    T end,\n    const std::function&lt; float(float)&gt; &amp; function,\n    float t\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/math.hpp</code></p>"},{"location":"References/structatlas_1_1light/","title":"Struct atlas::light","text":"<p>ClassList &gt; atlas &gt; light</p> <p>TODO: Make this better (when we do lighting) </p> <ul> <li><code>#include &lt;components.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1light/#public-attributes","title":"Public Attributes","text":"Type Name glm::vec3 Position   = <code>{ 1.f }</code>"},{"location":"References/structatlas_1_1light/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1light/#variable-position","title":"variable Position","text":"<pre><code>glm::vec3 atlas::light::Position;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/components.hpp</code></p>"},{"location":"References/structatlas_1_1material/","title":"Struct atlas::material","text":"<p>ClassList &gt; atlas &gt; material</p> <p>More...</p> <ul> <li><code>#include &lt;components.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1material/#public-attributes","title":"Public Attributes","text":"Type Name glm::vec4 color   = <code>{ 1.f }</code> std::string model_path   = <code>\"\"</code> bool model_reload   = <code>false</code> std::vector&lt; std::string &gt; texture_filepaths std::string texture_path   = <code>/* multi line expression */</code> bool texture_reload   = <code>false</code>"},{"location":"References/structatlas_1_1material/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Contains our render target as the mesh TODO: IMPORTANT: NEED TO CHANGE HOW THIS WORKSS!! IMPORTANT: flecs gives you a lifetime issue if it doesnt have a default constructor implictly added to a struct/class </p>"},{"location":"References/structatlas_1_1material/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1material/#variable-color","title":"variable color","text":"<pre><code>glm::vec4 atlas::material::color;\n</code></pre>"},{"location":"References/structatlas_1_1material/#variable-model_path","title":"variable model_path","text":"<pre><code>std::string atlas::material::model_path;\n</code></pre>"},{"location":"References/structatlas_1_1material/#variable-model_reload","title":"variable model_reload","text":"<pre><code>bool atlas::material::model_reload;\n</code></pre>"},{"location":"References/structatlas_1_1material/#variable-texture_filepaths","title":"variable texture_filepaths","text":"<pre><code>std::vector&lt;std::string&gt; atlas::material::texture_filepaths;\n</code></pre>"},{"location":"References/structatlas_1_1material/#variable-texture_path","title":"variable texture_path","text":"<pre><code>std::string atlas::material::texture_path;\n</code></pre>"},{"location":"References/structatlas_1_1material/#variable-texture_reload","title":"variable texture_reload","text":"<pre><code>bool atlas::material::texture_reload;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/components.hpp</code></p>"},{"location":"References/structatlas_1_1math__generic/","title":"Struct atlas::math_generic","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; math_generic</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/structatlas_1_1matrix2/","title":"Struct atlas::matrix2","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; matrix2</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/structatlas_1_1matrix3/","title":"Struct atlas::matrix3","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; matrix3</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/structatlas_1_1matrix4/","title":"Struct atlas::matrix4","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; matrix4</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/classatlas_1_1mesh/","title":"Class atlas::mesh","text":"<p>ClassList &gt; atlas &gt; mesh</p>"},{"location":"References/classatlas_1_1mesh/#public-functions","title":"Public Functions","text":"Type Name mesh () = default mesh (const std::string &amp; p_filepath)"},{"location":"References/classatlas_1_1mesh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1mesh/#function-mesh-12","title":"function mesh [1/2]","text":"<pre><code>atlas::mesh::mesh () = default\n</code></pre>"},{"location":"References/classatlas_1_1mesh/#function-mesh-22","title":"function mesh [2/2]","text":"<pre><code>atlas::mesh::mesh (\n    const std::string &amp; p_filepath\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/geometry/mesh.hpp</code></p>"},{"location":"References/namespaceatlas_1_1physics/","title":"Namespace atlas::physics","text":"<p>Namespace List &gt; atlas &gt; physics</p> <p>Handles error handling with in jolt. More...</p>"},{"location":"References/namespaceatlas_1_1physics/#classes","title":"Classes","text":"Type Name class broad_phase_layer_interface This class is made to control the broadphase layer. Filters can be added to it to create a better and more organized broadphase. Ass well as giving some control to the user on how the broadphase should be organized. This requires dynamic masking however, which is not currently running. struct collider_body struct collider_event This is a replacement for an event system to handle collider. It will be replaced by an event system once we have functional one up and running. struct contact_event class contact_listener This is the glue between contact events and jolts contact listener. It takes the calls from jolt through virtual functions and allows users to create children for jolt collision. class jolt_api class jolt_collision This is the collision api. It allows users to create children of this collision handler and write their own functions over the virtual ones. Then they can assign it to the engine. class jolt_collision_manager This allows users to make thier own version of jolt collition and run them their own way. It allows users to interact with the calls by creating a child class of jolt_collision and run whatever action they want. struct jolt_config Used to keep global data for player access and use. Tells how physics bodies should act within a given scene by default. class jolt_context This class is made to be 1 of three api wrappers for jolt. Jolt context is specifically for engine only use of the api. It wraps the inititialization, the physics step and the clean up. Allow use not to have to write batching algorithms for each time we want to change the settings of jolt physics. struct jolt_settings This includes global configs for each scene and how the physics engine will behave in a paticular scene. struct matrix4 &lt;typename T&gt; struct matrix4&lt; JPH::Mat44 &gt; &lt;&gt; class object_layer_pair_filter This goes into more detailed ways of filtering, where the object collisions may be defined be what the other object is. In this case a static setup allows static object to trigger collision only when it is touched by a dynamic target. class object_vs_broadphase_layer This is used to tell Jolt what can or cannot collide. As of right now the list is static therfore the layers do not need a dynamic set up. This will change when the object layers become user definable. class physics_api struct physics_body class physics_context The context is the way to interact with only the engine. It is the api for all the background funcitons and information that the user shouldn not see. It is a virtual based type erasure class so thatmany engines can implement the same functions. Specifically realted to backend engine creation like batching, starting runtime, etc... class physics_engine The manager class for all physics engines. Manages the physics contexts and the collision engines. struct quaternion &lt;typename T&gt; struct vector3 &lt;typename T&gt; struct vector3&lt; JPH::DVec3 &gt; &lt;&gt; struct vector3&lt; JPH::Double3 &gt; &lt;&gt; struct vector3&lt; JPH::Float3 &gt; &lt;&gt; struct vector3&lt; JPH::Vec3 &gt; &lt;&gt; struct vector4 &lt;typename T&gt; struct vector4&lt; JPH::Float4 &gt; &lt;&gt; struct vector4&lt; JPH::Vec4 &gt; &lt;&gt;"},{"location":"References/namespaceatlas_1_1physics/#public-types","title":"Public Types","text":"Type Name enum std::uint8_t BroadPhaseLayers enum std::uint8_t ObjectLayer This contains a few important comparisons having to do with setting up the oct-trees correctly as well as the filtering and collision interaction. enum uint8_t body_layer enum uint8_t body_type enum uint8_t collider_shape enum uint8_t physics_backend This is the manager of all three api for physics. It contians the scope for all physics engine related functions. It passes the jolt_vlaues to engine and gives them to the user api. enum uint8_t thread_system"},{"location":"References/namespaceatlas_1_1physics/#public-functions","title":"Public Functions","text":"Type Name void add_angular_velocity (const glm::vec3 &amp; angular_velocity, const physics_body &amp; body)  void add_force (const glm::vec3 &amp; force, const physics_body &amp; body) These functions are the generic functions implmented in jolt but should be able to switch to any engine. void add_velocity (const glm::vec3 &amp; velocity, const physics_body &amp; body) FIXME: This is a difficult funciton that requires locks and waiting multiple frames before running. So it is later. bool assert_failed_impl (const char * p_in_expression, const char * p_in_message, const char * p_in_file, unsigned int p_in_line) Allows for custom desciptions and messages when Asserts fail. ref&lt; physics_engine &gt; initialize_engine (const ref&lt; scene_object &gt; &amp; p_physics_object, flecs::world &amp; p_registery) Creates the engine and all three api - collision, user, and engine api. void set_angular_velocity (const glm::vec3 &amp; angular_velocity, const physics_body &amp; body)  void set_velocity (const glm::vec3 &amp; velocity, const physics_body &amp; body)  void trace_impl (const char * p_in_fmt, ...) Enforced by JPH to handle assert and give users and ourselves a way to track where those asserts are coming from in Jolt."},{"location":"References/namespaceatlas_1_1physics/#detailed-description","title":"Detailed Description","text":"<p>Types are still be filled out. When this is completed to_jph() can be removed.</p> <p>This is the how the user is able to call functions relating to jolt. It is the api calls for the user. Most of them running in runtime. With a couple effecting config which is a system wide change. This api is deticated to user interaction, however a few functions will be used by both the engine and the user.</p> <p>Note:</p> <p>FIXME: Should have a custom definition for how we want to handle and print JPH_ASSERTS(). </p>"},{"location":"References/namespaceatlas_1_1physics/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"References/namespaceatlas_1_1physics/#enum-broadphaselayers","title":"enum BroadPhaseLayers","text":"<pre><code>enum atlas::physics::BroadPhaseLayers {\n    NonMoving = 0,\n    Moving = 1,\n    NumLayers\n};\n</code></pre>"},{"location":"References/namespaceatlas_1_1physics/#enum-objectlayer","title":"enum ObjectLayer","text":"<p>This contains a few important comparisons having to do with setting up the oct-trees correctly as well as the filtering and collision interaction. <pre><code>enum atlas::physics::ObjectLayer {\n    NonMoving = 0,\n    Moving = 1,\n    NumLayers\n};\n</code></pre></p> <p>Warning:</p> <p>Most of these contain implicit conversions which might lead to unexpected behavior. This should probably be fixed or atleast checked eventually. </p>"},{"location":"References/namespaceatlas_1_1physics/#enum-body_layer","title":"enum body_layer","text":"<pre><code>enum atlas::physics::body_layer {\n    NonMoving = 0,\n    Moving = 1,\n    LayerNum\n};\n</code></pre>"},{"location":"References/namespaceatlas_1_1physics/#enum-body_type","title":"enum body_type","text":"<pre><code>enum atlas::physics::body_type {\n    Static = 0,\n    Kenmatic = 1,\n    Dynamic = 2,\n    BodyNum\n};\n</code></pre>"},{"location":"References/namespaceatlas_1_1physics/#enum-collider_shape","title":"enum collider_shape","text":"<pre><code>enum atlas::physics::collider_shape {\n    Box,\n    Sphere,\n    Capsule\n};\n</code></pre>"},{"location":"References/namespaceatlas_1_1physics/#enum-physics_backend","title":"enum physics_backend","text":"<p>This is the manager of all three api for physics. It contians the scope for all physics engine related functions. It passes the jolt_vlaues to engine and gives them to the user api. <pre><code>enum atlas::physics::physics_backend {\n    JoltBackend\n};\n</code></pre></p>"},{"location":"References/namespaceatlas_1_1physics/#enum-thread_system","title":"enum thread_system","text":"<pre><code>enum atlas::physics::thread_system {\n    Default = 0,\n    JobSystem = 1\n};\n</code></pre>"},{"location":"References/namespaceatlas_1_1physics/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1physics/#function-add_angular_velocity","title":"function add_angular_velocity","text":"<pre><code>void atlas::physics::add_angular_velocity (\n    const glm::vec3 &amp; angular_velocity,\n    const physics_body &amp; body\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1physics/#function-add_force","title":"function add_force","text":"<p>These functions are the generic functions implmented in jolt but should be able to switch to any engine. <pre><code>void atlas::physics::add_force (\n    const glm::vec3 &amp; force,\n    const physics_body &amp; body\n) \n</code></pre></p>"},{"location":"References/namespaceatlas_1_1physics/#function-add_velocity","title":"function add_velocity","text":"<p>FIXME: This is a difficult funciton that requires locks and waiting multiple frames before running. So it is later. <pre><code>void atlas::physics::add_velocity (\n    const glm::vec3 &amp; velocity,\n    const physics_body &amp; body\n) \n</code></pre></p>"},{"location":"References/namespaceatlas_1_1physics/#function-assert_failed_impl","title":"function assert_failed_impl","text":"<p>Allows for custom desciptions and messages when Asserts fail. <pre><code>bool atlas::physics::assert_failed_impl (\n    const char * p_in_expression,\n    const char * p_in_message,\n    const char * p_in_file,\n    unsigned int p_in_line\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_in_expression</code> The failing arguement </li> <li><code>p_in_message</code> The message provided </li> <li><code>p_in_file</code> The file the assert is in </li> <li><code>p_in_line</code> The line the assert is on </li> </ul> <p>Returns:</p> <p>true </p> <p>Returns:</p> <p>false </p>"},{"location":"References/namespaceatlas_1_1physics/#function-initialize_engine","title":"function initialize_engine","text":"<p>Creates the engine and all three api - collision, user, and engine api. <pre><code>ref &lt; physics_engine &gt; atlas::physics::initialize_engine (\n    const ref &lt; scene_object &gt; &amp; p_physics_object,\n    flecs::world &amp; p_registery\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_physics_object</code> </li> <li><code>p_registery</code> </li> </ul> <p>Returns:</p> <p>ref&lt;physics_engine&gt; </p>"},{"location":"References/namespaceatlas_1_1physics/#function-set_angular_velocity","title":"function set_angular_velocity","text":"<pre><code>void atlas::physics::set_angular_velocity (\n    const glm::vec3 &amp; angular_velocity,\n    const physics_body &amp; body\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1physics/#function-set_velocity","title":"function set_velocity","text":"<pre><code>void atlas::physics::set_velocity (\n    const glm::vec3 &amp; velocity,\n    const physics_body &amp; body\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1physics/#function-trace_impl","title":"function trace_impl","text":"<p>Enforced by JPH to handle assert and give users and ourselves a way to track where those asserts are coming from in Jolt. <pre><code>void atlas::physics::trace_impl (\n    const char * p_in_fmt,\n    ...\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_collision.hpp</code></p>"},{"location":"References/classatlas_1_1physics_1_1broad__phase__layer__interface/","title":"Class atlas::physics::broad_phase_layer_interface","text":"<p>ClassList &gt; atlas &gt; physics &gt; broad_phase_layer_interface</p> <p>This class is made to control the broadphase layer. Filters can be added to it to create a better and more organized broadphase. Ass well as giving some control to the user on how the broadphase should be organized. This requires dynamic masking however, which is not currently running. </p> <ul> <li><code>#include &lt;jolt_broad_phase.hpp&gt;</code></li> </ul> <p>Inherits the following classes: JPH::BroadPhaseLayerInterface</p>"},{"location":"References/classatlas_1_1physics_1_1broad__phase__layer__interface/#public-functions","title":"Public Functions","text":"Type Name JPH::BroadPhaseLayer GetBroadPhaseLayer (JPH::ObjectLayer p_in_layer) override constGives the caller access to the broadphase object. Allowing for some manipulation on how those interactions may go. Including but not limited to changing the filtering of the broadphase or reorganizing the oct-tree. uint32_t GetNumBroadPhaseLayers () override constGet the Number of layers that exsist in the current context. Static for now. broad_phase_layer_interface () = default"},{"location":"References/classatlas_1_1physics_1_1broad__phase__layer__interface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1physics_1_1broad__phase__layer__interface/#function-getbroadphaselayer","title":"function GetBroadPhaseLayer","text":"<p>Gives the caller access to the broadphase object. Allowing for some manipulation on how those interactions may go. Including but not limited to changing the filtering of the broadphase or reorganizing the oct-tree. <pre><code>inline JPH::BroadPhaseLayer atlas::physics::broad_phase_layer_interface::GetBroadPhaseLayer (\n    JPH::ObjectLayer p_in_layer\n) override const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_in_layer</code> The layer that the player wants. </li> </ul> <p>Returns:</p> <p>JPH::BroadPhaseLayer Object to organize and manipulate the oct-tree for that layer. </p>"},{"location":"References/classatlas_1_1physics_1_1broad__phase__layer__interface/#function-getnumbroadphaselayers","title":"function GetNumBroadPhaseLayers","text":"<p>Get the Number of layers that exsist in the current context. Static for now. <pre><code>inline uint32_t atlas::physics::broad_phase_layer_interface::GetNumBroadPhaseLayers () override const\n</code></pre></p> <p>Returns:</p> <p>uint32_t </p>"},{"location":"References/classatlas_1_1physics_1_1broad__phase__layer__interface/#function-broad_phase_layer_interface","title":"function broad_phase_layer_interface","text":"<pre><code>atlas::physics::broad_phase_layer_interface::broad_phase_layer_interface () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/jolt/interface/jolt_broad_phase.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1collider__body/","title":"Struct atlas::physics::collider_body","text":"<p>ClassList &gt; atlas &gt; physics &gt; collider_body</p>"},{"location":"References/structatlas_1_1physics_1_1collider__body/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t body_id   = <code>0</code> float capsule_half_height   = <code>0.5f</code> bool collision_enabled   = <code>true</code> glm::vec3 half_extents   = <code>glm::vec3(0.5f)</code> float radius   = <code>0.5f</code> collider_shape shape_type   = <code>collider\\_shape::Box</code>"},{"location":"References/structatlas_1_1physics_1_1collider__body/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1physics_1_1collider__body/#variable-body_id","title":"variable body_id","text":"<pre><code>uint32_t atlas::physics::collider_body::body_id;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1collider__body/#variable-capsule_half_height","title":"variable capsule_half_height","text":"<pre><code>float atlas::physics::collider_body::capsule_half_height;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1collider__body/#variable-collision_enabled","title":"variable collision_enabled","text":"<pre><code>bool atlas::physics::collider_body::collision_enabled;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1collider__body/#variable-half_extents","title":"variable half_extents","text":"<pre><code>glm::vec3 atlas::physics::collider_body::half_extents;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1collider__body/#variable-radius","title":"variable radius","text":"<pre><code>float atlas::physics::collider_body::radius;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1collider__body/#variable-shape_type","title":"variable shape_type","text":"<pre><code>collider_shape atlas::physics::collider_body::shape_type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_components.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1collider__event/","title":"Struct atlas::physics::collider_event","text":"<p>ClassList &gt; atlas &gt; physics &gt; collider_event</p> <p>This is a replacement for an event system to handle collider. It will be replaced by an event system once we have functional one up and running. More...</p> <ul> <li><code>#include &lt;jolt_components.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1physics_1_1collider__event/#public-attributes","title":"Public Attributes","text":"Type Name uint64_t id   = <code>0</code>"},{"location":"References/structatlas_1_1physics_1_1collider__event/#detailed-description","title":"Detailed Description","text":"<p>Its point is to associate entities with user made jolt collisions. </p>"},{"location":"References/structatlas_1_1physics_1_1collider__event/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1physics_1_1collider__event/#variable-id","title":"variable id","text":"<pre><code>uint64_t atlas::physics::collider_event::id;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_components.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1contact__event/","title":"Struct atlas::physics::contact_event","text":"<p>ClassList &gt; atlas &gt; physics &gt; contact_event</p>"},{"location":"References/structatlas_1_1physics_1_1contact__event/#public-attributes","title":"Public Attributes","text":"Type Name uint64_t entity_a   = <code>0</code> uint64_t entity_b   = <code>0</code> JPH::ContactManifold manifold JPH::ContactSettings settings"},{"location":"References/structatlas_1_1physics_1_1contact__event/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1physics_1_1contact__event/#variable-entity_a","title":"variable entity_a","text":"<pre><code>uint64_t atlas::physics::contact_event::entity_a;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1contact__event/#variable-entity_b","title":"variable entity_b","text":"<pre><code>uint64_t atlas::physics::contact_event::entity_b;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1contact__event/#variable-manifold","title":"variable manifold","text":"<pre><code>JPH::ContactManifold atlas::physics::contact_event::manifold;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1contact__event/#variable-settings","title":"variable settings","text":"<pre><code>JPH::ContactSettings atlas::physics::contact_event::settings;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_components.hpp</code></p>"},{"location":"References/classatlas_1_1physics_1_1contact__listener/","title":"Class atlas::physics::contact_listener","text":"<p>ClassList &gt; atlas &gt; physics &gt; contact_listener</p> <p>This is the glue between contact events and jolts contact listener. It takes the calls from jolt through virtual functions and allows users to create children for jolt collision. </p> <ul> <li><code>#include &lt;jolt_contact_listener.hpp&gt;</code></li> </ul> <p>Inherits the following classes: JPH::ContactListener</p>"},{"location":"References/classatlas_1_1physics_1_1contact__listener/#public-functions","title":"Public Functions","text":"Type Name void clear_events () Deletes all events. Helps reset the collisions on load, etc... contact_listener () Construct a new contact listener object. void run_events_added () Calls all events that came into contact this frame. void run_events_persisted () Runs all events that came into contact every frame but first and last. void run_events_removed () Runs all events who stopped contact this frame."},{"location":"References/classatlas_1_1physics_1_1contact__listener/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1physics_1_1contact__listener/#function-clear_events","title":"function clear_events","text":"<p>Deletes all events. Helps reset the collisions on load, etc... <pre><code>void atlas::physics::contact_listener::clear_events () \n</code></pre></p>"},{"location":"References/classatlas_1_1physics_1_1contact__listener/#function-contact_listener","title":"function contact_listener","text":"<p>Construct a new contact listener object. <pre><code>atlas::physics::contact_listener::contact_listener () \n</code></pre></p>"},{"location":"References/classatlas_1_1physics_1_1contact__listener/#function-run_events_added","title":"function run_events_added","text":"<p>Calls all events that came into contact this frame. <pre><code>void atlas::physics::contact_listener::run_events_added () \n</code></pre></p>"},{"location":"References/classatlas_1_1physics_1_1contact__listener/#function-run_events_persisted","title":"function run_events_persisted","text":"<p>Runs all events that came into contact every frame but first and last. <pre><code>void atlas::physics::contact_listener::run_events_persisted () \n</code></pre></p>"},{"location":"References/classatlas_1_1physics_1_1contact__listener/#function-run_events_removed","title":"function run_events_removed","text":"<p>Runs all events who stopped contact this frame. <pre><code>void atlas::physics::contact_listener::run_events_removed () \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_contact_listener.hpp</code></p>"},{"location":"References/classatlas_1_1physics_1_1jolt__api/","title":"Class atlas::physics::jolt_api","text":"<p>ClassList &gt; atlas &gt; physics &gt; jolt_api</p> <p>Inherits the following classes: atlas::physics::physics_api</p>"},{"location":"References/classatlas_1_1physics_1_1jolt__api/#public-functions","title":"Public Functions","text":"Type Name jolt_api (const jolt_config &amp; p_config, const ref&lt; JPH::PhysicsSystem &gt; &amp; p_physics_system, const flecs::world &amp; p_registery) Construct a new jolt api object."},{"location":"References/classatlas_1_1physics_1_1jolt__api/#public-functions-inherited-from-atlasphysicsphysics_api","title":"Public Functions inherited from atlas::physics::physics_api","text":"<p>See atlas::physics::physics_api</p> Type Name void add_angular_velocity_by_body (const glm::vec3 &amp; p_angular_velocity, const physics_body &amp; p_body)  void add_force_by_body (const glm::vec3 &amp; p_force, const physics_body &amp; p_body) Calls the corresponding virtuals. void add_linear_velocity_by_body (const glm::vec3 &amp; p_velocity, const physics_body &amp; p_body) FIXME: This one is really complicated because it needs to try over multiple frames. And locks are requried. So will be implemented later. void set_angular_velocity_by_body (const glm::vec3 &amp; p_angular_velocity, const physics_body &amp; p_body)  void set_linear_velocity_by_body (const glm::vec3 &amp; p_velocity, const physics_body &amp; p_body)  void update_atlas_values () Allows for jolt values to sync with flecs. void update_jolt_values () Allows for flecs values to sync with jolt without running into collisions. virtual ~physics_api () = default"},{"location":"References/classatlas_1_1physics_1_1jolt__api/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1physics_1_1jolt__api/#function-jolt_api","title":"function jolt_api","text":"<p>Construct a new jolt api object. <pre><code>atlas::physics::jolt_api::jolt_api (\n    const jolt_config &amp; p_config,\n    const ref &lt; JPH::PhysicsSystem &gt; &amp; p_physics_system,\n    const flecs::world &amp; p_registery\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_config</code> All system wide runtime configurations </li> <li><code>p_physics_system</code> Passed by the engine to allow interaction between the engine and users </li> <li><code>p_registery</code> The world this api is associated with. FIXME: This is a temperary solve until have a funciton like get_active_scenes(), added const </li> </ul> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/jolt/jolt_api.hpp</code></p>"},{"location":"References/classatlas_1_1physics_1_1jolt__collision/","title":"Class atlas::physics::jolt_collision","text":"<p>ClassList &gt; atlas &gt; physics &gt; jolt_collision</p> <p>This is the collision api. It allows users to create children of this collision handler and write their own functions over the virtual ones. Then they can assign it to the engine. </p> <ul> <li><code>#include &lt;jolt_collision.hpp&gt;</code></li> </ul>"},{"location":"References/classatlas_1_1physics_1_1jolt__collision/#public-functions","title":"Public Functions","text":"Type Name void collision_added (contact_event &amp; p_event)  jolt_collision ()  jolt_collision (flecs::entity_t p_entity_id)"},{"location":"References/classatlas_1_1physics_1_1jolt__collision/#protected-attributes","title":"Protected Attributes","text":"Type Name uint64_t m_id Allows to keep track of the collision events and what that are assigned to."},{"location":"References/classatlas_1_1physics_1_1jolt__collision/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1physics_1_1jolt__collision/#function-collision_added","title":"function collision_added","text":"<pre><code>void atlas::physics::jolt_collision::collision_added (\n    contact_event &amp; p_event\n) \n</code></pre>"},{"location":"References/classatlas_1_1physics_1_1jolt__collision/#function-jolt_collision-12","title":"function jolt_collision [1/2]","text":"<pre><code>atlas::physics::jolt_collision::jolt_collision () \n</code></pre>"},{"location":"References/classatlas_1_1physics_1_1jolt__collision/#function-jolt_collision-22","title":"function jolt_collision [2/2]","text":"<pre><code>atlas::physics::jolt_collision::jolt_collision (\n    flecs::entity_t p_entity_id\n) \n</code></pre>"},{"location":"References/classatlas_1_1physics_1_1jolt__collision/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"References/classatlas_1_1physics_1_1jolt__collision/#variable-m_id","title":"variable m_id","text":"<p>Allows to keep track of the collision events and what that are assigned to. <pre><code>uint64_t atlas::physics::jolt_collision::m_id;\n</code></pre></p> <p>Note:</p> <p>FIXME: Add these function to handle removal and continous collision detection:  </p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_collision.hpp</code></p>"},{"location":"References/classatlas_1_1physics_1_1jolt__collision__manager/","title":"Class atlas::physics::jolt_collision_manager","text":"<p>ClassList &gt; atlas &gt; physics &gt; jolt_collision_manager</p> <p>This allows users to make thier own version of jolt collition and run them their own way. It allows users to interact with the calls by creating a child class of jolt_collision and run whatever action they want.</p> <ul> <li><code>#include &lt;jolt_collision_manager.hpp&gt;</code></li> </ul>"},{"location":"References/classatlas_1_1physics_1_1jolt__collision__manager/#public-functions","title":"Public Functions","text":"Type Name jolt_collision_manager () = default void run_collision_added (uint64_t p_id, contact_event &amp; p_event) Connects an entity to a defualt or user defined jolt_collision . Runs the functions ofjolt_collision passing the arguments for the user to utilize."},{"location":"References/classatlas_1_1physics_1_1jolt__collision__manager/#public-static-functions","title":"Public Static Functions","text":"Type Name scope&lt; jolt_collision_manager &gt; initialize (const std::string &amp; p_tag) Creates all the neccessary starting components for collisions to begin working. Is utilized by the physics engine to run user defined collisions in a simple way. void subscribe_action (uint64_t p_id, jolt_collision &amp; p_collision_action) FIXME: These need to be implemented along with all other persisted and removed events."},{"location":"References/classatlas_1_1physics_1_1jolt__collision__manager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1physics_1_1jolt__collision__manager/#function-jolt_collision_manager","title":"function jolt_collision_manager","text":"<pre><code>atlas::physics::jolt_collision_manager::jolt_collision_manager () = default\n</code></pre>"},{"location":"References/classatlas_1_1physics_1_1jolt__collision__manager/#function-run_collision_added","title":"function run_collision_added","text":"<p>Connects an entity to a defualt or user defined jolt_collision . Runs the functions ofjolt_collision passing the arguments for the user to utilize. <pre><code>void atlas::physics::jolt_collision_manager::run_collision_added (\n    uint64_t p_id,\n    contact_event &amp; p_event\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_id</code> Generally a way to connect the id of a flecs::entity_t to a specified jolt_collision </li> <li><code>p_event</code> Describes the collision that took place </li> </ul>"},{"location":"References/classatlas_1_1physics_1_1jolt__collision__manager/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1physics_1_1jolt__collision__manager/#function-initialize","title":"function initialize","text":"<p>Creates all the neccessary starting components for collisions to begin working. Is utilized by the physics engine to run user defined collisions in a simple way. <pre><code>static scope&lt; jolt_collision_manager &gt; atlas::physics::jolt_collision_manager::initialize (\n    const std::string &amp; p_tag\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_tag</code> Creates a tag for the collision manager so debugging later will be simplied. Specifically when there are more then one scenes in the game world at once.</li> </ul> <p>Returns:</p> <p>scope&lt;jolt_collision_manager&gt; is the way the engine can run the non-statics collision functions. </p>"},{"location":"References/classatlas_1_1physics_1_1jolt__collision__manager/#function-subscribe_action","title":"function subscribe_action","text":"<p>FIXME: These need to be implemented along with all other persisted and removed events. <pre><code>static void atlas::physics::jolt_collision_manager::subscribe_action (\n    uint64_t p_id,\n    jolt_collision &amp; p_collision_action\n) \n</code></pre></p> <p>Allows the user to subscribe their own collision_handlers to the map and connecting those handlers to entities that they define.</p> <p>Parameters:</p> <ul> <li><code>p_id</code> Used to connect an entity to a collision instance. </li> <li><code>p_collision_action</code> The collision handler to create actions based on the collision given.</li> </ul> <p>Todo</p> <p>We need to subscribe action. This might be fixed when we have events to take and subcribes their user actions with. Or this could be done like the other subscribes that exsist. </p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_collision_manager.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/","title":"Struct atlas::physics::jolt_config","text":"<p>ClassList &gt; atlas &gt; physics &gt; jolt_config</p> <p>Used to keep global data for player access and use. Tells how physics bodies should act within a given scene by default. </p> <ul> <li><code>#include &lt;jolt_components.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#public-attributes","title":"Public Attributes","text":"Type Name float contact_bias_factor   = <code>0.2f</code> bool enable_collision_callbacks   = <code>true</code> bool enable_constraints   = <code>true</code> combine_friction friction_type   = <code>combine\\_friction::FrictionDefualt</code> glm::vec3 gravity   = <code>glm::vec3(0.0f, -9.80665f, 0.0f)</code> float restitution_threshold   = <code>1.0f</code> combine_restitution restitution_type   = <code>/* multi line expression */</code> float time_before_sleep   = <code>5.0f</code>In seconds. float world_unit_scale   = <code>1.0f</code>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-contact_bias_factor","title":"variable contact_bias_factor","text":"<pre><code>float atlas::physics::jolt_config::contact_bias_factor;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-enable_collision_callbacks","title":"variable enable_collision_callbacks","text":"<pre><code>bool atlas::physics::jolt_config::enable_collision_callbacks;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-enable_constraints","title":"variable enable_constraints","text":"<pre><code>bool atlas::physics::jolt_config::enable_constraints;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-friction_type","title":"variable friction_type","text":"<pre><code>combine_friction atlas::physics::jolt_config::friction_type;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-gravity","title":"variable gravity","text":"<pre><code>glm::vec3 atlas::physics::jolt_config::gravity;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-restitution_threshold","title":"variable restitution_threshold","text":"<pre><code>float atlas::physics::jolt_config::restitution_threshold;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-restitution_type","title":"variable restitution_type","text":"<pre><code>combine_restitution atlas::physics::jolt_config::restitution_type;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-time_before_sleep","title":"variable time_before_sleep","text":"<p>In seconds. <pre><code>float atlas::physics::jolt_config::time_before_sleep;\n</code></pre></p>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-world_unit_scale","title":"variable world_unit_scale","text":"<pre><code>float atlas::physics::jolt_config::world_unit_scale;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_components.hpp</code></p>"},{"location":"References/classatlas_1_1physics_1_1jolt__context/","title":"Class atlas::physics::jolt_context","text":"<p>ClassList &gt; atlas &gt; physics &gt; jolt_context</p> <p>This class is made to be 1 of three api wrappers for jolt. Jolt context is specifically for engine only use of the api. It wraps the inititialization, the physics step and the clean up. Allow use not to have to write batching algorithms for each time we want to change the settings of jolt physics. More...</p> <ul> <li><code>#include &lt;jolt_context.hpp&gt;</code></li> </ul> <p>Inherits the following classes: atlas::physics::physics_context</p>"},{"location":"References/classatlas_1_1physics_1_1jolt__context/#public-attributes","title":"Public Attributes","text":"Type Name ref&lt; JPH::PhysicsSystem &gt; m_physics_system Gives access to the physics system. Is given to jolt_api as well. This is to allow us to give seperation of concerns. However, may change now do to Jolt conflict and unhandled dangling pointers withinjolt_api ."},{"location":"References/classatlas_1_1physics_1_1jolt__context/#public-functions","title":"Public Functions","text":"Type Name jolt_context (const jolt_settings &amp; p_settings)  ~jolt_context () override"},{"location":"References/classatlas_1_1physics_1_1jolt__context/#public-functions-inherited-from-atlasphysicsphysics_context","title":"Public Functions inherited from atlas::physics::physics_context","text":"<p>See atlas::physics::physics_context</p> Type Name void clean_bodies ()  void contact_added_event ()  void create_bodies ()  void run_physics_step ()  virtual ~physics_context () = default"},{"location":"References/classatlas_1_1physics_1_1jolt__context/#detailed-description","title":"Detailed Description","text":"<p>Remark:</p> <p>This is different that jolt_api, which is the user wrapper. It is meant to contain all the effects that can happen during runtime. Where most of the data can be called by the user. m_physics_system is the only link between the two classes. Both of which use it for different purposes. Jolt context to control the functionality of the entire systems and the Jolt Api for user based control of the system and bodies.</p> <p>Remark:</p> <p>The third api is collisions which has its own context for jolt. </p>"},{"location":"References/classatlas_1_1physics_1_1jolt__context/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/classatlas_1_1physics_1_1jolt__context/#variable-m_physics_system","title":"variable m_physics_system","text":"<p>Gives access to the physics system. Is given to jolt_api as well. This is to allow us to give seperation of concerns. However, may change now do to Jolt conflict and unhandled dangling pointers withinjolt_api . <pre><code>ref&lt;JPH::PhysicsSystem&gt; atlas::physics::jolt_context::m_physics_system;\n</code></pre></p>"},{"location":"References/classatlas_1_1physics_1_1jolt__context/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1physics_1_1jolt__context/#function-jolt_context","title":"function jolt_context","text":"<pre><code>atlas::physics::jolt_context::jolt_context (\n    const jolt_settings &amp; p_settings\n) \n</code></pre>"},{"location":"References/classatlas_1_1physics_1_1jolt__context/#function-jolt_context_1","title":"function ~jolt_context","text":"<pre><code>atlas::physics::jolt_context::~jolt_context () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/jolt/jolt_context.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/","title":"Struct atlas::physics::jolt_settings","text":"<p>ClassList &gt; atlas &gt; physics &gt; jolt_settings</p> <p>This includes global configs for each scene and how the physics engine will behave in a paticular scene. More...</p> <ul> <li><code>#include &lt;jolt_components.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#public-attributes","title":"Public Attributes","text":"Type Name unsigned int allocation_amount   = <code>10 \\* 1024 \\* 1024</code> float broadphase_scale   = <code>1.0f</code> uint32_t collision_filter_layer_count   = <code>32</code> uint32_t default_collision_group   = <code>0</code> uint32_t default_filter_mask   = <code>0xFFFFFFFF</code> float fixed_time_step   = <code>1.0f / 60.0f</code> bool is_multithreaded   = <code>true</code> uint32_t max_barriers   = <code>physics\\_threads \\* 16</code> uint32_t max_bodies   = <code>16384</code> uint32_t max_body_pairs   = <code>32768</code> uint32_t max_contact_constraints   = <code>8192</code> uint32_t max_jobs_power   = <code>10</code> glm::vec3 physics_scene_position   = <code>glm::vec3(0.0f, 0.0f, 0.0f)</code> uint32_t physics_threads   = <code>/* multi line expression */</code> uint32_t position_iterations   = <code>1</code> float sleep_angular_velocity_threshold   = <code>0.05f</code> float sleep_velocity_threshold   = <code>0.05f</code> thread_system thread_type   = <code>Default</code> bool use_4_layer_broadphase   = <code>true</code> bool use_fixed_timestep   = <code>false</code> uint32_t velocity_iterations   = <code>8</code> glm::vec3 world_bounds_max   = <code>glm::vec3(500.0f, 500.0f, 500.0f)</code> glm::vec3 world_bounds_min   = <code>glm::vec3(-500.0f, -500.0f, -500.0f)</code>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#detailed-description","title":"Detailed Description","text":"<p>Remark:</p> <p>world_bounds_min &amp;&amp; world_bounds_max: These values are arbitrary until further investigation happens and are more of a reminder that floating point error exsists. True max values should be determined in the near future. </p>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-allocation_amount","title":"variable allocation_amount","text":"<pre><code>unsigned int atlas::physics::jolt_settings::allocation_amount;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-broadphase_scale","title":"variable broadphase_scale","text":"<pre><code>float atlas::physics::jolt_settings::broadphase_scale;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-collision_filter_layer_count","title":"variable collision_filter_layer_count","text":"<pre><code>uint32_t atlas::physics::jolt_settings::collision_filter_layer_count;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-default_collision_group","title":"variable default_collision_group","text":"<pre><code>uint32_t atlas::physics::jolt_settings::default_collision_group;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-default_filter_mask","title":"variable default_filter_mask","text":"<pre><code>uint32_t atlas::physics::jolt_settings::default_filter_mask;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-fixed_time_step","title":"variable fixed_time_step","text":"<pre><code>float atlas::physics::jolt_settings::fixed_time_step;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-is_multithreaded","title":"variable is_multithreaded","text":"<pre><code>bool atlas::physics::jolt_settings::is_multithreaded;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-max_barriers","title":"variable max_barriers","text":"<pre><code>uint32_t atlas::physics::jolt_settings::max_barriers;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-max_bodies","title":"variable max_bodies","text":"<pre><code>uint32_t atlas::physics::jolt_settings::max_bodies;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-max_body_pairs","title":"variable max_body_pairs","text":"<pre><code>uint32_t atlas::physics::jolt_settings::max_body_pairs;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-max_contact_constraints","title":"variable max_contact_constraints","text":"<pre><code>uint32_t atlas::physics::jolt_settings::max_contact_constraints;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-max_jobs_power","title":"variable max_jobs_power","text":"<pre><code>uint32_t atlas::physics::jolt_settings::max_jobs_power;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-physics_scene_position","title":"variable physics_scene_position","text":"<pre><code>glm::vec3 atlas::physics::jolt_settings::physics_scene_position;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-physics_threads","title":"variable physics_threads","text":"<pre><code>uint32_t atlas::physics::jolt_settings::physics_threads;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-position_iterations","title":"variable position_iterations","text":"<pre><code>uint32_t atlas::physics::jolt_settings::position_iterations;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-sleep_angular_velocity_threshold","title":"variable sleep_angular_velocity_threshold","text":"<pre><code>float atlas::physics::jolt_settings::sleep_angular_velocity_threshold;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-sleep_velocity_threshold","title":"variable sleep_velocity_threshold","text":"<pre><code>float atlas::physics::jolt_settings::sleep_velocity_threshold;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-thread_type","title":"variable thread_type","text":"<pre><code>thread_system atlas::physics::jolt_settings::thread_type;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-use_4_layer_broadphase","title":"variable use_4_layer_broadphase","text":"<pre><code>bool atlas::physics::jolt_settings::use_4_layer_broadphase;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-use_fixed_timestep","title":"variable use_fixed_timestep","text":"<pre><code>bool atlas::physics::jolt_settings::use_fixed_timestep;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-velocity_iterations","title":"variable velocity_iterations","text":"<pre><code>uint32_t atlas::physics::jolt_settings::velocity_iterations;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-world_bounds_max","title":"variable world_bounds_max","text":"<pre><code>glm::vec3 atlas::physics::jolt_settings::world_bounds_max;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-world_bounds_min","title":"variable world_bounds_min","text":"<pre><code>glm::vec3 atlas::physics::jolt_settings::world_bounds_min;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_components.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1matrix4/","title":"Struct atlas::physics::matrix4","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; physics &gt; matrix4</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/types.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1matrix4_3_01JPH_1_1Mat44_01_4/","title":"Struct atlas::physics::matrix4&lt; JPH::Mat44 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; atlas &gt; physics &gt; matrix4&lt; JPH::Mat44 &gt;</p>"},{"location":"References/structatlas_1_1physics_1_1matrix4_3_01JPH_1_1Mat44_01_4/#public-functions","title":"Public Functions","text":"Type Name matrix4 () = default matrix4 (const JPH::Mat44 &amp; m)  mat4 () const glm::mat4 operator= (const JPH::Mat44 &amp; m)  bool operator== (const glm::mat4 &amp; other) const"},{"location":"References/structatlas_1_1physics_1_1matrix4_3_01JPH_1_1Mat44_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1physics_1_1matrix4_3_01JPH_1_1Mat44_01_4/#function-matrix4-12","title":"function matrix4 [1/2]","text":"<pre><code>atlas::physics::matrix4&lt; JPH::Mat44 &gt;::matrix4 () = default\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1matrix4_3_01JPH_1_1Mat44_01_4/#function-matrix4-22","title":"function matrix4 [2/2]","text":"<pre><code>inline atlas::physics::matrix4&lt; JPH::Mat44 &gt;::matrix4 (\n    const JPH::Mat44 &amp; m\n) \n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1matrix4_3_01JPH_1_1Mat44_01_4/#function-mat4","title":"function mat4","text":"<pre><code>inline atlas::physics::matrix4&lt; JPH::Mat44 &gt;::mat4 () const\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1matrix4_3_01JPH_1_1Mat44_01_4/#function-operator","title":"function operator=","text":"<pre><code>inline glm::mat4 atlas::physics::matrix4&lt; JPH::Mat44 &gt;::operator= (\n    const JPH::Mat44 &amp; m\n) \n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1matrix4_3_01JPH_1_1Mat44_01_4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::physics::matrix4&lt; JPH::Mat44 &gt;::operator== (\n    const glm::mat4 &amp; other\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/types.hpp</code></p>"},{"location":"References/classatlas_1_1physics_1_1object__layer__pair__filter/","title":"Class atlas::physics::object_layer_pair_filter","text":"<p>ClassList &gt; atlas &gt; physics &gt; object_layer_pair_filter</p> <p>This goes into more detailed ways of filtering, where the object collisions may be defined be what the other object is. In this case a static setup allows static object to trigger collision only when it is touched by a dynamic target. </p> <ul> <li><code>#include &lt;jolt_broad_phase.hpp&gt;</code></li> </ul> <p>Inherits the following classes: JPH::ObjectLayerPairFilter</p>"},{"location":"References/classatlas_1_1physics_1_1object__layer__pair__filter/#public-functions","title":"Public Functions","text":"Type Name bool ShouldCollide (JPH::ObjectLayer p_in_object1, JPH::ObjectLayer p_in_object2) override const"},{"location":"References/classatlas_1_1physics_1_1object__layer__pair__filter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1physics_1_1object__layer__pair__filter/#function-shouldcollide","title":"function ShouldCollide","text":"<pre><code>inline bool atlas::physics::object_layer_pair_filter::ShouldCollide (\n    JPH::ObjectLayer p_in_object1,\n    JPH::ObjectLayer p_in_object2\n) override const\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/jolt/interface/jolt_broad_phase.hpp</code></p>"},{"location":"References/classatlas_1_1physics_1_1object__vs__broadphase__layer/","title":"Class atlas::physics::object_vs_broadphase_layer","text":"<p>ClassList &gt; atlas &gt; physics &gt; object_vs_broadphase_layer</p> <p>This is used to tell Jolt what can or cannot collide. As of right now the list is static therfore the layers do not need a dynamic set up. This will change when the object layers become user definable. More...</p> <ul> <li><code>#include &lt;jolt_broad_phase.hpp&gt;</code></li> </ul> <p>Inherits the following classes: JPH::ObjectVsBroadPhaseLayerFilter</p>"},{"location":"References/classatlas_1_1physics_1_1object__vs__broadphase__layer/#public-functions","title":"Public Functions","text":"Type Name bool ShouldCollide (JPH::ObjectLayer p_in_layer1, JPH::BroadPhaseLayer p_in_layer2) override const"},{"location":"References/classatlas_1_1physics_1_1object__vs__broadphase__layer/#detailed-description","title":"Detailed Description","text":"<p>Remark:</p> <p>To give an example, there might exist something like this in the config of the editor:  Dynamic \u2705 \u2705 \u2705 Kenmatic \u2705 \u2705 Static \u2705</p> <p>Where the interactions can partially be defined and controlled by the developer of the game. </p>"},{"location":"References/classatlas_1_1physics_1_1object__vs__broadphase__layer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1physics_1_1object__vs__broadphase__layer/#function-shouldcollide","title":"function ShouldCollide","text":"<pre><code>inline bool atlas::physics::object_vs_broadphase_layer::ShouldCollide (\n    JPH::ObjectLayer p_in_layer1,\n    JPH::BroadPhaseLayer p_in_layer2\n) override const\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/jolt/interface/jolt_broad_phase.hpp</code></p>"},{"location":"References/classatlas_1_1physics_1_1physics__api/","title":"Class atlas::physics::physics_api","text":"<p>ClassList &gt; atlas &gt; physics &gt; physics_api</p> <p>Inherited by the following classes: atlas::physics::jolt_api</p>"},{"location":"References/classatlas_1_1physics_1_1physics__api/#public-functions","title":"Public Functions","text":"Type Name void add_angular_velocity_by_body (const glm::vec3 &amp; p_angular_velocity, const physics_body &amp; p_body)  void add_force_by_body (const glm::vec3 &amp; p_force, const physics_body &amp; p_body) Calls the corresponding virtuals. void add_linear_velocity_by_body (const glm::vec3 &amp; p_velocity, const physics_body &amp; p_body) FIXME: This one is really complicated because it needs to try over multiple frames. And locks are requried. So will be implemented later. void set_angular_velocity_by_body (const glm::vec3 &amp; p_angular_velocity, const physics_body &amp; p_body)  void set_linear_velocity_by_body (const glm::vec3 &amp; p_velocity, const physics_body &amp; p_body)  void update_atlas_values () Allows for jolt values to sync with flecs. void update_jolt_values () Allows for flecs values to sync with jolt without running into collisions. virtual ~physics_api () = default"},{"location":"References/classatlas_1_1physics_1_1physics__api/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1physics_1_1physics__api/#function-add_angular_velocity_by_body","title":"function add_angular_velocity_by_body","text":"<pre><code>void atlas::physics::physics_api::add_angular_velocity_by_body (\n    const glm::vec3 &amp; p_angular_velocity,\n    const physics_body &amp; p_body\n) \n</code></pre>"},{"location":"References/classatlas_1_1physics_1_1physics__api/#function-add_force_by_body","title":"function add_force_by_body","text":"<p>Calls the corresponding virtuals. <pre><code>void atlas::physics::physics_api::add_force_by_body (\n    const glm::vec3 &amp; p_force,\n    const physics_body &amp; p_body\n) \n</code></pre></p>"},{"location":"References/classatlas_1_1physics_1_1physics__api/#function-add_linear_velocity_by_body","title":"function add_linear_velocity_by_body","text":"<p>FIXME: This one is really complicated because it needs to try over multiple frames. And locks are requried. So will be implemented later. <pre><code>void atlas::physics::physics_api::add_linear_velocity_by_body (\n    const glm::vec3 &amp; p_velocity,\n    const physics_body &amp; p_body\n) \n</code></pre></p>"},{"location":"References/classatlas_1_1physics_1_1physics__api/#function-set_angular_velocity_by_body","title":"function set_angular_velocity_by_body","text":"<pre><code>void atlas::physics::physics_api::set_angular_velocity_by_body (\n    const glm::vec3 &amp; p_angular_velocity,\n    const physics_body &amp; p_body\n) \n</code></pre>"},{"location":"References/classatlas_1_1physics_1_1physics__api/#function-set_linear_velocity_by_body","title":"function set_linear_velocity_by_body","text":"<pre><code>void atlas::physics::physics_api::set_linear_velocity_by_body (\n    const glm::vec3 &amp; p_velocity,\n    const physics_body &amp; p_body\n) \n</code></pre>"},{"location":"References/classatlas_1_1physics_1_1physics__api/#function-update_atlas_values","title":"function update_atlas_values","text":"<p>Allows for jolt values to sync with flecs. <pre><code>void atlas::physics::physics_api::update_atlas_values () \n</code></pre></p> <p>Note:</p> <p>should be called either by user to sync events or just after physics_update() </p>"},{"location":"References/classatlas_1_1physics_1_1physics__api/#function-update_jolt_values","title":"function update_jolt_values","text":"<p>Allows for flecs values to sync with jolt without running into collisions. <pre><code>void atlas::physics::physics_api::update_jolt_values () \n</code></pre></p> <p>Note:</p> <p>Takes all transforms, rigidbodies, and collider bodies that changed and updates jolt.</p> <p>Note:</p> <p>should be called either by the user to sync events or just before physics_update() </p>"},{"location":"References/classatlas_1_1physics_1_1physics__api/#function-physics_api","title":"function ~physics_api","text":"<pre><code>virtual atlas::physics::physics_api::~physics_api () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/physics_api.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1physics__body/","title":"Struct atlas::physics::physics_body","text":"<p>ClassList &gt; atlas &gt; physics &gt; physics_body</p>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#public-attributes","title":"Public Attributes","text":"Type Name float angular_damping   = <code>0.0f</code> glm::vec3 angular_velocity   = <code>glm::vec3(0.0f)</code> uint32_t body_id   = <code>0</code> uint8_t body_layer_type   = <code>body\\_layer::Moving</code> uint8_t body_movement_type   = <code>body\\_type::Static</code> uint8_t body_type   = <code>2</code> glm::vec3 center_mass_position   = <code>glm::vec3(0.0)</code> int count   = <code>0</code> glm::vec3 cumulative_force   = <code>glm::vec3(0.0)</code> glm::vec3 cumulative_torque   = <code>glm::vec3(0.0)</code> float friction   = <code>0.8f</code> float gravity_factor   = <code>1.0f</code> float linear_damping   = <code>0.0f</code> glm::vec3 linear_velocity   = <code>glm::vec3(0.0)</code> float mass_factor   = <code>1.0f</code> float restitution   = <code>0.2f</code> bool use_gravity   = <code>true</code>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1physics_1_1physics__body/#variable-angular_damping","title":"variable angular_damping","text":"<pre><code>float atlas::physics::physics_body::angular_damping;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#variable-angular_velocity","title":"variable angular_velocity","text":"<pre><code>glm::vec3 atlas::physics::physics_body::angular_velocity;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#variable-body_id","title":"variable body_id","text":"<pre><code>uint32_t atlas::physics::physics_body::body_id;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#variable-body_layer_type","title":"variable body_layer_type","text":"<pre><code>uint8_t atlas::physics::physics_body::body_layer_type;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#variable-body_movement_type","title":"variable body_movement_type","text":"<pre><code>uint8_t atlas::physics::physics_body::body_movement_type;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#variable-body_type","title":"variable body_type","text":"<pre><code>uint8_t atlas::physics::physics_body::body_type;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#variable-center_mass_position","title":"variable center_mass_position","text":"<pre><code>glm::vec3 atlas::physics::physics_body::center_mass_position;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#variable-count","title":"variable count","text":"<pre><code>int atlas::physics::physics_body::count;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#variable-cumulative_force","title":"variable cumulative_force","text":"<pre><code>glm::vec3 atlas::physics::physics_body::cumulative_force;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#variable-cumulative_torque","title":"variable cumulative_torque","text":"<pre><code>glm::vec3 atlas::physics::physics_body::cumulative_torque;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#variable-friction","title":"variable friction","text":"<pre><code>float atlas::physics::physics_body::friction;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#variable-gravity_factor","title":"variable gravity_factor","text":"<pre><code>float atlas::physics::physics_body::gravity_factor;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#variable-linear_damping","title":"variable linear_damping","text":"<pre><code>float atlas::physics::physics_body::linear_damping;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#variable-linear_velocity","title":"variable linear_velocity","text":"<pre><code>glm::vec3 atlas::physics::physics_body::linear_velocity;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#variable-mass_factor","title":"variable mass_factor","text":"<pre><code>float atlas::physics::physics_body::mass_factor;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#variable-restitution","title":"variable restitution","text":"<pre><code>float atlas::physics::physics_body::restitution;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1physics__body/#variable-use_gravity","title":"variable use_gravity","text":"<pre><code>bool atlas::physics::physics_body::use_gravity;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_components.hpp</code></p>"},{"location":"References/classatlas_1_1physics_1_1physics__context/","title":"Class atlas::physics::physics_context","text":"<p>ClassList &gt; atlas &gt; physics &gt; physics_context</p> <p>The context is the way to interact with only the engine. It is the api for all the background funcitons and information that the user shouldn not see. It is a virtual based type erasure class so thatmany engines can implement the same functions. Specifically realted to backend engine creation like batching, starting runtime, etc... </p> <ul> <li><code>#include &lt;physics_context.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: atlas::physics::jolt_context</p>"},{"location":"References/classatlas_1_1physics_1_1physics__context/#public-functions","title":"Public Functions","text":"Type Name void clean_bodies ()  void contact_added_event ()  void create_bodies ()  void run_physics_step ()  virtual ~physics_context () = default"},{"location":"References/classatlas_1_1physics_1_1physics__context/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1physics_1_1physics__context/#function-clean_bodies","title":"function clean_bodies","text":"<pre><code>void atlas::physics::physics_context::clean_bodies () \n</code></pre>"},{"location":"References/classatlas_1_1physics_1_1physics__context/#function-contact_added_event","title":"function contact_added_event","text":"<pre><code>void atlas::physics::physics_context::contact_added_event () \n</code></pre>"},{"location":"References/classatlas_1_1physics_1_1physics__context/#function-create_bodies","title":"function create_bodies","text":"<pre><code>void atlas::physics::physics_context::create_bodies () \n</code></pre>"},{"location":"References/classatlas_1_1physics_1_1physics__context/#function-run_physics_step","title":"function run_physics_step","text":"<pre><code>void atlas::physics::physics_context::run_physics_step () \n</code></pre>"},{"location":"References/classatlas_1_1physics_1_1physics__context/#function-physics_context","title":"function ~physics_context","text":"<pre><code>virtual atlas::physics::physics_context::~physics_context () = default\n</code></pre> <p>Remark:</p> <p>This has to be public to get shared pointer working </p> <p>Note:</p> <p>With one exception being some friend class but not the way </p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/physics_context.hpp</code></p>"},{"location":"References/classatlas_1_1physics_1_1physics__engine/","title":"Class atlas::physics::physics_engine","text":"<p>ClassList &gt; atlas &gt; physics &gt; physics_engine</p> <p>The manager class for all physics engines. Manages the physics contexts and the collision engines. </p> <ul> <li><code>#include &lt;physics_engine.hpp&gt;</code></li> </ul>"},{"location":"References/classatlas_1_1physics_1_1physics__engine/#public-functions","title":"Public Functions","text":"Type Name physics_engine () = default physics_engine (const jolt_settings &amp; p_settings, const ref&lt; physics_context &gt; &amp; p_engine, const ref&lt; physics_api &gt; &amp; p_user_api)  void physics_step () Runs a single frame of the simulation. Should at minimum be called 60 fps. If below, it must be called twice. void run_contact_add () Allows for contacts to be handled by the user right after physics_step has fully run. void start_runtime () The runtime is specifically the way to start the physics, utilizing defined data from level_scene and eventually any scene to create a physics scene and manage physics step. void stop_runtime () Deletes all physics bodies and shapes. Preps itself for runtime to be called again."},{"location":"References/classatlas_1_1physics_1_1physics__engine/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1physics_1_1physics__engine/#function-physics_engine-12","title":"function physics_engine [1/2]","text":"<pre><code>atlas::physics::physics_engine::physics_engine () = default\n</code></pre>"},{"location":"References/classatlas_1_1physics_1_1physics__engine/#function-physics_engine-22","title":"function physics_engine [2/2]","text":"<pre><code>atlas::physics::physics_engine::physics_engine (\n    const jolt_settings &amp; p_settings,\n    const ref &lt; physics_context &gt; &amp; p_engine,\n    const ref &lt; physics_api &gt; &amp; p_user_api\n) \n</code></pre>"},{"location":"References/classatlas_1_1physics_1_1physics__engine/#function-physics_step","title":"function physics_step","text":"<p>Runs a single frame of the simulation. Should at minimum be called 60 fps. If below, it must be called twice. <pre><code>void atlas::physics::physics_engine::physics_step () \n</code></pre></p>"},{"location":"References/classatlas_1_1physics_1_1physics__engine/#function-run_contact_add","title":"function run_contact_add","text":"<p>Allows for contacts to be handled by the user right after physics_step has fully run. <pre><code>void atlas::physics::physics_engine::run_contact_add () \n</code></pre></p> <p>Warning:</p> <p>It is important that these stay distict until we have a job manager to maintain them. </p>"},{"location":"References/classatlas_1_1physics_1_1physics__engine/#function-start_runtime","title":"function start_runtime","text":"<p>The runtime is specifically the way to start the physics, utilizing defined data from level_scene and eventually any scene to create a physics scene and manage physics step. <pre><code>void atlas::physics::physics_engine::start_runtime () \n</code></pre></p>"},{"location":"References/classatlas_1_1physics_1_1physics__engine/#function-stop_runtime","title":"function stop_runtime","text":"<p>Deletes all physics bodies and shapes. Preps itself for runtime to be called again. <pre><code>void atlas::physics::physics_engine::stop_runtime () \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/physics_engine.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1quaternion/","title":"Struct atlas::physics::quaternion","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; physics &gt; quaternion</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/types.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1vector3/","title":"Struct atlas::physics::vector3","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; physics &gt; vector3</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/types.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1DVec3_01_4/","title":"Struct atlas::physics::vector3&lt; JPH::DVec3 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; atlas &gt; physics &gt; vector3&lt; JPH::DVec3 &gt;</p>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1DVec3_01_4/#public-functions","title":"Public Functions","text":"Type Name dvec3 () const glm::dvec3 operator= (const JPH::DVec3 &amp; v)  bool operator== (const glm::dvec3 &amp; other) const vector3 () = default vector3 (const JPH::DVec3 &amp; v)"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1DVec3_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1DVec3_01_4/#function-dvec3","title":"function dvec3","text":"<pre><code>inline atlas::physics::vector3&lt; JPH::DVec3 &gt;::dvec3 () const\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1DVec3_01_4/#function-operator","title":"function operator=","text":"<pre><code>inline glm::dvec3 atlas::physics::vector3&lt; JPH::DVec3 &gt;::operator= (\n    const JPH::DVec3 &amp; v\n) \n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1DVec3_01_4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::physics::vector3&lt; JPH::DVec3 &gt;::operator== (\n    const glm::dvec3 &amp; other\n) const\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1DVec3_01_4/#function-vector3-12","title":"function vector3 [1/2]","text":"<pre><code>atlas::physics::vector3&lt; JPH::DVec3 &gt;::vector3 () = default\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1DVec3_01_4/#function-vector3-22","title":"function vector3 [2/2]","text":"<pre><code>inline atlas::physics::vector3&lt; JPH::DVec3 &gt;::vector3 (\n    const JPH::DVec3 &amp; v\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/types.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Double3_01_4/","title":"Struct atlas::physics::vector3&lt; JPH::Double3 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; atlas &gt; physics &gt; vector3&lt; JPH::Double3 &gt;</p>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Double3_01_4/#public-functions","title":"Public Functions","text":"Type Name dvec3 () const glm::dvec3 operator= (const JPH::Double3 &amp; v)  bool operator== (const glm::dvec3 &amp; other) const vector3 () = default vector3 (const JPH::Double3 &amp; v)"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Double3_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Double3_01_4/#function-dvec3","title":"function dvec3","text":"<pre><code>inline atlas::physics::vector3&lt; JPH::Double3 &gt;::dvec3 () const\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Double3_01_4/#function-operator","title":"function operator=","text":"<pre><code>inline glm::dvec3 atlas::physics::vector3&lt; JPH::Double3 &gt;::operator= (\n    const JPH::Double3 &amp; v\n) \n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Double3_01_4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::physics::vector3&lt; JPH::Double3 &gt;::operator== (\n    const glm::dvec3 &amp; other\n) const\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Double3_01_4/#function-vector3-12","title":"function vector3 [1/2]","text":"<pre><code>atlas::physics::vector3&lt; JPH::Double3 &gt;::vector3 () = default\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Double3_01_4/#function-vector3-22","title":"function vector3 [2/2]","text":"<pre><code>inline atlas::physics::vector3&lt; JPH::Double3 &gt;::vector3 (\n    const JPH::Double3 &amp; v\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/types.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Float3_01_4/","title":"Struct atlas::physics::vector3&lt; JPH::Float3 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; atlas &gt; physics &gt; vector3&lt; JPH::Float3 &gt;</p>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Float3_01_4/#public-functions","title":"Public Functions","text":"Type Name vec3 () const glm::vec3 operator= (const JPH::Float3 &amp; v)  bool operator== (const glm::vec3 &amp; other) const vector3 () = default vector3 (const JPH::Float3 &amp; v)"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Float3_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Float3_01_4/#function-vec3","title":"function vec3","text":"<pre><code>inline atlas::physics::vector3&lt; JPH::Float3 &gt;::vec3 () const\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Float3_01_4/#function-operator","title":"function operator=","text":"<pre><code>inline glm::vec3 atlas::physics::vector3&lt; JPH::Float3 &gt;::operator= (\n    const JPH::Float3 &amp; v\n) \n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Float3_01_4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::physics::vector3&lt; JPH::Float3 &gt;::operator== (\n    const glm::vec3 &amp; other\n) const\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Float3_01_4/#function-vector3-12","title":"function vector3 [1/2]","text":"<pre><code>atlas::physics::vector3&lt; JPH::Float3 &gt;::vector3 () = default\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Float3_01_4/#function-vector3-22","title":"function vector3 [2/2]","text":"<pre><code>inline atlas::physics::vector3&lt; JPH::Float3 &gt;::vector3 (\n    const JPH::Float3 &amp; v\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/types.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Vec3_01_4/","title":"Struct atlas::physics::vector3&lt; JPH::Vec3 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; atlas &gt; physics &gt; vector3&lt; JPH::Vec3 &gt;</p>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Vec3_01_4/#public-functions","title":"Public Functions","text":"Type Name vec3 () const glm::vec3 operator= (const JPH::Vec3 &amp; v)  bool operator== (const glm::vec3 &amp; other) const vector3 () = default vector3 (const JPH::Vec3 &amp; v)"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Vec3_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Vec3_01_4/#function-vec3","title":"function vec3","text":"<pre><code>inline atlas::physics::vector3&lt; JPH::Vec3 &gt;::vec3 () const\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Vec3_01_4/#function-operator","title":"function operator=","text":"<pre><code>inline glm::vec3 atlas::physics::vector3&lt; JPH::Vec3 &gt;::operator= (\n    const JPH::Vec3 &amp; v\n) \n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Vec3_01_4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::physics::vector3&lt; JPH::Vec3 &gt;::operator== (\n    const glm::vec3 &amp; other\n) const\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Vec3_01_4/#function-vector3-12","title":"function vector3 [1/2]","text":"<pre><code>atlas::physics::vector3&lt; JPH::Vec3 &gt;::vector3 () = default\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector3_3_01JPH_1_1Vec3_01_4/#function-vector3-22","title":"function vector3 [2/2]","text":"<pre><code>inline atlas::physics::vector3&lt; JPH::Vec3 &gt;::vector3 (\n    const JPH::Vec3 &amp; v\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/types.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1vector4/","title":"Struct atlas::physics::vector4","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; physics &gt; vector4</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/types.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1vector4_3_01JPH_1_1Float4_01_4/","title":"Struct atlas::physics::vector4&lt; JPH::Float4 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; atlas &gt; physics &gt; vector4&lt; JPH::Float4 &gt;</p>"},{"location":"References/structatlas_1_1physics_1_1vector4_3_01JPH_1_1Float4_01_4/#public-functions","title":"Public Functions","text":"Type Name vec4 () const glm::vec4 operator= (const JPH::Float4 &amp; v)  bool operator== (const glm::vec4 &amp; other) const vector4 () = default vector4 (const JPH::Float4 &amp; v)"},{"location":"References/structatlas_1_1physics_1_1vector4_3_01JPH_1_1Float4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1physics_1_1vector4_3_01JPH_1_1Float4_01_4/#function-vec4","title":"function vec4","text":"<pre><code>inline atlas::physics::vector4&lt; JPH::Float4 &gt;::vec4 () const\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector4_3_01JPH_1_1Float4_01_4/#function-operator","title":"function operator=","text":"<pre><code>inline glm::vec4 atlas::physics::vector4&lt; JPH::Float4 &gt;::operator= (\n    const JPH::Float4 &amp; v\n) \n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector4_3_01JPH_1_1Float4_01_4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::physics::vector4&lt; JPH::Float4 &gt;::operator== (\n    const glm::vec4 &amp; other\n) const\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector4_3_01JPH_1_1Float4_01_4/#function-vector4-12","title":"function vector4 [1/2]","text":"<pre><code>atlas::physics::vector4&lt; JPH::Float4 &gt;::vector4 () = default\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector4_3_01JPH_1_1Float4_01_4/#function-vector4-22","title":"function vector4 [2/2]","text":"<pre><code>inline atlas::physics::vector4&lt; JPH::Float4 &gt;::vector4 (\n    const JPH::Float4 &amp; v\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/types.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1vector4_3_01JPH_1_1Vec4_01_4/","title":"Struct atlas::physics::vector4&lt; JPH::Vec4 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; atlas &gt; physics &gt; vector4&lt; JPH::Vec4 &gt;</p>"},{"location":"References/structatlas_1_1physics_1_1vector4_3_01JPH_1_1Vec4_01_4/#public-functions","title":"Public Functions","text":"Type Name vec4 () const glm::vec4 operator= (const JPH::Vec4 &amp; v)  bool operator== (const glm::vec4 &amp; other) const vector4 () = default vector4 (const JPH::Vec4 &amp; v)"},{"location":"References/structatlas_1_1physics_1_1vector4_3_01JPH_1_1Vec4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1physics_1_1vector4_3_01JPH_1_1Vec4_01_4/#function-vec4","title":"function vec4","text":"<pre><code>inline atlas::physics::vector4&lt; JPH::Vec4 &gt;::vec4 () const\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector4_3_01JPH_1_1Vec4_01_4/#function-operator","title":"function operator=","text":"<pre><code>inline glm::vec4 atlas::physics::vector4&lt; JPH::Vec4 &gt;::operator= (\n    const JPH::Vec4 &amp; v\n) \n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector4_3_01JPH_1_1Vec4_01_4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::physics::vector4&lt; JPH::Vec4 &gt;::operator== (\n    const glm::vec4 &amp; other\n) const\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector4_3_01JPH_1_1Vec4_01_4/#function-vector4-12","title":"function vector4 [1/2]","text":"<pre><code>atlas::physics::vector4&lt; JPH::Vec4 &gt;::vector4 () = default\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1vector4_3_01JPH_1_1Vec4_01_4/#function-vector4-22","title":"function vector4 [2/2]","text":"<pre><code>inline atlas::physics::vector4&lt; JPH::Vec4 &gt;::vector4 (\n    const JPH::Vec4 &amp; v\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/types.hpp</code></p>"},{"location":"References/structatlas_1_1reload/","title":"Struct atlas::reload","text":"<p>ClassList &gt; atlas &gt; reload</p> <p>Actually might do a query for this along with rendertarget3d. More...</p> <ul> <li><code>#include &lt;components.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1reload/#public-attributes","title":"Public Attributes","text":"Type Name bool on_reload   = <code>false</code> bool on_texture_reload   = <code>false</code>"},{"location":"References/structatlas_1_1reload/#detailed-description","title":"Detailed Description","text":"<p>This is because we can have multiple things that could be reloaded</p> <p>Such as the single texture and the mesh .obj 3d model as well </p>"},{"location":"References/structatlas_1_1reload/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1reload/#variable-on_reload","title":"variable on_reload","text":"<pre><code>bool atlas::reload::on_reload;\n</code></pre>"},{"location":"References/structatlas_1_1reload/#variable-on_texture_reload","title":"variable on_texture_reload","text":"<pre><code>bool atlas::reload::on_texture_reload;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/components.hpp</code></p>"},{"location":"References/classatlas_1_1render__context/","title":"Class atlas::render_context","text":"<p>ClassList &gt; atlas &gt; render_context</p> <p>Inherited by the following classes: atlas::vk::vk_renderer</p>"},{"location":"References/classatlas_1_1render__context/#public-functions","title":"Public Functions","text":"Type Name void begin_frame (const vk::vk_command_buffer &amp; p_current, const vk::vk_swapchain &amp; p_swapchain_handler)  void end_frame ()  void set_background_color (const std::array&lt; float, 4 &gt; &amp; p_color)  virtual ~render_context () = default"},{"location":"References/classatlas_1_1render__context/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1render__context/#function-begin_frame","title":"function begin_frame","text":"<pre><code>inline void atlas::render_context::begin_frame (\n    const vk::vk_command_buffer &amp; p_current,\n    const vk::vk_swapchain &amp; p_swapchain_handler\n) \n</code></pre>"},{"location":"References/classatlas_1_1render__context/#function-end_frame","title":"function end_frame","text":"<pre><code>inline void atlas::render_context::end_frame () \n</code></pre>"},{"location":"References/classatlas_1_1render__context/#function-set_background_color","title":"function set_background_color","text":"<pre><code>inline void atlas::render_context::set_background_color (\n    const std::array&lt; float, 4 &gt; &amp; p_color\n) \n</code></pre>"},{"location":"References/classatlas_1_1render__context/#function-render_context","title":"function ~render_context","text":"<pre><code>virtual atlas::render_context::~render_context () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/renderer_context.hpp</code></p>"},{"location":"References/classatlas_1_1renderer/","title":"Class atlas::renderer","text":"<p>ClassList &gt; atlas &gt; renderer</p>"},{"location":"References/classatlas_1_1renderer/#public-functions","title":"Public Functions","text":"Type Name void begin (const vk::vk_command_buffer &amp; p_current, const vk::vk_swapchain &amp; p_current_rp) Indicates to the renderer is at the start of the next frame to prepare workloads before next frame is processeed. void end () Indications when the renderer has reached the end of the frame. renderer () = default renderer (const vk::vk_swapchain &amp; p_swapchain, const std::string &amp; p_tag=\"Renderer\")  void set_background_color (const std::array&lt; float, 4 &gt; &amp; p_color)"},{"location":"References/classatlas_1_1renderer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1renderer/#function-begin","title":"function begin","text":"<p>Indicates to the renderer is at the start of the next frame to prepare workloads before next frame is processeed. <pre><code>void atlas::renderer::begin (\n    const vk::vk_command_buffer &amp; p_current,\n    const vk::vk_swapchain &amp; p_current_rp\n) \n</code></pre></p>"},{"location":"References/classatlas_1_1renderer/#function-end","title":"function end","text":"<p>Indications when the renderer has reached the end of the frame. <pre><code>void atlas::renderer::end () \n</code></pre></p>"},{"location":"References/classatlas_1_1renderer/#function-renderer-12","title":"function renderer [1/2]","text":"<pre><code>atlas::renderer::renderer () = default\n</code></pre>"},{"location":"References/classatlas_1_1renderer/#function-renderer-22","title":"function renderer [2/2]","text":"<pre><code>atlas::renderer::renderer (\n    const vk::vk_swapchain &amp; p_swapchain,\n    const std::string &amp; p_tag=\"Renderer\"\n) \n</code></pre>"},{"location":"References/classatlas_1_1renderer/#function-set_background_color","title":"function set_background_color","text":"<pre><code>void atlas::renderer::set_background_color (\n    const std::array&lt; float, 4 &gt; &amp; p_color\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/renderer/renderer.hpp</code></p>"},{"location":"References/structatlas_1_1rigidbody3d/","title":"Struct atlas::rigidbody3d","text":"<p>ClassList &gt; atlas &gt; rigidbody3d</p> <p>More...</p> <ul> <li><code>#include &lt;components.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1rigidbody3d/#public-types","title":"Public Types","text":"Type Name enum body_type"},{"location":"References/structatlas_1_1rigidbody3d/#public-attributes","title":"Public Attributes","text":"Type Name void * body_at_runtime   = <code>/* multi line expression */</code> bool hax_fixation   = <code>false</code> body_type type   = <code>body\\_type::e\\_static</code>"},{"location":"References/structatlas_1_1rigidbody3d/#public-functions","title":"Public Functions","text":"Type Name rigidbody3d () = default"},{"location":"References/structatlas_1_1rigidbody3d/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Our interpretation of the RigidBody3D </p>"},{"location":"References/structatlas_1_1rigidbody3d/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"References/structatlas_1_1rigidbody3d/#enum-body_type","title":"enum body_type","text":"<pre><code>enum atlas::rigidbody3d::body_type {\n    e_static = 0,\n    e_dynamic = 1,\n    e_kinematic = 2\n};\n</code></pre>"},{"location":"References/structatlas_1_1rigidbody3d/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1rigidbody3d/#variable-body_at_runtime","title":"variable body_at_runtime","text":"<pre><code>void* atlas::rigidbody3d::body_at_runtime;\n</code></pre>"},{"location":"References/structatlas_1_1rigidbody3d/#variable-hax_fixation","title":"variable hax_fixation","text":"<pre><code>bool atlas::rigidbody3d::hax_fixation;\n</code></pre>"},{"location":"References/structatlas_1_1rigidbody3d/#variable-type","title":"variable type","text":"<pre><code>body_type atlas::rigidbody3d::type;\n</code></pre>"},{"location":"References/structatlas_1_1rigidbody3d/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1rigidbody3d/#function-rigidbody3d","title":"function rigidbody3d","text":"<pre><code>atlas::rigidbody3d::rigidbody3d () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/components.hpp</code></p>"},{"location":"References/classatlas_1_1scene__object/","title":"Class atlas::scene_object","text":"<p>ClassList &gt; atlas &gt; scene_object</p>"},{"location":"References/classatlas_1_1scene__object/#public-functions","title":"Public Functions","text":"Type Name void add ()  void add (UComponent &amp; p_component_value)  void add_query () Specify groups of entity signatures to add to the entity. const UComponent * get () const UComponent * get_mut ()  bool has ()  entity () const entity ()  void remove ()  scene_object (flecs::world * p_registry, const std::string &amp; p_name)  void set (const UComponent &amp; p_component)  void set (const UComponent &amp; p_component, const UComponent2 &amp; p_component2)  ~scene_object ()"},{"location":"References/classatlas_1_1scene__object/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1scene__object/#function-add-12","title":"function add [1/2]","text":"<pre><code>template&lt;typename UComponent&gt;\ninline void atlas::scene_object::add () \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-add-22","title":"function add [2/2]","text":"<pre><code>template&lt;typename UComponent&gt;\ninline void atlas::scene_object::add (\n    UComponent &amp; p_component_value\n) \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-add_query","title":"function add_query","text":"<p>Specify groups of entity signatures to add to the entity. <pre><code>template&lt;typename... Args&gt;\ninline void atlas::scene_object::add_query () \n</code></pre></p> <p>signatures being the components EXPERIEMENTAL: Function to add multiple components but still in its experiemental stages. </p>"},{"location":"References/classatlas_1_1scene__object/#function-get","title":"function get","text":"<pre><code>template&lt;typename UComponent&gt;\ninline const UComponent * atlas::scene_object::get () const\n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-get_mut","title":"function get_mut","text":"<pre><code>template&lt;typename UComponent&gt;\ninline UComponent * atlas::scene_object::get_mut () \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-has","title":"function has","text":"<pre><code>template&lt;typename UComponent&gt;\ninline bool atlas::scene_object::has () \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-entity-12","title":"function entity [1/2]","text":"<pre><code>inline atlas::scene_object::entity () const\n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-entity-22","title":"function entity [2/2]","text":"<pre><code>inline atlas::scene_object::entity () \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-remove","title":"function remove","text":"<pre><code>template&lt;typename UComponent&gt;\ninline void atlas::scene_object::remove () \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-scene_object","title":"function scene_object","text":"<pre><code>atlas::scene_object::scene_object (\n    flecs::world * p_registry,\n    const std::string &amp; p_name\n) \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-set-12","title":"function set [1/2]","text":"<pre><code>template&lt;typename UComponent&gt;\ninline void atlas::scene_object::set (\n    const UComponent &amp; p_component\n) \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-set-22","title":"function set [2/2]","text":"<pre><code>template&lt;typename UComponent, typename UComponent2&gt;\ninline void atlas::scene_object::set (\n    const UComponent &amp; p_component,\n    const UComponent2 &amp; p_component2\n) \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-scene_object_1","title":"function ~scene_object","text":"<pre><code>inline atlas::scene_object::~scene_object () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/scene_object.hpp</code></p>"},{"location":"References/classatlas_1_1scene__scope/","title":"Class atlas::scene_scope","text":"<p>ClassList &gt; atlas &gt; scene_scope</p>"},{"location":"References/classatlas_1_1scene__scope/#public-functions","title":"Public Functions","text":"Type Name ref&lt; scene_object &gt; create_new_object (const std::string &amp; p_tag)  std::string get_tag ()  world () const world ()  flecs::query_builder&lt; Comps... &gt; query_builder (Args &amp;&amp;... args) const scene_scope ()  scene_scope (const std::string &amp; p_tag)  virtual ~scene_scope () = default"},{"location":"References/classatlas_1_1scene__scope/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1scene__scope/#function-create_new_object","title":"function create_new_object","text":"<pre><code>inline ref &lt; scene_object &gt; atlas::scene_scope::create_new_object (\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1scene__scope/#function-get_tag","title":"function get_tag","text":"<pre><code>inline std::string atlas::scene_scope::get_tag () \n</code></pre>"},{"location":"References/classatlas_1_1scene__scope/#function-world-12","title":"function world [1/2]","text":"<pre><code>inline atlas::scene_scope::world () const\n</code></pre>"},{"location":"References/classatlas_1_1scene__scope/#function-world-22","title":"function world [2/2]","text":"<pre><code>inline atlas::scene_scope::world () \n</code></pre>"},{"location":"References/classatlas_1_1scene__scope/#function-query_builder","title":"function query_builder","text":"<pre><code>template&lt;typename... Comps, typename... Args&gt;\ninline flecs::query_builder&lt; Comps... &gt; atlas::scene_scope::query_builder (\n    Args &amp;&amp;... args\n) const\n</code></pre>"},{"location":"References/classatlas_1_1scene__scope/#function-scene_scope-12","title":"function scene_scope [1/2]","text":"<pre><code>inline atlas::scene_scope::scene_scope () \n</code></pre>"},{"location":"References/classatlas_1_1scene__scope/#function-scene_scope-22","title":"function scene_scope [2/2]","text":"<pre><code>inline atlas::scene_scope::scene_scope (\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1scene__scope/#function-scene_scope","title":"function ~scene_scope","text":"<pre><code>virtual atlas::scene_scope::~scene_scope () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/scene.hpp</code></p>"},{"location":"References/classatlas_1_1serializer/","title":"Class atlas::serializer","text":"<p>ClassList &gt; atlas &gt; serializer</p>"},{"location":"References/classatlas_1_1serializer/#public-functions","title":"Public Functions","text":"Type Name void save_as (const std::string &amp; p_filepath)  serializer (const scene_scope * p_scene_ctx)"},{"location":"References/classatlas_1_1serializer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1serializer/#function-save_as","title":"function save_as","text":"<pre><code>void atlas::serializer::save_as (\n    const std::string &amp; p_filepath\n) \n</code></pre>"},{"location":"References/classatlas_1_1serializer/#function-serializer","title":"function serializer","text":"<pre><code>atlas::serializer::serializer (\n    const scene_scope * p_scene_ctx\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/serialize/serializer.hpp</code></p>"},{"location":"References/namespaceatlas_1_1sync__update/","title":"Namespace atlas::sync_update","text":"<p>Namespace List &gt; atlas &gt; sync_update</p>"},{"location":"References/namespaceatlas_1_1sync__update/#public-attributes","title":"Public Attributes","text":"Type Name std::deque&lt; std::function&lt; void()&gt; &gt; s_late_update std::deque&lt; std::function&lt; void()&gt; &gt; s_physica_update std::deque&lt; std::function&lt; void()&gt; &gt; s_ui_update std::deque&lt; std::function&lt; void()&gt; &gt; s_update"},{"location":"References/namespaceatlas_1_1sync__update/#public-functions","title":"Public Functions","text":"Type Name void attach (UObject * p_instance, const UCallable &amp; p_callable)  float delta_time ()  void initialize ()  void on_late_update ()  void on_physics_update ()  void on_ui_update ()  void on_update ()  void post (UObject * p_instance, const UCallable &amp; p_callable)  void sync (UObject * p_instance, const UFunction &amp; p_callable)  void sync_physics (UObject * p_instance, const UFunction &amp; p_callable)"},{"location":"References/namespaceatlas_1_1sync__update/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/namespaceatlas_1_1sync__update/#variable-s_late_update","title":"variable s_late_update","text":"<pre><code>std::deque&lt;std::function&lt;void()&gt; &gt; atlas::sync_update::s_late_update;\n</code></pre>"},{"location":"References/namespaceatlas_1_1sync__update/#variable-s_physica_update","title":"variable s_physica_update","text":"<pre><code>std::deque&lt;std::function&lt;void()&gt; &gt; atlas::sync_update::s_physica_update;\n</code></pre>"},{"location":"References/namespaceatlas_1_1sync__update/#variable-s_ui_update","title":"variable s_ui_update","text":"<pre><code>std::deque&lt;std::function&lt;void()&gt; &gt; atlas::sync_update::s_ui_update;\n</code></pre>"},{"location":"References/namespaceatlas_1_1sync__update/#variable-s_update","title":"variable s_update","text":"<pre><code>std::deque&lt;std::function&lt;void()&gt; &gt; atlas::sync_update::s_update;\n</code></pre>"},{"location":"References/namespaceatlas_1_1sync__update/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1sync__update/#function-attach","title":"function attach","text":"<pre><code>template&lt;typename UObject, typename UCallable&gt;\nvoid atlas::sync_update::attach (\n    UObject * p_instance,\n    const UCallable &amp; p_callable\n) \n</code></pre> <p>Note:</p> <p>Attach our UI Updates </p>"},{"location":"References/namespaceatlas_1_1sync__update/#function-delta_time","title":"function delta_time","text":"<pre><code>float atlas::sync_update::delta_time () \n</code></pre> <p>Note:</p> <p>Retrieves the local delta time </p>"},{"location":"References/namespaceatlas_1_1sync__update/#function-initialize","title":"function initialize","text":"<pre><code>void atlas::sync_update::initialize () \n</code></pre> <p>Note:</p> <p>Initializes sync update manager to make sure our manager is able to dispatch our update functions. </p>"},{"location":"References/namespaceatlas_1_1sync__update/#function-on_late_update","title":"function on_late_update","text":"<pre><code>void atlas::sync_update::on_late_update () \n</code></pre>"},{"location":"References/namespaceatlas_1_1sync__update/#function-on_physics_update","title":"function on_physics_update","text":"<pre><code>void atlas::sync_update::on_physics_update () \n</code></pre>"},{"location":"References/namespaceatlas_1_1sync__update/#function-on_ui_update","title":"function on_ui_update","text":"<pre><code>void atlas::sync_update::on_ui_update () \n</code></pre>"},{"location":"References/namespaceatlas_1_1sync__update/#function-on_update","title":"function on_update","text":"<pre><code>void atlas::sync_update::on_update () \n</code></pre>"},{"location":"References/namespaceatlas_1_1sync__update/#function-post","title":"function post","text":"<pre><code>template&lt;typename UObject, typename UCallable&gt;\ninline void atlas::sync_update::post (\n    UObject * p_instance,\n    const UCallable &amp; p_callable\n) \n</code></pre> <p>Note:</p> <p>Post update - newly defined late update </p>"},{"location":"References/namespaceatlas_1_1sync__update/#function-sync","title":"function sync","text":"<pre><code>template&lt;typename UObject, typename UFunction&gt;\nvoid atlas::sync_update::sync (\n    UObject * p_instance,\n    const UFunction &amp; p_callable\n) \n</code></pre> <p>Note:</p> <p>Synchronize our update per frame </p>"},{"location":"References/namespaceatlas_1_1sync__update/#function-sync_physics","title":"function sync_physics","text":"<pre><code>template&lt;typename UObject, typename UFunction&gt;\nvoid atlas::sync_update::sync_physics (\n    UObject * p_instance,\n    const UFunction &amp; p_callable\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/update_handlers/sync_update.hpp</code></p>"},{"location":"References/classatlas_1_1system__registry/","title":"Class atlas::system_registry","text":"<p>ClassList &gt; atlas &gt; system_registry</p>"},{"location":"References/classatlas_1_1system__registry/#public-functions","title":"Public Functions","text":"Type Name system_registry (const std::string &amp; p_tag)  ~system_registry ()"},{"location":"References/classatlas_1_1system__registry/#public-static-functions","title":"Public Static Functions","text":"Type Name ref&lt; world_scope &gt; create_world (const std::string &amp; p_tag) Instantiates new world_scope . ref&lt; world_scope &gt; get_world (const std::string &amp; p_tag) Searches and returns world_scope if found."},{"location":"References/classatlas_1_1system__registry/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1system__registry/#function-system_registry","title":"function system_registry","text":"<pre><code>atlas::system_registry::system_registry (\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1system__registry/#function-system_registry_1","title":"function ~system_registry","text":"<pre><code>atlas::system_registry::~system_registry () \n</code></pre>"},{"location":"References/classatlas_1_1system__registry/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1system__registry/#function-create_world","title":"function create_world","text":"<p>Instantiates new world_scope . <pre><code>static ref &lt; world_scope &gt; atlas::system_registry::create_world (\n    const std::string &amp; p_tag\n) \n</code></pre></p> <p>Note:</p> <p>system_registry does the following: * Creates world scopes * Manages Lifetimes of world objects * Keeps tracks of the refcounting of references to these world objects * Provide globalized access to other worlds </p>"},{"location":"References/classatlas_1_1system__registry/#function-get_world","title":"function get_world","text":"<p>Searches and returns world_scope if found. <pre><code>static ref &lt; world_scope &gt; atlas::system_registry::get_world (\n    const std::string &amp; p_tag\n) \n</code></pre></p> <p>Returns nullptr if world_scope not found </p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/system_framework/system_registry.hpp</code></p>"},{"location":"References/structatlas_1_1tag/","title":"Struct atlas::tag","text":"<p>ClassList &gt; atlas &gt; tag</p>"},{"location":"References/structatlas_1_1tag/#public-attributes","title":"Public Attributes","text":"Type Name std::string TagMetadata   = <code>\"\"</code>"},{"location":"References/structatlas_1_1tag/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1tag/#variable-tagmetadata","title":"variable TagMetadata","text":"<pre><code>std::string atlas::tag::TagMetadata;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/components.hpp</code></p>"},{"location":"References/classatlas_1_1thread/","title":"Class atlas::thread","text":"<p>ClassList &gt; atlas &gt; thread</p> <p>More...</p> <ul> <li><code>#include &lt;thread.hpp&gt;</code></li> </ul>"},{"location":"References/classatlas_1_1thread/#public-functions","title":"Public Functions","text":"Type Name void Join ()  bool Joinable ()  void dispatch (const T &amp; p_function)  void dispatch (T &amp;&amp; func, Args &amp;&amp;... args)  thread (const std::string &amp; p_tag)  thread () = delete thread (const std::string &amp; p_tag=\"Undefined\")  ~thread ()"},{"location":"References/classatlas_1_1thread/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Current work to get back to it.</p> <p>Note:</p> <p>The thought we are doing are the following</p> <p>Note:</p> <p>First implement thread.hpp </p> <p>Note:</p> <p>Implementing the thread class to wrap around the &lt;thread&gt; for handling and doing thread stuff like thread statuses, policies, etc</p> <p>Note:</p> <p>Second improve &lt;thread_pool&gt; to first be able to spawn those threads </p> <p>Note:</p> <p>Then once we can spawn those specific threads successfully then we apply what global update does and use a similar logic into the &lt;thread_pool&gt; itself</p> <p>Note:</p> <p>Third, fix up the FPS and timer for udpate frequency </p>"},{"location":"References/classatlas_1_1thread/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1thread/#function-join","title":"function Join","text":"<pre><code>inline void atlas::thread::Join () \n</code></pre>"},{"location":"References/classatlas_1_1thread/#function-joinable","title":"function Joinable","text":"<pre><code>inline bool atlas::thread::Joinable () \n</code></pre>"},{"location":"References/classatlas_1_1thread/#function-dispatch-12","title":"function dispatch [1/2]","text":"<pre><code>template&lt;typename T&gt;\ninline void atlas::thread::dispatch (\n    const T &amp; p_function\n) \n</code></pre>"},{"location":"References/classatlas_1_1thread/#function-dispatch-22","title":"function dispatch [2/2]","text":"<pre><code>template&lt;typename T, typename... Args&gt;\ninline void atlas::thread::dispatch (\n    T &amp;&amp; func,\n    Args &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/classatlas_1_1thread/#function-thread-13","title":"function thread [1/3]","text":"<pre><code>atlas::thread::thread (\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1thread/#function-thread-23","title":"function thread [2/3]","text":"<pre><code>atlas::thread::thread () = delete\n</code></pre>"},{"location":"References/classatlas_1_1thread/#function-thread-33","title":"function thread [3/3]","text":"<pre><code>inline atlas::thread::thread (\n    const std::string &amp; p_tag=\"Undefined\"\n) \n</code></pre>"},{"location":"References/classatlas_1_1thread/#function-thread","title":"function ~thread","text":"<pre><code>inline atlas::thread::~thread () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/threads/thread.hpp</code></p>"},{"location":"References/classatlas_1_1timer/","title":"Class atlas::timer","text":"<p>ClassList &gt; atlas &gt; timer</p>"},{"location":"References/classatlas_1_1timer/#public-functions","title":"Public Functions","text":"Type Name std::chrono::time_point&lt; std::chrono::high_resolution_clock &gt; current_time ()  float elapsed ()  void reset ()  float seconds ()  timer ()"},{"location":"References/classatlas_1_1timer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1timer/#function-current_time","title":"function current_time","text":"<pre><code>std::chrono::time_point&lt; std::chrono::high_resolution_clock &gt; atlas::timer::current_time () \n</code></pre>"},{"location":"References/classatlas_1_1timer/#function-elapsed","title":"function elapsed","text":"<pre><code>float atlas::timer::elapsed () \n</code></pre>"},{"location":"References/classatlas_1_1timer/#function-reset","title":"function reset","text":"<pre><code>void atlas::timer::reset () \n</code></pre>"},{"location":"References/classatlas_1_1timer/#function-seconds","title":"function seconds","text":"<pre><code>float atlas::timer::seconds () \n</code></pre>"},{"location":"References/classatlas_1_1timer/#function-timer","title":"function timer","text":"<pre><code>atlas::timer::timer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/update_handlers/timer.hpp</code></p>"},{"location":"References/structatlas_1_1transform/","title":"Struct atlas::transform","text":"<p>ClassList &gt; atlas &gt; transform</p>"},{"location":"References/structatlas_1_1transform/#public-attributes","title":"Public Attributes","text":"Type Name glm::highp_vec3 Position   = <code>{ 0.f }</code> glm::highp_vec4 QuaternionRotation   = <code>{ 0.f, 0, 0, 1 }</code> glm::highp_vec3 Rotation   = <code>{ 0.f }</code> glm::highp_vec3 Scale   = <code>{ 1.f }</code>"},{"location":"References/structatlas_1_1transform/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1transform/#variable-position","title":"variable Position","text":"<pre><code>glm::highp_vec3 atlas::transform::Position;\n</code></pre>"},{"location":"References/structatlas_1_1transform/#variable-quaternionrotation","title":"variable QuaternionRotation","text":"<pre><code>glm::highp_vec4 atlas::transform::QuaternionRotation;\n</code></pre>"},{"location":"References/structatlas_1_1transform/#variable-rotation","title":"variable Rotation","text":"<pre><code>glm::highp_vec3 atlas::transform::Rotation;\n</code></pre>"},{"location":"References/structatlas_1_1transform/#variable-scale","title":"variable Scale","text":"<pre><code>glm::highp_vec3 atlas::transform::Scale;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/components.hpp</code></p>"},{"location":"References/structatlas_1_1transform__physics/","title":"Struct atlas::transform_physics","text":"<p>ClassList &gt; atlas &gt; transform_physics</p> <p>More...</p> <ul> <li><code>#include &lt;transform.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1transform__physics/#public-attributes","title":"Public Attributes","text":"Type Name glm::highp_vec3 position   = <code>{ 0.f }</code> glm::highp_vec4 quaterion_rotation   = <code>{ 0.0f, 0.0f, 0.0f, 1.0f }</code> glm::highp_vec3 rotation   = <code>{ 0.f }</code> glm::highp_vec3 scale   = <code>{ 1.f }</code>"},{"location":"References/structatlas_1_1transform__physics/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>This is the struct that jolt_context uses </p> <p>Note:</p> <p>When changing to transform change jolt_context transform_physics to transform as well </p>"},{"location":"References/structatlas_1_1transform__physics/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1transform__physics/#variable-position","title":"variable position","text":"<pre><code>glm::highp_vec3 atlas::transform_physics::position;\n</code></pre>"},{"location":"References/structatlas_1_1transform__physics/#variable-quaterion_rotation","title":"variable quaterion_rotation","text":"<pre><code>glm::highp_vec4 atlas::transform_physics::quaterion_rotation;\n</code></pre>"},{"location":"References/structatlas_1_1transform__physics/#variable-rotation","title":"variable rotation","text":"<pre><code>glm::highp_vec3 atlas::transform_physics::rotation;\n</code></pre>"},{"location":"References/structatlas_1_1transform__physics/#variable-scale","title":"variable scale","text":"<pre><code>glm::highp_vec3 atlas::transform_physics::scale;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/components/transform.hpp</code></p>"},{"location":"References/namespaceatlas_1_1ui/","title":"Namespace atlas::ui","text":"<p>Namespace List &gt; atlas &gt; ui</p>"},{"location":"References/namespaceatlas_1_1ui/#public-functions","title":"Public Functions","text":"Type Name bool begin_popup_context_window (const char * p_str_id, ImGuiMouseButton p_mb, bool p_over_items)  void button_open_file_dialog (const std::string &amp; p_tag, std::string &amp; p_filepath, const std::string &amp; p_filter=\"obj;glftf;fbx\")  void dockspace_window (GLFWwindow * p_window)  void draw_float (const std::string &amp; p_tag, float &amp; p_value, float p_reset_value=0.f)  void draw_vec3 (const std::string &amp; p_tag, glm::vec3 &amp; p_value, float p_reset_value=0.f)  void draw_vec4 (const std::string &amp; p_tag, glm::vec4 &amp; p_value, float p_reset_value=0.f)"},{"location":"References/namespaceatlas_1_1ui/#public-static-functions","title":"Public Static Functions","text":"Type Name void draw_panel_component (const std::string &amp; p_tag, const UFunction &amp; p_callable)"},{"location":"References/namespaceatlas_1_1ui/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1ui/#function-begin_popup_context_window","title":"function begin_popup_context_window","text":"<pre><code>bool atlas::ui::begin_popup_context_window (\n    const char * p_str_id,\n    ImGuiMouseButton p_mb,\n    bool p_over_items\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1ui/#function-button_open_file_dialog","title":"function button_open_file_dialog","text":"<pre><code>void atlas::ui::button_open_file_dialog (\n    const std::string &amp; p_tag,\n    std::string &amp; p_filepath,\n    const std::string &amp; p_filter=\"obj;glftf;fbx\"\n) \n</code></pre> <p>Note:</p> <p>Sets up UI button for loading files </p>"},{"location":"References/namespaceatlas_1_1ui/#function-dockspace_window","title":"function dockspace_window","text":"<pre><code>void atlas::ui::dockspace_window (\n    GLFWwindow * p_window\n) \n</code></pre> <p>Note:</p> <p>Sets up dockspaces </p>"},{"location":"References/namespaceatlas_1_1ui/#function-draw_float","title":"function draw_float","text":"<pre><code>void atlas::ui::draw_float (\n    const std::string &amp; p_tag,\n    float &amp; p_value,\n    float p_reset_value=0.f\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1ui/#function-draw_vec3","title":"function draw_vec3","text":"<pre><code>void atlas::ui::draw_vec3 (\n    const std::string &amp; p_tag,\n    glm::vec3 &amp; p_value,\n    float p_reset_value=0.f\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1ui/#function-draw_vec4","title":"function draw_vec4","text":"<pre><code>void atlas::ui::draw_vec4 (\n    const std::string &amp; p_tag,\n    glm::vec4 &amp; p_value,\n    float p_reset_value=0.f\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1ui/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1ui/#function-draw_panel_component","title":"function draw_panel_component","text":"<pre><code>template&lt;typename T, typename UFunction&gt;\nstatic void atlas::ui::draw_panel_component (\n    const std::string &amp; p_tag,\n    const UFunction &amp; p_callable\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/ui/widgets.hpp</code></p>"},{"location":"References/structatlas_1_1vector2/","title":"Struct atlas::vector2","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; vector2</p> <p>More...</p>"},{"location":"References/structatlas_1_1vector2/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>The reason why we do this is because if we have an arbitrary type of vec2, vec3, vec4. This allows us to still utilize glm::vec3 as our default vec3 types </p> <p>Note:</p> <p>The computation would still be of how you can do math can be implemented by the math library of your choice, the only thing you just to is make those changes at compile-time to glm::vec2, glm::vec3, or even glm::vec4. </p> <p>Note:</p> <p>Hence why you override these metadata classes for specifically vec2, 3, and 4</p> <p>Note:</p> <p>By doing this we can let the default we define be utilizing glm's mathematical data types. Then letting users define their own customizable types if they choose to utilize a different mathematical type </p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4/","title":"Struct atlas::vector2&lt; glm::highp_vec2 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; atlas &gt; vector2&lt; glm::highp_vec2 &gt;</p>"},{"location":"References/structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4/#public-functions","title":"Public Functions","text":"Type Name highp_vec2 ()  glm::highp_vec2 operator= (const glm::highp_vec2 &amp; p_other)  bool operator== (const glm::vec4 &amp; p_other)  vector2 () = default vector2 (const glm::highp_vec2 &amp; p_other)"},{"location":"References/structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4/#function-highp_vec2","title":"function highp_vec2","text":"<pre><code>inline atlas::vector2&lt; glm::highp_vec2 &gt;::highp_vec2 () \n</code></pre>"},{"location":"References/structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4/#function-operator","title":"function operator=","text":"<pre><code>inline glm::highp_vec2 atlas::vector2&lt; glm::highp_vec2 &gt;::operator= (\n    const glm::highp_vec2 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::vector2&lt; glm::highp_vec2 &gt;::operator== (\n    const glm::vec4 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4/#function-vector2-12","title":"function vector2 [1/2]","text":"<pre><code>atlas::vector2&lt; glm::highp_vec2 &gt;::vector2 () = default\n</code></pre>"},{"location":"References/structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4/#function-vector2-22","title":"function vector2 [2/2]","text":"<pre><code>inline atlas::vector2&lt; glm::highp_vec2 &gt;::vector2 (\n    const glm::highp_vec2 &amp; p_other\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/structatlas_1_1vector3/","title":"Struct atlas::vector3","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; vector3</p>"},{"location":"References/structatlas_1_1vector3/#public-functions","title":"Public Functions","text":"Type Name vec3 ()  glm::vec3 operator= (const T &amp; p_other)  bool operator== (const glm::vec3 &amp; p_other)  vector3 () = default vector3 (const T &amp; p_other)  vector3 (float x, float y, float z)  vector3 (const std::initializer_list&lt; float &gt; &amp; values)"},{"location":"References/structatlas_1_1vector3/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1vector3/#function-vec3","title":"function vec3","text":"<pre><code>inline atlas::vector3::vec3 () \n</code></pre>"},{"location":"References/structatlas_1_1vector3/#function-operator","title":"function operator=","text":"<pre><code>inline glm::vec3 atlas::vector3::operator= (\n    const T &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector3/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::vector3::operator== (\n    const glm::vec3 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector3/#function-vector3-14","title":"function vector3 [1/4]","text":"<pre><code>atlas::vector3::vector3 () = default\n</code></pre>"},{"location":"References/structatlas_1_1vector3/#function-vector3-24","title":"function vector3 [2/4]","text":"<pre><code>inline atlas::vector3::vector3 (\n    const T &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector3/#function-vector3-34","title":"function vector3 [3/4]","text":"<pre><code>inline atlas::vector3::vector3 (\n    float x,\n    float y,\n    float z\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector3/#function-vector3-44","title":"function vector3 [4/4]","text":"<pre><code>inline atlas::vector3::vector3 (\n    const std::initializer_list&lt; float &gt; &amp; values\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4/","title":"Struct atlas::vector3&lt; JPH::Vec3 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; atlas &gt; vector3&lt; JPH::Vec3 &gt;</p>"},{"location":"References/structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4/#public-functions","title":"Public Functions","text":"Type Name vec3 ()  glm::vec3 operator= (const JPH::Vec3 &amp; p_other)  bool operator== (const glm::vec3 &amp; p_other)  vector3 () = default vector3 (const JPH::Vec3 &amp; p_other)"},{"location":"References/structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4/#function-vec3","title":"function vec3","text":"<pre><code>inline atlas::vector3&lt; JPH::Vec3 &gt;::vec3 () \n</code></pre>"},{"location":"References/structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4/#function-operator","title":"function operator=","text":"<pre><code>inline glm::vec3 atlas::vector3&lt; JPH::Vec3 &gt;::operator= (\n    const JPH::Vec3 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::vector3&lt; JPH::Vec3 &gt;::operator== (\n    const glm::vec3 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4/#function-vector3-12","title":"function vector3 [1/2]","text":"<pre><code>atlas::vector3&lt; JPH::Vec3 &gt;::vector3 () = default\n</code></pre>"},{"location":"References/structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4/#function-vector3-22","title":"function vector3 [2/2]","text":"<pre><code>inline atlas::vector3&lt; JPH::Vec3 &gt;::vector3 (\n    const JPH::Vec3 &amp; p_other\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/jolt/jolt_helper.hpp</code></p>"},{"location":"References/structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4/","title":"Struct atlas::vector3&lt; glm::highp_vec3 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; atlas &gt; vector3&lt; glm::highp_vec3 &gt;</p>"},{"location":"References/structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4/#public-functions","title":"Public Functions","text":"Type Name highp_vec3 ()  glm::highp_vec3 operator= (const glm::highp_vec3 &amp; p_other)  bool operator== (const glm::highp_vec3 &amp; p_other)  vector3 () = default vector3 (const glm::highp_vec3 &amp; p_other)"},{"location":"References/structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4/#function-highp_vec3","title":"function highp_vec3","text":"<pre><code>inline atlas::vector3&lt; glm::highp_vec3 &gt;::highp_vec3 () \n</code></pre>"},{"location":"References/structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4/#function-operator","title":"function operator=","text":"<pre><code>inline glm::highp_vec3 atlas::vector3&lt; glm::highp_vec3 &gt;::operator= (\n    const glm::highp_vec3 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::vector3&lt; glm::highp_vec3 &gt;::operator== (\n    const glm::highp_vec3 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4/#function-vector3-12","title":"function vector3 [1/2]","text":"<pre><code>atlas::vector3&lt; glm::highp_vec3 &gt;::vector3 () = default\n</code></pre>"},{"location":"References/structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4/#function-vector3-22","title":"function vector3 [2/2]","text":"<pre><code>inline atlas::vector3&lt; glm::highp_vec3 &gt;::vector3 (\n    const glm::highp_vec3 &amp; p_other\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/structatlas_1_1vector4/","title":"Struct atlas::vector4","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; vector4</p>"},{"location":"References/structatlas_1_1vector4/#public-functions","title":"Public Functions","text":"Type Name vec4 ()  glm::vec4 operator= (const T &amp; p_other)  bool operator== (const glm::vec4 &amp; p_other)  vector4 () = default vector4 (const T &amp; p_other)  vector4 (float x, float y, float z, float w)"},{"location":"References/structatlas_1_1vector4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1vector4/#function-vec4","title":"function vec4","text":"<pre><code>inline atlas::vector4::vec4 () \n</code></pre>"},{"location":"References/structatlas_1_1vector4/#function-operator","title":"function operator=","text":"<pre><code>inline glm::vec4 atlas::vector4::operator= (\n    const T &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::vector4::operator== (\n    const glm::vec4 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector4/#function-vector4-13","title":"function vector4 [1/3]","text":"<pre><code>atlas::vector4::vector4 () = default\n</code></pre>"},{"location":"References/structatlas_1_1vector4/#function-vector4-23","title":"function vector4 [2/3]","text":"<pre><code>inline atlas::vector4::vector4 (\n    const T &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector4/#function-vector4-33","title":"function vector4 [3/3]","text":"<pre><code>inline atlas::vector4::vector4 (\n    float x,\n    float y,\n    float z,\n    float w\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4/","title":"Struct atlas::vector4&lt; glm::highp_vec4 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; atlas &gt; vector4&lt; glm::highp_vec4 &gt;</p>"},{"location":"References/structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4/#public-functions","title":"Public Functions","text":"Type Name highp_vec4 ()  glm::highp_vec4 operator= (const glm::highp_vec4 &amp; p_other)  bool operator== (const glm::highp_vec4 &amp; p_other)  vector4 () = default vector4 (const glm::highp_vec4 &amp; p_other)"},{"location":"References/structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4/#function-highp_vec4","title":"function highp_vec4","text":"<pre><code>inline atlas::vector4&lt; glm::highp_vec4 &gt;::highp_vec4 () \n</code></pre>"},{"location":"References/structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4/#function-operator","title":"function operator=","text":"<pre><code>inline glm::highp_vec4 atlas::vector4&lt; glm::highp_vec4 &gt;::operator= (\n    const glm::highp_vec4 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::vector4&lt; glm::highp_vec4 &gt;::operator== (\n    const glm::highp_vec4 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4/#function-vector4-12","title":"function vector4 [1/2]","text":"<pre><code>atlas::vector4&lt; glm::highp_vec4 &gt;::vector4 () = default\n</code></pre>"},{"location":"References/structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4/#function-vector4-22","title":"function vector4 [2/2]","text":"<pre><code>inline atlas::vector4&lt; glm::highp_vec4 &gt;::vector4 (\n    const glm::highp_vec4 &amp; p_other\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/namespaceatlas_1_1vk/","title":"Namespace atlas::vk","text":"<p>Namespace List &gt; atlas &gt; vk</p>"},{"location":"References/namespaceatlas_1_1vk/#classes","title":"Classes","text":"Type Name struct camera_ubo Going to remove this. struct command_buffer_settings settings for specifying command buffers to construct struct descriptor_binding_entry struct descriptor_binding_point class descriptor_set struct descriptor_set_layout struct global_ubo Just for testing purposes for sending this struct over to the shader. struct hud_data struct image_extent class imgui_context struct material_uniform material is going to define properties about how a scene object itself gets rendered class mesh mesh class specifically defined with vulkan implementations for specific primitives TODO: Whenever we load in a texture that will be laucnhed asyncronously struct renderpass_attachment struct renderpass_options struct shader_info struct surface_properties class texture struct texture_extent struct texture_properties struct vertex_attribute struct vertex_attribute_entry struct vertex_input struct vk_buffer vulkan buffer struct to define the handlers and memory specifications required for buffer handlers in vulkan struct vk_buffer_info Specifications of the vulkan buffer handlers and the use and memory bits associated with the buffer handlers. class vk_command_buffer Vulkan Command Buffers. class vk_context class vk_driver vulkan implementation of extracting a logical device struct vk_filter_range Range between min and max for the VkFilter. class vk_graphics_queue graphics queue mainly used for submitting to the graphics family specific queue struct vk_image vulkan image handler with resources; used when handling textures struct vk_image_handle class vk_index_buffer class vk_physical_driver class vk_pipeline class vk_present_queue Handles submissions to the specific queue for presentation. struct vk_queue_options class vk_renderer Something to consider for mesh loading. class vk_renderpass defines a renderpass operation struct vk_renderpass_options Renderpass specifictations for VkRenderpass. class vk_shader_group struct vk_shader_module class vk_swapchain class vk_uniform_buffer class vk_vertex_buffer class vk_window"},{"location":"References/namespaceatlas_1_1vk/#public-types","title":"Public Types","text":"Type Name enum uint8_t attachment_load Equivalent to VkAttachmentLoadOp. enum uint8_t attachment_store Equivalent to VkAttachmentStoreOp. enum uint8_t buffer enum uint8_t command_buffer_levels enum uint64_t format enum uint8_t image_layout enum uint8_t input_rate Refers to the input rate. enum uint8_t pipeline_bind_point Equivalent to VkPipelineBindPoint. enum uint8_t renderpass_type this is the expectation of specifying the renderpass attachments enum uint8_t sample_bit Equivalent to doing VkSampleCountFlagBits but simplified. enum shader_stage"},{"location":"References/namespaceatlas_1_1vk/#public-functions","title":"Public Functions","text":"Type Name void begin_command_buffer (const VkCommandBuffer &amp; p_command_buffer, VkCommandBufferUsageFlags p_usage_flags)  int bytes_per_texture_format (VkFormat p_format)  void copy (vk_command_buffer &amp; p_command_buffer, VkImage &amp; p_image, VkBuffer &amp; p_buffer, uint32_t p_width, uint32_t p_height)  void copy (const vk_buffer &amp; p_src, const vk_buffer &amp; p_dst, size_t p_size_of_bytes) Copies from one buffer source into another buffer source with a specific size of bytes to be stored the buffer that is being copied to. vk_buffer create_buffer (const vk_buffer_info &amp; p_info)  vk_image create_image2d (uint32_t p_width, uint32_t p_height, VkFormat p_format, VkImageUsageFlags p_usage, VkMemoryPropertyFlagBits p_property) Returns vk_image which contains the VkImage and VkImage handlers with image 2D specifications. vk_image_handle create_image2d (const VkDevice &amp; p_driver, const image_extent &amp; p_extent)  VkImageView create_image_view (const VkImage &amp; p_image, VkFormat p_format, VkImageAspectFlags p_aspect_flags)  VkImageView create_image_view (const VkDevice &amp; p_driver, VkImage p_image, VkSurfaceFormatKHR p_surface_format, VkImageAspectFlags p_aspect_flags, VkImageViewType p_view_t, uint32_t p_layer_count, uint32_t p_mip_level=1)  VkSampler create_sampler (const vk_filter_range &amp; p_range, VkSamplerAddressMode p_address_mode)  VkSemaphore create_semaphore (const VkDevice &amp; p_driver)  VkCommandBuffer create_single_command_buffer (const VkCommandPool &amp; p_command_pool)  VkCommandPool create_single_command_pool ()  vk_buffer create_uniform_buffer (uint32_t p_size)  void end_command_buffer (const VkCommandBuffer &amp; p_command_buffer)  void free_buffer (const VkDevice &amp; p_driver, vk_buffer &amp; p_buffer)  void free_image (const VkDevice &amp; p_driver, vk_image &amp; p_image)  bool has_stencil_attachment (VkFormat p_format) Validate if the format specified is a stencil attachment. void image_memory_barrier (VkCommandBuffer &amp; p_command_buffer, VkImage &amp; p_image, VkFormat p_format, VkImageLayout p_old, VkImageLayout p_new)  void queue_submit (const VkQueue &amp; p_queue_handle, const std::span&lt; VkCommandBuffer &gt; &amp; p_commands)  VkPresentModeKHR select_compatible_present_mode (const VkPresentModeKHR &amp; p_request, const std::span&lt; VkPresentModeKHR &gt; &amp; p_modes)  uint32_t select_images_size (const VkSurfaceCapabilitiesKHR &amp; p_surface_capabilities)  VkAttachmentLoadOp to_vk_attachment_load (attachment_load p_attachment_type)  VkAttachmentStoreOp to_vk_attachment_store (const attachment_store &amp; p_attachment_type)  VkCommandBufferLevel to_vk_command_buffer_level (const command_buffer_levels &amp; p_levels) Conversion function that returns VkCommandBufferLevel. VkDescriptorType to_vk_descriptor_type (const buffer &amp; p_type)  VkFormat to_vk_format (const format &amp; p_format) converts high-level specifications of format to VkFormat VkImageLayout to_vk_image_layout (const image_layout &amp; p_layout)  VkVertexInputRate to_vk_input_rate (const input_rate &amp; p_input_rate)  VkPipelineBindPoint to_vk_pipeline_bind_point (const pipeline_bind_point &amp; p_bind_point)  VkSampleCountFlagBits to_vk_sample_count_bits (const sample_bit &amp; p_sample_count_bit)  VkShaderStageFlags to_vk_shader_stage (const shader_stage &amp; p_stage)  VkShaderStageFlagBits to_vk_shader_stage_bits (const shader_stage &amp; p_stage)  void transition_image_layout (VkImage &amp; p_image, VkFormat p_format, VkImageLayout p_old, VkImageLayout p_new)  void transition_image_layout (VkCommandBuffer &amp; p_command_buffer, VkImage &amp; p_image, VkFormat p_format, VkImageLayout p_old, VkImageLayout p_new)  void vk_check (const VkResult &amp; p_result, const std::string &amp; p_name, const std::source_location &amp; p_source=std::source_location::current())  void vk_check_format (VkFormat p_format, const char * p_filepath, uint32_t p_line, const char * p_function_name) Checks for valid <code>VkFormat</code> specified. std::string vk_format_to_string (VkFormat p_format)  std::string vk_present_mode_to_string (VkPresentModeKHR p_present_mode)  void write (const vk_buffer &amp; p_buffer, const void * p_data, size_t p_size_in_bytes) maps the current buffer handler to some block of memory and the byte size for that chunk void write (const vk_buffer &amp; p_buffer, const std::span&lt; uint32_t &gt; &amp; p_in_buffer) Maps buffer handler to chunk of data of type, that is std::span&lt;uint32_t&gt;. void write (const vk_buffer &amp; p_buffer, const std::span&lt; vertex_input &gt; &amp; p_in_buffer) Maps buffer handler to data chunks that contain vertices."},{"location":"References/namespaceatlas_1_1vk/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"References/namespaceatlas_1_1vk/#enum-attachment_load","title":"enum attachment_load","text":"<p>Equivalent to VkAttachmentLoadOp. <pre><code>enum atlas::vk::attachment_load {\n    load = 0,\n    clear,\n    dont_care,\n    none_khr,\n    none_ext,\n    max_enum\n};\n</code></pre></p>"},{"location":"References/namespaceatlas_1_1vk/#enum-attachment_store","title":"enum attachment_store","text":"<p>Equivalent to VkAttachmentStoreOp. <pre><code>enum atlas::vk::attachment_store {\n    store = 0,\n    dont_care,\n    none_khr,\n    none_qcom,\n    none_ext,\n    max_enum\n};\n</code></pre></p>"},{"location":"References/namespaceatlas_1_1vk/#enum-buffer","title":"enum buffer","text":"<pre><code>enum atlas::vk::buffer {\n    uniform = 0,\n    storage = 1,\n    combined_image_sampler = 2,\n    sampled_image = 3\n};\n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#enum-command_buffer_levels","title":"enum command_buffer_levels","text":"<pre><code>enum atlas::vk::command_buffer_levels {\n    primary = 0,\n    secondary = 1,\n    max_enum = 2\n};\n</code></pre> <p>Parameters:</p> <ul> <li><code>Primary</code> submission: immediately to vulkan queue for executing on device execution: vkQueueSubmit primarily submits primary command buffers</li> <li><code>Seconary</code> submission: Cannot be submitted directly to vulkan queue execution: Indirect execution by being called from primary command buffers using <code>vkCmdExecuteCommands</code></li> </ul> <p>When executed within render-pass instance, they inherit renderpass/subpass state from primary command buffer</p> <p>Can be allocated and recorded in parallel, which can leverage devices that support multi-core processing</p> <p>Have independent lifetimes that can be managed independently of primary command buffers, allowing for more flexible resource management </p>"},{"location":"References/namespaceatlas_1_1vk/#enum-format","title":"enum format","text":"<pre><code>enum atlas::vk::format {\n    rgb32_sfloat,\n    rg32_sfloat\n};\n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#enum-image_layout","title":"enum image_layout","text":"<pre><code>enum atlas::vk::image_layout {\n    undefined = 0,\n    general = 1,\n    color_optimal = 2,\n    depth_stencil_optimal =\n          3,\n    depth_stencil_read_only_optimal =\n          4\n};\n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#enum-input_rate","title":"enum input_rate","text":"<p>Refers to the input rate. <pre><code>enum atlas::vk::input_rate {\n    vertex,\n    instance,\n    max_enum\n};\n</code></pre></p> <p>vertex - refers to most common rate. Indicates GPU to move next data entry (next vertex data) into a buffer for every single vertex that's processed. * Used for vertex attributes that change per vertex on the mesh * vertex attribute-only data * Per-object based specification in the next data entry</p> <p>instance - refers to data entry per-instance. Specifying to the GPU that the data entry in the buffer is to be after the instance of the object itself. * Typically used for instanced rendering. Specfying next entry of data to be after instanced drawn, could be shared. Therefore instance is an option to choose from if vertex data is across as a per-instance basis.</p> <p>instance-based specification next data entry </p>"},{"location":"References/namespaceatlas_1_1vk/#enum-pipeline_bind_point","title":"enum pipeline_bind_point","text":"<p>Equivalent to VkPipelineBindPoint. <pre><code>enum atlas::vk::pipeline_bind_point {\n    graphics = 0,\n    compute = 1,\n    ray_tracing_khr,\n    subpass_shading_hauwei,\n    ray_tracing_nv,\n    max_enum\n};\n</code></pre></p>"},{"location":"References/namespaceatlas_1_1vk/#enum-renderpass_type","title":"enum renderpass_type","text":"<p>this is the expectation of specifying the renderpass attachments <pre><code>enum atlas::vk::renderpass_type {\n    color,\n    depth\n};\n</code></pre></p>"},{"location":"References/namespaceatlas_1_1vk/#enum-sample_bit","title":"enum sample_bit","text":"<p>Equivalent to doing VkSampleCountFlagBits but simplified. <pre><code>enum atlas::vk::sample_bit {\n    count_1,\n    count_2,\n    count_4,\n    count_8,\n    count_16,\n    count_32,\n    count_64,\n    max_enum\n};\n</code></pre></p>"},{"location":"References/namespaceatlas_1_1vk/#enum-shader_stage","title":"enum shader_stage","text":"<pre><code>enum atlas::vk::shader_stage {\n    undefined = -1,\n    vertex = 0,\n    fragment = 1\n};\n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1vk/#function-begin_command_buffer","title":"function begin_command_buffer","text":"<pre><code>void atlas::vk::begin_command_buffer (\n    const VkCommandBuffer &amp; p_command_buffer,\n    VkCommandBufferUsageFlags p_usage_flags\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-bytes_per_texture_format","title":"function bytes_per_texture_format","text":"<pre><code>int atlas::vk::bytes_per_texture_format (\n    VkFormat p_format\n) \n</code></pre> <p>Returns:</p> <p>the bytes of the texture format specified by the parameter \"VkFormat\" </p>"},{"location":"References/namespaceatlas_1_1vk/#function-copy","title":"function copy","text":"<pre><code>void atlas::vk::copy (\n    vk_command_buffer &amp; p_command_buffer,\n    VkImage &amp; p_image,\n    VkBuffer &amp; p_buffer,\n    uint32_t p_width,\n    uint32_t p_height\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-copy_1","title":"function copy","text":"<p>Copies from one buffer source into another buffer source with a specific size of bytes to be stored the buffer that is being copied to. <pre><code>void atlas::vk::copy (\n    const vk_buffer &amp; p_src,\n    const vk_buffer &amp; p_dst,\n    size_t p_size_of_bytes\n) \n</code></pre></p>"},{"location":"References/namespaceatlas_1_1vk/#function-create_buffer","title":"function create_buffer","text":"<pre><code>vk_buffer atlas::vk::create_buffer (\n    const vk_buffer_info &amp; p_info\n) \n</code></pre> <p>Returns:</p> <p>new vk_buffer handler </p>"},{"location":"References/namespaceatlas_1_1vk/#function-create_image2d","title":"function create_image2d","text":"<p>Returns vk_image which contains the VkImage and VkImage handlers with image 2D specifications. <pre><code>vk_image atlas::vk::create_image2d (\n    uint32_t p_width,\n    uint32_t p_height,\n    VkFormat p_format,\n    VkImageUsageFlags p_usage,\n    VkMemoryPropertyFlagBits p_property\n) \n</code></pre></p>"},{"location":"References/namespaceatlas_1_1vk/#function-create_image2d_1","title":"function create_image2d","text":"<pre><code>vk_image_handle atlas::vk::create_image2d (\n    const VkDevice &amp; p_driver,\n    const image_extent &amp; p_extent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>p_driver</code> current logical device to associate this image creation to </li> <li><code>p_extent</code> image extent of properties required for creating the image </li> </ul>"},{"location":"References/namespaceatlas_1_1vk/#function-create_image_view","title":"function create_image_view","text":"<pre><code>VkImageView atlas::vk::create_image_view (\n    const VkImage &amp; p_image,\n    VkFormat p_format,\n    VkImageAspectFlags p_aspect_flags\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>p_image</code> is the image handler to create a view handler from </li> <li><code>p_format</code> specify format to create the VkImageView handler from </li> <li><code>p_aspect_flag</code> to specify the data this VkImageView handler will contain </li> </ul>"},{"location":"References/namespaceatlas_1_1vk/#function-create_image_view_1","title":"function create_image_view","text":"<pre><code>VkImageView atlas::vk::create_image_view (\n    const VkDevice &amp; p_driver,\n    VkImage p_image,\n    VkSurfaceFormatKHR p_surface_format,\n    VkImageAspectFlags p_aspect_flags,\n    VkImageViewType p_view_t,\n    uint32_t p_layer_count,\n    uint32_t p_mip_level=1\n) \n</code></pre> <p>Returns:</p> <p>new VkImageView handler object </p> <p>Parameters:</p> <ul> <li><code>p_driver</code> the driver to create the new handler </li> <li><code>p_surface_format</code> specify a surface format to create the VkImageView handler with </li> <li><code>p_aspect_flag</code> to specify what kind of aspect of data this VkImageView will contain </li> <li><code>p_mip_level</code> default to 1; used to set mip levels if required </li> </ul>"},{"location":"References/namespaceatlas_1_1vk/#function-create_sampler","title":"function create_sampler","text":"<pre><code>VkSampler atlas::vk::create_sampler (\n    const vk_filter_range &amp; p_range,\n    VkSamplerAddressMode p_address_mode\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-create_semaphore","title":"function create_semaphore","text":"<pre><code>VkSemaphore atlas::vk::create_semaphore (\n    const VkDevice &amp; p_driver\n) \n</code></pre> <p>Returns:</p> <p>new semaphore handle </p>"},{"location":"References/namespaceatlas_1_1vk/#function-create_single_command_buffer","title":"function create_single_command_buffer","text":"<pre><code>VkCommandBuffer atlas::vk::create_single_command_buffer (\n    const VkCommandPool &amp; p_command_pool\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-create_single_command_pool","title":"function create_single_command_pool","text":"<pre><code>VkCommandPool atlas::vk::create_single_command_pool () \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-create_uniform_buffer","title":"function create_uniform_buffer","text":"<pre><code>vk_buffer atlas::vk::create_uniform_buffer (\n    uint32_t p_size\n) \n</code></pre> <p>Returns:</p> <p>vulkan buffer handler that is initialized as a uniform buffer handler </p>"},{"location":"References/namespaceatlas_1_1vk/#function-end_command_buffer","title":"function end_command_buffer","text":"<pre><code>void atlas::vk::end_command_buffer (\n    const VkCommandBuffer &amp; p_command_buffer\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-free_buffer","title":"function free_buffer","text":"<pre><code>void atlas::vk::free_buffer (\n    const VkDevice &amp; p_driver,\n    vk_buffer &amp; p_buffer\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-free_image","title":"function free_image","text":"<pre><code>void atlas::vk::free_image (\n    const VkDevice &amp; p_driver,\n    vk_image &amp; p_image\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-has_stencil_attachment","title":"function has_stencil_attachment","text":"<p>Validate if the format specified is a stencil attachment. <pre><code>bool atlas::vk::has_stencil_attachment (\n    VkFormat p_format\n) \n</code></pre></p>"},{"location":"References/namespaceatlas_1_1vk/#function-image_memory_barrier","title":"function image_memory_barrier","text":"<pre><code>void atlas::vk::image_memory_barrier (\n    VkCommandBuffer &amp; p_command_buffer,\n    VkImage &amp; p_image,\n    VkFormat p_format,\n    VkImageLayout p_old,\n    VkImageLayout p_new\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-queue_submit","title":"function queue_submit","text":"<pre><code>void atlas::vk::queue_submit (\n    const VkQueue &amp; p_queue_handle,\n    const std::span&lt; VkCommandBuffer &gt; &amp; p_commands\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-select_compatible_present_mode","title":"function select_compatible_present_mode","text":"<pre><code>VkPresentModeKHR atlas::vk::select_compatible_present_mode (\n    const VkPresentModeKHR &amp; p_request,\n    const std::span&lt; VkPresentModeKHR &gt; &amp; p_modes\n) \n</code></pre> <p>Returns:</p> <p><code>VkPresentModeKHR</code> by selecting the current compatiable presentation modes available </p>"},{"location":"References/namespaceatlas_1_1vk/#function-select_images_size","title":"function select_images_size","text":"<pre><code>uint32_t atlas::vk::select_images_size (\n    const VkSurfaceCapabilitiesKHR &amp; p_surface_capabilities\n) \n</code></pre> <p>Returns:</p> <p>the image size based on the capabilities of the vulkan <code>VkSurfaceKHR</code> that is supported </p>"},{"location":"References/namespaceatlas_1_1vk/#function-to_vk_attachment_load","title":"function to_vk_attachment_load","text":"<pre><code>VkAttachmentLoadOp atlas::vk::to_vk_attachment_load (\n    attachment_load p_attachment_type\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-to_vk_attachment_store","title":"function to_vk_attachment_store","text":"<pre><code>VkAttachmentStoreOp atlas::vk::to_vk_attachment_store (\n    const attachment_store &amp; p_attachment_type\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-to_vk_command_buffer_level","title":"function to_vk_command_buffer_level","text":"<p>Conversion function that returns VkCommandBufferLevel. <pre><code>VkCommandBufferLevel atlas::vk::to_vk_command_buffer_level (\n    const command_buffer_levels &amp; p_levels\n) \n</code></pre></p>"},{"location":"References/namespaceatlas_1_1vk/#function-to_vk_descriptor_type","title":"function to_vk_descriptor_type","text":"<pre><code>VkDescriptorType atlas::vk::to_vk_descriptor_type (\n    const buffer &amp; p_type\n) \n</code></pre> <p>Returns:</p> <p>Returns the VkDescriptorType that represents a \"handle\" the shader resource is acecssing </p>"},{"location":"References/namespaceatlas_1_1vk/#function-to_vk_format","title":"function to_vk_format","text":"<p>converts high-level specifications of format to VkFormat <pre><code>VkFormat atlas::vk::to_vk_format (\n    const format &amp; p_format\n) \n</code></pre></p>"},{"location":"References/namespaceatlas_1_1vk/#function-to_vk_image_layout","title":"function to_vk_image_layout","text":"<pre><code>VkImageLayout atlas::vk::to_vk_image_layout (\n    const image_layout &amp; p_layout\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-to_vk_input_rate","title":"function to_vk_input_rate","text":"<pre><code>VkVertexInputRate atlas::vk::to_vk_input_rate (\n    const input_rate &amp; p_input_rate\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-to_vk_pipeline_bind_point","title":"function to_vk_pipeline_bind_point","text":"<pre><code>VkPipelineBindPoint atlas::vk::to_vk_pipeline_bind_point (\n    const pipeline_bind_point &amp; p_bind_point\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-to_vk_sample_count_bits","title":"function to_vk_sample_count_bits","text":"<pre><code>VkSampleCountFlagBits atlas::vk::to_vk_sample_count_bits (\n    const sample_bit &amp; p_sample_count_bit\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-to_vk_shader_stage","title":"function to_vk_shader_stage","text":"<pre><code>VkShaderStageFlags atlas::vk::to_vk_shader_stage (\n    const shader_stage &amp; p_stage\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-to_vk_shader_stage_bits","title":"function to_vk_shader_stage_bits","text":"<pre><code>VkShaderStageFlagBits atlas::vk::to_vk_shader_stage_bits (\n    const shader_stage &amp; p_stage\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-transition_image_layout","title":"function transition_image_layout","text":"<pre><code>void atlas::vk::transition_image_layout (\n    VkImage &amp; p_image,\n    VkFormat p_format,\n    VkImageLayout p_old,\n    VkImageLayout p_new\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-transition_image_layout_1","title":"function transition_image_layout","text":"<pre><code>void atlas::vk::transition_image_layout (\n    VkCommandBuffer &amp; p_command_buffer,\n    VkImage &amp; p_image,\n    VkFormat p_format,\n    VkImageLayout p_old,\n    VkImageLayout p_new\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-vk_check","title":"function vk_check","text":"<pre><code>void atlas::vk::vk_check (\n    const VkResult &amp; p_result,\n    const std::string &amp; p_name,\n    const std::source_location &amp; p_source=std::source_location::current()\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>p_result</code> checks if the result of a vulkan handler was created correctly </li> <li><code>p_name</code> used for debugging of which handler failed </li> <li><code>p_source</code> is the location of the call-site that invoked vk_check </li> </ul>"},{"location":"References/namespaceatlas_1_1vk/#function-vk_check_format","title":"function vk_check_format","text":"<p>Checks for valid <code>VkFormat</code> specified. <pre><code>void atlas::vk::vk_check_format (\n    VkFormat p_format,\n    const char * p_filepath,\n    uint32_t p_line,\n    const char * p_function_name\n) \n</code></pre></p>"},{"location":"References/namespaceatlas_1_1vk/#function-vk_format_to_string","title":"function vk_format_to_string","text":"<pre><code>std::string atlas::vk::vk_format_to_string (\n    VkFormat p_format\n) \n</code></pre> <p>Returns:</p> <p>stringified version of the <code>VkFormat</code> </p>"},{"location":"References/namespaceatlas_1_1vk/#function-vk_present_mode_to_string","title":"function vk_present_mode_to_string","text":"<pre><code>std::string atlas::vk::vk_present_mode_to_string (\n    VkPresentModeKHR p_present_mode\n) \n</code></pre> <p>Returns:</p> <p>stringified version of the <code>VkPresentModeKHR</code> </p>"},{"location":"References/namespaceatlas_1_1vk/#function-write","title":"function write","text":"<p>maps the current buffer handler to some block of memory and the byte size for that chunk <pre><code>void atlas::vk::write (\n    const vk_buffer &amp; p_buffer,\n    const void * p_data,\n    size_t p_size_in_bytes\n) \n</code></pre></p>"},{"location":"References/namespaceatlas_1_1vk/#function-write_1","title":"function write","text":"<p>Maps buffer handler to chunk of data of type, that is std::span&lt;uint32_t&gt;. <pre><code>void atlas::vk::write (\n    const vk_buffer &amp; p_buffer,\n    const std::span&lt; uint32_t &gt; &amp; p_in_buffer\n) \n</code></pre></p>"},{"location":"References/namespaceatlas_1_1vk/#function-write_2","title":"function write","text":"<p>Maps buffer handler to data chunks that contain vertices. <pre><code>void atlas::vk::write (\n    const vk_buffer &amp; p_buffer,\n    const std::span&lt; vertex_input &gt; &amp; p_in_buffer\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/helper_functions.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1camera__ubo/","title":"Struct atlas::vk::camera_ubo","text":"<p>ClassList &gt; atlas &gt; vk &gt; camera_ubo</p> <p>Going to remove this. More...</p> <ul> <li><code>#include &lt;vk_types.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1vk_1_1camera__ubo/#public-attributes","title":"Public Attributes","text":"Type Name glm::mat4 projection   = <code>{ 1.f }</code> glm::mat4 view   = <code>{ 1.f }</code>"},{"location":"References/structatlas_1_1vk_1_1camera__ubo/#detailed-description","title":"Detailed Description","text":"<p>This is being used by descriptor sets and vk_renderer TODO: Modify vk_descriptor_set and vk_renderer and add uniforms.hpp inside renderer/ (dir) for used across vk_renderer and the renderer </p>"},{"location":"References/structatlas_1_1vk_1_1camera__ubo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1camera__ubo/#variable-projection","title":"variable projection","text":"<pre><code>glm::mat4 atlas::vk::camera_ubo::projection;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1camera__ubo/#variable-view","title":"variable view","text":"<pre><code>glm::mat4 atlas::vk::camera_ubo::view;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1command__buffer__settings/","title":"Struct atlas::vk::command_buffer_settings","text":"<p>ClassList &gt; atlas &gt; vk &gt; command_buffer_settings</p> <p>settings for specifying command buffers to construct More...</p> <ul> <li><code>#include &lt;vk_types.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1vk_1_1command__buffer__settings/#public-attributes","title":"Public Attributes","text":"Type Name command_buffer_levels levels VkCommandPoolCreateFlagBits pool_flag uint32_t queue_index   = <code>-1</code>"},{"location":"References/structatlas_1_1vk_1_1command__buffer__settings/#public-functions","title":"Public Functions","text":"Type Name command_buffer_settings (uint32_t p_queue_family, const command_buffer_levels &amp; p_levels, const VkCommandPoolCreateFlagBits &amp; p_pool_flags)"},{"location":"References/structatlas_1_1vk_1_1command__buffer__settings/#detailed-description","title":"Detailed Description","text":"<p>Parameters:</p> <ul> <li><code>Levels</code> are for specifying the kind of command buffer being constructed</li> </ul> <p>queue_index specifies the queue family associated with this command buffer</p> <p>pool_flag in the context of the command buffers are used to control memory allocation behavior within the command buffer pool to allocate</p> <p>Parameters:</p> <ul> <li><code>VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</code> Indicates command buffers allocated from pool will be short-lived, meaning they'll reset or freed quickly </li> <li><code>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</code> Allows individual command buffers allocated from the pool to be reset to their initial state using <code>vkResetCommandBuffer</code> </li> <li><code>VK_COMMAND_POOL_CREATE_PROTECTED_BIT</code> Designates command buffers allocated from the pool as protective command buffers, implying they are stored in protected memory and access to them is restricted to authorized operations </li> </ul>"},{"location":"References/structatlas_1_1vk_1_1command__buffer__settings/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1command__buffer__settings/#variable-levels","title":"variable levels","text":"<pre><code>command_buffer_levels atlas::vk::command_buffer_settings::levels;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1command__buffer__settings/#variable-pool_flag","title":"variable pool_flag","text":"<pre><code>VkCommandPoolCreateFlagBits atlas::vk::command_buffer_settings::pool_flag;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1command__buffer__settings/#variable-queue_index","title":"variable queue_index","text":"<pre><code>uint32_t atlas::vk::command_buffer_settings::queue_index;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1command__buffer__settings/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1command__buffer__settings/#function-command_buffer_settings","title":"function command_buffer_settings","text":"<pre><code>inline atlas::vk::command_buffer_settings::command_buffer_settings (\n    uint32_t p_queue_family,\n    const command_buffer_levels &amp; p_levels,\n    const VkCommandPoolCreateFlagBits &amp; p_pool_flags\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1descriptor__binding__entry/","title":"Struct atlas::vk::descriptor_binding_entry","text":"<p>ClassList &gt; atlas &gt; vk &gt; descriptor_binding_entry</p>"},{"location":"References/structatlas_1_1vk_1_1descriptor__binding__entry/#public-attributes","title":"Public Attributes","text":"Type Name descriptor_binding_point binding_point uint32_t descriptor_count buffer type"},{"location":"References/structatlas_1_1vk_1_1descriptor__binding__entry/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1descriptor__binding__entry/#variable-binding_point","title":"variable binding_point","text":"<pre><code>descriptor_binding_point atlas::vk::descriptor_binding_entry::binding_point;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1descriptor__binding__entry/#variable-descriptor_count","title":"variable descriptor_count","text":"<pre><code>uint32_t atlas::vk::descriptor_binding_entry::descriptor_count;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1descriptor__binding__entry/#variable-type","title":"variable type","text":"<pre><code>buffer atlas::vk::descriptor_binding_entry::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1descriptor__binding__point/","title":"Struct atlas::vk::descriptor_binding_point","text":"<p>ClassList &gt; atlas &gt; vk &gt; descriptor_binding_point</p>"},{"location":"References/structatlas_1_1vk_1_1descriptor__binding__point/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t binding shader_stage stage"},{"location":"References/structatlas_1_1vk_1_1descriptor__binding__point/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1descriptor__binding__point/#variable-binding","title":"variable binding","text":"<pre><code>uint32_t atlas::vk::descriptor_binding_point::binding;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1descriptor__binding__point/#variable-stage","title":"variable stage","text":"<pre><code>shader_stage atlas::vk::descriptor_binding_point::stage;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set/","title":"Class atlas::vk::descriptor_set","text":"<p>ClassList &gt; atlas &gt; vk &gt; descriptor_set</p>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set/#public-functions","title":"Public Functions","text":"Type Name void bind (const VkCommandBuffer &amp; p_current, uint32_t p_frame_index, const VkPipelineLayout &amp;)  descriptor_set () = default descriptor_set (const uint32_t &amp; p_set_slot, const descriptor_set_layout &amp; p_entry)  void destroy ()  VkDescriptorSetLayout get_layout () const void update (const std::span&lt; vk_uniform_buffer &gt; &amp; p_uniforms, const std::span&lt; texture &gt; &amp; p_textures) Updating descriptors with uniforms/textures specified. void update (const std::span&lt; vk_uniform_buffer &gt; &amp; p_uniforms)  ~descriptor_set () = default"},{"location":"References/classatlas_1_1vk_1_1descriptor__set/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1descriptor__set/#function-bind","title":"function bind","text":"<pre><code>void atlas::vk::descriptor_set::bind (\n    const VkCommandBuffer &amp; p_current,\n    uint32_t p_frame_index,\n    const VkPipelineLayout &amp;\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set/#function-descriptor_set-12","title":"function descriptor_set [1/2]","text":"<pre><code>atlas::vk::descriptor_set::descriptor_set () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set/#function-descriptor_set-22","title":"function descriptor_set [2/2]","text":"<pre><code>atlas::vk::descriptor_set::descriptor_set (\n    const uint32_t &amp; p_set_slot,\n    const descriptor_set_layout &amp; p_entry\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>p_set_slot</code> is the slot index to bind this descriptor set Tells vulkan when binding this descriptor set where the resources location for shader to know where to access the resources binded </li> </ul>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set/#function-destroy","title":"function destroy","text":"<pre><code>void atlas::vk::descriptor_set::destroy () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set/#function-get_layout","title":"function get_layout","text":"<pre><code>inline VkDescriptorSetLayout atlas::vk::descriptor_set::get_layout () const\n</code></pre> <p>Something to note for myself The vk_renderer will actually store in and cache vk::mesh into a map&lt;string, vk::mesh&gt; Each mesh will actually store the actual geometry data and apply a per-pipeline-info on them This update_mesh would be invoked like(m_uniformss, m_cached_meshes[p_entity.name()]); Where we invoke the mesh we want to update with the following invokation call here vk::mesh will also contain the matrices such as glm::mat4 that is the model matrix </p>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set/#function-update-12","title":"function update [1/2]","text":"<p>Updating descriptors with uniforms/textures specified. <pre><code>void atlas::vk::descriptor_set::update (\n    const std::span&lt; vk_uniform_buffer &gt; &amp; p_uniforms,\n    const std::span&lt; texture &gt; &amp; p_textures\n) \n</code></pre></p>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set/#function-update-22","title":"function update [2/2]","text":"<pre><code>void atlas::vk::descriptor_set::update (\n    const std::span&lt; vk_uniform_buffer &gt; &amp; p_uniforms\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set/#function-descriptor_set","title":"function ~descriptor_set","text":"<pre><code>atlas::vk::descriptor_set::~descriptor_set () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_descriptor_set.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1descriptor__set__layout/","title":"Struct atlas::vk::descriptor_set_layout","text":"<p>ClassList &gt; atlas &gt; vk &gt; descriptor_set_layout</p>"},{"location":"References/structatlas_1_1vk_1_1descriptor__set__layout/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t allocate_count   = <code>0</code> std::span&lt; descriptor_binding_entry &gt; entry uint32_t max_sets   = <code>0</code> uint32_t size_bytes   = <code>0</code>"},{"location":"References/structatlas_1_1vk_1_1descriptor__set__layout/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1descriptor__set__layout/#variable-allocate_count","title":"variable allocate_count","text":"<pre><code>uint32_t atlas::vk::descriptor_set_layout::allocate_count;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1descriptor__set__layout/#variable-entry","title":"variable entry","text":"<pre><code>std::span&lt;descriptor_binding_entry&gt; atlas::vk::descriptor_set_layout::entry;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1descriptor__set__layout/#variable-max_sets","title":"variable max_sets","text":"<pre><code>uint32_t atlas::vk::descriptor_set_layout::max_sets;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1descriptor__set__layout/#variable-size_bytes","title":"variable size_bytes","text":"<pre><code>uint32_t atlas::vk::descriptor_set_layout::size_bytes;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1global__ubo/","title":"Struct atlas::vk::global_ubo","text":"<p>ClassList &gt; atlas &gt; vk &gt; global_ubo</p> <p>Just for testing purposes for sending this struct over to the shader. </p> <ul> <li><code>#include &lt;vk_types.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1vk_1_1global__ubo/#public-attributes","title":"Public Attributes","text":"Type Name glm::mat4 mvp   = <code>{ 1.f }</code>"},{"location":"References/structatlas_1_1vk_1_1global__ubo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1global__ubo/#variable-mvp","title":"variable mvp","text":"<pre><code>glm::mat4 atlas::vk::global_ubo::mvp;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1hud__data/","title":"Struct atlas::vk::hud_data","text":"<p>ClassList &gt; atlas &gt; vk &gt; hud_data</p>"},{"location":"References/structatlas_1_1vk_1_1hud__data/#public-attributes","title":"Public Attributes","text":"Type Name std::string currentWeapon   = <code>\"Assault Rifle\"</code> float fps   = <code>0.0f</code> float playerHealth   = <code>100.0f</code> int playerScore   = <code>0</code>"},{"location":"References/structatlas_1_1vk_1_1hud__data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1hud__data/#variable-currentweapon","title":"variable currentWeapon","text":"<pre><code>std::string atlas::vk::hud_data::currentWeapon;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1hud__data/#variable-fps","title":"variable fps","text":"<pre><code>float atlas::vk::hud_data::fps;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1hud__data/#variable-playerhealth","title":"variable playerHealth","text":"<pre><code>float atlas::vk::hud_data::playerHealth;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1hud__data/#variable-playerscore","title":"variable playerScore","text":"<pre><code>int atlas::vk::hud_data::playerScore;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_imgui.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1image__extent/","title":"Struct atlas::vk::image_extent","text":"<p>ClassList &gt; atlas &gt; vk &gt; image_extent</p>"},{"location":"References/structatlas_1_1vk_1_1image__extent/#public-attributes","title":"Public Attributes","text":"Type Name VkDeviceMemory device_memory uint32_t height uint32_t mip_level   = <code>1</code> uint32_t width"},{"location":"References/structatlas_1_1vk_1_1image__extent/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1image__extent/#variable-device_memory","title":"variable device_memory","text":"<pre><code>VkDeviceMemory atlas::vk::image_extent::device_memory;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1image__extent/#variable-height","title":"variable height","text":"<pre><code>uint32_t atlas::vk::image_extent::height;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1image__extent/#variable-mip_level","title":"variable mip_level","text":"<pre><code>uint32_t atlas::vk::image_extent::mip_level;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1image__extent/#variable-width","title":"variable width","text":"<pre><code>uint32_t atlas::vk::image_extent::width;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1imgui__context/","title":"Class atlas::vk::imgui_context","text":"<p>ClassList &gt; atlas &gt; vk &gt; imgui_context</p>"},{"location":"References/classatlas_1_1vk_1_1imgui__context/#public-functions","title":"Public Functions","text":"Type Name void begin (const VkCommandBuffer &amp; p_current, const uint32_t &amp; p_current_frame_idx)  void draw_hud (const hud_data &amp; p_test, const window_settings &amp; p_settings)  void end ()  imgui_context () = default imgui_context (GLFWwindow * p_window_handler, const vk_swapchain &amp; p_current_swapchain_handler, const VkRenderPass &amp; p_current_renderpass)  void recreate (GLFWwindow * p_window_handler, const uint32_t &amp; p_image_size, const VkRenderPass &amp; p_current_renderpass)"},{"location":"References/classatlas_1_1vk_1_1imgui__context/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1imgui__context/#function-begin","title":"function begin","text":"<pre><code>void atlas::vk::imgui_context::begin (\n    const VkCommandBuffer &amp; p_current,\n    const uint32_t &amp; p_current_frame_idx\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1imgui__context/#function-draw_hud","title":"function draw_hud","text":"<pre><code>void atlas::vk::imgui_context::draw_hud (\n    const hud_data &amp; p_test,\n    const window_settings &amp; p_settings\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1imgui__context/#function-end","title":"function end","text":"<pre><code>void atlas::vk::imgui_context::end () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1imgui__context/#function-imgui_context-12","title":"function imgui_context [1/2]","text":"<pre><code>atlas::vk::imgui_context::imgui_context () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1imgui__context/#function-imgui_context-22","title":"function imgui_context [2/2]","text":"<pre><code>atlas::vk::imgui_context::imgui_context (\n    GLFWwindow * p_window_handler,\n    const vk_swapchain &amp; p_current_swapchain_handler,\n    const VkRenderPass &amp; p_current_renderpass\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1imgui__context/#function-recreate","title":"function recreate","text":"<pre><code>void atlas::vk::imgui_context::recreate (\n    GLFWwindow * p_window_handler,\n    const uint32_t &amp; p_image_size,\n    const VkRenderPass &amp; p_current_renderpass\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_imgui.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1material__uniform/","title":"Struct atlas::vk::material_uniform","text":"<p>ClassList &gt; atlas &gt; vk &gt; material_uniform</p> <p>material is going to define properties about how a scene object itself gets rendered </p> <ul> <li><code>#include &lt;vk_types.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1vk_1_1material__uniform/#public-attributes","title":"Public Attributes","text":"Type Name glm::vec4 color   = <code>{ 1.f }</code> glm::mat4 model   = <code>{ 1.f }</code>"},{"location":"References/structatlas_1_1vk_1_1material__uniform/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1material__uniform/#variable-color","title":"variable color","text":"<pre><code>glm::vec4 atlas::vk::material_uniform::color;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1material__uniform/#variable-model","title":"variable model","text":"<pre><code>glm::mat4 atlas::vk::material_uniform::model;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1mesh/","title":"Class atlas::vk::mesh","text":"<p>ClassList &gt; atlas &gt; vk &gt; mesh</p> <p>mesh class specifically defined with vulkan implementations for specific primitives TODO: Whenever we load in a texture that will be laucnhed asyncronously More...</p> <ul> <li><code>#include &lt;mesh.hpp&gt;</code></li> </ul>"},{"location":"References/classatlas_1_1vk_1_1mesh/#public-functions","title":"Public Functions","text":"Type Name void add_texture (const std::filesystem::path &amp; p_path) Loading single texture with specified std::filesystem::path. void destroy ()  void draw (const VkCommandBuffer &amp; p_command_buffer)  void initialize_uniforms (uint32_t p_size_bytes_ubo)  bool loaded () const vk_uniform_buffer material_ubo () const mesh () = default mesh (const std::span&lt; vertex_input &gt; &amp; p_vertices, const std::span&lt; uint32_t &gt; &amp; p_indices)  mesh (const std::filesystem::path &amp; p_filename)  std::span&lt; texture &gt; read_textures ()  void reload_mesh (const std::filesystem::path &amp; p_path) Reload mesh vertices and indices when requested. void update_uniform (const material_uniform &amp; p_material_ubo)"},{"location":"References/classatlas_1_1vk_1_1mesh/#detailed-description","title":"Detailed Description","text":"<p>mesh class will contain metadata needed by vulkan specifications Ways to communicate through vulkan by only supplying information needed to update this mesh</p> <p>Represents a renderable object  supporting various material types, etc TODO - For now we have a map&lt;name: string, material_source&gt;, this should be expanded to a proper material system for blending various materials </p>"},{"location":"References/classatlas_1_1vk_1_1mesh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1mesh/#function-add_texture","title":"function add_texture","text":"<p>Loading single texture with specified std::filesystem::path. <pre><code>void atlas::vk::mesh::add_texture (\n    const std::filesystem::path &amp; p_path\n) \n</code></pre></p>"},{"location":"References/classatlas_1_1vk_1_1mesh/#function-destroy","title":"function destroy","text":"<pre><code>void atlas::vk::mesh::destroy () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1mesh/#function-draw","title":"function draw","text":"<pre><code>void atlas::vk::mesh::draw (\n    const VkCommandBuffer &amp; p_command_buffer\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1mesh/#function-initialize_uniforms","title":"function initialize_uniforms","text":"<pre><code>void atlas::vk::mesh::initialize_uniforms (\n    uint32_t p_size_bytes_ubo\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1mesh/#function-loaded","title":"function loaded","text":"<pre><code>inline bool atlas::vk::mesh::loaded () const\n</code></pre> <p>Returns:</p> <p>true if mesh geometry model loaded succesfully </p>"},{"location":"References/classatlas_1_1vk_1_1mesh/#function-material_ubo","title":"function material_ubo","text":"<pre><code>inline vk_uniform_buffer atlas::vk::mesh::material_ubo () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1mesh/#function-mesh-13","title":"function mesh [1/3]","text":"<pre><code>atlas::vk::mesh::mesh () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1mesh/#function-mesh-23","title":"function mesh [2/3]","text":"<pre><code>atlas::vk::mesh::mesh (\n    const std::span&lt; vertex_input &gt; &amp; p_vertices,\n    const std::span&lt; uint32_t &gt; &amp; p_indices\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1mesh/#function-mesh-33","title":"function mesh [3/3]","text":"<pre><code>atlas::vk::mesh::mesh (\n    const std::filesystem::path &amp; p_filename\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1mesh/#function-read_textures","title":"function read_textures","text":"<pre><code>inline std::span&lt; texture &gt; atlas::vk::mesh::read_textures () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1mesh/#function-reload_mesh","title":"function reload_mesh","text":"<p>Reload mesh vertices and indices when requested. <pre><code>void atlas::vk::mesh::reload_mesh (\n    const std::filesystem::path &amp; p_path\n) \n</code></pre></p>"},{"location":"References/classatlas_1_1vk_1_1mesh/#function-update_uniform","title":"function update_uniform","text":"<pre><code>void atlas::vk::mesh::update_uniform (\n    const material_uniform &amp; p_material_ubo\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/mesh.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1renderpass__attachment/","title":"Struct atlas::vk::renderpass_attachment","text":"<p>ClassList &gt; atlas &gt; vk &gt; renderpass_attachment</p>"},{"location":"References/structatlas_1_1vk_1_1renderpass__attachment/#public-attributes","title":"Public Attributes","text":"Type Name image_layout finalize format format image_layout initial image_layout layout attachment_load load sample_bit sample_count attachment_load stencil_load attachment_store stencil_store attachment_store store renderpass_type type"},{"location":"References/structatlas_1_1vk_1_1renderpass__attachment/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1renderpass__attachment/#variable-finalize","title":"variable finalize","text":"<pre><code>image_layout atlas::vk::renderpass_attachment::finalize;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1renderpass__attachment/#variable-format","title":"variable format","text":"<pre><code>format atlas::vk::renderpass_attachment::format;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1renderpass__attachment/#variable-initial","title":"variable initial","text":"<pre><code>image_layout atlas::vk::renderpass_attachment::initial;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1renderpass__attachment/#variable-layout","title":"variable layout","text":"<pre><code>image_layout atlas::vk::renderpass_attachment::layout;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1renderpass__attachment/#variable-load","title":"variable load","text":"<pre><code>attachment_load atlas::vk::renderpass_attachment::load;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1renderpass__attachment/#variable-sample_count","title":"variable sample_count","text":"<pre><code>sample_bit atlas::vk::renderpass_attachment::sample_count;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1renderpass__attachment/#variable-stencil_load","title":"variable stencil_load","text":"<pre><code>attachment_load atlas::vk::renderpass_attachment::stencil_load;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1renderpass__attachment/#variable-stencil_store","title":"variable stencil_store","text":"<pre><code>attachment_store atlas::vk::renderpass_attachment::stencil_store;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1renderpass__attachment/#variable-store","title":"variable store","text":"<pre><code>attachment_store atlas::vk::renderpass_attachment::store;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1renderpass__attachment/#variable-type","title":"variable type","text":"<pre><code>renderpass_type atlas::vk::renderpass_attachment::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1renderpass__options/","title":"Struct atlas::vk::renderpass_options","text":"<p>ClassList &gt; atlas &gt; vk &gt; renderpass_options</p>"},{"location":"References/structatlas_1_1vk_1_1renderpass__options/#public-attributes","title":"Public Attributes","text":"Type Name std::span&lt; VkClearColorValue &gt; clear_values   = <code>{}</code> std::span&lt; renderpass_attachment &gt; color_attachments   = <code>{}</code> std::span&lt; renderpass_attachment &gt; depth_attachments   = <code>{}</code>"},{"location":"References/structatlas_1_1vk_1_1renderpass__options/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1renderpass__options/#variable-clear_values","title":"variable clear_values","text":"<pre><code>std::span&lt;VkClearColorValue&gt; atlas::vk::renderpass_options::clear_values;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1renderpass__options/#variable-color_attachments","title":"variable color_attachments","text":"<pre><code>std::span&lt;renderpass_attachment&gt; atlas::vk::renderpass_options::color_attachments;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1renderpass__options/#variable-depth_attachments","title":"variable depth_attachments","text":"<pre><code>std::span&lt;renderpass_attachment&gt; atlas::vk::renderpass_options::depth_attachments;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1shader__info/","title":"Struct atlas::vk::shader_info","text":"<p>ClassList &gt; atlas &gt; vk &gt; shader_info</p>"},{"location":"References/structatlas_1_1vk_1_1shader__info/#public-attributes","title":"Public Attributes","text":"Type Name std::string source   = <code>\"\"</code> shader_stage stage   = <code>undefined</code>"},{"location":"References/structatlas_1_1vk_1_1shader__info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1shader__info/#variable-source","title":"variable source","text":"<pre><code>std::string atlas::vk::shader_info::source;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1shader__info/#variable-stage","title":"variable stage","text":"<pre><code>shader_stage atlas::vk::shader_info::stage;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1surface__properties/","title":"Struct atlas::vk::surface_properties","text":"<p>ClassList &gt; atlas &gt; vk &gt; surface_properties</p>"},{"location":"References/structatlas_1_1vk_1_1surface__properties/#public-attributes","title":"Public Attributes","text":"Type Name VkSurfaceCapabilitiesKHR surface_capabilities VkSurfaceFormatKHR surface_format"},{"location":"References/structatlas_1_1vk_1_1surface__properties/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1surface__properties/#variable-surface_capabilities","title":"variable surface_capabilities","text":"<pre><code>VkSurfaceCapabilitiesKHR atlas::vk::surface_properties::surface_capabilities;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1surface__properties/#variable-surface_format","title":"variable surface_format","text":"<pre><code>VkSurfaceFormatKHR atlas::vk::surface_properties::surface_format;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_physical_driver.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1texture/","title":"Class atlas::vk::texture","text":"<p>ClassList &gt; atlas &gt; vk &gt; texture</p>"},{"location":"References/classatlas_1_1vk_1_1texture/#public-functions","title":"Public Functions","text":"Type Name void create (const std::filesystem::path &amp; p_path)  vk_image data () const void destroy ()  uint32_t height () const VkImage image () const VkImageView image_view () const bool loaded () const VkSampler sampler () const texture () = default texture (const texture_extent &amp; p_extent)  texture (const std::filesystem::path &amp; p_filepath)  uint32_t width () const"},{"location":"References/classatlas_1_1vk_1_1texture/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1texture/#function-create","title":"function create","text":"<pre><code>void atlas::vk::texture::create (\n    const std::filesystem::path &amp; p_path\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1texture/#function-data","title":"function data","text":"<pre><code>inline vk_image atlas::vk::texture::data () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1texture/#function-destroy","title":"function destroy","text":"<pre><code>void atlas::vk::texture::destroy () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1texture/#function-height","title":"function height","text":"<pre><code>uint32_t atlas::vk::texture::height () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1texture/#function-image","title":"function image","text":"<pre><code>inline VkImage atlas::vk::texture::image () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1texture/#function-image_view","title":"function image_view","text":"<pre><code>inline VkImageView atlas::vk::texture::image_view () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1texture/#function-loaded","title":"function loaded","text":"<pre><code>inline bool atlas::vk::texture::loaded () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1texture/#function-sampler","title":"function sampler","text":"<pre><code>inline VkSampler atlas::vk::texture::sampler () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1texture/#function-texture-13","title":"function texture [1/3]","text":"<pre><code>atlas::vk::texture::texture () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1texture/#function-texture-23","title":"function texture [2/3]","text":"<pre><code>atlas::vk::texture::texture (\n    const texture_extent &amp; p_extent\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1texture/#function-texture-33","title":"function texture [3/3]","text":"<pre><code>atlas::vk::texture::texture (\n    const std::filesystem::path &amp; p_filepath\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1texture/#function-width","title":"function width","text":"<pre><code>uint32_t atlas::vk::texture::width () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_texture.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1texture__extent/","title":"Struct atlas::vk::texture_extent","text":"<p>ClassList &gt; atlas &gt; vk &gt; texture_extent</p>"},{"location":"References/structatlas_1_1vk_1_1texture__extent/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t height uint32_t width"},{"location":"References/structatlas_1_1vk_1_1texture__extent/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1texture__extent/#variable-height","title":"variable height","text":"<pre><code>uint32_t atlas::vk::texture_extent::height;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1texture__extent/#variable-width","title":"variable width","text":"<pre><code>uint32_t atlas::vk::texture_extent::width;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_texture.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1texture__properties/","title":"Struct atlas::vk::texture_properties","text":"<p>ClassList &gt; atlas &gt; vk &gt; texture_properties</p>"},{"location":"References/structatlas_1_1vk_1_1texture__properties/#public-attributes","title":"Public Attributes","text":"Type Name VkFormat format uint32_t height VkMemoryPropertyFlagBits property VkImageUsageFlagBits usage uint32_t width"},{"location":"References/structatlas_1_1vk_1_1texture__properties/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1texture__properties/#variable-format","title":"variable format","text":"<pre><code>VkFormat atlas::vk::texture_properties::format;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1texture__properties/#variable-height","title":"variable height","text":"<pre><code>uint32_t atlas::vk::texture_properties::height;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1texture__properties/#variable-property","title":"variable property","text":"<pre><code>VkMemoryPropertyFlagBits atlas::vk::texture_properties::property;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1texture__properties/#variable-usage","title":"variable usage","text":"<pre><code>VkImageUsageFlagBits atlas::vk::texture_properties::usage;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1texture__properties/#variable-width","title":"variable width","text":"<pre><code>uint32_t atlas::vk::texture_properties::width;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1vertex__attribute/","title":"Struct atlas::vk::vertex_attribute","text":"<p>ClassList &gt; atlas &gt; vk &gt; vertex_attribute</p>"},{"location":"References/structatlas_1_1vk_1_1vertex__attribute/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t binding std::span&lt; vertex_attribute_entry &gt; entries input_rate input_rate uint32_t stride"},{"location":"References/structatlas_1_1vk_1_1vertex__attribute/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1vertex__attribute/#variable-binding","title":"variable binding","text":"<pre><code>uint32_t atlas::vk::vertex_attribute::binding;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vertex__attribute/#variable-entries","title":"variable entries","text":"<pre><code>std::span&lt;vertex_attribute_entry&gt; atlas::vk::vertex_attribute::entries;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vertex__attribute/#variable-input_rate","title":"variable input_rate","text":"<pre><code>input_rate atlas::vk::vertex_attribute::input_rate;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vertex__attribute/#variable-stride","title":"variable stride","text":"<pre><code>uint32_t atlas::vk::vertex_attribute::stride;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1vertex__attribute__entry/","title":"Struct atlas::vk::vertex_attribute_entry","text":"<p>ClassList &gt; atlas &gt; vk &gt; vertex_attribute_entry</p>"},{"location":"References/structatlas_1_1vk_1_1vertex__attribute__entry/#public-attributes","title":"Public Attributes","text":"Type Name format format uint32_t location uint32_t stride"},{"location":"References/structatlas_1_1vk_1_1vertex__attribute__entry/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1vertex__attribute__entry/#variable-format","title":"variable format","text":"<pre><code>format atlas::vk::vertex_attribute_entry::format;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vertex__attribute__entry/#variable-location","title":"variable location","text":"<pre><code>uint32_t atlas::vk::vertex_attribute_entry::location;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vertex__attribute__entry/#variable-stride","title":"variable stride","text":"<pre><code>uint32_t atlas::vk::vertex_attribute_entry::stride;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1vertex__input/","title":"Struct atlas::vk::vertex_input","text":"<p>ClassList &gt; atlas &gt; vk &gt; vertex_input</p>"},{"location":"References/structatlas_1_1vk_1_1vertex__input/#public-attributes","title":"Public Attributes","text":"Type Name glm::vec3 color glm::vec3 normals glm::vec3 position glm::vec2 uv"},{"location":"References/structatlas_1_1vk_1_1vertex__input/#public-functions","title":"Public Functions","text":"Type Name bool operator== (const vertex_input &amp; other) const"},{"location":"References/structatlas_1_1vk_1_1vertex__input/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1vertex__input/#variable-color","title":"variable color","text":"<pre><code>glm::vec3 atlas::vk::vertex_input::color;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vertex__input/#variable-normals","title":"variable normals","text":"<pre><code>glm::vec3 atlas::vk::vertex_input::normals;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vertex__input/#variable-position","title":"variable position","text":"<pre><code>glm::vec3 atlas::vk::vertex_input::position;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vertex__input/#variable-uv","title":"variable uv","text":"<pre><code>glm::vec2 atlas::vk::vertex_input::uv;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vertex__input/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1vertex__input/#function-operator","title":"function operator==","text":"<pre><code>inline bool atlas::vk::vertex_input::operator== (\n    const vertex_input &amp; other\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1vk__buffer/","title":"Struct atlas::vk::vk_buffer","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_buffer</p> <p>vulkan buffer struct to define the handlers and memory specifications required for buffer handlers in vulkan </p> <ul> <li><code>#include &lt;vk_types.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1vk_1_1vk__buffer/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t allocation_size   = <code>0</code> VkDeviceMemory device_memory   = <code>nullptr</code> VkBuffer handler   = <code>nullptr</code>"},{"location":"References/structatlas_1_1vk_1_1vk__buffer/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1vk__buffer/#variable-allocation_size","title":"variable allocation_size","text":"<pre><code>uint32_t atlas::vk::vk_buffer::allocation_size;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__buffer/#variable-device_memory","title":"variable device_memory","text":"<pre><code>VkDeviceMemory atlas::vk::vk_buffer::device_memory;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__buffer/#variable-handler","title":"variable handler","text":"<pre><code>VkBuffer atlas::vk::vk_buffer::handler;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1vk__buffer__info/","title":"Struct atlas::vk::vk_buffer_info","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_buffer_info</p> <p>Specifications of the vulkan buffer handlers and the use and memory bits associated with the buffer handlers. </p> <ul> <li><code>#include &lt;vk_types.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1vk_1_1vk__buffer__info/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t device_size   = <code>0</code> VkMemoryPropertyFlags memory_property_flag VkBufferUsageFlags usage"},{"location":"References/structatlas_1_1vk_1_1vk__buffer__info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1vk__buffer__info/#variable-device_size","title":"variable device_size","text":"<pre><code>uint32_t atlas::vk::vk_buffer_info::device_size;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__buffer__info/#variable-memory_property_flag","title":"variable memory_property_flag","text":"<pre><code>VkMemoryPropertyFlags atlas::vk::vk_buffer_info::memory_property_flag;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__buffer__info/#variable-usage","title":"variable usage","text":"<pre><code>VkBufferUsageFlags atlas::vk::vk_buffer_info::usage;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__command__buffer/","title":"Class atlas::vk::vk_command_buffer","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_command_buffer</p> <p>Vulkan Command Buffers. More...</p> <ul> <li><code>#include &lt;vk_command_buffer.hpp&gt;</code></li> </ul>"},{"location":"References/classatlas_1_1vk_1_1vk__command__buffer/#public-functions","title":"Public Functions","text":"Type Name void begin (const VkCommandBufferUsageFlags &amp; p_usage_flags) Indication when for this command buffer to start recording (writing) commands to this command buffer. void destroy () API for explicitly invoking cleanup on the command buffer. void end () Indication when the command buffer to stop recording (write) commands to this buffer. bool is_valid () constEnable to check for command buffers if they are valid. operator VkCommandBuffer () const operator VkCommandBuffer ()  vk_command_buffer () = default vk_command_buffer (const command_buffer_settings &amp; p_settings) Constructs new command buffer."},{"location":"References/classatlas_1_1vk_1_1vk__command__buffer/#detailed-description","title":"Detailed Description","text":"<p>Use this to create a command buffer according to vulkan specifications</p> <p>vulkan command buffer is how vulkan submits commands specifically directly or indirectly to the GPU via <code>vkQueueSubmit</code></p> <p>Command buffers in vulkan only know about the queue family they are associated with, their primary flag, and allocation operation associated with. </p>"},{"location":"References/classatlas_1_1vk_1_1vk__command__buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__command__buffer/#function-begin","title":"function begin","text":"<p>Indication when for this command buffer to start recording (writing) commands to this command buffer. <pre><code>void atlas::vk::vk_command_buffer::begin (\n    const VkCommandBufferUsageFlags &amp; p_usage_flags\n) \n</code></pre></p>"},{"location":"References/classatlas_1_1vk_1_1vk__command__buffer/#function-destroy","title":"function destroy","text":"<p>API for explicitly invoking cleanup on the command buffer. <pre><code>void atlas::vk::vk_command_buffer::destroy () \n</code></pre></p>"},{"location":"References/classatlas_1_1vk_1_1vk__command__buffer/#function-end","title":"function end","text":"<p>Indication when the command buffer to stop recording (write) commands to this buffer. <pre><code>void atlas::vk::vk_command_buffer::end () \n</code></pre></p>"},{"location":"References/classatlas_1_1vk_1_1vk__command__buffer/#function-is_valid","title":"function is_valid","text":"<p>Enable to check for command buffers if they are valid. <pre><code>inline bool atlas::vk::vk_command_buffer::is_valid () const\n</code></pre></p>"},{"location":"References/classatlas_1_1vk_1_1vk__command__buffer/#function-operator-vkcommandbuffer-12","title":"function operator VkCommandBuffer [1/2]","text":"<pre><code>inline atlas::vk::vk_command_buffer::operator VkCommandBuffer () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__command__buffer/#function-operator-vkcommandbuffer-22","title":"function operator VkCommandBuffer [2/2]","text":"<pre><code>inline atlas::vk::vk_command_buffer::operator VkCommandBuffer () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__command__buffer/#function-vk_command_buffer-12","title":"function vk_command_buffer [1/2]","text":"<pre><code>atlas::vk::vk_command_buffer::vk_command_buffer () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__command__buffer/#function-vk_command_buffer-22","title":"function vk_command_buffer [2/2]","text":"<p>Constructs new command buffer. <pre><code>atlas::vk::vk_command_buffer::vk_command_buffer (\n    const command_buffer_settings &amp; p_settings\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_command_buffer.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__context/","title":"Class atlas::vk::vk_context","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_context</p> <p>Inherits the following classes: atlas::graphics_context</p>"},{"location":"References/classatlas_1_1vk_1_1vk__context/#public-functions","title":"Public Functions","text":"Type Name vk_context (const std::string &amp; p_tag)"},{"location":"References/classatlas_1_1vk_1_1vk__context/#public-functions-inherited-from-atlasgraphics_context","title":"Public Functions inherited from atlas::graphics_context","text":"<p>See atlas::graphics_context</p> Type Name void destroy ()  virtual ~graphics_context () = default"},{"location":"References/classatlas_1_1vk_1_1vk__context/#public-static-functions","title":"Public Static Functions","text":"Type Name vk_driver driver_context ()  VkInstance handler ()  vk_physical_driver physical_driver ()  void submit_resource_free (std::function&lt; void()&gt; &amp;&amp; p_resource)"},{"location":"References/classatlas_1_1vk_1_1vk__context/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__context/#function-vk_context","title":"function vk_context","text":"<pre><code>atlas::vk::vk_context::vk_context (\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__context/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__context/#function-driver_context","title":"function driver_context","text":"<pre><code>static inline vk_driver atlas::vk::vk_context::driver_context () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__context/#function-handler","title":"function handler","text":"<pre><code>static VkInstance atlas::vk::vk_context::handler () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__context/#function-physical_driver","title":"function physical_driver","text":"<pre><code>static inline vk_physical_driver atlas::vk::vk_context::physical_driver () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__context/#function-submit_resource_free","title":"function submit_resource_free","text":"<pre><code>static void atlas::vk::vk_context::submit_resource_free (\n    std::function&lt; void()&gt; &amp;&amp; p_resource\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_context.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/","title":"Class atlas::vk::vk_driver","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_driver</p> <p>vulkan implementation of extracting a logical device More...</p> <ul> <li><code>#include &lt;vk_driver.hpp&gt;</code></li> </ul>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#public-functions","title":"Public Functions","text":"Type Name VkFormat depth_format () const void destroy ()  VkQueue get_queue (const vk_queue_options &amp; p_present_queue)  VkQueue graphics_queue () const operator VkDevice () const operator VkDevice ()  uint32_t select_memory_type (uint32_t p_type_filter, VkMemoryPropertyFlags p_property_flag)  vk_driver () = default vk_driver (const vk_physical_driver &amp; p_physical)  ~vk_driver () = default"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#detailed-description","title":"Detailed Description","text":"<p>TODO  Implement a device manager for managing multiple available logical devices for potential of multi-viewport support </p>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__driver/#function-depth_format","title":"function depth_format","text":"<pre><code>VkFormat atlas::vk::vk_driver::depth_format () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#function-destroy","title":"function destroy","text":"<pre><code>void atlas::vk::vk_driver::destroy () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#function-get_queue","title":"function get_queue","text":"<pre><code>VkQueue atlas::vk::vk_driver::get_queue (\n    const vk_queue_options &amp; p_present_queue\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#function-graphics_queue","title":"function graphics_queue","text":"<pre><code>inline VkQueue atlas::vk::vk_driver::graphics_queue () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#function-operator-vkdevice-12","title":"function operator VkDevice [1/2]","text":"<pre><code>inline atlas::vk::vk_driver::operator VkDevice () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#function-operator-vkdevice-22","title":"function operator VkDevice [2/2]","text":"<pre><code>inline atlas::vk::vk_driver::operator VkDevice () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#function-select_memory_type","title":"function select_memory_type","text":"<pre><code>uint32_t atlas::vk::vk_driver::select_memory_type (\n    uint32_t p_type_filter,\n    VkMemoryPropertyFlags p_property_flag\n) \n</code></pre> <p>Note:</p> <p>Returns -1 if there are no flags available/compatible/valid </p>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#function-vk_driver-12","title":"function vk_driver [1/2]","text":"<pre><code>atlas::vk::vk_driver::vk_driver () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#function-vk_driver-22","title":"function vk_driver [2/2]","text":"<pre><code>atlas::vk::vk_driver::vk_driver (\n    const vk_physical_driver &amp; p_physical\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#function-vk_driver","title":"function ~vk_driver","text":"<pre><code>atlas::vk::vk_driver::~vk_driver () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_driver.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1vk__filter__range/","title":"Struct atlas::vk::vk_filter_range","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_filter_range</p> <p>Range between min and max for the VkFilter. </p> <ul> <li><code>#include &lt;vk_types.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1vk_1_1vk__filter__range/#public-attributes","title":"Public Attributes","text":"Type Name VkFilter max VkFilter min"},{"location":"References/structatlas_1_1vk_1_1vk__filter__range/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1vk__filter__range/#variable-max","title":"variable max","text":"<pre><code>VkFilter atlas::vk::vk_filter_range::max;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__filter__range/#variable-min","title":"variable min","text":"<pre><code>VkFilter atlas::vk::vk_filter_range::min;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__graphics__queue/","title":"Class atlas::vk::vk_graphics_queue","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_graphics_queue</p> <p>graphics queue mainly used for submitting to the graphics family specific queue More...</p> <ul> <li><code>#include &lt;vk_graphics_queue.hpp&gt;</code></li> </ul>"},{"location":"References/classatlas_1_1vk_1_1vk__graphics__queue/#public-functions","title":"Public Functions","text":"Type Name void destroy ()  void immediate_submit_async (const VkCommandBuffer &amp; p_command_buffer)  void immediate_submit_sync (const VkCommandBuffer &amp; p_command_buffer)  operator VkQueue ()  operator VkQueue () const vk_graphics_queue () = default vk_graphics_queue (const vk_queue_options &amp; p_queue_options)  void wait_idle ()"},{"location":"References/classatlas_1_1vk_1_1vk__graphics__queue/#detailed-description","title":"Detailed Description","text":"<p>Graphic Queues are used for submitting commands via rendering commands directly or indirectly to the GPU</p> <p>Single graphics queue can only perform compute and transfer operations as well</p> <p>Primarily used for rendeirng logic commands processing </p>"},{"location":"References/classatlas_1_1vk_1_1vk__graphics__queue/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__graphics__queue/#function-destroy","title":"function destroy","text":"<pre><code>void atlas::vk::vk_graphics_queue::destroy () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__graphics__queue/#function-immediate_submit_async","title":"function immediate_submit_async","text":"<pre><code>void atlas::vk::vk_graphics_queue::immediate_submit_async (\n    const VkCommandBuffer &amp; p_command_buffer\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__graphics__queue/#function-immediate_submit_sync","title":"function immediate_submit_sync","text":"<pre><code>void atlas::vk::vk_graphics_queue::immediate_submit_sync (\n    const VkCommandBuffer &amp; p_command_buffer\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__graphics__queue/#function-operator-vkqueue-12","title":"function operator VkQueue [1/2]","text":"<pre><code>inline atlas::vk::vk_graphics_queue::operator VkQueue () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__graphics__queue/#function-operator-vkqueue-22","title":"function operator VkQueue [2/2]","text":"<pre><code>inline atlas::vk::vk_graphics_queue::operator VkQueue () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__graphics__queue/#function-vk_graphics_queue-12","title":"function vk_graphics_queue [1/2]","text":"<pre><code>atlas::vk::vk_graphics_queue::vk_graphics_queue () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__graphics__queue/#function-vk_graphics_queue-22","title":"function vk_graphics_queue [2/2]","text":"<pre><code>atlas::vk::vk_graphics_queue::vk_graphics_queue (\n    const vk_queue_options &amp; p_queue_options\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__graphics__queue/#function-wait_idle","title":"function wait_idle","text":"<pre><code>void atlas::vk::vk_graphics_queue::wait_idle () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_graphics_queue.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1vk__image/","title":"Struct atlas::vk::vk_image","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_image</p> <p>vulkan image handler with resources; used when handling textures </p> <ul> <li><code>#include &lt;vk_types.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1vk_1_1vk__image/#public-attributes","title":"Public Attributes","text":"Type Name VkDeviceMemory device_memory   = <code>nullptr</code> VkImage image   = <code>nullptr</code> VkImageView image_view   = <code>nullptr</code> VkSampler sampler   = <code>nullptr</code>"},{"location":"References/structatlas_1_1vk_1_1vk__image/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1vk__image/#variable-device_memory","title":"variable device_memory","text":"<pre><code>VkDeviceMemory atlas::vk::vk_image::device_memory;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__image/#variable-image","title":"variable image","text":"<pre><code>VkImage atlas::vk::vk_image::image;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__image/#variable-image_view","title":"variable image_view","text":"<pre><code>VkImageView atlas::vk::vk_image::image_view;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__image/#variable-sampler","title":"variable sampler","text":"<pre><code>VkSampler atlas::vk::vk_image::sampler;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1vk__image__handle/","title":"Struct atlas::vk::vk_image_handle","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_image_handle</p>"},{"location":"References/structatlas_1_1vk_1_1vk__image__handle/#public-attributes","title":"Public Attributes","text":"Type Name VkImage image   = <code>nullptr</code> VkImageView image_view   = <code>nullptr</code>"},{"location":"References/structatlas_1_1vk_1_1vk__image__handle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1vk__image__handle/#variable-image","title":"variable image","text":"<pre><code>VkImage atlas::vk::vk_image_handle::image;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__image__handle/#variable-image_view","title":"variable image_view","text":"<pre><code>VkImageView atlas::vk::vk_image_handle::image_view;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__index__buffer/","title":"Class atlas::vk::vk_index_buffer","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_index_buffer</p>"},{"location":"References/classatlas_1_1vk_1_1vk__index__buffer/#public-functions","title":"Public Functions","text":"Type Name void bind (const VkCommandBuffer &amp; p_current)  void destroy ()  void draw (const VkCommandBuffer &amp; p_current)  size_t size () const vk_index_buffer () = default vk_index_buffer (const std::span&lt; uint32_t &gt; &amp; p_indices)"},{"location":"References/classatlas_1_1vk_1_1vk__index__buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__index__buffer/#function-bind","title":"function bind","text":"<pre><code>void atlas::vk::vk_index_buffer::bind (\n    const VkCommandBuffer &amp; p_current\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__index__buffer/#function-destroy","title":"function destroy","text":"<pre><code>void atlas::vk::vk_index_buffer::destroy () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__index__buffer/#function-draw","title":"function draw","text":"<pre><code>void atlas::vk::vk_index_buffer::draw (\n    const VkCommandBuffer &amp; p_current\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__index__buffer/#function-size","title":"function size","text":"<pre><code>inline size_t atlas::vk::vk_index_buffer::size () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__index__buffer/#function-vk_index_buffer-12","title":"function vk_index_buffer [1/2]","text":"<pre><code>atlas::vk::vk_index_buffer::vk_index_buffer () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__index__buffer/#function-vk_index_buffer-22","title":"function vk_index_buffer [2/2]","text":"<pre><code>atlas::vk::vk_index_buffer::vk_index_buffer (\n    const std::span&lt; uint32_t &gt; &amp; p_indices\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_index_buffer.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/","title":"Class atlas::vk::vk_physical_driver","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_physical_driver</p>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#public-functions","title":"Public Functions","text":"Type Name surface_properties get_surface_properties (const VkSurfaceKHR &amp; p_surface)  operator VkPhysicalDevice ()  operator VkPhysicalDevice () const uint32_t read_presentation_index (const VkSurfaceKHR &amp; p_surface)  queue_family_indices read_queue_family_indices () const vk_physical_driver () = default vk_physical_driver (const VkInstance &amp; p_instance)  ~vk_physical_driver ()"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#function-get_surface_properties","title":"function get_surface_properties","text":"<pre><code>surface_properties atlas::vk::vk_physical_driver::get_surface_properties (\n    const VkSurfaceKHR &amp; p_surface\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#function-operator-vkphysicaldevice-12","title":"function operator VkPhysicalDevice [1/2]","text":"<pre><code>inline atlas::vk::vk_physical_driver::operator VkPhysicalDevice () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#function-operator-vkphysicaldevice-22","title":"function operator VkPhysicalDevice [2/2]","text":"<pre><code>inline atlas::vk::vk_physical_driver::operator VkPhysicalDevice () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#function-read_presentation_index","title":"function read_presentation_index","text":"<pre><code>uint32_t atlas::vk::vk_physical_driver::read_presentation_index (\n    const VkSurfaceKHR &amp; p_surface\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#function-read_queue_family_indices","title":"function read_queue_family_indices","text":"<pre><code>inline queue_family_indices atlas::vk::vk_physical_driver::read_queue_family_indices () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#function-vk_physical_driver-12","title":"function vk_physical_driver [1/2]","text":"<pre><code>atlas::vk::vk_physical_driver::vk_physical_driver () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#function-vk_physical_driver-22","title":"function vk_physical_driver [2/2]","text":"<pre><code>atlas::vk::vk_physical_driver::vk_physical_driver (\n    const VkInstance &amp; p_instance\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#function-vk_physical_driver","title":"function ~vk_physical_driver","text":"<pre><code>atlas::vk::vk_physical_driver::~vk_physical_driver () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_physical_driver.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__pipeline/","title":"Class atlas::vk::vk_pipeline","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_pipeline</p>"},{"location":"References/classatlas_1_1vk_1_1vk__pipeline/#public-functions","title":"Public Functions","text":"Type Name void bind (const VkCommandBuffer &amp; p_current)  void create (const VkRenderPass &amp; p_renderpass)  void destroy ()  VkPipelineLayout get_layout () const VkPipelineLayout layout () const operator VkPipeline ()  operator VkPipeline () const vk_pipeline () = default vk_pipeline (const VkRenderPass &amp; p_renderpass, vk_shader_group &amp; p_shader_group)  vk_pipeline (const VkRenderPass &amp; p_renderpass, const vk_shader_group &amp; p_shader_group, const std::span&lt; VkDescriptorSetLayout &gt; &amp; p_descriptor_layout)"},{"location":"References/classatlas_1_1vk_1_1vk__pipeline/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__pipeline/#function-bind","title":"function bind","text":"<pre><code>void atlas::vk::vk_pipeline::bind (\n    const VkCommandBuffer &amp; p_current\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__pipeline/#function-create","title":"function create","text":"<pre><code>void atlas::vk::vk_pipeline::create (\n    const VkRenderPass &amp; p_renderpass\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__pipeline/#function-destroy","title":"function destroy","text":"<pre><code>void atlas::vk::vk_pipeline::destroy () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__pipeline/#function-get_layout","title":"function get_layout","text":"<pre><code>inline VkPipelineLayout atlas::vk::vk_pipeline::get_layout () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__pipeline/#function-layout","title":"function layout","text":"<pre><code>inline VkPipelineLayout atlas::vk::vk_pipeline::layout () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__pipeline/#function-operator-vkpipeline-12","title":"function operator VkPipeline [1/2]","text":"<pre><code>inline atlas::vk::vk_pipeline::operator VkPipeline () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__pipeline/#function-operator-vkpipeline-22","title":"function operator VkPipeline [2/2]","text":"<pre><code>inline atlas::vk::vk_pipeline::operator VkPipeline () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__pipeline/#function-vk_pipeline-13","title":"function vk_pipeline [1/3]","text":"<pre><code>atlas::vk::vk_pipeline::vk_pipeline () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__pipeline/#function-vk_pipeline-23","title":"function vk_pipeline [2/3]","text":"<pre><code>atlas::vk::vk_pipeline::vk_pipeline (\n    const VkRenderPass &amp; p_renderpass,\n    vk_shader_group &amp; p_shader_group\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__pipeline/#function-vk_pipeline-33","title":"function vk_pipeline [3/3]","text":"<pre><code>atlas::vk::vk_pipeline::vk_pipeline (\n    const VkRenderPass &amp; p_renderpass,\n    const vk_shader_group &amp; p_shader_group,\n    const std::span&lt; VkDescriptorSetLayout &gt; &amp; p_descriptor_layout\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_pipeline.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__present__queue/","title":"Class atlas::vk::vk_present_queue","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_present_queue</p> <p>Handles submissions to the specific queue for presentation. More...</p> <ul> <li><code>#include &lt;vk_present_queue.hpp&gt;</code></li> </ul>"},{"location":"References/classatlas_1_1vk_1_1vk__present__queue/#public-functions","title":"Public Functions","text":"Type Name uint32_t acquired_frame ()  void destroy () Explicitly invoking cleanup for the presentation queue. bool is_alive () const operator VkQueue ()  operator VkQueue () const void present_frame (const uint32_t &amp; p_current_frame) Then again, this probably won't be needed. bool resize_requested () const void set_resize_status (bool p_status)  void submit_immediate_async (const VkCommandBuffer &amp; p_command) Submitting current command buffer with async enabled. void submit_immediate_sync (const VkCommandBuffer &amp; p_command) Submitting current command buffer with async disabled. vk_present_queue () = default vk_present_queue (const VkSwapchainKHR &amp; p_swapchain, const vk_queue_options &amp; p_queue_options) Constructs new presentation queue. void wait_idle () Ensures that operations finished within this queue before processing new frames."},{"location":"References/classatlas_1_1vk_1_1vk__present__queue/#detailed-description","title":"Detailed Description","text":"<p>This queue is for submitting presentation images through this queue that gets displayed onto the swapchain</p> <p>Used by the vk_swapchain to present currently processed command buffers to the swapchain </p>"},{"location":"References/classatlas_1_1vk_1_1vk__present__queue/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__present__queue/#function-acquired_frame","title":"function acquired_frame","text":"<pre><code>uint32_t atlas::vk::vk_present_queue::acquired_frame () \n</code></pre> <p>Returns:</p> <p>uint32_t next index to the presentable image for the current frame </p>"},{"location":"References/classatlas_1_1vk_1_1vk__present__queue/#function-destroy","title":"function destroy","text":"<p>Explicitly invoking cleanup for the presentation queue. <pre><code>void atlas::vk::vk_present_queue::destroy () \n</code></pre></p>"},{"location":"References/classatlas_1_1vk_1_1vk__present__queue/#function-is_alive","title":"function is_alive","text":"<pre><code>inline bool atlas::vk::vk_present_queue::is_alive () const\n</code></pre> <p>Returns:</p> <p>bool if the presentation queue handler is valid or not </p>"},{"location":"References/classatlas_1_1vk_1_1vk__present__queue/#function-operator-vkqueue-12","title":"function operator VkQueue [1/2]","text":"<pre><code>inline atlas::vk::vk_present_queue::operator VkQueue () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__present__queue/#function-operator-vkqueue-22","title":"function operator VkQueue [2/2]","text":"<pre><code>inline atlas::vk::vk_present_queue::operator VkQueue () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__present__queue/#function-present_frame","title":"function present_frame","text":"<p>Then again, this probably won't be needed. <pre><code>void atlas::vk::vk_present_queue::present_frame (\n    const uint32_t &amp; p_current_frame\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_current_frame</code> current frame of image presentable to the swapchain </li> </ul>"},{"location":"References/classatlas_1_1vk_1_1vk__present__queue/#function-resize_requested","title":"function resize_requested","text":"<pre><code>inline bool atlas::vk::vk_present_queue::resize_requested () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__present__queue/#function-set_resize_status","title":"function set_resize_status","text":"<pre><code>inline void atlas::vk::vk_present_queue::set_resize_status (\n    bool p_status\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__present__queue/#function-submit_immediate_async","title":"function submit_immediate_async","text":"<p>Submitting current command buffer with async enabled. <pre><code>void atlas::vk::vk_present_queue::submit_immediate_async (\n    const VkCommandBuffer &amp; p_command\n) \n</code></pre></p>"},{"location":"References/classatlas_1_1vk_1_1vk__present__queue/#function-submit_immediate_sync","title":"function submit_immediate_sync","text":"<p>Submitting current command buffer with async disabled. <pre><code>void atlas::vk::vk_present_queue::submit_immediate_sync (\n    const VkCommandBuffer &amp; p_command\n) \n</code></pre></p>"},{"location":"References/classatlas_1_1vk_1_1vk__present__queue/#function-vk_present_queue-12","title":"function vk_present_queue [1/2]","text":"<pre><code>atlas::vk::vk_present_queue::vk_present_queue () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__present__queue/#function-vk_present_queue-22","title":"function vk_present_queue [2/2]","text":"<p>Constructs new presentation queue. <pre><code>atlas::vk::vk_present_queue::vk_present_queue (\n    const VkSwapchainKHR &amp; p_swapchain,\n    const vk_queue_options &amp; p_queue_options\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_swapchain</code> presentation queue needs a swapchain of where the images are being rendered to </li> <li><code>p_queue_options</code> specifies options on the types of queue family index, and queue associated index to which queue family handler for submitting work to </li> </ul>"},{"location":"References/classatlas_1_1vk_1_1vk__present__queue/#function-wait_idle","title":"function wait_idle","text":"<p>Ensures that operations finished within this queue before processing new frames. <pre><code>void atlas::vk::vk_present_queue::wait_idle () \n</code></pre></p> <p>Synchronization handling </p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_present_queue.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1vk__queue__options/","title":"Struct atlas::vk::vk_queue_options","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_queue_options</p>"},{"location":"References/structatlas_1_1vk_1_1vk__queue__options/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t family_index   = <code>-1</code> uint32_t queue_index   = <code>0</code>"},{"location":"References/structatlas_1_1vk_1_1vk__queue__options/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1vk__queue__options/#variable-family_index","title":"variable family_index","text":"<pre><code>uint32_t atlas::vk::vk_queue_options::family_index;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__queue__options/#variable-queue_index","title":"variable queue_index","text":"<pre><code>uint32_t atlas::vk::vk_queue_options::queue_index;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__renderer/","title":"Class atlas::vk::vk_renderer","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_renderer</p> <p>Something to consider for mesh loading. More...</p> <ul> <li><code>#include &lt;vk_renderer.hpp&gt;</code></li> </ul> <p>Inherits the following classes: atlas::render_context</p>"},{"location":"References/classatlas_1_1vk_1_1vk__renderer/#public-functions","title":"Public Functions","text":"Type Name vk_renderer (const vk_swapchain &amp; p_swapchain, const std::string &amp; p_tag)  ~vk_renderer () override"},{"location":"References/classatlas_1_1vk_1_1vk__renderer/#public-functions-inherited-from-atlasrender_context","title":"Public Functions inherited from atlas::render_context","text":"<p>See atlas::render_context</p> Type Name void begin_frame (const vk::vk_command_buffer &amp; p_current, const vk::vk_swapchain &amp; p_swapchain_handler)  void end_frame ()  void set_background_color (const std::array&lt; float, 4 &gt; &amp; p_color)  virtual ~render_context () = default"},{"location":"References/classatlas_1_1vk_1_1vk__renderer/#detailed-description","title":"Detailed Description","text":"<p>How will meshes get loaded?</p> <p>There are a few ways for considering for the base approach, which are: TODO: These are things to think about how this may happen because I want to make this lightweight in the sense the data isnt continuously being modified. Taking a looking at minimizing the loading state of vulkan implementation-specific meshes * While also making the way how mesh components are being added the same as before</p> <p>Something to avoid is the entities containing the geometry data itself but being able to reference to their respective geometry data that are getting submitted to the GPU</p> <ul> <li>Batching ID's into hash table that contains the actual geometry data</li> <li>Using ID to search up the mesh loaded and cached into the map, then reuse that geometry whenever the uniforms are changed</li> <li>This way we aren't reloading in the same mesh multiple times, treating the hash table as a slot of the mesh contained within that scene</li> <li>Potentially std::map&lt;std::string, std::map&lt;std::string, vk::mesh_metadata&gt;&gt; m_geometries<ul> <li>Idea is the std::string is the geometries within this scene, the data format is: &lt;scene_str, &lt;mesh_str, mesh_metadata&gt;&gt; </li> </ul> </li> </ul>"},{"location":"References/classatlas_1_1vk_1_1vk__renderer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__renderer/#function-vk_renderer","title":"function vk_renderer","text":"<pre><code>atlas::vk::vk_renderer::vk_renderer (\n    const vk_swapchain &amp; p_swapchain,\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__renderer/#function-vk_renderer_1","title":"function ~vk_renderer","text":"<pre><code>atlas::vk::vk_renderer::~vk_renderer () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_renderer.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__renderpass/","title":"Class atlas::vk::vk_renderpass","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_renderpass</p> <p>defines a renderpass operation More...</p> <ul> <li><code>#include &lt;vk_renderpass.hpp&gt;</code></li> </ul>"},{"location":"References/classatlas_1_1vk_1_1vk__renderpass/#public-functions","title":"Public Functions","text":"Type Name void configure (const vk_renderpass_options &amp; p_renderpass_options) contsructs new renderpass and configures it with the following attachments void destroy () contsructs new renderpass and configures it with the following attachments operator VkRenderPass () const operator VkRenderPass ()  vk_renderpass () = default vk_renderpass (const vk_renderpass_options &amp; p_renderpass_options) Invokes configure when constructing new renderpass."},{"location":"References/classatlas_1_1vk_1_1vk__renderpass/#detailed-description","title":"Detailed Description","text":"<p>vk_renderpass </p> <p>Handles </p>"},{"location":"References/classatlas_1_1vk_1_1vk__renderpass/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__renderpass/#function-configure","title":"function configure","text":"<p>contsructs new renderpass and configures it with the following attachments <pre><code>void atlas::vk::vk_renderpass::configure (\n    const vk_renderpass_options &amp; p_renderpass_options\n) \n</code></pre></p>"},{"location":"References/classatlas_1_1vk_1_1vk__renderpass/#function-destroy","title":"function destroy","text":"<p>contsructs new renderpass and configures it with the following attachments <pre><code>void atlas::vk::vk_renderpass::destroy () \n</code></pre></p>"},{"location":"References/classatlas_1_1vk_1_1vk__renderpass/#function-operator-vkrenderpass-12","title":"function operator VkRenderPass [1/2]","text":"<pre><code>inline atlas::vk::vk_renderpass::operator VkRenderPass () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__renderpass/#function-operator-vkrenderpass-22","title":"function operator VkRenderPass [2/2]","text":"<pre><code>inline atlas::vk::vk_renderpass::operator VkRenderPass () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__renderpass/#function-vk_renderpass-12","title":"function vk_renderpass [1/2]","text":"<pre><code>atlas::vk::vk_renderpass::vk_renderpass () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__renderpass/#function-vk_renderpass-22","title":"function vk_renderpass [2/2]","text":"<p>Invokes configure when constructing new renderpass. <pre><code>atlas::vk::vk_renderpass::vk_renderpass (\n    const vk_renderpass_options &amp; p_renderpass_options\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_renderpass.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1vk__renderpass__options/","title":"Struct atlas::vk::vk_renderpass_options","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_renderpass_options</p> <p>Renderpass specifictations for VkRenderpass. More...</p> <ul> <li><code>#include &lt;vk_types.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1vk_1_1vk__renderpass__options/#public-attributes","title":"Public Attributes","text":"Type Name std::span&lt; VkAttachmentDescription &gt; attachments   = <code>{}</code> bool cache   = <code>false</code> std::span&lt; VkClearColorValue &gt; clear_values   = <code>{}</code> std::span&lt; VkSubpassDependency &gt; dependencies   = <code>{}</code> std::span&lt; VkSubpassDescription &gt; subpass_descriptions   = <code>{}</code>"},{"location":"References/structatlas_1_1vk_1_1vk__renderpass__options/#detailed-description","title":"Detailed Description","text":"<p>Specifying requirements needed for specifying the vulkan renderpass handlers </p>"},{"location":"References/structatlas_1_1vk_1_1vk__renderpass__options/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1vk__renderpass__options/#variable-attachments","title":"variable attachments","text":"<pre><code>std::span&lt;VkAttachmentDescription&gt; atlas::vk::vk_renderpass_options::attachments;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__renderpass__options/#variable-cache","title":"variable cache","text":"<pre><code>bool atlas::vk::vk_renderpass_options::cache;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__renderpass__options/#variable-clear_values","title":"variable clear_values","text":"<pre><code>std::span&lt;VkClearColorValue&gt; atlas::vk::vk_renderpass_options::clear_values;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__renderpass__options/#variable-dependencies","title":"variable dependencies","text":"<pre><code>std::span&lt;VkSubpassDependency&gt; atlas::vk::vk_renderpass_options::dependencies;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__renderpass__options/#variable-subpass_descriptions","title":"variable subpass_descriptions","text":"<pre><code>std::span&lt;VkSubpassDescription&gt; atlas::vk::vk_renderpass_options::subpass_descriptions;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__shader__group/","title":"Class atlas::vk::vk_shader_group","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_shader_group</p>"},{"location":"References/classatlas_1_1vk_1_1vk__shader__group/#public-functions","title":"Public Functions","text":"Type Name void compile ()  std::span&lt; const vk_shader_module &gt; data () const void destroy ()  void set_vertex_attributes (const std::initializer_list&lt; VkVertexInputAttributeDescription &gt; &amp; p_attributes)  void set_vertex_attributes (const std::span&lt; VkVertexInputAttributeDescription &gt; &amp; p_attributes)  void set_vertex_bind_attributes (const std::initializer_list&lt; VkVertexInputBindingDescription &gt; &amp; p_bind_attributes)  void set_vertex_bind_attributes (const std::span&lt; VkVertexInputBindingDescription &gt; &amp; p_bind_attributes)  uint32_t size () const void vertex_attributes (const std::span&lt; vertex_attribute &gt; &amp; p_vertex_attributes)  std::span&lt; VkVertexInputAttributeDescription &gt; vertex_attributes ()  std::span&lt; VkVertexInputBindingDescription &gt; vertex_bind_attributes ()  vk_shader_group () = default vk_shader_group (const std::initializer_list&lt; shader_info &gt; &amp; p_list) Constructing new shader group as an initialized list. vk_shader_group (const std::span&lt; shader_info &gt; &amp; p_shader_sources) Constructs a shader group because a pipeline may have multiple shader groups part of the shader pipeline with a specific stage associated with it."},{"location":"References/classatlas_1_1vk_1_1vk__shader__group/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__shader__group/#function-compile","title":"function compile","text":"<pre><code>void atlas::vk::vk_shader_group::compile () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__shader__group/#function-data","title":"function data","text":"<pre><code>inline std::span&lt; const vk_shader_module &gt; atlas::vk::vk_shader_group::data () const\n</code></pre> <p>Returns:</p> <p>span of vk_shader_module that contains the handler and stage this handler was loaded at </p>"},{"location":"References/classatlas_1_1vk_1_1vk__shader__group/#function-destroy","title":"function destroy","text":"<pre><code>void atlas::vk::vk_shader_group::destroy () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__shader__group/#function-set_vertex_attributes-12","title":"function set_vertex_attributes [1/2]","text":"<pre><code>void atlas::vk::vk_shader_group::set_vertex_attributes (\n    const std::initializer_list&lt; VkVertexInputAttributeDescription &gt; &amp; p_attributes\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__shader__group/#function-set_vertex_attributes-22","title":"function set_vertex_attributes [2/2]","text":"<pre><code>void atlas::vk::vk_shader_group::set_vertex_attributes (\n    const std::span&lt; VkVertexInputAttributeDescription &gt; &amp; p_attributes\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__shader__group/#function-set_vertex_bind_attributes-12","title":"function set_vertex_bind_attributes [1/2]","text":"<pre><code>void atlas::vk::vk_shader_group::set_vertex_bind_attributes (\n    const std::initializer_list&lt; VkVertexInputBindingDescription &gt; &amp; p_bind_attributes\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__shader__group/#function-set_vertex_bind_attributes-22","title":"function set_vertex_bind_attributes [2/2]","text":"<pre><code>void atlas::vk::vk_shader_group::set_vertex_bind_attributes (\n    const std::span&lt; VkVertexInputBindingDescription &gt; &amp; p_bind_attributes\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__shader__group/#function-size","title":"function size","text":"<pre><code>inline uint32_t atlas::vk::vk_shader_group::size () const\n</code></pre> <p>Returns:</p> <p>uint32_t the size of vulkan shader modules loaded </p>"},{"location":"References/classatlas_1_1vk_1_1vk__shader__group/#function-vertex_attributes-12","title":"function vertex_attributes [1/2]","text":"<pre><code>void atlas::vk::vk_shader_group::vertex_attributes (\n    const std::span&lt; vertex_attribute &gt; &amp; p_vertex_attributes\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__shader__group/#function-vertex_attributes-22","title":"function vertex_attributes [2/2]","text":"<pre><code>inline std::span&lt; VkVertexInputAttributeDescription &gt; atlas::vk::vk_shader_group::vertex_attributes () \n</code></pre> <p>Returns:</p> <p>vertex attributes set in the vertex shader </p>"},{"location":"References/classatlas_1_1vk_1_1vk__shader__group/#function-vertex_bind_attributes","title":"function vertex_bind_attributes","text":"<pre><code>inline std::span&lt; VkVertexInputBindingDescription &gt; atlas::vk::vk_shader_group::vertex_bind_attributes () \n</code></pre> <p>Returns:</p> <p>binding vertex attributes also set in the vertex shader </p>"},{"location":"References/classatlas_1_1vk_1_1vk__shader__group/#function-vk_shader_group-13","title":"function vk_shader_group [1/3]","text":"<pre><code>atlas::vk::vk_shader_group::vk_shader_group () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__shader__group/#function-vk_shader_group-23","title":"function vk_shader_group [2/3]","text":"<p>Constructing new shader group as an initialized list. <pre><code>atlas::vk::vk_shader_group::vk_shader_group (\n    const std::initializer_list&lt; shader_info &gt; &amp; p_list\n) \n</code></pre></p>"},{"location":"References/classatlas_1_1vk_1_1vk__shader__group/#function-vk_shader_group-33","title":"function vk_shader_group [3/3]","text":"<p>Constructs a shader group because a pipeline may have multiple shader groups part of the shader pipeline with a specific stage associated with it. <pre><code>atlas::vk::vk_shader_group::vk_shader_group (\n    const std::span&lt; shader_info &gt; &amp; p_shader_sources\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_shader_group.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1vk__shader__module/","title":"Struct atlas::vk::vk_shader_module","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_shader_module</p>"},{"location":"References/structatlas_1_1vk_1_1vk__shader__module/#public-attributes","title":"Public Attributes","text":"Type Name VkShaderModule module_handler   = <code>nullptr</code> shader_stage stage   = <code>undefined</code>"},{"location":"References/structatlas_1_1vk_1_1vk__shader__module/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1vk__shader__module/#variable-module_handler","title":"variable module_handler","text":"<pre><code>VkShaderModule atlas::vk::vk_shader_module::module_handler;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__shader__module/#variable-stage","title":"variable stage","text":"<pre><code>shader_stage atlas::vk::vk_shader_module::stage;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/","title":"Class atlas::vk::vk_swapchain","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_swapchain</p>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#public-functions","title":"Public Functions","text":"Type Name vk_command_buffer active_command_buffer (uint32_t p_frame) const VkFramebuffer active_framebuffer (uint32_t p_frame) const void configure (const window_settings &amp; p_settings) Constructs new swapchain with specified window-integration configuration settings. surface_properties data () const void destroy ()  uint32_t image_size () const operator VkSwapchainKHR () const operator VkSwapchainKHR ()  void present (const uint32_t &amp; p_current_frame)  uint32_t read_acquired_image () Used for when swapchain is resized then only reconfigured properties to get resizability. window_settings settings () const void submit (const VkCommandBuffer &amp; p_command)  VkRenderPass swapchain_renderpass () const vk_swapchain () = default vk_swapchain (const VkSurfaceKHR &amp; p_surface, const window_settings &amp; p_settings) Constructs a new vulkan swapchain with a window settings to apply to this swapchain."},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-active_command_buffer","title":"function active_command_buffer","text":"<pre><code>inline vk_command_buffer atlas::vk::vk_swapchain::active_command_buffer (\n    uint32_t p_frame\n) const\n</code></pre> <p>Returns:</p> <p>current active command buffer being processed </p>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-active_framebuffer","title":"function active_framebuffer","text":"<pre><code>inline VkFramebuffer atlas::vk::vk_swapchain::active_framebuffer (\n    uint32_t p_frame\n) const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-configure","title":"function configure","text":"<p>Constructs new swapchain with specified window-integration configuration settings. <pre><code>void atlas::vk::vk_swapchain::configure (\n    const window_settings &amp; p_settings\n) \n</code></pre></p>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-data","title":"function data","text":"<pre><code>inline surface_properties atlas::vk::vk_swapchain::data () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-destroy","title":"function destroy","text":"<pre><code>void atlas::vk::vk_swapchain::destroy () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-image_size","title":"function image_size","text":"<pre><code>inline uint32_t atlas::vk::vk_swapchain::image_size () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-operator-vkswapchainkhr-12","title":"function operator VkSwapchainKHR [1/2]","text":"<pre><code>inline atlas::vk::vk_swapchain::operator VkSwapchainKHR () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-operator-vkswapchainkhr-22","title":"function operator VkSwapchainKHR [2/2]","text":"<pre><code>inline atlas::vk::vk_swapchain::operator VkSwapchainKHR () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-present","title":"function present","text":"<pre><code>void atlas::vk::vk_swapchain::present (\n    const uint32_t &amp; p_current_frame\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-read_acquired_image","title":"function read_acquired_image","text":"<p>Used for when swapchain is resized then only reconfigured properties to get resizability. <pre><code>uint32_t atlas::vk::vk_swapchain::read_acquired_image () \n</code></pre></p> <p>Returns:</p> <p>uint32_t the next available image to present acquired </p>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-settings","title":"function settings","text":"<pre><code>inline window_settings atlas::vk::vk_swapchain::settings () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-submit","title":"function submit","text":"<pre><code>void atlas::vk::vk_swapchain::submit (\n    const VkCommandBuffer &amp; p_command\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-swapchain_renderpass","title":"function swapchain_renderpass","text":"<pre><code>inline VkRenderPass atlas::vk::vk_swapchain::swapchain_renderpass () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-vk_swapchain-12","title":"function vk_swapchain [1/2]","text":"<pre><code>atlas::vk::vk_swapchain::vk_swapchain () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-vk_swapchain-22","title":"function vk_swapchain [2/2]","text":"<p>Constructs a new vulkan swapchain with a window settings to apply to this swapchain. <pre><code>atlas::vk::vk_swapchain::vk_swapchain (\n    const VkSurfaceKHR &amp; p_surface,\n    const window_settings &amp; p_settings\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_surface</code> passing in the surface handler for swapchain uses </li> </ul> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_swapchain.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__uniform__buffer/","title":"Class atlas::vk::vk_uniform_buffer","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_uniform_buffer</p>"},{"location":"References/classatlas_1_1vk_1_1vk__uniform__buffer/#public-functions","title":"Public Functions","text":"Type Name void destroy ()  operator VkBuffer () const operator VkBuffer ()  uint32_t size_bytes () const void update (const void * p_data)  vk_uniform_buffer () = default vk_uniform_buffer (uint32_t p_size_in_bytes)"},{"location":"References/classatlas_1_1vk_1_1vk__uniform__buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__uniform__buffer/#function-destroy","title":"function destroy","text":"<pre><code>void atlas::vk::vk_uniform_buffer::destroy () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__uniform__buffer/#function-operator-vkbuffer-12","title":"function operator VkBuffer [1/2]","text":"<pre><code>inline atlas::vk::vk_uniform_buffer::operator VkBuffer () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__uniform__buffer/#function-operator-vkbuffer-22","title":"function operator VkBuffer [2/2]","text":"<pre><code>inline atlas::vk::vk_uniform_buffer::operator VkBuffer () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__uniform__buffer/#function-size_bytes","title":"function size_bytes","text":"<pre><code>inline uint32_t atlas::vk::vk_uniform_buffer::size_bytes () const\n</code></pre> <p>Returns:</p> <p>bytes of the uniform data stored with this uniform buffer handler </p>"},{"location":"References/classatlas_1_1vk_1_1vk__uniform__buffer/#function-update","title":"function update","text":"<pre><code>void atlas::vk::vk_uniform_buffer::update (\n    const void * p_data\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__uniform__buffer/#function-vk_uniform_buffer-12","title":"function vk_uniform_buffer [1/2]","text":"<pre><code>atlas::vk::vk_uniform_buffer::vk_uniform_buffer () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__uniform__buffer/#function-vk_uniform_buffer-22","title":"function vk_uniform_buffer [2/2]","text":"<pre><code>atlas::vk::vk_uniform_buffer::vk_uniform_buffer (\n    uint32_t p_size_in_bytes\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_uniform_buffer.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/","title":"Class atlas::vk::vk_vertex_buffer","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_vertex_buffer</p>"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#public-functions","title":"Public Functions","text":"Type Name void bind (const VkCommandBuffer &amp; p_current)  void destroy ()  void draw (const VkCommandBuffer &amp; p_current)  operator VkBuffer ()  operator VkBuffer () const size_t size () const size_t size_bytes () const vk_vertex_buffer () = default vk_vertex_buffer (const std::span&lt; vertex_input &gt; &amp; p_vertices)  ~vk_vertex_buffer () = default"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#function-bind","title":"function bind","text":"<pre><code>void atlas::vk::vk_vertex_buffer::bind (\n    const VkCommandBuffer &amp; p_current\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#function-destroy","title":"function destroy","text":"<pre><code>void atlas::vk::vk_vertex_buffer::destroy () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#function-draw","title":"function draw","text":"<pre><code>void atlas::vk::vk_vertex_buffer::draw (\n    const VkCommandBuffer &amp; p_current\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#function-operator-vkbuffer-12","title":"function operator VkBuffer [1/2]","text":"<pre><code>inline atlas::vk::vk_vertex_buffer::operator VkBuffer () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#function-operator-vkbuffer-22","title":"function operator VkBuffer [2/2]","text":"<pre><code>inline atlas::vk::vk_vertex_buffer::operator VkBuffer () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#function-size","title":"function size","text":"<pre><code>inline size_t atlas::vk::vk_vertex_buffer::size () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#function-size_bytes","title":"function size_bytes","text":"<pre><code>inline size_t atlas::vk::vk_vertex_buffer::size_bytes () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#function-vk_vertex_buffer-12","title":"function vk_vertex_buffer [1/2]","text":"<pre><code>atlas::vk::vk_vertex_buffer::vk_vertex_buffer () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#function-vk_vertex_buffer-22","title":"function vk_vertex_buffer [2/2]","text":"<pre><code>atlas::vk::vk_vertex_buffer::vk_vertex_buffer (\n    const std::span&lt; vertex_input &gt; &amp; p_vertices\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#function-vk_vertex_buffer","title":"function ~vk_vertex_buffer","text":"<pre><code>atlas::vk::vk_vertex_buffer::~vk_vertex_buffer () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_vertex_buffer.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__window/","title":"Class atlas::vk::vk_window","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_window</p> <p>Inherits the following classes: atlas::window</p>"},{"location":"References/classatlas_1_1vk_1_1vk__window/#public-functions","title":"Public Functions","text":"Type Name vk_window (const window_settings &amp; p_settings)  ~vk_window () override"},{"location":"References/classatlas_1_1vk_1_1vk__window/#public-functions-inherited-from-atlaswindow","title":"Public Functions inherited from atlas::window","text":"<p>See atlas::window</p> Type Name uint32_t acquired_next_frame () Returns the available presentable image to use, retrieve index that image is called. vk::vk_command_buffer active_command_buffer (uint32_t p_frame_idx)  float aspect_ratio () constReturns the aspect ratio of the current window. bool available () constChecks if window is available to close. void close () Closing the window operation. vk::vk_swapchain current_swapchain () constReturns the window's currently selected swapchain. uint32_t height () constReturns the height dimension of the window. operator GLFWwindow * () const operator GLFWwindow * ()  void present (const uint32_t &amp; p_current_frame_idx)  uint32_t width () constReturns the width dimension of the window. virtual ~window () = default"},{"location":"References/classatlas_1_1vk_1_1vk__window/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__window/#function-vk_window","title":"function vk_window","text":"<pre><code>atlas::vk::vk_window::vk_window (\n    const window_settings &amp; p_settings\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__window/#function-vk_window_1","title":"function ~vk_window","text":"<pre><code>atlas::vk::vk_window::~vk_window () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_window.hpp</code></p>"},{"location":"References/classatlas_1_1window/","title":"Class atlas::window","text":"<p>ClassList &gt; atlas &gt; window</p> <p>Inherited by the following classes: atlas::vk::vk_window</p>"},{"location":"References/classatlas_1_1window/#public-functions","title":"Public Functions","text":"Type Name uint32_t acquired_next_frame () Returns the available presentable image to use, retrieve index that image is called. vk::vk_command_buffer active_command_buffer (uint32_t p_frame_idx)  float aspect_ratio () constReturns the aspect ratio of the current window. bool available () constChecks if window is available to close. void close () Closing the window operation. vk::vk_swapchain current_swapchain () constReturns the window's currently selected swapchain. uint32_t height () constReturns the height dimension of the window. operator GLFWwindow * () const operator GLFWwindow * ()  void present (const uint32_t &amp; p_current_frame_idx)  uint32_t width () constReturns the width dimension of the window. virtual ~window () = default"},{"location":"References/classatlas_1_1window/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1window/#function-acquired_next_frame","title":"function acquired_next_frame","text":"<p>Returns the available presentable image to use, retrieve index that image is called. <pre><code>inline uint32_t atlas::window::acquired_next_frame () \n</code></pre></p>"},{"location":"References/classatlas_1_1window/#function-active_command_buffer","title":"function active_command_buffer","text":"<pre><code>inline vk::vk_command_buffer atlas::window::active_command_buffer (\n    uint32_t p_frame_idx\n) \n</code></pre>"},{"location":"References/classatlas_1_1window/#function-aspect_ratio","title":"function aspect_ratio","text":"<p>Returns the aspect ratio of the current window. <pre><code>float atlas::window::aspect_ratio () const\n</code></pre></p>"},{"location":"References/classatlas_1_1window/#function-available","title":"function available","text":"<p>Checks if window is available to close. <pre><code>bool atlas::window::available () const\n</code></pre></p>"},{"location":"References/classatlas_1_1window/#function-close","title":"function close","text":"<p>Closing the window operation. <pre><code>void atlas::window::close () \n</code></pre></p>"},{"location":"References/classatlas_1_1window/#function-current_swapchain","title":"function current_swapchain","text":"<p>Returns the window's currently selected swapchain. <pre><code>inline vk::vk_swapchain atlas::window::current_swapchain () const\n</code></pre></p>"},{"location":"References/classatlas_1_1window/#function-height","title":"function height","text":"<p>Returns the height dimension of the window. <pre><code>uint32_t atlas::window::height () const\n</code></pre></p>"},{"location":"References/classatlas_1_1window/#function-operator-glfwwindow-12","title":"function operator GLFWwindow * [1/2]","text":"<pre><code>inline atlas::window::operator GLFWwindow * () const\n</code></pre>"},{"location":"References/classatlas_1_1window/#function-operator-glfwwindow-22","title":"function operator GLFWwindow * [2/2]","text":"<pre><code>inline atlas::window::operator GLFWwindow * () \n</code></pre>"},{"location":"References/classatlas_1_1window/#function-present","title":"function present","text":"<pre><code>void atlas::window::present (\n    const uint32_t &amp; p_current_frame_idx\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>p_current_frame_idx</code> is the current frame index for the next available image </li> </ul>"},{"location":"References/classatlas_1_1window/#function-width","title":"function width","text":"<p>Returns the width dimension of the window. <pre><code>uint32_t atlas::window::width () const\n</code></pre></p>"},{"location":"References/classatlas_1_1window/#function-window","title":"function ~window","text":"<pre><code>virtual atlas::window::~window () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/window.hpp</code></p>"},{"location":"References/structatlas_1_1window__settings/","title":"Struct atlas::window_settings","text":"<p>ClassList &gt; atlas &gt; window_settings</p> <p>Specific settings to the window configuration. More...</p> <ul> <li><code>#include &lt;types.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1window__settings/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t frames_in_flight   = <code>2</code> uint32_t height   = <code>-1</code> std::string name   = <code>\"\"</code> uint32_t width   = <code>-1</code>"},{"location":"References/structatlas_1_1window__settings/#detailed-description","title":"Detailed Description","text":"<p>Contains window properties for doing things with the windows </p>"},{"location":"References/structatlas_1_1window__settings/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1window__settings/#variable-frames_in_flight","title":"variable frames_in_flight","text":"<pre><code>uint32_t atlas::window_settings::frames_in_flight;\n</code></pre>"},{"location":"References/structatlas_1_1window__settings/#variable-height","title":"variable height","text":"<pre><code>uint32_t atlas::window_settings::height;\n</code></pre>"},{"location":"References/structatlas_1_1window__settings/#variable-name","title":"variable name","text":"<pre><code>std::string atlas::window_settings::name;\n</code></pre>"},{"location":"References/structatlas_1_1window__settings/#variable-width","title":"variable width","text":"<pre><code>uint32_t atlas::window_settings::width;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/utilities/types.hpp</code></p>"},{"location":"References/classatlas_1_1world__scope/","title":"Class atlas::world_scope","text":"<p>ClassList &gt; atlas &gt; world_scope</p> <p>Lets rethink how world_scope gets created.More...</p> <ul> <li><code>#include &lt;world.hpp&gt;</code></li> </ul> <p>Inherits the following classes: std::enable_shared_from_this&lt; world_scope &gt;</p>"},{"location":"References/classatlas_1_1world__scope/#public-functions","title":"Public Functions","text":"Type Name void add_scene (const ref&lt; scene_scope &gt; &amp; p_scene_context)  ref&lt; world_scope &gt; get ()  ref&lt; scene_scope &gt; get_scene (const std::string &amp; p_tag)  std::string get_tag () const world &amp; ()  world_scope () = default world_scope (const std::string &amp; p_tag)  ~world_scope ()"},{"location":"References/classatlas_1_1world__scope/#detailed-description","title":"Detailed Description","text":"<p>The way this works is system_registry is going to essentially be how we register worlds</p> <p>Only difference is we aren't constructing it like: register_to(this)</p> <p>What WE are going to do is world_handler = system_registry::create(p_tag);</p> <p>What this does is essentially creates a world scope inside your world that you want to create and the system registry will create, manage, and keep track of lifetimes of world_scopes </p>"},{"location":"References/classatlas_1_1world__scope/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1world__scope/#function-add_scene","title":"function add_scene","text":"<pre><code>void atlas::world_scope::add_scene (\n    const ref &lt; scene_scope &gt; &amp; p_scene_context\n) \n</code></pre>"},{"location":"References/classatlas_1_1world__scope/#function-get","title":"function get","text":"<pre><code>inline ref &lt; world_scope &gt; atlas::world_scope::get () \n</code></pre>"},{"location":"References/classatlas_1_1world__scope/#function-get_scene","title":"function get_scene","text":"<pre><code>inline ref &lt; scene_scope &gt; atlas::world_scope::get_scene (\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1world__scope/#function-get_tag","title":"function get_tag","text":"<pre><code>inline std::string atlas::world_scope::get_tag () const\n</code></pre>"},{"location":"References/classatlas_1_1world__scope/#function-world","title":"function world &amp;","text":"<pre><code>inline atlas::world_scope::world &amp; () \n</code></pre>"},{"location":"References/classatlas_1_1world__scope/#function-world_scope-12","title":"function world_scope [1/2]","text":"<pre><code>atlas::world_scope::world_scope () = default\n</code></pre>"},{"location":"References/classatlas_1_1world__scope/#function-world_scope-22","title":"function world_scope [2/2]","text":"<pre><code>atlas::world_scope::world_scope (\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1world__scope/#function-world_scope","title":"function ~world_scope","text":"<pre><code>atlas::world_scope::~world_scope () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/world.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1vk__driver_1_1device__queue__family/","title":"Struct atlas::vk::vk_driver::device_queue_family","text":"<p>ClassList &gt; device_queue_family</p>"},{"location":"References/structatlas_1_1vk_1_1vk__driver_1_1device__queue__family/#public-attributes","title":"Public Attributes","text":"Type Name VkQueue compute_queue VkQueue graphics_queue VkQueue transfer_queue"},{"location":"References/structatlas_1_1vk_1_1vk__driver_1_1device__queue__family/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1vk__driver_1_1device__queue__family/#variable-compute_queue","title":"variable compute_queue","text":"<pre><code>VkQueue atlas::vk::vk_driver::device_queue_family::compute_queue;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__driver_1_1device__queue__family/#variable-graphics_queue","title":"variable graphics_queue","text":"<pre><code>VkQueue atlas::vk::vk_driver::device_queue_family::graphics_queue;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__driver_1_1device__queue__family/#variable-transfer_queue","title":"variable transfer_queue","text":"<pre><code>VkQueue atlas::vk::vk_driver::device_queue_family::transfer_queue;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_driver.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1vk__physical__driver_1_1queue__family__indices/","title":"Struct atlas::vk::vk_physical_driver::queue_family_indices","text":"<p>ClassList &gt; queue_family_indices</p>"},{"location":"References/structatlas_1_1vk_1_1vk__physical__driver_1_1queue__family__indices/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t compute   = <code>-1</code> uint32_t graphics   = <code>-1</code> uint32_t transfer   = <code>-1</code>"},{"location":"References/structatlas_1_1vk_1_1vk__physical__driver_1_1queue__family__indices/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1vk__physical__driver_1_1queue__family__indices/#variable-compute","title":"variable compute","text":"<pre><code>uint32_t atlas::vk::vk_physical_driver::queue_family_indices::compute;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__physical__driver_1_1queue__family__indices/#variable-graphics","title":"variable graphics","text":"<pre><code>uint32_t atlas::vk::vk_physical_driver::queue_family_indices::graphics;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__physical__driver_1_1queue__family__indices/#variable-transfer","title":"variable transfer","text":"<pre><code>uint32_t atlas::vk::vk_physical_driver::queue_family_indices::transfer;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_physical_driver.hpp</code></p>"},{"location":"References/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p>"},{"location":"References/namespacestd/#classes","title":"Classes","text":"Type Name struct hash&lt; atlas::vk::vertex_input &gt; &lt;&gt; <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/hash.hpp</code></p>"},{"location":"References/structstd_1_1hash_3_01atlas_1_1vk_1_1vertex__input_01_4/","title":"Struct std::hash&lt; atlas::vk::vertex_input &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; std &gt; hash&lt; atlas::vk::vertex_input &gt;</p>"},{"location":"References/structstd_1_1hash_3_01atlas_1_1vk_1_1vertex__input_01_4/#public-functions","title":"Public Functions","text":"Type Name size_t operator() (const atlas::vk::vertex_input &amp; vertex) const"},{"location":"References/structstd_1_1hash_3_01atlas_1_1vk_1_1vertex__input_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structstd_1_1hash_3_01atlas_1_1vk_1_1vertex__input_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline size_t std::hash&lt; atlas::vk::vertex_input &gt;::operator() (\n    const atlas::vk::vertex_input &amp; vertex\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/hash.hpp</code></p>"},{"location":"References/dir_b67f019f7e2fe784ec01f943d860c92a/","title":"Dir TheAtlasEngine","text":"<p>FileList &gt; TheAtlasEngine</p>"},{"location":"References/dir_b67f019f7e2fe784ec01f943d860c92a/#directories","title":"Directories","text":"Type Name dir atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/</code></p>"},{"location":"References/dir_1e6ffef027cfcf7ded3287660b505c9f/","title":"Dir TheAtlasEngine/atlas","text":"<p>FileList &gt; atlas</p>"},{"location":"References/dir_1e6ffef027cfcf7ded3287660b505c9f/#directories","title":"Directories","text":"Type Name dir components dir core dir drivers dir physics dir renderer dir thread_utils <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/</code></p>"},{"location":"References/dir_7f5341bb8b9b7f96a10597da121f5884/","title":"Dir TheAtlasEngine/atlas/components","text":"<p>FileList &gt; atlas &gt; components</p>"},{"location":"References/dir_7f5341bb8b9b7f96a10597da121f5884/#files","title":"Files","text":"Type Name file transform.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/components/</code></p>"},{"location":"References/transform_8hpp/","title":"File transform.hpp","text":"<p>FileList &gt; atlas &gt; components &gt; transform.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> </ul>"},{"location":"References/transform_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/transform_8hpp/#classes","title":"Classes","text":"Type Name struct transform_physics <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/components/transform.hpp</code></p>"},{"location":"References/transform_8hpp_source/","title":"File transform.hpp","text":"<p>File List &gt; atlas &gt; components &gt; transform.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;glm/glm.hpp&gt;\n\nnamespace atlas {\n\n    // While integrating with the graphics make this transform instead of\n    // transform physics\n\n    // This can be put in components.hpp as tranform after merging and fixing\n    // renderer to have its own component for color and material.\n    struct transform_physics {\n        glm::highp_vec3 position{ 0.f };\n        glm::highp_vec4 quaterion_rotation{ 0.0f, 0.0f, 0.0f, 1.0f };\n        glm::highp_vec3 rotation{ 0.f };\n        glm::highp_vec3 scale{ 1.f };\n    };\n};\n</code></pre>"},{"location":"References/dir_ab5f97e7ae27ba905c508150b2df25d1/","title":"Dir TheAtlasEngine/atlas/core","text":"<p>FileList &gt; atlas &gt; core</p>"},{"location":"References/dir_ab5f97e7ae27ba905c508150b2df25d1/#files","title":"Files","text":"Type Name file api.hpp file application.hpp file core.hpp file engine_logger.hpp file timer.hpp file window.hpp"},{"location":"References/dir_ab5f97e7ae27ba905c508150b2df25d1/#directories","title":"Directories","text":"Type Name dir event dir filesystem dir geometry dir image dir math dir scene dir serialize dir system_framework dir threads dir ui dir update_handlers dir utilities <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/</code></p>"},{"location":"References/dir_b27da4b5790a8b0d69c02bcd8b78255a/","title":"Dir TheAtlasEngine/atlas/core/event","text":"<p>FileList &gt; atlas &gt; core &gt; event</p>"},{"location":"References/dir_b27da4b5790a8b0d69c02bcd8b78255a/#files","title":"Files","text":"Type Name file event.hpp file joystick_codes.hpp file key_codes.hpp file mouse_codes.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/event/</code></p>"},{"location":"References/event_8hpp/","title":"File event.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; event &gt; event.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/event/key_codes.hpp&gt;</code></li> <li><code>#include &lt;core/event/mouse_codes.hpp&gt;</code></li> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/event_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace event"},{"location":"References/event_8hpp/#classes","title":"Classes","text":"Type Name struct joystick_button struct joystick_info <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/event/event.hpp</code></p>"},{"location":"References/event_8hpp_source/","title":"File event.hpp","text":"<p>File List &gt; atlas &gt; core &gt; event &gt; event.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/event/key_codes.hpp&gt;\n#include &lt;core/event/mouse_codes.hpp&gt;\n#include &lt;glm/glm.hpp&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n\nnamespace atlas::event {\n    enum input_state { None, Idle, Pressed, Released };\n\n    struct joystick_button {\n        int ID = -1;\n        std::string Name = \"\";\n        input_state ButtonState = input_state::None;\n        input_state PreviousButtonState = input_state::None;\n    };\n\n    struct joystick_info {\n        int ID = -1;\n        std::string JoystickName = \"Default\";\n        std::map&lt;int, joystick_button&gt; Buttons;\n        std::map&lt;int, bool&gt; ButtonsDown;\n        std::map&lt;int, const float*&gt; AxesOfController;\n    };\n\n    bool is_key_pressed(int p_key);\n\n    bool is_key_released(int p_key);\n\n    bool is_mouse_pressed(int p_mouse_code);\n    bool is_mouse_released(int p_mouse_code);\n\n    glm::vec2 cursor_position();\n\n    // joystic-specific functions\n\n    bool is_joystic_present(int p_controller_id);\n\n    const char* is_joystick_guid(int p_controller_id);\n\n    float get_joystic_axis(int p_controller_id, int p_button);\n\n    // bool is_button_pressed(int p_button_id, int p_controller_id);\n\n    // bool is_button_released(int p_button_id, int p_controller_id);\n\n    bool is_joystick_button_pressed(int p_button);\n\n    bool is_joystick_button_released(int p_button);\n\n    // specific for listening events\n    void update_events();\n\n    void wait_for_events();\n}; // namespace atlas::event\n</code></pre>"},{"location":"References/joystick__codes_8hpp/","title":"File joystick_codes.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; event &gt; joystick_codes.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"References/joystick__codes_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace event"},{"location":"References/joystick__codes_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr int joystick_1   = <code>::atlas::event::JoystickCodes::Joystick1</code> constexpr int joystick_10   = <code>::atlas::event::JoystickCodes::Joystick10</code> constexpr int joystick_11   = <code>::atlas::event::JoystickCodes::Joystick11</code> constexpr int joystick_12   = <code>::atlas::event::JoystickCodes::Joystick12</code> constexpr int joystick_13   = <code>::atlas::event::JoystickCodes::Joystick13</code> constexpr int joystick_14   = <code>::atlas::event::JoystickCodes::Joystick14</code> constexpr int joystick_15   = <code>::atlas::event::JoystickCodes::Joystick15</code> constexpr int joystick_16   = <code>::atlas::event::JoystickCodes::Joystick16</code> constexpr int joystick_2   = <code>::atlas::event::JoystickCodes::Joystick2</code> constexpr int joystick_3   = <code>::atlas::event::JoystickCodes::Joystick3</code> constexpr int joystick_4   = <code>::atlas::event::JoystickCodes::Joystick4</code> constexpr int joystick_5   = <code>::atlas::event::JoystickCodes::Joystick5</code> constexpr int joystick_6   = <code>::atlas::event::JoystickCodes::Joystick6</code> constexpr int joystick_7   = <code>::atlas::event::JoystickCodes::Joystick7</code> constexpr int joystick_8   = <code>::atlas::event::JoystickCodes::Joystick8</code> constexpr int joystick_9   = <code>::atlas::event::JoystickCodes::Joystick9</code> constexpr int joystick_last   = <code>/* multi line expression */</code>"},{"location":"References/joystick__codes_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/joystick__codes_8hpp/#variable-joystick_1","title":"variable joystick_1","text":"<pre><code>constexpr int joystick_1;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_10","title":"variable joystick_10","text":"<pre><code>constexpr int joystick_10;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_11","title":"variable joystick_11","text":"<pre><code>constexpr int joystick_11;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_12","title":"variable joystick_12","text":"<pre><code>constexpr int joystick_12;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_13","title":"variable joystick_13","text":"<pre><code>constexpr int joystick_13;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_14","title":"variable joystick_14","text":"<pre><code>constexpr int joystick_14;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_15","title":"variable joystick_15","text":"<pre><code>constexpr int joystick_15;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_16","title":"variable joystick_16","text":"<pre><code>constexpr int joystick_16;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_2","title":"variable joystick_2","text":"<pre><code>constexpr int joystick_2;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_3","title":"variable joystick_3","text":"<pre><code>constexpr int joystick_3;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_4","title":"variable joystick_4","text":"<pre><code>constexpr int joystick_4;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_5","title":"variable joystick_5","text":"<pre><code>constexpr int joystick_5;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_6","title":"variable joystick_6","text":"<pre><code>constexpr int joystick_6;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_7","title":"variable joystick_7","text":"<pre><code>constexpr int joystick_7;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_8","title":"variable joystick_8","text":"<pre><code>constexpr int joystick_8;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_9","title":"variable joystick_9","text":"<pre><code>constexpr int joystick_9;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_last","title":"variable joystick_last","text":"<pre><code>constexpr int joystick_last;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/event/joystick_codes.hpp</code></p>"},{"location":"References/joystick__codes_8hpp_source/","title":"File joystick_codes.hpp","text":"<p>File List &gt; atlas &gt; core &gt; event &gt; joystick_codes.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n\nnamespace atlas::event {\n    enum JoystickCodes : int {\n        Joystick1 = 0,\n\n        Joystick2 = 1,\n\n        Joystick3 = 2,\n\n        Joystick4 = 3,\n\n        Joystick5 = 4,\n\n        Joystick6 = 5,\n\n        Joystick7 = 6,\n\n        Joystick8 = 7,\n\n        Joystick9 = 8,\n\n        Joystick10 = 9,\n\n        Joystick11 = 10,\n\n        Joystick12 = 11,\n\n        Joystick13 = 12,\n\n        Joystick14 = 13,\n\n        Joystick15 = 14,\n\n        Joystick16 = 15,\n\n        JoystickLAST = Joystick16,\n    };\n}; // namespace atlas\n\ninline constexpr int joystick_1 = ::atlas::event::JoystickCodes::Joystick1;\ninline constexpr int joystick_2 = ::atlas::event::JoystickCodes::Joystick2;\ninline constexpr int joystick_3 = ::atlas::event::JoystickCodes::Joystick3;\ninline constexpr int joystick_4 = ::atlas::event::JoystickCodes::Joystick4;\ninline constexpr int joystick_5 = ::atlas::event::JoystickCodes::Joystick5;\ninline constexpr int joystick_6 = ::atlas::event::JoystickCodes::Joystick6;\ninline constexpr int joystick_7 = ::atlas::event::JoystickCodes::Joystick7;\ninline constexpr int joystick_8 = ::atlas::event::JoystickCodes::Joystick8;\ninline constexpr int joystick_9 = ::atlas::event::JoystickCodes::Joystick9;\ninline constexpr int joystick_10 = ::atlas::event::JoystickCodes::Joystick10;\ninline constexpr int joystick_11 = ::atlas::event::JoystickCodes::Joystick11;\ninline constexpr int joystick_12 = ::atlas::event::JoystickCodes::Joystick12;\ninline constexpr int joystick_13 = ::atlas::event::JoystickCodes::Joystick13;\ninline constexpr int joystick_14 = ::atlas::event::JoystickCodes::Joystick14;\ninline constexpr int joystick_15 = ::atlas::event::JoystickCodes::Joystick15;\ninline constexpr int joystick_16 = ::atlas::event::JoystickCodes::Joystick16;\ninline constexpr int joystick_last =\n  ::atlas::event::JoystickCodes::JoystickLAST;\n</code></pre>"},{"location":"References/key__codes_8hpp/","title":"File key_codes.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; event &gt; key_codes.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"References/key__codes_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace event"},{"location":"References/key__codes_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr uint32_t key_0   = <code>::atlas::event::Key::D0</code> constexpr uint32_t key_1   = <code>::atlas::event::Key::D1</code> constexpr uint32_t key_2   = <code>::atlas::event::Key::D2</code> constexpr uint32_t key_3   = <code>::atlas::event::Key::D3</code> constexpr uint32_t key_4   = <code>::atlas::event::Key::D4</code> constexpr uint32_t key_5   = <code>::atlas::event::Key::D5</code> constexpr uint32_t key_6   = <code>::atlas::event::Key::D6</code> constexpr uint32_t key_7   = <code>::atlas::event::Key::D7</code> constexpr uint32_t key_8   = <code>::atlas::event::Key::D8</code> constexpr uint32_t key_9   = <code>::atlas::event::Key::D9</code> constexpr uint32_t key_a   = <code>::atlas::event::Key::A</code> constexpr uint32_t key_apostrophe   = <code>/* multi line expression */</code> constexpr uint32_t key_b   = <code>::atlas::event::Key::B</code> constexpr uint32_t key_backslash   = <code>/* multi line expression */</code> constexpr uint32_t key_backspace   = <code>::atlas::event::Key::Backspace</code> constexpr uint32_t key_c   = <code>::atlas::event::Key::C</code> constexpr uint32_t key_caps_lock   = <code>::atlas::event::Key::CapsLock</code> constexpr uint32_t key_comma   = <code>::atlas::event::Key::Comma</code> constexpr uint32_t key_d   = <code>::atlas::event::Key::D</code> constexpr uint32_t key_delete   = <code>::atlas::event::Key::Delete</code> constexpr uint32_t key_down   = <code>::atlas::event::Key::Down</code> constexpr uint32_t key_e   = <code>::atlas::event::Key::E</code> constexpr uint32_t key_end   = <code>::atlas::event::Key::End</code> constexpr uint32_t key_enter   = <code>::atlas::event::Key::Enter</code> constexpr uint32_t key_equal   = <code>::atlas::event::Key::Equal</code> constexpr uint32_t key_escape   = <code>::atlas::event::Key::Escape</code> constexpr uint32_t key_f   = <code>::atlas::event::Key::F</code> constexpr uint32_t key_f1   = <code>::atlas::event::Key::F1</code> constexpr uint32_t key_f10   = <code>::atlas::event::Key::F10</code> constexpr uint32_t key_f11   = <code>::atlas::event::Key::F11</code> constexpr uint32_t key_f12   = <code>::atlas::event::Key::F12</code> constexpr uint32_t key_f13   = <code>::atlas::event::Key::F13</code> constexpr uint32_t key_f14   = <code>::atlas::event::Key::F14</code> constexpr uint32_t key_f15   = <code>::atlas::event::Key::F15</code> constexpr uint32_t key_f16   = <code>::atlas::event::Key::F16</code> constexpr uint32_t key_f17   = <code>::atlas::event::Key::F17</code> constexpr uint32_t key_f18   = <code>::atlas::event::Key::F18</code> constexpr uint32_t key_f19   = <code>::atlas::event::Key::F19</code> constexpr uint32_t key_f2   = <code>::atlas::event::Key::F2</code> constexpr uint32_t key_f20   = <code>::atlas::event::Key::F20</code> constexpr uint32_t key_f21   = <code>::atlas::event::Key::F21</code> constexpr uint32_t key_f22   = <code>::atlas::event::Key::F22</code> constexpr uint32_t key_f23   = <code>::atlas::event::Key::F23</code> constexpr uint32_t key_f24   = <code>::atlas::event::Key::F24</code> constexpr uint32_t key_f25   = <code>::atlas::event::Key::F25</code> constexpr uint32_t key_f3   = <code>::atlas::event::Key::F3</code> constexpr uint32_t key_f4   = <code>::atlas::event::Key::F4</code> constexpr uint32_t key_f5   = <code>::atlas::event::Key::F5</code> constexpr uint32_t key_f6   = <code>::atlas::event::Key::F6</code> constexpr uint32_t key_f7   = <code>::atlas::event::Key::F7</code> constexpr uint32_t key_f8   = <code>::atlas::event::Key::F8</code> constexpr uint32_t key_f9   = <code>::atlas::event::Key::F9</code> constexpr uint32_t key_g   = <code>::atlas::event::Key::G</code> constexpr uint32_t key_gravity_accent   = <code>/* multi line expression */</code> constexpr uint32_t key_h   = <code>::atlas::event::Key::H</code> constexpr uint32_t key_home   = <code>::atlas::event::Key::Home</code> constexpr uint32_t key_i   = <code>::atlas::event::Key::I</code> constexpr uint32_t key_insert   = <code>::atlas::event::Key::Insert</code> constexpr uint32_t key_j   = <code>::atlas::event::Key::J</code> constexpr uint32_t key_k   = <code>::atlas::event::Key::K</code> constexpr uint32_t key_kp_0   = <code>::atlas::event::Key::KP0</code> constexpr uint32_t key_kp_1   = <code>::atlas::event::Key::KP1</code> constexpr uint32_t key_kp_2   = <code>::atlas::event::Key::KP2</code> constexpr uint32_t key_kp_3   = <code>::atlas::event::Key::KP3</code> constexpr uint32_t key_kp_4   = <code>::atlas::event::Key::KP4</code> constexpr uint32_t key_kp_5   = <code>::atlas::event::Key::KP5</code> constexpr uint32_t key_kp_6   = <code>::atlas::event::Key::KP6</code> constexpr uint32_t key_kp_7   = <code>::atlas::event::Key::KP7</code> constexpr uint32_t key_kp_8   = <code>::atlas::event::Key::KP8</code> constexpr uint32_t key_kp_9   = <code>::atlas::event::Key::KP9</code> constexpr uint32_t key_kp_add   = <code>::atlas::event::Key::KPAdd</code> constexpr uint32_t key_kp_decimal   = <code>::atlas::event::Key::KPDecimal</code> constexpr uint32_t key_kp_divide   = <code>::atlas::event::Key::KPDivide</code> constexpr uint32_t key_kp_enter   = <code>::atlas::event::Key::KPEnter</code> constexpr uint32_t key_kp_equal   = <code>::atlas::event::Key::KPEqual</code> constexpr uint32_t key_kp_multiply   = <code>::atlas::event::Key::KPMultiply</code> constexpr uint32_t key_kp_subtract   = <code>::atlas::event::Key::KPSubtract</code> constexpr uint32_t key_l   = <code>::atlas::event::Key::L</code> constexpr uint32_t key_left   = <code>::atlas::event::Key::Left</code> constexpr uint32_t key_left_alt   = <code>::atlas::event::Key::LeftAlt</code> constexpr uint32_t key_left_bracket   = <code>/* multi line expression */</code> constexpr uint32_t key_left_control   = <code>::atlas::event::Key::LeftControl</code> constexpr uint32_t key_left_shift   = <code>::atlas::event::Key::LeftShift</code> constexpr uint32_t key_left_super   = <code>::atlas::event::Key::Leftsuper</code> constexpr uint32_t key_m   = <code>::atlas::event::Key::M</code> constexpr uint32_t key_menu   = <code>::atlas::event::Key::Menu</code> constexpr uint32_t key_minus   = <code>::atlas::event::Key::Minus</code> constexpr uint32_t key_n   = <code>::atlas::event::Key::N</code> constexpr uint32_t key_num_lock   = <code>::atlas::event::Key::NumLock</code> constexpr uint32_t key_o   = <code>::atlas::event::Key::O</code> constexpr uint32_t key_p   = <code>::atlas::event::Key::P</code> constexpr uint32_t key_page_down   = <code>::atlas::event::Key::PageDown</code> constexpr uint32_t key_page_up   = <code>::atlas::event::Key::PageUp</code> constexpr uint32_t key_pause   = <code>::atlas::event::Key::Pause</code> constexpr uint32_t key_period   = <code>::atlas::event::Key::Period</code> constexpr uint32_t key_print_screen   = <code>::atlas::event::Key::PrintScreen</code> constexpr uint32_t key_q   = <code>::atlas::event::Key::Q</code> constexpr uint32_t key_r   = <code>::atlas::event::Key::R</code> constexpr uint32_t key_right   = <code>::atlas::event::Key::Right</code> constexpr uint32_t key_right_alt   = <code>::atlas::event::Key::RightAlt</code> constexpr uint32_t key_right_bracket   = <code>/* multi line expression */</code> constexpr uint32_t key_right_control   = <code>::atlas::event::Key::RightControl</code> constexpr uint32_t key_right_shift   = <code>::atlas::event::Key::RightShift</code> constexpr uint32_t key_right_super   = <code>::atlas::event::Key::Rightsuper</code> constexpr uint32_t key_s   = <code>::atlas::event::Key::S</code> constexpr uint32_t key_scroll_lock   = <code>::atlas::event::Key::ScrollLock</code> constexpr uint32_t key_semicolon   = <code>/* multi line expression */</code> constexpr uint32_t key_slash   = <code>::atlas::event::Key::Slash</code> constexpr uint32_t key_space   = <code>::atlas::event::Key::Space</code> constexpr uint32_t key_tab   = <code>::atlas::event::Key::Tab</code> constexpr uint32_t key_u   = <code>::atlas::event::Key::U</code> constexpr uint32_t key_up   = <code>::atlas::event::Key::Up</code> constexpr uint32_t key_v   = <code>::atlas::event::Key::V</code> constexpr uint32_t key_w   = <code>::atlas::event::Key::W</code> constexpr uint32_t key_world_1   = <code>/* multi line expression */</code> constexpr uint32_t key_world_2   = <code>/* multi line expression */</code> constexpr uint32_t key_x   = <code>::atlas::event::Key::X</code> constexpr uint32_t key_y   = <code>::atlas::event::Key::Y</code> constexpr uint32_t key_z   = <code>::atlas::event::Key::Z</code>"},{"location":"References/key__codes_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/key__codes_8hpp/#variable-key_0","title":"variable key_0","text":"<pre><code>constexpr uint32_t key_0;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_1","title":"variable key_1","text":"<pre><code>constexpr uint32_t key_1;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_2","title":"variable key_2","text":"<pre><code>constexpr uint32_t key_2;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_3","title":"variable key_3","text":"<pre><code>constexpr uint32_t key_3;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_4","title":"variable key_4","text":"<pre><code>constexpr uint32_t key_4;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_5","title":"variable key_5","text":"<pre><code>constexpr uint32_t key_5;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_6","title":"variable key_6","text":"<pre><code>constexpr uint32_t key_6;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_7","title":"variable key_7","text":"<pre><code>constexpr uint32_t key_7;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_8","title":"variable key_8","text":"<pre><code>constexpr uint32_t key_8;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_9","title":"variable key_9","text":"<pre><code>constexpr uint32_t key_9;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_a","title":"variable key_a","text":"<pre><code>constexpr uint32_t key_a;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_apostrophe","title":"variable key_apostrophe","text":"<pre><code>constexpr uint32_t key_apostrophe;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_b","title":"variable key_b","text":"<pre><code>constexpr uint32_t key_b;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_backslash","title":"variable key_backslash","text":"<pre><code>constexpr uint32_t key_backslash;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_backspace","title":"variable key_backspace","text":"<pre><code>constexpr uint32_t key_backspace;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_c","title":"variable key_c","text":"<pre><code>constexpr uint32_t key_c;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_caps_lock","title":"variable key_caps_lock","text":"<pre><code>constexpr uint32_t key_caps_lock;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_comma","title":"variable key_comma","text":"<pre><code>constexpr uint32_t key_comma;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_d","title":"variable key_d","text":"<pre><code>constexpr uint32_t key_d;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_delete","title":"variable key_delete","text":"<pre><code>constexpr uint32_t key_delete;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_down","title":"variable key_down","text":"<pre><code>constexpr uint32_t key_down;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_e","title":"variable key_e","text":"<pre><code>constexpr uint32_t key_e;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_end","title":"variable key_end","text":"<pre><code>constexpr uint32_t key_end;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_enter","title":"variable key_enter","text":"<pre><code>constexpr uint32_t key_enter;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_equal","title":"variable key_equal","text":"<pre><code>constexpr uint32_t key_equal;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_escape","title":"variable key_escape","text":"<pre><code>constexpr uint32_t key_escape;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f","title":"variable key_f","text":"<pre><code>constexpr uint32_t key_f;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f1","title":"variable key_f1","text":"<pre><code>constexpr uint32_t key_f1;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f10","title":"variable key_f10","text":"<pre><code>constexpr uint32_t key_f10;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f11","title":"variable key_f11","text":"<pre><code>constexpr uint32_t key_f11;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f12","title":"variable key_f12","text":"<pre><code>constexpr uint32_t key_f12;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f13","title":"variable key_f13","text":"<pre><code>constexpr uint32_t key_f13;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f14","title":"variable key_f14","text":"<pre><code>constexpr uint32_t key_f14;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f15","title":"variable key_f15","text":"<pre><code>constexpr uint32_t key_f15;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f16","title":"variable key_f16","text":"<pre><code>constexpr uint32_t key_f16;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f17","title":"variable key_f17","text":"<pre><code>constexpr uint32_t key_f17;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f18","title":"variable key_f18","text":"<pre><code>constexpr uint32_t key_f18;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f19","title":"variable key_f19","text":"<pre><code>constexpr uint32_t key_f19;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f2","title":"variable key_f2","text":"<pre><code>constexpr uint32_t key_f2;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f20","title":"variable key_f20","text":"<pre><code>constexpr uint32_t key_f20;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f21","title":"variable key_f21","text":"<pre><code>constexpr uint32_t key_f21;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f22","title":"variable key_f22","text":"<pre><code>constexpr uint32_t key_f22;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f23","title":"variable key_f23","text":"<pre><code>constexpr uint32_t key_f23;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f24","title":"variable key_f24","text":"<pre><code>constexpr uint32_t key_f24;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f25","title":"variable key_f25","text":"<pre><code>constexpr uint32_t key_f25;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f3","title":"variable key_f3","text":"<pre><code>constexpr uint32_t key_f3;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f4","title":"variable key_f4","text":"<pre><code>constexpr uint32_t key_f4;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f5","title":"variable key_f5","text":"<pre><code>constexpr uint32_t key_f5;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f6","title":"variable key_f6","text":"<pre><code>constexpr uint32_t key_f6;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f7","title":"variable key_f7","text":"<pre><code>constexpr uint32_t key_f7;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f8","title":"variable key_f8","text":"<pre><code>constexpr uint32_t key_f8;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f9","title":"variable key_f9","text":"<pre><code>constexpr uint32_t key_f9;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_g","title":"variable key_g","text":"<pre><code>constexpr uint32_t key_g;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_gravity_accent","title":"variable key_gravity_accent","text":"<pre><code>constexpr uint32_t key_gravity_accent;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_h","title":"variable key_h","text":"<pre><code>constexpr uint32_t key_h;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_home","title":"variable key_home","text":"<pre><code>constexpr uint32_t key_home;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_i","title":"variable key_i","text":"<pre><code>constexpr uint32_t key_i;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_insert","title":"variable key_insert","text":"<pre><code>constexpr uint32_t key_insert;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_j","title":"variable key_j","text":"<pre><code>constexpr uint32_t key_j;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_k","title":"variable key_k","text":"<pre><code>constexpr uint32_t key_k;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_0","title":"variable key_kp_0","text":"<pre><code>constexpr uint32_t key_kp_0;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_1","title":"variable key_kp_1","text":"<pre><code>constexpr uint32_t key_kp_1;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_2","title":"variable key_kp_2","text":"<pre><code>constexpr uint32_t key_kp_2;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_3","title":"variable key_kp_3","text":"<pre><code>constexpr uint32_t key_kp_3;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_4","title":"variable key_kp_4","text":"<pre><code>constexpr uint32_t key_kp_4;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_5","title":"variable key_kp_5","text":"<pre><code>constexpr uint32_t key_kp_5;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_6","title":"variable key_kp_6","text":"<pre><code>constexpr uint32_t key_kp_6;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_7","title":"variable key_kp_7","text":"<pre><code>constexpr uint32_t key_kp_7;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_8","title":"variable key_kp_8","text":"<pre><code>constexpr uint32_t key_kp_8;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_9","title":"variable key_kp_9","text":"<pre><code>constexpr uint32_t key_kp_9;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_add","title":"variable key_kp_add","text":"<pre><code>constexpr uint32_t key_kp_add;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_decimal","title":"variable key_kp_decimal","text":"<pre><code>constexpr uint32_t key_kp_decimal;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_divide","title":"variable key_kp_divide","text":"<pre><code>constexpr uint32_t key_kp_divide;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_enter","title":"variable key_kp_enter","text":"<pre><code>constexpr uint32_t key_kp_enter;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_equal","title":"variable key_kp_equal","text":"<pre><code>constexpr uint32_t key_kp_equal;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_multiply","title":"variable key_kp_multiply","text":"<pre><code>constexpr uint32_t key_kp_multiply;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_subtract","title":"variable key_kp_subtract","text":"<pre><code>constexpr uint32_t key_kp_subtract;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_l","title":"variable key_l","text":"<pre><code>constexpr uint32_t key_l;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_left","title":"variable key_left","text":"<pre><code>constexpr uint32_t key_left;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_left_alt","title":"variable key_left_alt","text":"<pre><code>constexpr uint32_t key_left_alt;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_left_bracket","title":"variable key_left_bracket","text":"<pre><code>constexpr uint32_t key_left_bracket;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_left_control","title":"variable key_left_control","text":"<pre><code>constexpr uint32_t key_left_control;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_left_shift","title":"variable key_left_shift","text":"<pre><code>constexpr uint32_t key_left_shift;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_left_super","title":"variable key_left_super","text":"<pre><code>constexpr uint32_t key_left_super;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_m","title":"variable key_m","text":"<pre><code>constexpr uint32_t key_m;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_menu","title":"variable key_menu","text":"<pre><code>constexpr uint32_t key_menu;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_minus","title":"variable key_minus","text":"<pre><code>constexpr uint32_t key_minus;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_n","title":"variable key_n","text":"<pre><code>constexpr uint32_t key_n;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_num_lock","title":"variable key_num_lock","text":"<pre><code>constexpr uint32_t key_num_lock;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_o","title":"variable key_o","text":"<pre><code>constexpr uint32_t key_o;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_p","title":"variable key_p","text":"<pre><code>constexpr uint32_t key_p;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_page_down","title":"variable key_page_down","text":"<pre><code>constexpr uint32_t key_page_down;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_page_up","title":"variable key_page_up","text":"<pre><code>constexpr uint32_t key_page_up;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_pause","title":"variable key_pause","text":"<pre><code>constexpr uint32_t key_pause;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_period","title":"variable key_period","text":"<pre><code>constexpr uint32_t key_period;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_print_screen","title":"variable key_print_screen","text":"<pre><code>constexpr uint32_t key_print_screen;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_q","title":"variable key_q","text":"<pre><code>constexpr uint32_t key_q;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_r","title":"variable key_r","text":"<pre><code>constexpr uint32_t key_r;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_right","title":"variable key_right","text":"<pre><code>constexpr uint32_t key_right;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_right_alt","title":"variable key_right_alt","text":"<pre><code>constexpr uint32_t key_right_alt;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_right_bracket","title":"variable key_right_bracket","text":"<pre><code>constexpr uint32_t key_right_bracket;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_right_control","title":"variable key_right_control","text":"<pre><code>constexpr uint32_t key_right_control;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_right_shift","title":"variable key_right_shift","text":"<pre><code>constexpr uint32_t key_right_shift;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_right_super","title":"variable key_right_super","text":"<pre><code>constexpr uint32_t key_right_super;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_s","title":"variable key_s","text":"<pre><code>constexpr uint32_t key_s;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_scroll_lock","title":"variable key_scroll_lock","text":"<pre><code>constexpr uint32_t key_scroll_lock;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_semicolon","title":"variable key_semicolon","text":"<pre><code>constexpr uint32_t key_semicolon;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_slash","title":"variable key_slash","text":"<pre><code>constexpr uint32_t key_slash;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_space","title":"variable key_space","text":"<pre><code>constexpr uint32_t key_space;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_tab","title":"variable key_tab","text":"<pre><code>constexpr uint32_t key_tab;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_u","title":"variable key_u","text":"<pre><code>constexpr uint32_t key_u;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_up","title":"variable key_up","text":"<pre><code>constexpr uint32_t key_up;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_v","title":"variable key_v","text":"<pre><code>constexpr uint32_t key_v;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_w","title":"variable key_w","text":"<pre><code>constexpr uint32_t key_w;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_world_1","title":"variable key_world_1","text":"<pre><code>constexpr uint32_t key_world_1;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_world_2","title":"variable key_world_2","text":"<pre><code>constexpr uint32_t key_world_2;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_x","title":"variable key_x","text":"<pre><code>constexpr uint32_t key_x;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_y","title":"variable key_y","text":"<pre><code>constexpr uint32_t key_y;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_z","title":"variable key_z","text":"<pre><code>constexpr uint32_t key_z;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/event/key_codes.hpp</code></p>"},{"location":"References/key__codes_8hpp_source/","title":"File key_codes.hpp","text":"<p>File List &gt; atlas &gt; core &gt; event &gt; key_codes.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n\nnamespace atlas::event {\n    enum Key : uint32_t {\n        // From glfw3.h\n        Space = 32,\n        Apostrophe = 39, /* ' */\n        Comma = 44,      /* , */\n        Minus = 45,      /* - */\n        Period = 46,     /* . */\n        Slash = 47,      /* / */\n\n        D0 = 48, /* 0 */\n        D1 = 49, /* 1 */\n        D2 = 50, /* 2 */\n        D3 = 51, /* 3 */\n        D4 = 52, /* 4 */\n        D5 = 53, /* 5 */\n        D6 = 54, /* 6 */\n        D7 = 55, /* 7 */\n        D8 = 56, /* 8 */\n        D9 = 57, /* 9 */\n\n        Semicolon = 59, /* ; */\n        Equal = 61,     /* = */\n\n        A = 65,\n        B = 66,\n        C = 67,\n        D = 68,\n        E = 69,\n        F = 70,\n        G = 71,\n        H = 72,\n        I = 73,\n        J = 74,\n        K = 75,\n        L = 76,\n        M = 77,\n        N = 78,\n        O = 79,\n        P = 80,\n        Q = 81,\n        R = 82,\n        S = 83,\n        T = 84,\n        U = 85,\n        V = 86,\n        W = 87,\n        X = 88,\n        Y = 89,\n        Z = 90,\n\n        LeftBracket = 91,  /* [ */\n        Backslash = 92,    /* \\ */\n        RightBracket = 93, /* ] */\n        GraveAccent = 96,  /* ` */\n\n        World1 = 161, /* non-US #1 */\n        World2 = 162, /* non-US #2 */\n\n        /* Function keys */\n        Escape = 256,\n        Enter = 257,\n        Tab = 258,\n        Backspace = 259,\n        Insert = 260,\n        Delete = 261,\n        Right = 262,\n        Left = 263,\n        Down = 264,\n        Up = 265,\n        PageUp = 266,\n        PageDown = 267,\n        Home = 268,\n        End = 269,\n        CapsLock = 280,\n        ScrollLock = 281,\n        NumLock = 282,\n        PrintScreen = 283,\n        Pause = 284,\n        F1 = 290,\n        F2 = 291,\n        F3 = 292,\n        F4 = 293,\n        F5 = 294,\n        F6 = 295,\n        F7 = 296,\n        F8 = 297,\n        F9 = 298,\n        F10 = 299,\n        F11 = 300,\n        F12 = 301,\n        F13 = 302,\n        F14 = 303,\n        F15 = 304,\n        F16 = 305,\n        F17 = 306,\n        F18 = 307,\n        F19 = 308,\n        F20 = 309,\n        F21 = 310,\n        F22 = 311,\n        F23 = 312,\n        F24 = 313,\n        F25 = 314,\n\n        /* Keypad */\n        KP0 = 320,\n        KP1 = 321,\n        KP2 = 322,\n        KP3 = 323,\n        KP4 = 324,\n        KP5 = 325,\n        KP6 = 326,\n        KP7 = 327,\n        KP8 = 328,\n        KP9 = 329,\n        KPDecimal = 330,\n        KPDivide = 331,\n        KPMultiply = 332,\n        KPSubtract = 333,\n        KPAdd = 334,\n        KPEnter = 335,\n        KPEqual = 336,\n\n        LeftShift = 340,\n        LeftControl = 341,\n        LeftAlt = 342,\n        Leftsuper = 343,\n        RightShift = 344,\n        RightControl = 345,\n        RightAlt = 346,\n        Rightsuper = 347,\n        Menu = 348\n    };\n}\n\n// From glfw3.h\n\ninline constexpr uint32_t key_space = ::atlas::event::Key::Space;\ninline constexpr uint32_t key_apostrophe =\n  ::atlas::event::Key::Apostrophe;                                  /* ' */\ninline constexpr uint32_t key_comma = ::atlas::event::Key::Comma;   /* , */\ninline constexpr uint32_t key_minus = ::atlas::event::Key::Minus;   /* - */\ninline constexpr uint32_t key_period = ::atlas::event::Key::Period; /* . */\ninline constexpr uint32_t key_slash = ::atlas::event::Key::Slash;   /* / */\ninline constexpr uint32_t key_0 = ::atlas::event::Key::D0;\ninline constexpr uint32_t key_1 = ::atlas::event::Key::D1;\ninline constexpr uint32_t key_2 = ::atlas::event::Key::D2;\ninline constexpr uint32_t key_3 = ::atlas::event::Key::D3;\ninline constexpr uint32_t key_4 = ::atlas::event::Key::D4;\ninline constexpr uint32_t key_5 = ::atlas::event::Key::D5;\ninline constexpr uint32_t key_6 = ::atlas::event::Key::D6;\ninline constexpr uint32_t key_7 = ::atlas::event::Key::D7;\ninline constexpr uint32_t key_8 = ::atlas::event::Key::D8;\ninline constexpr uint32_t key_9 = ::atlas::event::Key::D9;\ninline constexpr uint32_t key_semicolon =\n  ::atlas::event::Key::Semicolon;                                 /* ; */\ninline constexpr uint32_t key_equal = ::atlas::event::Key::Equal; /* = */\ninline constexpr uint32_t key_a = ::atlas::event::Key::A;\ninline constexpr uint32_t key_b = ::atlas::event::Key::B;\ninline constexpr uint32_t key_c = ::atlas::event::Key::C;\ninline constexpr uint32_t key_d = ::atlas::event::Key::D;\ninline constexpr uint32_t key_e = ::atlas::event::Key::E;\ninline constexpr uint32_t key_f = ::atlas::event::Key::F;\ninline constexpr uint32_t key_g = ::atlas::event::Key::G;\ninline constexpr uint32_t key_h = ::atlas::event::Key::H;\ninline constexpr uint32_t key_i = ::atlas::event::Key::I;\ninline constexpr uint32_t key_j = ::atlas::event::Key::J;\ninline constexpr uint32_t key_k = ::atlas::event::Key::K;\ninline constexpr uint32_t key_l = ::atlas::event::Key::L;\ninline constexpr uint32_t key_m = ::atlas::event::Key::M;\ninline constexpr uint32_t key_n = ::atlas::event::Key::N;\ninline constexpr uint32_t key_o = ::atlas::event::Key::O;\ninline constexpr uint32_t key_p = ::atlas::event::Key::P;\ninline constexpr uint32_t key_q = ::atlas::event::Key::Q;\ninline constexpr uint32_t key_r = ::atlas::event::Key::R;\ninline constexpr uint32_t key_s = ::atlas::event::Key::S;\n// inline constexpr uint32_t key_t = ::atlas::event::Key::T;\ninline constexpr uint32_t key_u = ::atlas::event::Key::U;\ninline constexpr uint32_t key_v = ::atlas::event::Key::V;\ninline constexpr uint32_t key_w = ::atlas::event::Key::W;\ninline constexpr uint32_t key_x = ::atlas::event::Key::X;\ninline constexpr uint32_t key_y = ::atlas::event::Key::Y;\ninline constexpr uint32_t key_z = ::atlas::event::Key::Z;\ninline constexpr uint32_t key_left_bracket =\n  ::atlas::event::Key::LeftBracket; /* [ */\ninline constexpr uint32_t key_backslash =\n  ::atlas::event::Key::Backslash; /* \\ */\ninline constexpr uint32_t key_right_bracket =\n  ::atlas::event::Key::RightBracket; /* ] */\ninline constexpr uint32_t key_gravity_accent =\n  ::atlas::event::Key::GraveAccent; /* ` */\ninline constexpr uint32_t key_world_1 =\n  ::atlas::event::Key::World1; /* non-US #1 */\ninline constexpr uint32_t key_world_2 =\n  ::atlas::event::Key::World2; /* non-US #2 */\n\n/* Function keys */\ninline constexpr uint32_t key_escape = ::atlas::event::Key::Escape;\ninline constexpr uint32_t key_enter = ::atlas::event::Key::Enter;\ninline constexpr uint32_t key_tab = ::atlas::event::Key::Tab;\ninline constexpr uint32_t key_backspace = ::atlas::event::Key::Backspace;\ninline constexpr uint32_t key_insert = ::atlas::event::Key::Insert;\ninline constexpr uint32_t key_delete = ::atlas::event::Key::Delete;\ninline constexpr uint32_t key_right = ::atlas::event::Key::Right;\ninline constexpr uint32_t key_left = ::atlas::event::Key::Left;\ninline constexpr uint32_t key_down = ::atlas::event::Key::Down;\ninline constexpr uint32_t key_up = ::atlas::event::Key::Up;\ninline constexpr uint32_t key_page_up = ::atlas::event::Key::PageUp;\ninline constexpr uint32_t key_page_down = ::atlas::event::Key::PageDown;\ninline constexpr uint32_t key_home = ::atlas::event::Key::Home;\ninline constexpr uint32_t key_end = ::atlas::event::Key::End;\ninline constexpr uint32_t key_caps_lock = ::atlas::event::Key::CapsLock;\ninline constexpr uint32_t key_scroll_lock = ::atlas::event::Key::ScrollLock;\ninline constexpr uint32_t key_num_lock = ::atlas::event::Key::NumLock;\ninline constexpr uint32_t key_print_screen = ::atlas::event::Key::PrintScreen;\ninline constexpr uint32_t key_pause = ::atlas::event::Key::Pause;\ninline constexpr uint32_t key_f1 = ::atlas::event::Key::F1;\ninline constexpr uint32_t key_f2 = ::atlas::event::Key::F2;\ninline constexpr uint32_t key_f3 = ::atlas::event::Key::F3;\ninline constexpr uint32_t key_f4 = ::atlas::event::Key::F4;\ninline constexpr uint32_t key_f5 = ::atlas::event::Key::F5;\ninline constexpr uint32_t key_f6 = ::atlas::event::Key::F6;\ninline constexpr uint32_t key_f7 = ::atlas::event::Key::F7;\ninline constexpr uint32_t key_f8 = ::atlas::event::Key::F8;\ninline constexpr uint32_t key_f9 = ::atlas::event::Key::F9;\ninline constexpr uint32_t key_f10 = ::atlas::event::Key::F10;\ninline constexpr uint32_t key_f11 = ::atlas::event::Key::F11;\ninline constexpr uint32_t key_f12 = ::atlas::event::Key::F12;\ninline constexpr uint32_t key_f13 = ::atlas::event::Key::F13;\ninline constexpr uint32_t key_f14 = ::atlas::event::Key::F14;\ninline constexpr uint32_t key_f15 = ::atlas::event::Key::F15;\ninline constexpr uint32_t key_f16 = ::atlas::event::Key::F16;\ninline constexpr uint32_t key_f17 = ::atlas::event::Key::F17;\ninline constexpr uint32_t key_f18 = ::atlas::event::Key::F18;\ninline constexpr uint32_t key_f19 = ::atlas::event::Key::F19;\ninline constexpr uint32_t key_f20 = ::atlas::event::Key::F20;\ninline constexpr uint32_t key_f21 = ::atlas::event::Key::F21;\ninline constexpr uint32_t key_f22 = ::atlas::event::Key::F22;\ninline constexpr uint32_t key_f23 = ::atlas::event::Key::F23;\ninline constexpr uint32_t key_f24 = ::atlas::event::Key::F24;\ninline constexpr uint32_t key_f25 = ::atlas::event::Key::F25;\n\n/* Keypad */\ninline constexpr uint32_t key_kp_0 = ::atlas::event::Key::KP0;\ninline constexpr uint32_t key_kp_1 = ::atlas::event::Key::KP1;\ninline constexpr uint32_t key_kp_2 = ::atlas::event::Key::KP2;\ninline constexpr uint32_t key_kp_3 = ::atlas::event::Key::KP3;\ninline constexpr uint32_t key_kp_4 = ::atlas::event::Key::KP4;\ninline constexpr uint32_t key_kp_5 = ::atlas::event::Key::KP5;\ninline constexpr uint32_t key_kp_6 = ::atlas::event::Key::KP6;\ninline constexpr uint32_t key_kp_7 = ::atlas::event::Key::KP7;\ninline constexpr uint32_t key_kp_8 = ::atlas::event::Key::KP8;\ninline constexpr uint32_t key_kp_9 = ::atlas::event::Key::KP9;\ninline constexpr uint32_t key_kp_decimal = ::atlas::event::Key::KPDecimal;\ninline constexpr uint32_t key_kp_divide = ::atlas::event::Key::KPDivide;\ninline constexpr uint32_t key_kp_multiply = ::atlas::event::Key::KPMultiply;\ninline constexpr uint32_t key_kp_subtract = ::atlas::event::Key::KPSubtract;\ninline constexpr uint32_t key_kp_add = ::atlas::event::Key::KPAdd;\ninline constexpr uint32_t key_kp_enter = ::atlas::event::Key::KPEnter;\ninline constexpr uint32_t key_kp_equal = ::atlas::event::Key::KPEqual;\n\ninline constexpr uint32_t key_left_shift = ::atlas::event::Key::LeftShift;\ninline constexpr uint32_t key_left_control = ::atlas::event::Key::LeftControl;\ninline constexpr uint32_t key_left_alt = ::atlas::event::Key::LeftAlt;\ninline constexpr uint32_t key_left_super = ::atlas::event::Key::Leftsuper;\ninline constexpr uint32_t key_right_shift = ::atlas::event::Key::RightShift;\ninline constexpr uint32_t key_right_control = ::atlas::event::Key::RightControl;\ninline constexpr uint32_t key_right_alt = ::atlas::event::Key::RightAlt;\ninline constexpr uint32_t key_right_super = ::atlas::event::Key::Rightsuper;\ninline constexpr uint32_t key_menu = ::atlas::event::Key::Menu;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/","title":"File mouse_codes.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; event &gt; mouse_codes.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"References/mouse__codes_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace event"},{"location":"References/mouse__codes_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr uint32_t mouse_button_0   = <code>::atlas::event::Mouse::Button0</code> constexpr uint32_t mouse_button_1   = <code>::atlas::event::Mouse::Button1</code> constexpr uint32_t mouse_button_2   = <code>::atlas::event::Mouse::Button2</code> constexpr uint32_t mouse_button_3   = <code>::atlas::event::Mouse::Button3</code> constexpr uint32_t mouse_button_4   = <code>::atlas::event::Mouse::Button4</code> constexpr uint32_t mouse_button_5   = <code>::atlas::event::Mouse::Button5</code> constexpr uint32_t mouse_button_6   = <code>::atlas::event::Mouse::Button6</code> constexpr uint32_t mouse_button_7   = <code>::atlas::event::Mouse::Button7</code> constexpr uint32_t mouse_button_last   = <code>::atlas::event::Mouse::ButtonLast</code> constexpr uint32_t mouse_button_left   = <code>::atlas::event::Mouse::ButtonLeft</code> constexpr uint32_t mouse_button_middle   = <code>/* multi line expression */</code> constexpr uint32_t mouse_button_right   = <code>/* multi line expression */</code>"},{"location":"References/mouse__codes_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_0","title":"variable mouse_button_0","text":"<pre><code>constexpr uint32_t mouse_button_0;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_1","title":"variable mouse_button_1","text":"<pre><code>constexpr uint32_t mouse_button_1;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_2","title":"variable mouse_button_2","text":"<pre><code>constexpr uint32_t mouse_button_2;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_3","title":"variable mouse_button_3","text":"<pre><code>constexpr uint32_t mouse_button_3;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_4","title":"variable mouse_button_4","text":"<pre><code>constexpr uint32_t mouse_button_4;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_5","title":"variable mouse_button_5","text":"<pre><code>constexpr uint32_t mouse_button_5;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_6","title":"variable mouse_button_6","text":"<pre><code>constexpr uint32_t mouse_button_6;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_7","title":"variable mouse_button_7","text":"<pre><code>constexpr uint32_t mouse_button_7;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_last","title":"variable mouse_button_last","text":"<pre><code>constexpr uint32_t mouse_button_last;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_left","title":"variable mouse_button_left","text":"<pre><code>constexpr uint32_t mouse_button_left;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_middle","title":"variable mouse_button_middle","text":"<pre><code>constexpr uint32_t mouse_button_middle;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_right","title":"variable mouse_button_right","text":"<pre><code>constexpr uint32_t mouse_button_right;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/event/mouse_codes.hpp</code></p>"},{"location":"References/mouse__codes_8hpp_source/","title":"File mouse_codes.hpp","text":"<p>File List &gt; atlas &gt; core &gt; event &gt; mouse_codes.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n\nnamespace atlas::event {\n    enum Mouse : uint32_t {\n        // From glfw3.h\n        Button0 = 0,\n        Button1 = 1,\n        Button2 = 2,\n        Button3 = 3,\n        Button4 = 4,\n        Button5 = 5,\n        Button6 = 6,\n        Button7 = 7,\n\n        ButtonLast = Button7,\n        ButtonLeft = Button0,\n        ButtonRight = Button1,\n        ButtonMiddle = Button2\n    };\n\n} // namespace atlas\n\ninline constexpr uint32_t mouse_button_0 = ::atlas::event::Mouse::Button0;\ninline constexpr uint32_t mouse_button_1 = ::atlas::event::Mouse::Button1;\ninline constexpr uint32_t mouse_button_2 = ::atlas::event::Mouse::Button2;\ninline constexpr uint32_t mouse_button_3 = ::atlas::event::Mouse::Button3;\ninline constexpr uint32_t mouse_button_4 = ::atlas::event::Mouse::Button4;\ninline constexpr uint32_t mouse_button_5 = ::atlas::event::Mouse::Button5;\ninline constexpr uint32_t mouse_button_6 = ::atlas::event::Mouse::Button6;\ninline constexpr uint32_t mouse_button_7 = ::atlas::event::Mouse::Button7;\ninline constexpr uint32_t mouse_button_last = ::atlas::event::Mouse::ButtonLast;\ninline constexpr uint32_t mouse_button_left = ::atlas::event::Mouse::ButtonLeft;\ninline constexpr uint32_t mouse_button_right =\n  ::atlas::event::Mouse::ButtonRight;\ninline constexpr uint32_t mouse_button_middle =\n  ::atlas::event::Mouse::ButtonMiddle;\n</code></pre>"},{"location":"References/dir_27ba7cf633e68cf06fb2d9a5a7eda525/","title":"Dir TheAtlasEngine/atlas/core/filesystem","text":"<p>FileList &gt; atlas &gt; core &gt; filesystem</p>"},{"location":"References/dir_27ba7cf633e68cf06fb2d9a5a7eda525/#files","title":"Files","text":"Type Name file file_dialog.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/filesystem/</code></p>"},{"location":"References/file__dialog_8hpp/","title":"File file_dialog.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; filesystem &gt; file_dialog.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/file__dialog_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace filesystem <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/filesystem/file_dialog.hpp</code></p>"},{"location":"References/file__dialog_8hpp_source/","title":"File file_dialog.hpp","text":"<p>File List &gt; atlas &gt; core &gt; filesystem &gt; file_dialog.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n\nnamespace atlas::filesystem {\n    std::string load_from_file_dialog(const std::string&amp; p_filter);\n\n    std::string save_to_file(const std::string&amp; p_filter);\n}; // namespace atlas::filesystem\n</code></pre>"},{"location":"References/dir_b5becf243c0000df8fbe7c991f964f21/","title":"Dir TheAtlasEngine/atlas/core/geometry","text":"<p>FileList &gt; atlas &gt; core &gt; geometry</p>"},{"location":"References/dir_b5becf243c0000df8fbe7c991f964f21/#files","title":"Files","text":"Type Name file mesh.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/geometry/</code></p>"},{"location":"References/core_2geometry_2mesh_8hpp/","title":"File mesh.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; geometry &gt; mesh.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/core_2geometry_2mesh_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/core_2geometry_2mesh_8hpp/#classes","title":"Classes","text":"Type Name class mesh <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/geometry/mesh.hpp</code></p>"},{"location":"References/core_2geometry_2mesh_8hpp_source/","title":"File mesh.hpp","text":"<p>File List &gt; atlas &gt; core &gt; geometry &gt; mesh.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n\nnamespace atlas {\n    class mesh {\n    public:\n        mesh() = default;\n        // TODO: Change this because UNUSED!!!\n        mesh(const std::string&amp; p_filepath);\n    };\n};\n</code></pre>"},{"location":"References/dir_3050860d9c50f9f4f11f08b3bfb0b023/","title":"Dir TheAtlasEngine/atlas/core/image","text":"<p>FileList &gt; atlas &gt; core &gt; image</p>"},{"location":"References/dir_3050860d9c50f9f4f11f08b3bfb0b023/#files","title":"Files","text":"Type Name file stb_image.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/image/</code></p>"},{"location":"References/stb__image_8hpp/","title":"File stb_image.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; image &gt; stb_image.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;stb_image.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/image/stb_image.hpp</code></p>"},{"location":"References/stb__image_8hpp_source/","title":"File stb_image.hpp","text":"<p>File List &gt; atlas &gt; core &gt; image &gt; stb_image.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;stb_image.h&gt;\n</code></pre>"},{"location":"References/dir_cd513ce3e965767955df67d416f47de6/","title":"Dir TheAtlasEngine/atlas/core/math","text":"<p>FileList &gt; atlas &gt; core &gt; math</p>"},{"location":"References/dir_cd513ce3e965767955df67d416f47de6/#files","title":"Files","text":"Type Name file math.hpp file types.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/</code></p>"},{"location":"References/math_8hpp/","title":"File math.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; math &gt; math.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;glm/detail/qualifier.hpp&gt;</code></li> <li><code>#include &lt;glm/fwd.hpp&gt;</code></li> </ul>"},{"location":"References/math_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/math_8hpp/#classes","title":"Classes","text":"Type Name class interpolation <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/math.hpp</code></p>"},{"location":"References/math_8hpp_source/","title":"File math.hpp","text":"<p>File List &gt; atlas &gt; core &gt; math &gt; math.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;functional&gt;\n#include &lt;glm/detail/qualifier.hpp&gt;\n#include &lt;glm/fwd.hpp&gt;\n\nnamespace atlas {\n\n    class interpolation {\n    public:\n        template&lt;typename T&gt;\n        static T linear_interpolate(T start,\n                                    T end,\n                                    const std::function&lt;float(float)&gt;&amp; function,\n                                    float t) {\n            float l_adjusted_time = 0.0f;\n            if (!function) {\n                l_adjusted_time = t;\n            }\n            else {\n                const float f = function(t);\n                l_adjusted_time = f;\n            }\n            if (l_adjusted_time &lt; 0) {\n                l_adjusted_time = 0.0f;\n            }\n            if (l_adjusted_time &gt; 1.0f) {\n                l_adjusted_time = 1.0f;\n            }\n\n            float time_dif = 1.0f - l_adjusted_time;\n\n            return start * time_dif + end * l_adjusted_time;\n        }\n\n    private:\n        interpolation() = default;\n    };\n}; // namespace atlas\n</code></pre>"},{"location":"References/core_2math_2types_8hpp/","title":"File types.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; math &gt; types.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> <li><code>#include &lt;initializer_list&gt;</code></li> </ul>"},{"location":"References/core_2math_2types_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/core_2math_2types_8hpp/#classes","title":"Classes","text":"Type Name struct vector2&lt; glm::highp_vec2 &gt; &lt;&gt; struct vector3 &lt;typename T&gt; struct vector3&lt; glm::highp_vec3 &gt; &lt;&gt; struct vector4 &lt;typename T&gt; struct vector4&lt; glm::highp_vec4 &gt; &lt;&gt; <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/core_2math_2types_8hpp_source/","title":"File types.hpp","text":"<p>File List &gt; atlas &gt; core &gt; math &gt; types.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;glm/glm.hpp&gt;\n#include &lt;initializer_list&gt;\n\nnamespace atlas {\n\n    /*\n    Will not be handling it like this, my reasons for changing it is within the\n    test cases I made that uses the new approach to doing this template&lt;typename\n    T&gt; concept IsVec2 = requires(T vec2){ { vec2.x } -&gt;\n    std::convertible_to&lt;float&gt;; { vec2.y } -&gt; std::convertible_to&lt;float&gt;;\n    };\n\n    template&lt;typename T&gt;\n    concept IsVec3 = requires(T vec3){\n        { vec3.x } -&gt; std::convertible_to&lt;float&gt;;\n        { vec3.y } -&gt; std::convertible_to&lt;float&gt;;\n        { vec3.z } -&gt; std::convertible_to&lt;float&gt;;\n    };\n\n    template&lt;typename T&gt;\n    concept IsVec4 = requires(T vec4){\n        { vec4.x } -&gt; std::convertible_to&lt;float&gt;;\n        { vec4.y } -&gt; std::convertible_to&lt;float&gt;;\n        { vec4.z } -&gt; std::convertible_to&lt;float&gt;;\n        { vec4.w } -&gt; std::convertible_to&lt;float&gt;;\n    };\n    */\n\n    template&lt;typename T&gt;\n    struct vector2;\n\n    template&lt;typename T&gt;\n    struct vector3 {\n        vector3() = default;\n\n        vector3(const T&amp; p_other)\n          : m_value(p_other) {}\n\n        vector3(float x, float y, float z)\n          : m_value(x, y, z) {}\n        vector3(const std::initializer_list&lt;float&gt;&amp; values)\n          : m_value(*values.begin(), *values.begin() + 1, *values.begin() + 2) {\n        }\n\n        operator glm::vec3() { return m_value; }\n\n        glm::vec3 operator=(const T&amp; p_other) { return p_other; }\n\n        bool operator==(const glm::vec3&amp; p_other) {\n            return (m_value.x == p_other.x and m_value.y == p_other.y and\n                    m_value.z == p_other.z);\n        }\n\n    private:\n        glm::vec3 m_value;\n    };\n\n    template&lt;typename T&gt;\n    struct vector4 {\n        vector4() = default;\n\n        vector4(const T&amp; p_other)\n          : m_value(p_other) {}\n\n        vector4(float x, float y, float z, float w)\n          : m_value(x, y, z, w) {}\n\n        operator glm::vec4() { return m_value; }\n\n        glm::vec4 operator=(const T&amp; p_other) { return p_other; }\n\n        bool operator==(const glm::vec4&amp; p_other) {\n            return (m_value.x == p_other.x and m_value.y == p_other.y and\n                    m_value.z == p_other.z and m_value.w == p_other.w);\n        }\n\n    private:\n        glm::vec4 m_value;\n    };\n\n    template&lt;&gt;\n    struct vector2&lt;glm::highp_vec2&gt; {\n        vector2() = default;\n\n        vector2(const glm::highp_vec2&amp; p_other)\n          : m_value(p_other) {}\n\n        operator glm::highp_vec2() { return m_value; }\n\n        glm::highp_vec2 operator=(const glm::highp_vec2&amp; p_other) {\n            return p_other;\n        }\n\n        bool operator==(const glm::vec4&amp; p_other) {\n            return (m_value.x == p_other.x and m_value.y == p_other.y);\n        }\n\n    private:\n        glm::highp_vec2 m_value;\n    };\n\n    template&lt;&gt;\n    struct vector3&lt;glm::highp_vec3&gt; {\n        vector3() = default;\n\n        vector3(const glm::highp_vec3&amp; p_other)\n          : m_value(p_other) {}\n\n        operator glm::highp_vec3() { return m_value; }\n\n        glm::highp_vec3 operator=(const glm::highp_vec3&amp; p_other) {\n            return p_other;\n        }\n\n        bool operator==(const glm::highp_vec3&amp; p_other) {\n            return (m_value.x == p_other.x and m_value.y == p_other.y and\n                    m_value.z == p_other.z);\n        }\n\n    private:\n        glm::highp_vec3 m_value;\n    };\n\n    template&lt;&gt;\n    struct vector4&lt;glm::highp_vec4&gt; {\n        vector4() = default;\n\n        vector4(const glm::highp_vec4&amp; p_other)\n          : m_value(p_other) {}\n\n        operator glm::highp_vec4() { return m_value; }\n\n        glm::highp_vec4 operator=(const glm::highp_vec4&amp; p_other) {\n            return p_other;\n        }\n\n        bool operator==(const glm::highp_vec4&amp; p_other) {\n            return (m_value.x == p_other.x and m_value.y == p_other.y and\n                    m_value.z == p_other.z and m_value.w == p_other.w);\n        }\n\n    private:\n        glm::highp_vec4 m_value;\n    };\n\n    template&lt;typename T&gt;\n    struct math_generic;\n\n    template&lt;typename T&gt;\n    struct matrix2;\n\n    template&lt;typename T&gt;\n    struct matrix3;\n\n    template&lt;typename T&gt;\n    struct matrix4;\n\n    template&lt;size_t Size, typename T&gt;\n    using vec = math_generic&lt;glm::vec&lt;Size, T&gt;&gt;;\n    using vec2 = vector2&lt;glm::vec2&gt;;\n    using vec3 = vector3&lt;glm::vec3&gt;;\n    using vec4 = vector4&lt;glm::vec4&gt;;\n\n    using highp_vec2 = vector2&lt;glm::highp_vec2&gt;;\n    using highp_vec3 = vector3&lt;glm::highp_vec3&gt;;\n    using highp_vec4 = vector4&lt;glm::highp_vec4&gt;;\n\n    template&lt;size_t C, size_t R, typename T&gt;\n    using mat = math_generic&lt;glm::mat&lt;C, R, T&gt;&gt;;\n\n    using mat2 = matrix2&lt;glm::mat2&gt;;\n    using mat3 = matrix3&lt;glm::mat3&gt;;\n    using mat4 = matrix4&lt;glm::mat4&gt;;\n}; // namespace atlas\n</code></pre>"},{"location":"References/dir_50632568389acd88e20d4049896804e3/","title":"Dir TheAtlasEngine/atlas/core/scene","text":"<p>FileList &gt; atlas &gt; core &gt; scene</p>"},{"location":"References/dir_50632568389acd88e20d4049896804e3/#files","title":"Files","text":"Type Name file components.hpp file entity.hpp file scene.hpp file scene_object.hpp file world.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/</code></p>"},{"location":"References/components_8hpp/","title":"File components.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; scene &gt; components.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/application.hpp&gt;</code></li> <li><code>#include &lt;core/geometry/mesh.hpp&gt;</code></li> <li><code>#include &lt;glm/ext/quaternion_transform.hpp&gt;</code></li> <li><code>#include &lt;glm/gtx/quaternion.hpp&gt;</code></li> <li><code>#include &lt;glm/gtc/matrix_transform.hpp&gt;</code></li> <li><code>#include &lt;glm/gtc/type_ptr.hpp&gt;</code></li> <li><code>#include &lt;glm/gtx/matrix_decompose.hpp&gt;</code></li> </ul>"},{"location":"References/components_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/components_8hpp/#classes","title":"Classes","text":"Type Name struct box_collider3d class camera struct light TODO: Make this better (when we do lighting) struct material struct reload Actually might do a query for this along with rendertarget3d. struct rigidbody3d struct tag struct transform"},{"location":"References/components_8hpp/#macros","title":"Macros","text":"Type Name define GLM_ENABLE_EXPERIMENTAL"},{"location":"References/components_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"References/components_8hpp/#define-glm_enable_experimental","title":"define GLM_ENABLE_EXPERIMENTAL","text":"<pre><code>#define GLM_ENABLE_EXPERIMENTAL \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/components.hpp</code></p>"},{"location":"References/components_8hpp_source/","title":"File components.hpp","text":"<p>File List &gt; atlas &gt; core &gt; scene &gt; components.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/application.hpp&gt;\n#include &lt;core/geometry/mesh.hpp&gt;\n#include &lt;glm/ext/quaternion_transform.hpp&gt;\n\n#define GLM_ENABLE_EXPERIMENTAL\n#include &lt;glm/gtx/quaternion.hpp&gt;\n\n#include &lt;glm/gtc/matrix_transform.hpp&gt;\n#include &lt;glm/gtc/type_ptr.hpp&gt;\n#include &lt;glm/gtx/matrix_decompose.hpp&gt;\n\nnamespace atlas {\n    struct tag {\n        std::string TagMetadata = \"\";\n    };\n\n    struct transform {\n        glm::highp_vec3 Position{ 0.f };\n        glm::highp_vec4 QuaternionRotation{ 0.f, 0, 0, 1 };\n        glm::highp_vec3 Rotation{ 0.f };\n        glm::highp_vec3 Scale{ 1.f };\n    };\n\n    struct rigidbody3d {\n        rigidbody3d() = default;\n\n        enum class body_type { e_static = 0, e_dynamic = 1, e_kinematic = 2 };\n\n        body_type type = body_type::e_static;\n        bool hax_fixation = false;\n        void* body_at_runtime =\n          nullptr; // for storing the actual data of the body\n    };\n\n    struct box_collider3d {\n        box_collider3d() = default;\n        box_collider3d(const box_collider3d&amp;) = default;\n\n        float density = 1.0f;\n        float friction = 0.5f;\n        float restitution = 0.0f;\n        float restitutionThreshold = 0.5f;\n\n        glm::vec3 offset = { 0.f, 0.f, 0.f };\n        glm::vec3 size = { 0.5f, 0.5f, 0.5f };\n    };\n\n    // Defines several possible options for camera movement. Used as abstraction\n    // to stay away from window-system specific input methods\n    enum CameraMovement { forward, backward, left, right, up, down };\n\n    // An abstract camera class that processes input and calculates the\n    // corresponding Euler Angles, Vectors and Matrices for use in OpenGL\n\n    struct light {\n        glm::vec3 Position{ 1.f };\n    };\n\n    struct reload {\n        bool on_reload = false;\n        bool on_texture_reload = false;\n    };\n\n    // struct rendertarget3d {\n    //     std::string model_path; // used to load in a model\n    //     std::string Filepath; // used for texture\n    //     // bool is_model_dirty=false; // checks if the model is needing to\n    //     reload bool is_texture_dirty=false; // checking if texture is needing\n    //     to reload\n    // };\n\n    struct material {\n        glm::vec4 color{ 1.f };\n        std::string model_path = \"\";\n        std::string texture_path =\n          \"\"; // This just contains the path to load the texture\n        std::vector&lt;std::string&gt; texture_filepaths;\n        bool model_reload = false;\n        bool texture_reload = false;\n    };\n\n    // An abstract camera class that processes input and calculates the\n    // corresponding Euler Angles, Vectors and Matrices for use in OpenGL\n\n    class camera {\n        // Default camera values\n        // const float yaw = -90.0f;\n        // const float PITCH = 0.0f;\n        // const float ZOOM = 45.0f;\n    public:\n        camera() = default;\n        // constructor with vectors\n        camera(float p_aspect_ratio,\n               glm::vec3 position = glm::vec3(0.0f, 1.50f, 0.0f),\n               glm::vec3 up = glm::vec3(0.0f, -1.0f, 0.0f),\n               float yaw = -90.0f,\n               float pitch = 0.0f)\n          : MovementSpeed(5.f)\n          , MouseSensitivity(0.1f)\n          , Zoom(45.0f)\n          , camera_mouse_sensitivity(0.1f) {\n            Position = position;\n            WorldUp = up;\n            EulerRotation = { yaw, pitch, 1.f };\n            AspectRatio = p_aspect_ratio;\n            update_camera();\n        }\n\n        // returns the view matrix calculated using Euler Angles and the LookAt\n        // Matrix\n        [[nodiscard]] glm::mat4 get_view() const { return View; }\n        [[nodiscard]] glm::mat4 get_projection() const { return Projection; }\n\n        // processes input received from any keyboard-like input system. Accepts\n        // input parameter in the form of camera defined ENUM (to abstract it\n        // from windowing systems)\n        void process_keyboard(CameraMovement p_direction, float p_delta_time) {\n            float velocity = MovementSpeed * p_delta_time;\n\n            if (p_direction == CameraMovement::forward)\n                Position += get_front() * velocity;\n            if (p_direction == CameraMovement::backward)\n                Position -= get_front() * velocity;\n            if (p_direction == CameraMovement::left)\n                Position -= Right * velocity;\n            if (p_direction == CameraMovement::right)\n                Position += Right * velocity;\n\n            if (p_direction == CameraMovement::up) {\n                Position += Up * velocity;\n            }\n\n            if (p_direction == CameraMovement::down) {\n                Position -= Up * velocity;\n            }\n        }\n\n        // processes input received from a mouse input system. Expects the\n        // offset value in both the x and y direction.\n        void process_mouse_movement(float p_x,\n                                    float p_y,\n                                    bool p_constraint_pitch = true) {\n\n            p_x *= MouseSensitivity;\n            p_y *= MouseSensitivity;\n\n            EulerRotation.x += p_x;\n            EulerRotation.y += p_y;\n\n            // make sure that when pitch is out of bounds, screen doesn't get\n            // flipped\n            if (p_constraint_pitch) {\n                if (EulerRotation.y &gt; 89.0f) {\n                    EulerRotation.y = 89.0f;\n                }\n                if (EulerRotation.y &lt; -89.0f) {\n                    EulerRotation.y = -89.0f;\n                }\n            }\n\n            // update Front, Right and Up Vectors using the updated Euler angles\n            update_camera();\n        }\n\n        // processes input received from a mouse scroll-wheel event. Only\n        // requires input on the vertical wheel-axis\n        void process_mouse_scroll(float yoffset) {\n            Zoom -= (float)yoffset;\n\n            if (Zoom &lt; 1.0f) {\n                Zoom = 1.0f;\n            }\n\n            if (Zoom &gt; 45.0f) {\n                Zoom = 45.0f;\n            }\n        }\n\n        void set_movement_speed(float p_sensitivity) {\n            camera_movement_sensitivity = p_sensitivity;\n            MovementSpeed = camera_movement_sensitivity;\n        }\n\n        void set_mouse_speed(float p_sensitivity) {\n            camera_mouse_sensitivity = p_sensitivity;\n        }\n\n        [[nodiscard]] float camera_sensitivity() const {\n            return camera_mouse_sensitivity;\n        }\n\n    private:\n        // calculates the front vector from the Camera's (updated) Euler Angles\n        void update_camera() {\n            // calculate the new Front vector\n            // glm::vec3 front;\n            // front.x = cos(glm::radians(EulerRotation.x)) *\n            // cos(glm::radians(EulerRotation.y)); front.y =\n            // sin(glm::radians(EulerRotation.y)); front.z =\n            // sin(glm::radians(EulerRotation.x)) *\n            // cos(glm::radians(EulerRotation.y)); Front =\n            // glm::normalize(front); also re-calculate the Right and Up vector\n            Right = glm::normalize(glm::cross(\n              get_front(),\n              WorldUp)); // normalize the vectors, because their length\n                         // gets closer to 0 the more you look up or\n                         // down which results in slower movement.\n            Left = glm::normalize(glm::cross(-get_front(), WorldUp));\n            Up = glm::normalize(glm::cross(Right, get_front()));\n            Down = glm::normalize(glm::cross(-Right, WorldUp));\n        }\n\n    public:\n        void update_proj_view() {\n            Projection =\n              glm::perspective(glm::radians(Zoom), AspectRatio, .1f, 50000.f);\n            View = glm::lookAt(Position, Position + get_front(), Up);\n        }\n\n        [[nodiscard]] glm::vec3 get_front() const {\n            glm::vec3 front_values;\n            front_values.x = cos(glm::radians(EulerRotation.x)) *\n                             cos(glm::radians(EulerRotation.y));\n            front_values.y = sin(glm::radians(EulerRotation.y));\n            front_values.z = sin(glm::radians(EulerRotation.x)) *\n                             cos(glm::radians(EulerRotation.y));\n            return glm::normalize(front_values);\n        }\n\n    public:\n        // camera Attributes\n        glm::vec3 Position;\n        // glm::vec3 Front;\n        glm::vec3 Up;\n        glm::vec3 Down;\n        glm::vec3 Right;\n        glm::vec3 Left;\n        glm::vec3 WorldUp;\n\n        glm::mat4 Projection;\n        glm::mat4 View;\n\n        float AspectRatio = 0.f;\n\n        // euler Angles\n        // {x: Yaw, y: Pitch, z: Roll}\n        glm::vec3 EulerRotation;\n        // camera options\n        float MovementSpeed{};\n        float MouseSensitivity{};\n        float Zoom{};\n\n        // float camera_mouse_sensitivity = 0.1f;\n        float camera_mouse_sensitivity = 2.5f;\n        float camera_movement_sensitivity = 2.5f;\n\n        // toggling between cameras and checking if our current\n        bool IsMainCamera = false;\n    };\n}; // namespace atlas\n</code></pre>"},{"location":"References/entity_8hpp/","title":"File entity.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; scene &gt; entity.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;flecs.h&gt;</code></li> </ul>"},{"location":"References/entity_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/entity_8hpp/#classes","title":"Classes","text":"Type Name class entity_t <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/entity.hpp</code></p>"},{"location":"References/entity_8hpp_source/","title":"File entity.hpp","text":"<p>File List &gt; atlas &gt; core &gt; scene &gt; entity.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n#include &lt;flecs.h&gt;\n\nnamespace atlas {\n    class entity_t {\n    public:\n        entity_t() = default;\n        entity_t(flecs::world* p_registry, const std::string&amp; p_tag);\n        entity_t(const flecs::entity&amp; p_entity)\n          : m_entity_id(p_entity) {}\n\n        ~entity_t();\n\n        [[nodiscard]] bool is_alive() const { return m_entity_id.is_alive(); }\n\n        void on_destruction() { m_entity_id.destruct(); }\n\n        template&lt;typename UComponent&gt;\n        void add() {\n            m_entity_id.add&lt;UComponent&gt;();\n        }\n\n        template&lt;typename UComponent&gt;\n        const UComponent* get() const {\n            return m_entity_id.get&lt;UComponent&gt;();\n        }\n\n        template&lt;typename UComponent&gt;\n        UComponent* get_mut() const {\n            return m_entity_id.get_mut&lt;UComponent&gt;();\n        }\n\n        template&lt;typename UComponent&gt;\n        [[nodiscard]] bool has() const {\n            return m_entity_id.has&lt;UComponent&gt;();\n        }\n\n\n        template&lt;typename UComponent&gt;\n        void set(const UComponent&amp; p_component) {\n            m_entity_id.set&lt;UComponent&gt;(p_component);\n        }\n\n        template&lt;typename UComponent1, typename UComponent2&gt;\n        void set(const UComponent1&amp; p_component1,\n                 const UComponent2&amp; p_component2) {\n            m_entity_id.set&lt;UComponent1, UComponent2&gt;(p_component1)\n              .set(p_component2);\n        }\n\n        template&lt;typename UComponent&gt;\n        void remove() {\n            m_entity_id.remove&lt;UComponent&gt;();\n        }\n\n        operator flecs::entity() const { return m_entity_id; }\n\n        operator flecs::entity() { return m_entity_id; }\n\n    private:\n        // Keep in mind that an entity just represent a 64-bit number\n        flecs::entity m_entity_id;\n    };\n}; // namespace atlas\n</code></pre>"},{"location":"References/scene_8hpp/","title":"File scene.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; scene &gt; scene.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;core/scene/scene_object.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/scene_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/scene_8hpp/#classes","title":"Classes","text":"Type Name class scene_scope <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/scene.hpp</code></p>"},{"location":"References/scene_8hpp_source/","title":"File scene.hpp","text":"<p>File List &gt; atlas &gt; core &gt; scene &gt; scene.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;core/scene/scene_object.hpp&gt;\n#include &lt;string&gt;\n\nnamespace atlas {\n    class scene_scope {\n    public:\n        scene_scope()\n          : m_tag(\"Undefined\") {}\n        scene_scope(const std::string&amp; p_tag)\n          : m_tag(p_tag) {}\n\n        ref&lt;scene_object&gt; create_new_object(const std::string&amp; p_tag) {\n            return create_ref&lt;scene_object&gt;(&amp;m_registry, p_tag);\n        }\n\n        template&lt;typename... Comps, typename... Args&gt;\n        flecs::query_builder&lt;Comps...&gt; query_builder(Args&amp;&amp;... args) const {\n            return flecs::query_builder&lt;Comps...&gt;(m_registry,\n                                                  std::forward(args)...);\n        }\n\n        virtual ~scene_scope() = default;\n\n        std::string get_tag() { return m_tag; }\n\n        operator flecs::world() const { return m_registry; }\n        operator flecs::world() { return m_registry; }\n\n    private:\n        flecs::world m_registry;\n        std::string m_tag = \"Undefined Tag\";\n    };\n}; // namespace atlas\n</code></pre>"},{"location":"References/scene__object_8hpp/","title":"File scene_object.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; scene &gt; scene_object.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;core/scene/components.hpp&gt;</code></li> <li><code>#include &lt;core/scene/entity.hpp&gt;</code></li> <li><code>#include &lt;variant&gt;</code></li> </ul>"},{"location":"References/scene__object_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/scene__object_8hpp/#classes","title":"Classes","text":"Type Name class scene_object <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/scene_object.hpp</code></p>"},{"location":"References/scene__object_8hpp_source/","title":"File scene_object.hpp","text":"<p>File List &gt; atlas &gt; core &gt; scene &gt; scene_object.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;core/scene/components.hpp&gt;\n#include &lt;core/scene/entity.hpp&gt;\n#include &lt;variant&gt;\n\nnamespace atlas {\n    class scene_object {\n    public:\n        scene_object(flecs::world* p_registry, const std::string&amp; p_name);\n\n        ~scene_object() {\n            if (m_entity.is_alive()) {\n                m_entity.destruct();\n            }\n        }\n\n        template&lt;typename UComponent&gt;\n        void add() {\n            m_entity.add&lt;UComponent&gt;();\n        }\n\n        template&lt;typename UComponent&gt;\n        void add(UComponent&amp; p_component_value) {\n            m_entity.add&lt;UComponent&gt;(p_component_value);\n        }\n\n        template&lt;typename... Args&gt;\n        void add_query() {\n            using tuple_variadic = std::tuple&lt;Args...&gt;;\n            std::variant&lt;tuple_variadic&gt; conditions;\n            std::visit(\n              [&amp;](const auto&amp; p_component) {\n                  std::apply(\n                    [&amp;](auto&amp;... p_placeholder) {\n                        (m_entity.add&lt;std::decay_t&lt;decltype(p_placeholder)&gt;&gt;(),\n                         ...);\n                    },\n                    p_component);\n              },\n              conditions);\n        }\n\n        template&lt;typename UComponent&gt;\n        [[nodiscard]] const UComponent* get() const {\n            return m_entity.get&lt;UComponent&gt;();\n        }\n\n        template&lt;typename UComponent&gt;\n        [[nodiscard]] UComponent* get_mut() {\n            return m_entity.get_mut&lt;UComponent&gt;();\n        }\n\n        template&lt;typename UComponent&gt;\n        bool has() {\n            return m_entity.has&lt;UComponent&gt;();\n        }\n\n        template&lt;typename UComponent&gt;\n        void set(const UComponent&amp; p_component) {\n            m_entity.set&lt;UComponent&gt;(p_component);\n        }\n\n        template&lt;typename UComponent, typename UComponent2&gt;\n        void set(const UComponent&amp; p_component,\n                 const UComponent2&amp; p_component2) {\n            m_entity.set&lt;UComponent&gt;(p_component, p_component2);\n        }\n\n        template&lt;typename UComponent&gt;\n        void remove() {\n            return m_entity.remove&lt;UComponent&gt;();\n        }\n\n        operator flecs::entity() const { return m_entity; }\n\n        operator flecs::entity() { return m_entity; }\n\n    private:\n        flecs::entity m_entity;\n    };\n}; // namespace atlas\n</code></pre>"},{"location":"References/world_8hpp/","title":"File world.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; scene &gt; world.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;flecs.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;core/scene/scene.hpp&gt;</code></li> </ul>"},{"location":"References/world_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/world_8hpp/#classes","title":"Classes","text":"Type Name class world_scope Lets rethink how world_scope gets created. <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/world.hpp</code></p>"},{"location":"References/world_8hpp_source/","title":"File world.hpp","text":"<p>File List &gt; atlas &gt; core &gt; scene &gt; world.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;flecs.h&gt;\n#include &lt;string&gt;\n#include &lt;core/scene/scene.hpp&gt;\n\nnamespace atlas {\n\n    // enable_shared_from cppreference link:\n    // https://en.cppreference.com/w/cpp/memory/enable_shared_from_this\n    class world_scope : public std::enable_shared_from_this&lt;world_scope&gt; {\n    public:\n        world_scope() = default;\n        world_scope(const std::string&amp; p_tag);\n        ~world_scope();\n\n        [[nodiscard]] std::string get_tag() const { return m_tag; }\n\n        void add_scene(const ref&lt;scene_scope&gt;&amp; p_scene_context);\n\n        // flecs::world* get_registry() { return &amp;m_scene_registry; }\n        ref&lt;scene_scope&gt; get_scene(const std::string&amp; p_tag) {\n            if (m_scene_container.contains(p_tag)) {\n                return m_scene_container[p_tag];\n            }\n\n            return nullptr;\n        }\n\n        ref&lt;world_scope&gt; get() { return shared_from_this(); }\n\n        operator flecs::world&amp;() { return m_scene_registry; }\n\n    private:\n        flecs::world m_scene_registry;\n        std::map&lt;std::string, ref&lt;scene_scope&gt;&gt; m_scene_container;\n        // ref&lt;scene_scope&gt; m_current_scene;\n        ref&lt;world_scope&gt; m_world_shared_instance = nullptr;\n        std::string m_tag = \"Undefined Tag\";\n    };\n}; // namespace atlas\n</code></pre>"},{"location":"References/dir_58a1ea337b9d91821031c085f16f9af8/","title":"Dir TheAtlasEngine/atlas/core/serialize","text":"<p>FileList &gt; atlas &gt; core &gt; serialize</p>"},{"location":"References/dir_58a1ea337b9d91821031c085f16f9af8/#files","title":"Files","text":"Type Name file serializer.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/serialize/</code></p>"},{"location":"References/serializer_8hpp/","title":"File serializer.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; serialize &gt; serializer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;core/scene/scene.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/serializer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/serializer_8hpp/#classes","title":"Classes","text":"Type Name class serializer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/serialize/serializer.hpp</code></p>"},{"location":"References/serializer_8hpp_source/","title":"File serializer.hpp","text":"<p>File List &gt; atlas &gt; core &gt; serialize &gt; serializer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;core/scene/scene.hpp&gt;\n#include &lt;string&gt;\n\nnamespace atlas {\n    class serializer {\n    public:\n        serializer(const scene_scope* p_scene_ctx);\n\n        void save_as(const std::string&amp; p_filepath);\n\n    private:\n        ref&lt;scene_scope&gt; m_current_scene_ctx;\n    };\n\n}; // namespace atlas\n</code></pre>"},{"location":"References/dir_95144a79d2a75258fa60dac31330b761/","title":"Dir TheAtlasEngine/atlas/core/system_framework","text":"<p>FileList &gt; atlas &gt; core &gt; system_framework</p>"},{"location":"References/dir_95144a79d2a75258fa60dac31330b761/#files","title":"Files","text":"Type Name file system_registry.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/system_framework/</code></p>"},{"location":"References/system__registry_8hpp/","title":"File system_registry.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; system_framework &gt; system_registry.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;core/scene/world.hpp&gt;</code></li> </ul>"},{"location":"References/system__registry_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/system__registry_8hpp/#classes","title":"Classes","text":"Type Name class system_registry <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/system_framework/system_registry.hpp</code></p>"},{"location":"References/system__registry_8hpp_source/","title":"File system_registry.hpp","text":"<p>File List &gt; atlas &gt; core &gt; system_framework &gt; system_registry.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;map&gt;\n#include &lt;core/scene/world.hpp&gt;\n\nnamespace atlas {\n    class system_registry {\n    public:\n        system_registry(const std::string&amp; p_tag);\n\n        ~system_registry();\n\n        static ref&lt;world_scope&gt; create_world(const std::string&amp; p_tag);\n\n        static ref&lt;world_scope&gt; get_world(const std::string&amp; p_tag);\n\n    private:\n        ref&lt;world_scope&gt; search_world(const std::string&amp; p_tag);\n\n        void append_world(const ref&lt;world_scope&gt;&amp; p_world);\n\n        ref&lt;world_scope&gt; append_world_scope(const ref&lt;world_scope&gt;&amp; p_world);\n\n    private:\n        static system_registry* s_instance;\n        std::string m_tag = \"Undefined\";\n        std::map&lt;std::string, ref&lt;world_scope&gt;&gt; m_world_registered;\n    };\n};\n</code></pre>"},{"location":"References/dir_3d5429f92b5f302f4e9406c3e899f86b/","title":"Dir TheAtlasEngine/atlas/core/threads","text":"<p>FileList &gt; atlas &gt; core &gt; threads</p>"},{"location":"References/dir_3d5429f92b5f302f4e9406c3e899f86b/#files","title":"Files","text":"Type Name file thread.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/threads/</code></p>"},{"location":"References/core_2threads_2thread_8hpp/","title":"File thread.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; threads &gt; thread.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/core_2threads_2thread_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/core_2threads_2thread_8hpp/#classes","title":"Classes","text":"Type Name class thread <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/threads/thread.hpp</code></p>"},{"location":"References/core_2threads_2thread_8hpp_source/","title":"File thread.hpp","text":"<p>File List &gt; atlas &gt; core &gt; threads &gt; thread.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n\nnamespace atlas {\n    class thread {\n    public:\n        thread(const std::string&amp; p_tag);\n\n        template&lt;typename T&gt;\n        void dispatch([[maybe_unused]] const T&amp; p_function) {}\n    };\n};\n</code></pre>"},{"location":"References/dir_ec4014881addefdc5691f44c9e98b9f4/","title":"Dir TheAtlasEngine/atlas/core/ui","text":"<p>FileList &gt; atlas &gt; core &gt; ui</p>"},{"location":"References/dir_ec4014881addefdc5691f44c9e98b9f4/#files","title":"Files","text":"Type Name file widgets.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/ui/</code></p>"},{"location":"References/widgets_8hpp/","title":"File widgets.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; ui &gt; widgets.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;imgui.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;core/filesystem/file_dialog.hpp&gt;</code></li> </ul>"},{"location":"References/widgets_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace ui"},{"location":"References/widgets_8hpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const std::filesystem::path g_asset_path   = <code>\"3d\\_models\"</code>"},{"location":"References/widgets_8hpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"References/widgets_8hpp/#variable-g_asset_path","title":"variable g_asset_path","text":"<pre><code>const std::filesystem::path g_asset_path;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/ui/widgets.hpp</code></p>"},{"location":"References/widgets_8hpp_source/","title":"File widgets.hpp","text":"<p>File List &gt; atlas &gt; core &gt; ui &gt; widgets.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;imgui.h&gt;\n#include &lt;string&gt;\n#include &lt;glm/glm.hpp&gt;\n#include &lt;GLFW/glfw3.h&gt;\n#include &lt;filesystem&gt;\n#include &lt;core/filesystem/file_dialog.hpp&gt;\n#include &lt;filesystem&gt;\n\nstatic const std::filesystem::path g_asset_path = \"3d_models\";\n\n// namespace ImGui {\n//     //! @note We need to see if this works\n//     //! @note Because imgui implements this but the header file for some\n//     reason\n//     //! does not contain this implementation...\n//     void PushMultiItemsWidths(int components, float w_full);\n// };\n\nnamespace atlas::ui {\n\n    bool begin_popup_context_window(const char* p_str_id,\n                                    ImGuiMouseButton p_mb,\n                                    bool p_over_items);\n\n    /* Rendering glm::vec3's as a UI widget */\n    void draw_vec3(const std::string&amp; p_tag,\n                   glm::vec3&amp; p_value,\n                   float p_reset_value = 0.f);\n\n    void draw_vec4(const std::string&amp; p_tag,\n                   glm::vec4&amp; p_value,\n                   float p_reset_value = 0.f);\n\n    /* Rendering float as a UI widget with default reset values */\n    void draw_float(const std::string&amp; p_tag,\n                    float&amp; p_value,\n                    float p_reset_value = 0.f);\n\n    /*\n        draw panel component\n\n        - is used to group widgets into specific panels\n\n        Parameters\n        T = is the type the component we want to draw to the UI\n        UFunction = callback that defines what data in the component to be\n       displayed in this panel that handles the UI layout of that component\n\n        USAGE:\n\n        draw_panel_component&lt;UComponent&gt;(\"Transform\", [](){\n            DrawVec3(\"Position\", position_value);\n            // etc....\n        });\n    */\n    template&lt;typename T, typename UFunction&gt;\n    static void draw_panel_component(const std::string&amp; p_tag,\n                                     const UFunction&amp; p_callable) {\n        const ImGuiTreeNodeFlags tree_node_flags =\n          ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_Framed |\n          ImGuiTreeNodeFlags_SpanAvailWidth |\n          ImGuiTreeNodeFlags_AllowItemOverlap | ImGuiTreeNodeFlags_FramePadding;\n\n        ImVec2 content_region = ImGui::GetContentRegionAvail();\n        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2{ 4, 4 });\n\n        float line_height =\n          ImGui::GetFontSize() + ImGui::GetStyle().FramePadding.y * 2.0f;\n        ImGui::Separator();\n\n        bool opened = ImGui::TreeNodeEx(\n          (void*)typeid(T).hash_code(), tree_node_flags, \"%s\", p_tag.c_str());\n        ImGui::PopStyleVar();\n\n        ImGui::SameLine(content_region.x - line_height * 0.05f);\n\n        if (ImGui::Button(\"+\", ImVec2(line_height, line_height))) {\n            ImGui::OpenPopup(\"ComponentSettings\");\n        }\n\n        // bool isRemovedComponent = false; // @note for deferring when to\n        // delete component.\n        if (ImGui::BeginPopup(\"ComponentSettings\")) {\n            if (ImGui::MenuItem(\"Remove Component\")) {\n            }\n            //     isRemovedComponent = true;\n\n            ImGui::EndPopup();\n        }\n\n        if (opened) {\n            p_callable();\n            ImGui::TreePop();\n        }\n    }\n\n    void dockspace_window(GLFWwindow* p_window);\n\n    void button_open_file_dialog(const std::string&amp; p_tag,\n                                 std::string&amp; p_filepath,\n                                 const std::string&amp; p_filter = \"obj;glftf;fbx\");\n};\n</code></pre>"},{"location":"References/dir_e4a875ec04a9822d1a20b5830cf2827b/","title":"Dir TheAtlasEngine/atlas/core/update_handlers","text":"<p>FileList &gt; atlas &gt; core &gt; update_handlers</p>"},{"location":"References/dir_e4a875ec04a9822d1a20b5830cf2827b/#files","title":"Files","text":"Type Name file sync_update.hpp file timer.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/update_handlers/</code></p>"},{"location":"References/sync__update_8hpp/","title":"File sync_update.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; update_handlers &gt; sync_update.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;deque&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> </ul>"},{"location":"References/sync__update_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace sync_update <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/update_handlers/sync_update.hpp</code></p>"},{"location":"References/sync__update_8hpp_source/","title":"File sync_update.hpp","text":"<p>File List &gt; atlas &gt; core &gt; update_handlers &gt; sync_update.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;deque&gt;\n#include &lt;functional&gt;\n\nnamespace atlas {\n    namespace sync_update {\n\n        void initialize();\n\n        float delta_time();\n\n        // Called by thread_manager\n        // void run_update(float deltaTime);\n\n        inline std::deque&lt;std::function&lt;void()&gt;&gt; s_update;\n        inline std::deque&lt;std::function&lt;void()&gt;&gt; s_late_update;\n        inline std::deque&lt;std::function&lt;void()&gt;&gt; s_ui_update;\n        inline std::deque&lt;std::function&lt;void()&gt;&gt; s_physica_update;\n\n        template&lt;typename UObject, typename UFunction&gt;\n        void sync(UObject* p_instance, const UFunction&amp; p_callable) {\n            static_assert(std::is_member_pointer_v&lt;UFunction&gt;,\n                          \"Invalid sync function\");\n\n            s_update.push_back(\n              [p_instance, p_callable]() { (p_instance-&gt;*p_callable)(); });\n        }\n\n        template&lt;typename UObject, typename UFunction&gt;\n        void sync_physics(UObject* p_instance, const UFunction&amp; p_callable) {\n            static_assert(std::is_member_pointer_v&lt;UFunction&gt;,\n                          \"Invalid sync function\");\n\n            s_physica_update.push_back(\n              [p_instance, p_callable]() { (p_instance-&gt;*p_callable)(); });\n        }\n\n        template&lt;typename UObject, typename UCallable&gt;\n        inline void post(UObject* p_instance, const UCallable&amp; p_callable) {\n            static_assert(std::is_member_pointer_v&lt;UCallable&gt;,\n                          \"Invalid post function\");\n\n            s_late_update.push_back(\n              [p_instance, p_callable]() { (p_instance-&gt;*p_callable)(); });\n        }\n\n        template&lt;typename UObject, typename UCallable&gt;\n        void attach(UObject* p_instance, const UCallable&amp; p_callable) {\n            // UI returns a boolean because this can be used to indicate whether\n            // specific callable functions are activated\n            static_assert(std::is_member_pointer_v&lt;UCallable&gt;,\n                          \"Invalid attach function\");\n\n            s_ui_update.push_back(\n              [p_instance, p_callable]() { (p_instance-&gt;*p_callable)(); });\n        }\n\n        void on_update();\n\n        void on_physics_update();\n\n        void on_ui_update();\n\n        void on_late_update();\n\n    };\n\n    template&lt;typename UObject, typename UCallable&gt;\n    void sync(UObject* p_instance, const UCallable&amp; p_callable) {\n        sync_update::sync(p_instance, p_callable);\n    }\n\n    template&lt;typename UObject, typename UCallable&gt;\n    void sync_physics(UObject* p_instance, const UCallable&amp; p_callable) {\n        sync_update::sync_physics(p_instance, p_callable);\n    }\n\n    template&lt;typename UObject, typename UCallable&gt;\n    void post(UObject* p_instance, const UCallable&amp; p_callable) {\n        sync_update::post(p_instance, p_callable);\n    }\n\n    template&lt;typename UObject, typename UCallable&gt;\n    void attach(UObject* p_instance, const UCallable&amp; p_callable) {\n        sync_update::attach(p_instance, p_callable);\n    }\n\n};\n</code></pre>"},{"location":"References/update__handlers_2timer_8hpp/","title":"File timer.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; update_handlers &gt; timer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> </ul>"},{"location":"References/update__handlers_2timer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/update__handlers_2timer_8hpp/#classes","title":"Classes","text":"Type Name class timer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/update_handlers/timer.hpp</code></p>"},{"location":"References/update__handlers_2timer_8hpp_source/","title":"File timer.hpp","text":"<p>File List &gt; atlas &gt; core &gt; update_handlers &gt; timer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;chrono&gt;\n\nnamespace atlas {\n    class timer {\n\n    public:\n        timer();\n\n        void reset();\n\n        float elapsed();\n\n        float seconds();\n\n        std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt;\n        current_time();\n\n    private:\n        std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt;\n          m_stop_watch;\n    };\n};\n</code></pre>"},{"location":"References/dir_5ecaaba7e34420a87db9680718b1325e/","title":"Dir TheAtlasEngine/atlas/core/utilities","text":"<p>FileList &gt; atlas &gt; core &gt; utilities</p>"},{"location":"References/dir_5ecaaba7e34420a87db9680718b1325e/#files","title":"Files","text":"Type Name file hash.hpp file types.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/utilities/</code></p>"},{"location":"References/core_2utilities_2hash_8hpp/","title":"File hash.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; utilities &gt; hash.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> </ul>"},{"location":"References/core_2utilities_2hash_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/utilities/hash.hpp</code></p>"},{"location":"References/core_2utilities_2hash_8hpp_source/","title":"File hash.hpp","text":"<p>File List &gt; atlas &gt; core &gt; utilities &gt; hash.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n#include &lt;unordered_map&gt;\n\nnamespace atlas {\n    template&lt;typename T, typename... Rest&gt;\n    void hash_combine(size_t&amp; seed, const T&amp; v, const Rest&amp;... rest) {\n        seed ^= std::hash&lt;T&gt;()(v) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &lt;&lt; 2);\n        (hash_combine(seed, rest), ...);\n    }\n\n};\n</code></pre>"},{"location":"References/core_2utilities_2types_8hpp/","title":"File types.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; utilities &gt; types.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/core_2utilities_2types_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/core_2utilities_2types_8hpp/#classes","title":"Classes","text":"Type Name struct window_settings Specific settings to the window configuration. <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/utilities/types.hpp</code></p>"},{"location":"References/core_2utilities_2types_8hpp_source/","title":"File types.hpp","text":"<p>File List &gt; atlas &gt; core &gt; utilities &gt; types.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n#include &lt;string&gt;\n\nnamespace atlas {\n    struct window_settings {\n        uint32_t width = -1;\n        uint32_t height = -1;\n        std::string name = \"\";\n        uint32_t frames_in_flight = 2;\n    };\n};\n</code></pre>"},{"location":"References/api_8hpp/","title":"File api.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; api.hpp</p> <p>Go to the source code of this file</p>"},{"location":"References/api_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/api.hpp</code></p>"},{"location":"References/api_8hpp_source/","title":"File api.hpp","text":"<p>File List &gt; atlas &gt; core &gt; api.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace atlas {\n    enum api { vulkan, dx11, fx12, undefined };\n\n};\n</code></pre>"},{"location":"References/application_8hpp/","title":"File application.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; application.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/api.hpp&gt;</code></li> <li><code>#include &lt;core/window.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;renderer/renderer.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_imgui.hpp&gt;</code></li> </ul>"},{"location":"References/application_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/application_8hpp/#classes","title":"Classes","text":"Type Name class application struct application_settings <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/application.hpp</code></p>"},{"location":"References/application_8hpp_source/","title":"File application.hpp","text":"<p>File List &gt; atlas &gt; core &gt; application.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/api.hpp&gt;\n#include &lt;core/window.hpp&gt;\n#include &lt;string&gt;\n#include &lt;renderer/renderer.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_imgui.hpp&gt;\n\nnamespace atlas {\n\n    struct application_settings {\n        std::string Name = \"Undefined\";\n        uint32_t Width = 0;\n        uint32_t Height = 0;\n    };\n\n    class application {\n    public:\n        application(const application_settings&amp; p_settings);\n        ~application();\n\n        static float delta_time();\n\n        static float physics_step();\n\n        /* executes the application's mainloop */\n        void execute();\n\n        void post_destroy();\n\n        /* Returns the current window selected in the application */\n        static window&amp; get_window() { return *s_instance-&gt;m_window; }\n\n        /* Retrieves the current selected graphics API */\n        static api current_api();\n\n        /* Returns the currently selected swapchain */\n        VkSwapchainKHR get_current_swapchain();\n\n        /* Destroys the application */\n        static void destroy();\n\n        static float aspect_ratio();\n\n        static uint32_t current_frame();\n\n        static uint32_t image_size();\n\n    private:\n        void set_current_api(api api);\n\n    private:\n        ref&lt;window&gt; m_window;\n        scope&lt;renderer&gt; m_renderer = nullptr;\n        uint32_t m_current_frame_index = -1;\n        vk::imgui_context m_ui_context;\n        static application* s_instance;\n    };\n\n    ref&lt;application&gt; initialize_application();\n};\n</code></pre>"},{"location":"References/core_8hpp/","title":"File core.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; core.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;spdlog/common.h&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> </ul>"},{"location":"References/core_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/core_8hpp/#macros","title":"Macros","text":"Type Name define ENGINE_API <code>\\_\\_attribute\\_\\_((visibility(\"default\")))</code>"},{"location":"References/core_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"References/core_8hpp/#define-engine_api","title":"define ENGINE_API","text":"<pre><code>#define ENGINE_API `__attribute__((visibility(\"default\")))`\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/core.hpp</code></p>"},{"location":"References/core_8hpp_source/","title":"File core.hpp","text":"<p>File List &gt; atlas &gt; core &gt; core.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cassert&gt;\n#include &lt;memory&gt;\n#include &lt;spdlog/common.h&gt;\n#include &lt;spdlog/spdlog.h&gt;\n\nnamespace atlas {\n#ifdef ENGINE_PLATFORM_WINDOWS\n#ifdef ENGINE_BUILD_DLL\n#define ENGINE_API __declspec(dllexport)\n#else\n#define ENGINE_API __declspec(dllimport)\n#endif\n#else // If we are on either Linux/Mac OS, since they use __attributes__\n#define ENGINE_API __attribute__((visibility(\"default\")))\n#endif\n\n#ifdef ATLAS_DEBUG_BUILD\n#define ATLAS_DEBUG_BUILD\n#endif\n\n    template&lt;typename... T&gt;\n    static void core_assert(bool x, T&amp;&amp;... args) {\n        // const char* filename = __FILE__;\n        // auto line = __LINE__;\n        if (!x) {\n            // spdlog::critical(\"assertion: {}\", fmt, std::forward&lt;T&gt;(args)...,\n            // filename, line);\n            spdlog::critical(\"assertion failed: {}\", std::forward&lt;T&gt;(args)...);\n        }\n    }\n\n    template&lt;typename T&gt;\n    using ref = std::shared_ptr&lt;T&gt;;\n\n    template&lt;typename T, typename... Args&gt;\n    constexpr ref&lt;T&gt; create_ref(Args&amp;&amp;... args) {\n        return std::make_shared&lt;T&gt;(std::forward&lt;Args&gt;(args)...);\n    }\n\n    template&lt;typename T&gt;\n    using scope = std::unique_ptr&lt;T&gt;;\n\n    template&lt;typename T, typename... Args&gt;\n    constexpr scope&lt;T&gt; create_scope(Args&amp;&amp;... args) {\n        return std::make_unique&lt;T&gt;(std::forward&lt;Args&gt;(args)...);\n    }\n\n    template&lt;typename T&gt;\n    using weak_ptr = std::weak_ptr&lt;T&gt;;\n\n    template&lt;typename T, typename... Args&gt;\n    constexpr weak_ptr&lt;T&gt; create_weak_ptr(Args&amp;&amp;... args) {\n        return std::weak_ptr&lt;T&gt;(std::forward&lt;Args&gt;(args)...);\n    }\n\n    template&lt;typename T, typename U&gt;\n    weak_ptr&lt;T&gt; to_weak_ptr(const U&amp; p_value) {\n        return CreateWeakPtr&lt;T&gt;(p_value);\n    }\n};\n</code></pre>"},{"location":"References/engine__logger_8hpp/","title":"File engine_logger.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; engine_logger.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;fmt/os.h&gt;</code></li> <li><code>#include &lt;fmt/ostream.h&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;spdlog/common.h&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> </ul>"},{"location":"References/engine__logger_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/engine__logger_8hpp/#classes","title":"Classes","text":"Type Name class console_log_manager"},{"location":"References/engine__logger_8hpp/#public-functions","title":"Public Functions","text":"Type Name void console_log_error (spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_error_tagged (const std::string &amp; p_tag, spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_fatal (spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_fatal_tagged (const std::string &amp; p_tag, spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_info (spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_info_tagged (const std::string &amp; p_tag, spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_trace (spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_trace_tagged (const std::string &amp; p_tag, spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_warn (spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_warn_tagged (const std::string &amp; p_tag, spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)"},{"location":"References/engine__logger_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/engine__logger_8hpp/#function-console_log_error","title":"function console_log_error","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_error (\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/engine__logger_8hpp/#function-console_log_error_tagged","title":"function console_log_error_tagged","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_error_tagged (\n    const std::string &amp; p_tag,\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/engine__logger_8hpp/#function-console_log_fatal","title":"function console_log_fatal","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_fatal (\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/engine__logger_8hpp/#function-console_log_fatal_tagged","title":"function console_log_fatal_tagged","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_fatal_tagged (\n    const std::string &amp; p_tag,\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/engine__logger_8hpp/#function-console_log_info","title":"function console_log_info","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_info (\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/engine__logger_8hpp/#function-console_log_info_tagged","title":"function console_log_info_tagged","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_info_tagged (\n    const std::string &amp; p_tag,\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/engine__logger_8hpp/#function-console_log_trace","title":"function console_log_trace","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_trace (\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre> <p>Note:</p> <p>Console Loggers (These are loggers that write specifically to the console, terminal console) </p> <p>Note:</p> <p>TODO  Specify that engine3d will have it's own console terminal that these will be written to. </p>"},{"location":"References/engine__logger_8hpp/#function-console_log_trace_tagged","title":"function console_log_trace_tagged","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_trace_tagged (\n    const std::string &amp; p_tag,\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/engine__logger_8hpp/#function-console_log_warn","title":"function console_log_warn","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_warn (\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/engine__logger_8hpp/#function-console_log_warn_tagged","title":"function console_log_warn_tagged","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_warn_tagged (\n    const std::string &amp; p_tag,\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/engine_logger.hpp</code></p>"},{"location":"References/engine__logger_8hpp_source/","title":"File engine_logger.hpp","text":"<p>File List &gt; atlas &gt; core &gt; engine_logger.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;fmt/os.h&gt;\n#include &lt;fmt/ostream.h&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;spdlog/common.h&gt;\n#include &lt;spdlog/spdlog.h&gt;\n\nnamespace atlas {\n    class console_log_manager {\n    public:\n        static void initialize_logger_manager(\n          const std::string&amp; pattern = \"%^[%T] %n: %v%$\");\n\n        static void set_current_logger(\n          const std::string&amp; p_tag = \"Undefined g_Tag in console_logger\");\n        static void create_new_logger(\n          const std::string&amp; p_tag = \"Undefined Tag\");\n        static ref&lt;spdlog::logger&gt; get(const std::string&amp; p_tag);\n\n    private:\n        static std::unordered_map&lt;std::string, ref&lt;spdlog::logger&gt;&gt; s_loggers;\n    };\n};\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_trace(spdlog::format_string_t&lt;T...&gt; fmt, T&amp;&amp;... args) {\n    atlas::console_log_manager::get(\"engine3d\")\n      -&gt;trace(fmt, std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_warn(spdlog::format_string_t&lt;T...&gt; fmt, T&amp;&amp;... args) {\n    atlas::console_log_manager::get(\"engine3d\")\n      -&gt;warn(fmt, std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_info(spdlog::format_string_t&lt;T...&gt; fmt, T&amp;&amp;... args) {\n    atlas::console_log_manager::get(\"engine3d\")\n      -&gt;info(fmt, std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_error(spdlog::format_string_t&lt;T...&gt; fmt, T&amp;&amp;... args) {\n    atlas::console_log_manager::get(\"engine3d\")\n      -&gt;error(fmt, std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_fatal(spdlog::format_string_t&lt;T...&gt; fmt, T&amp;&amp;... args) {\n    atlas::console_log_manager::get(\"engine3d\")\n      -&gt;critical(fmt, std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_trace_tagged(const std::string&amp; p_tag,\n                         spdlog::format_string_t&lt;T...&gt; fmt,\n                         T&amp;&amp;... args) {\n    atlas::console_log_manager::get(p_tag)-&gt;trace(fmt,\n                                                  std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_info_tagged(const std::string&amp; p_tag,\n                        spdlog::format_string_t&lt;T...&gt; fmt,\n                        T&amp;&amp;... args) {\n    atlas::console_log_manager::get(p_tag)-&gt;info(fmt, std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_warn_tagged(const std::string&amp; p_tag,\n                        spdlog::format_string_t&lt;T...&gt; fmt,\n                        T&amp;&amp;... args) {\n    atlas::console_log_manager::get(p_tag)-&gt;warn(fmt, std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_error_tagged(const std::string&amp; p_tag,\n                         spdlog::format_string_t&lt;T...&gt; fmt,\n                         T&amp;&amp;... args) {\n    atlas::console_log_manager::get(p_tag)-&gt;error(fmt,\n                                                  std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_fatal_tagged(const std::string&amp; p_tag,\n                         spdlog::format_string_t&lt;T...&gt; fmt,\n                         T&amp;&amp;... args) {\n    atlas::console_log_manager::get(p_tag)-&gt;critical(fmt,\n                                                     std::forward&lt;T&gt;(args)...);\n}\n</code></pre>"},{"location":"References/timer_8hpp/","title":"File timer.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; timer.hpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/timer.hpp</code></p>"},{"location":"References/timer_8hpp_source/","title":"File timer.hpp","text":"<p>File List &gt; atlas &gt; core &gt; timer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\nDelete this file\n- Only exists to prevent merge conflicts in CMakeLists.txt\n*/\n</code></pre>"},{"location":"References/window_8hpp/","title":"File window.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; window.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include &lt;core/utilities/types.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_swapchain.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_command_buffer.hpp&gt;</code></li> </ul>"},{"location":"References/window_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/window_8hpp/#classes","title":"Classes","text":"Type Name class window <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/window.hpp</code></p>"},{"location":"References/window_8hpp_source/","title":"File window.hpp","text":"<p>File List &gt; atlas &gt; core &gt; window.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;GLFW/glfw3.h&gt;\n#include &lt;core/core.hpp&gt;\n#include &lt;vulkan/vulkan.h&gt;\n#include &lt;core/utilities/types.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_swapchain.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_command_buffer.hpp&gt;\n\nnamespace atlas {\n\n    class window {\n    public:\n        virtual ~window() = default;\n\n        [[nodiscard]] uint32_t width() const;\n\n        [[nodiscard]] uint32_t height() const;\n\n        [[nodiscard]] bool available() const;\n\n        [[nodiscard]] float aspect_ratio() const;\n\n        [[nodiscard]] uint32_t acquired_next_frame() {\n            return read_acquired_next_frame();\n        }\n\n        [[nodiscard]] vk::vk_swapchain current_swapchain() const {\n            return window_swapchain();\n        }\n\n        vk::vk_command_buffer active_command_buffer(uint32_t p_frame_idx) {\n            return current_active_command_buffer(p_frame_idx);\n        }\n\n        operator GLFWwindow*() const { return native_window(); }\n\n        operator GLFWwindow*() { return native_window(); }\n\n        void close();\n\n        void present(const uint32_t&amp; p_current_frame_idx);\n\n    private:\n        [[nodiscard]] virtual window_settings settings() const = 0;\n        [[nodiscard]] virtual GLFWwindow* native_window() const = 0;\n        [[nodiscard]] virtual uint32_t read_acquired_next_frame() = 0;\n        [[nodiscard]] virtual vk::vk_swapchain window_swapchain() const = 0;\n        [[nodiscard]] virtual vk::vk_command_buffer\n        current_active_command_buffer(const uint32_t&amp; p_frame_idx) = 0;\n        virtual void presentation_process(const uint32_t&amp; p_current_frame) = 0;\n    };\n\n    ref&lt;window&gt; create_window(const window_settings&amp; p_settings);\n};\n</code></pre>"},{"location":"References/dir_1605561db8076fbb4262fa758aa3edc0/","title":"Dir TheAtlasEngine/atlas/drivers","text":"<p>FileList &gt; atlas &gt; drivers</p>"},{"location":"References/dir_1605561db8076fbb4262fa758aa3edc0/#files","title":"Files","text":"Type Name file graphics_context.hpp file renderer_context.hpp"},{"location":"References/dir_1605561db8076fbb4262fa758aa3edc0/#directories","title":"Directories","text":"Type Name dir vulkan-cpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/</code></p>"},{"location":"References/dir_47b67bd74134333dd9ae7c9592fa3f49/","title":"Dir TheAtlasEngine/atlas/drivers/vulkan-cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp</p>"},{"location":"References/dir_47b67bd74134333dd9ae7c9592fa3f49/#files","title":"Files","text":"Type Name file hash.hpp file helper_functions.hpp file mesh.hpp file vk_command_buffer.hpp file vk_context.hpp file vk_descriptor_set.hpp file vk_driver.hpp file vk_graphics_queue.hpp file vk_imgui.hpp file vk_index_buffer.hpp file vk_physical_driver.hpp file vk_pipeline.hpp file vk_present_queue.hpp file vk_renderer.hpp file vk_renderpass.hpp file vk_shader_group.hpp file vk_swapchain.hpp file vk_texture.hpp file vk_types.hpp file vk_uniform_buffer.hpp file vk_vertex_buffer.hpp file vk_window.hpp file vulkan-imports.hpp"},{"location":"References/dir_47b67bd74134333dd9ae7c9592fa3f49/#directories","title":"Directories","text":"Type Name dir utilties <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/</code></p>"},{"location":"References/dir_2f399d7733500af2adc0d3df97496b3f/","title":"Dir TheAtlasEngine/atlas/drivers/vulkan-cpp/utilties","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; utilties</p>"},{"location":"References/dir_2f399d7733500af2adc0d3df97496b3f/#files","title":"Files","text":"Type Name file utils.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/utilties/</code></p>"},{"location":"References/utils_8hpp/","title":"File utils.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; utilties &gt; utils.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_command_buffer.hpp&gt;</code></li> </ul>"},{"location":"References/utils_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/utilties/utils.hpp</code></p>"},{"location":"References/utils_8hpp_source/","title":"File utils.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; utilties &gt; utils.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;span&gt;\n#include &lt;vulkan/vulkan_core.h&gt;\n#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_command_buffer.hpp&gt;\n\nnamespace atlas::vk {\n\n    void begin_command_buffer(const VkCommandBuffer&amp; p_command_buffer,\n                              VkCommandBufferUsageFlags p_usage_flags);\n\n    void end_command_buffer(const VkCommandBuffer&amp; p_command_buffer);\n\n    VkCommandPool create_single_command_pool();\n\n    VkCommandBuffer create_single_command_buffer(\n      const VkCommandPool&amp; p_command_pool);\n\n    void copy(vk_command_buffer&amp; p_command_buffer,\n              VkImage&amp; p_image,\n              VkBuffer&amp; p_buffer,\n              uint32_t p_width,\n              uint32_t p_height);\n\n    void copy(const vk_buffer&amp; p_src,\n              const vk_buffer&amp; p_dst,\n              size_t p_size_of_bytes);\n\n    void write(const vk_buffer&amp; p_buffer,\n               const void* p_data,\n               size_t p_size_in_bytes);\n\n    void write(const vk_buffer&amp; p_buffer,\n               const std::span&lt;uint32_t&gt;&amp; p_in_buffer);\n\n    void write(const vk_buffer&amp; p_buffer,\n               const std::span&lt;vertex_input&gt;&amp; p_in_buffer);\n\n    void transition_image_layout(VkImage&amp; p_image,\n                                 VkFormat p_format,\n                                 VkImageLayout p_old,\n                                 VkImageLayout p_new);\n\n    void transition_image_layout(VkCommandBuffer&amp; p_command_buffer,\n                                 VkImage&amp; p_image,\n                                 VkFormat p_format,\n                                 VkImageLayout p_old,\n                                 VkImageLayout p_new);\n\n    void image_memory_barrier(VkCommandBuffer&amp; p_command_buffer,\n                              VkImage&amp; p_image,\n                              VkFormat p_format,\n                              VkImageLayout p_old,\n                              VkImageLayout p_new);\n    //\n\n    void queue_submit(const VkQueue&amp; p_queue_handle,\n                      const std::span&lt;VkCommandBuffer&gt;&amp; p_commands);\n};\n</code></pre>"},{"location":"References/drivers_2vulkan-cpp_2hash_8hpp/","title":"File hash.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; hash.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;</code></li> <li><code>#include &lt;glm/gtx/hash.hpp&gt;</code></li> </ul>"},{"location":"References/drivers_2vulkan-cpp_2hash_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace std"},{"location":"References/drivers_2vulkan-cpp_2hash_8hpp/#classes","title":"Classes","text":"Type Name struct hash&lt; atlas::vk::vertex_input &gt; &lt;&gt;"},{"location":"References/drivers_2vulkan-cpp_2hash_8hpp/#macros","title":"Macros","text":"Type Name define GLM_ENABLE_EXPERIMENTAL"},{"location":"References/drivers_2vulkan-cpp_2hash_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"References/drivers_2vulkan-cpp_2hash_8hpp/#define-glm_enable_experimental","title":"define GLM_ENABLE_EXPERIMENTAL","text":"<pre><code>#define GLM_ENABLE_EXPERIMENTAL \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/hash.hpp</code></p>"},{"location":"References/drivers_2vulkan-cpp_2hash_8hpp_source/","title":"File hash.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; hash.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;\n#define GLM_ENABLE_EXPERIMENTAL\n#include &lt;glm/gtx/hash.hpp&gt;\n\nnamespace atlas {\n    template&lt;typename T, typename... Rest&gt;\n    void hash_combine(size_t&amp; seed, const T&amp; v, const Rest&amp;... rest) {\n        seed ^= std::hash&lt;T&gt;()(v) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &lt;&lt; 2);\n        (hash_combine(seed, rest), ...);\n    }\n\n};\n\nnamespace std {\n\n    template&lt;&gt;\n    struct hash&lt;atlas::vk::vertex_input&gt; {\n        size_t operator()(const atlas::vk::vertex_input&amp; vertex) const {\n            size_t seed = 0;\n            atlas::hash_combine(\n              seed, vertex.position, vertex.color, vertex.normals, vertex.uv);\n            return seed;\n        }\n    };\n}\n</code></pre>"},{"location":"References/helper__functions_8hpp/","title":"File helper_functions.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; helper_functions.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_command_buffer.hpp&gt;</code></li> <li><code>#include &lt;source_location&gt;</code></li> </ul>"},{"location":"References/helper__functions_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/helper_functions.hpp</code></p>"},{"location":"References/helper__functions_8hpp_source/","title":"File helper_functions.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; helper_functions.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n#include &lt;span&gt;\n#include &lt;vulkan/vulkan_core.h&gt;\n#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_command_buffer.hpp&gt;\n#include &lt;source_location&gt;\n\nnamespace atlas::vk {\n\n    void vk_check(\n      const VkResult&amp; p_result,\n      const std::string&amp; p_name,\n      const std::source_location&amp; p_source = std::source_location::current());\n\n    void vk_check_format(VkFormat p_format,\n                         const char* p_filepath,\n                         uint32_t p_line,\n                         const char* p_function_name);\n\n    VkFormat to_vk_format(const format&amp; p_format);\n\n    VkImageView create_image_view(const VkImage&amp; p_image,\n                                  VkFormat p_format,\n                                  VkImageAspectFlags p_aspect_flags);\n\n    VkImageView create_image_view(const VkDevice&amp; p_driver,\n                                  VkImage p_image,\n                                  VkSurfaceFormatKHR p_surface_format,\n                                  VkImageAspectFlags p_aspect_flags,\n                                  VkImageViewType p_view_t,\n                                  uint32_t p_layer_count,\n                                  uint32_t p_mip_level = 1);\n\n    vk_image create_image2d(uint32_t p_width,\n                            uint32_t p_height,\n                            VkFormat p_format,\n                            VkImageUsageFlags p_usage,\n                            VkMemoryPropertyFlagBits p_property);\n\n    VkSampler create_sampler(const vk_filter_range&amp; p_range,\n                             VkSamplerAddressMode p_address_mode);\n\n    vk_image_handle create_image2d(const VkDevice&amp; p_driver,\n                                   const image_extent&amp; p_extent);\n\n    void free_buffer(const VkDevice&amp; p_driver, vk_buffer&amp; p_buffer);\n\n    void free_image(const VkDevice&amp; p_driver, vk_image&amp; p_image);\n\n    VkShaderStageFlags to_vk_shader_stage(const shader_stage&amp; p_stage);\n\n    VkShaderStageFlagBits to_vk_shader_stage_bits(const shader_stage&amp; p_stage);\n\n    vk_buffer create_uniform_buffer(uint32_t p_size);\n\n    VkDescriptorType to_vk_descriptor_type(const buffer&amp; p_type);\n\n    VkCommandBufferLevel to_vk_command_buffer_level(\n      const command_buffer_levels&amp; p_levels);\n\n    VkSemaphore create_semaphore(const VkDevice&amp; p_driver);\n\n    vk_buffer create_buffer(const vk_buffer_info&amp; p_info);\n\n    bool has_stencil_attachment(VkFormat p_format);\n\n    std::string vk_present_mode_to_string(VkPresentModeKHR p_present_mode);\n\n    std::string vk_format_to_string(VkFormat p_format);\n\n    int bytes_per_texture_format(VkFormat p_format);\n\n    VkPresentModeKHR select_compatible_present_mode(\n      const VkPresentModeKHR&amp; p_request,\n      const std::span&lt;VkPresentModeKHR&gt;&amp; p_modes);\n\n    uint32_t select_images_size(\n      const VkSurfaceCapabilitiesKHR&amp; p_surface_capabilities);\n\n    VkPipelineBindPoint to_vk_pipeline_bind_point(\n      const pipeline_bind_point&amp; p_bind_point);\n\n    VkAttachmentLoadOp to_vk_attachment_load(attachment_load p_attachment_type);\n\n    VkAttachmentStoreOp to_vk_attachment_store(\n      const attachment_store&amp; p_attachment_type);\n\n    VkSampleCountFlagBits to_vk_sample_count_bits(\n      const sample_bit&amp; p_sample_count_bit);\n\n    VkImageLayout to_vk_image_layout(const image_layout&amp; p_layout);\n\n    VkVertexInputRate to_vk_input_rate(const input_rate&amp; p_input_rate);\n};\n</code></pre>"},{"location":"References/drivers_2vulkan-cpp_2mesh_8hpp/","title":"File mesh.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; mesh.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/vulkan-cpp/vk_vertex_buffer.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_index_buffer.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;</code></li> <li><code>#include &lt;glm/gtx/hash.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_texture.hpp&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_uniform_buffer.hpp&gt;</code></li> </ul>"},{"location":"References/drivers_2vulkan-cpp_2mesh_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/drivers_2vulkan-cpp_2mesh_8hpp/#classes","title":"Classes","text":"Type Name class mesh mesh class specifically defined with vulkan implementations for specific primitives TODO: Whenever we load in a texture that will be laucnhed asyncronously"},{"location":"References/drivers_2vulkan-cpp_2mesh_8hpp/#macros","title":"Macros","text":"Type Name define GLM_ENABLE_EXPERIMENTAL"},{"location":"References/drivers_2vulkan-cpp_2mesh_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"References/drivers_2vulkan-cpp_2mesh_8hpp/#define-glm_enable_experimental","title":"define GLM_ENABLE_EXPERIMENTAL","text":"<pre><code>#define GLM_ENABLE_EXPERIMENTAL \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/mesh.hpp</code></p>"},{"location":"References/drivers_2vulkan-cpp_2mesh_8hpp_source/","title":"File mesh.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; mesh.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;drivers/vulkan-cpp/vk_vertex_buffer.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_index_buffer.hpp&gt;\n\n#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;\n\n#define GLM_ENABLE_EXPERIMENTAL\n#include &lt;glm/gtx/hash.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_texture.hpp&gt;\n#include &lt;filesystem&gt;\n#include &lt;drivers/vulkan-cpp/vk_uniform_buffer.hpp&gt;\n\nnamespace atlas::vk {\n\n    class mesh {\n    public:\n        mesh() = default;\n        mesh(const std::span&lt;vertex_input&gt;&amp; p_vertices,\n             const std::span&lt;uint32_t&gt;&amp; p_indices);\n        mesh(const std::filesystem::path&amp; p_filename);\n\n        void reload_mesh(const std::filesystem::path&amp; p_path);\n\n        void initialize_uniforms(uint32_t p_size_bytes_ubo);\n\n        void update_uniform(const material_uniform&amp; p_material_ubo);\n\n        [[nodiscard]] vk_uniform_buffer material_ubo() const {\n            return m_geoemtry_ubo;\n        }\n\n        void draw(const VkCommandBuffer&amp; p_command_buffer);\n\n        void destroy();\n\n        void add_texture(const std::filesystem::path&amp; p_path);\n\n        [[nodiscard]] std::span&lt;texture&gt; read_textures() { return m_textures; }\n\n        [[nodiscard]] bool loaded() const { return m_model_loaded; }\n\n    private:\n        void load_obj(const std::filesystem::path&amp; p_filename);\n        void load_gltf(const std::filesystem::path&amp; p_filename);\n\n    private:\n        std::vector&lt;texture&gt; m_textures;\n        vk_vertex_buffer m_vbo{};\n        vk_index_buffer m_ibo{};\n        vk_uniform_buffer m_geoemtry_ubo;\n        bool m_model_loaded = false;\n    };\n};\n</code></pre>"},{"location":"References/vk__command__buffer_8hpp/","title":"File vk_command_buffer.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_command_buffer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;</code></li> </ul>"},{"location":"References/vk__command__buffer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__command__buffer_8hpp/#classes","title":"Classes","text":"Type Name class vk_command_buffer Vulkan Command Buffers. <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_command_buffer.hpp</code></p>"},{"location":"References/vk__command__buffer_8hpp_source/","title":"File vk_command_buffer.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_command_buffer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n#include &lt;vulkan/vulkan.h&gt;\n#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;\n\nnamespace atlas::vk {\n\n    class vk_command_buffer {\n    public:\n        vk_command_buffer() = default;\n\n        vk_command_buffer(const command_buffer_settings&amp; p_settings);\n\n        void begin(const VkCommandBufferUsageFlags&amp; p_usage_flags);\n\n        void end();\n\n        [[nodiscard]] bool is_valid() const {\n            return (m_command_buffer_handler != nullptr);\n        }\n\n        void destroy();\n\n        operator VkCommandBuffer() const {\n            if (m_begin_end_count != 2) {\n            }\n            return m_command_buffer_handler;\n        }\n        operator VkCommandBuffer() { return m_command_buffer_handler; }\n\n    private:\n        VkDevice m_driver = nullptr;\n        VkCommandBuffer m_command_buffer_handler = nullptr;\n        VkCommandPool m_command_pool = nullptr;\n        uint32_t m_begin_end_count = 0;\n    };\n};\n</code></pre>"},{"location":"References/vk__context_8hpp/","title":"File vk_context.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_context.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/graphics_context.hpp&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include &lt;deque&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_driver.hpp&gt;</code></li> </ul>"},{"location":"References/vk__context_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__context_8hpp/#classes","title":"Classes","text":"Type Name class vk_context <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_context.hpp</code></p>"},{"location":"References/vk__context_8hpp_source/","title":"File vk_context.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_context.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;drivers/graphics_context.hpp&gt;\n#include &lt;vulkan/vulkan.h&gt;\n#include &lt;deque&gt;\n#include &lt;drivers/vulkan-cpp/vk_driver.hpp&gt;\n\nnamespace atlas::vk {\n    class vk_context : public graphics_context {\n    public:\n        vk_context(const std::string&amp; p_tag);\n\n        static void submit_resource_free(std::function&lt;void()&gt;&amp;&amp; p_resource);\n\n        static VkInstance handler();\n\n        static vk_physical_driver physical_driver() {\n            return s_instance-&gt;m_physical;\n        }\n\n        static vk_driver driver_context() { return s_instance-&gt;m_driver; }\n\n    private:\n        void resource_free(std::function&lt;void()&gt;&amp;&amp; p_resource);\n\n    private:\n        void destroy_context() override;\n\n    private:\n        static vk_context* s_instance;\n        VkInstance m_instance_handler = nullptr;\n        vk_physical_driver m_physical{};\n        vk_driver m_driver{};\n        std::deque&lt;std::function&lt;void()&gt;&gt; m_resources_free{};\n    };\n};\n</code></pre>"},{"location":"References/vk__descriptor__set_8hpp/","title":"File vk_descriptor_set.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_descriptor_set.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_uniform_buffer.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_vertex_buffer.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_texture.hpp&gt;</code></li> </ul>"},{"location":"References/vk__descriptor__set_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__descriptor__set_8hpp/#classes","title":"Classes","text":"Type Name class descriptor_set <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_descriptor_set.hpp</code></p>"},{"location":"References/vk__descriptor__set_8hpp_source/","title":"File vk_descriptor_set.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_descriptor_set.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n#include &lt;string&gt;\n#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;\n#include &lt;span&gt;\n#include &lt;vulkan/vulkan.h&gt;\n#include &lt;vector&gt;\n#include &lt;drivers/vulkan-cpp/vk_uniform_buffer.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_vertex_buffer.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_uniform_buffer.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_texture.hpp&gt;\n\nnamespace atlas::vk {\n\n    // TODO: These structs are for adding some high-level specifications for\n    // writing resources via to the descriptors struct write_buffer_descriptor {\n    //     std::span&lt;vk_uniform_buffer&gt; data;\n    // };\n\n    // struct write_image_descriptor {\n    //     std::span&lt;texture&gt; data;\n    //     image_layout layout;\n    // };\n\n    // struct write_descriptors {\n    //     std::span&lt;vk_uniform_buffer&gt; uniforms;\n    //     // std::span&lt;texture&gt; images;\n    //     write_image_descriptor image;\n    //     uint32_t dst_binding;\n    //     uint32_t descriptor_count;\n    //     buffer descriptor_type;\n    // };\n\n    class descriptor_set {\n    public:\n        descriptor_set() = default;\n        descriptor_set(const uint32_t&amp; p_set_slot,\n                       const descriptor_set_layout&amp; p_entry);\n        ~descriptor_set() = default;\n\n        void bind(const VkCommandBuffer&amp; p_current,\n                  uint32_t p_frame_index,\n                  const VkPipelineLayout&amp;);\n\n        [[nodiscard]] VkDescriptorSetLayout get_layout() const {\n            return m_descriptor_set_layout;\n        }\n\n        void update(const std::span&lt;vk_uniform_buffer&gt;&amp; p_uniforms,\n                    const std::span&lt;texture&gt;&amp; p_textures);\n\n        void update(const std::span&lt;vk_uniform_buffer&gt;&amp; p_uniforms);\n\n        // void update(const std::span&lt;write_descriptors&gt;&amp; p_descriptors);\n        // void update(const vk_uniform_buffer&amp; p_uniforms);\n\n        void destroy();\n\n    private:\n        VkDevice m_driver = nullptr;\n        uint32_t m_set_slot = 0;\n        uint32_t m_allocated_descriptors = 0;\n        uint32_t m_size_bytes = 0;\n        VkDescriptorPool m_descriptor_pool = nullptr;\n        VkDescriptorSetLayout m_descriptor_set_layout = nullptr;\n        std::vector&lt;VkDescriptorSet&gt; m_descriptor_sets{};\n        texture m_error_texture;\n    };\n};\n</code></pre>"},{"location":"References/vk__driver_8hpp/","title":"File vk_driver.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_driver.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_physical_driver.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;</code></li> </ul>"},{"location":"References/vk__driver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__driver_8hpp/#classes","title":"Classes","text":"Type Name class vk_driver vulkan implementation of extracting a logical device <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_driver.hpp</code></p>"},{"location":"References/vk__driver_8hpp_source/","title":"File vk_driver.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_driver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;vulkan/vulkan.h&gt;\n#include &lt;drivers/vulkan-cpp/vk_physical_driver.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;\n\nnamespace atlas::vk {\n\n    class vk_driver {\n        struct device_queue_family {\n            VkQueue graphics_queue;\n            VkQueue transfer_queue;\n            VkQueue compute_queue;\n        };\n\n    public:\n        vk_driver() = default;\n        vk_driver(const vk_physical_driver&amp; p_physical);\n        ~vk_driver() = default;\n\n        [[nodiscard]] VkQueue graphics_queue() const {\n            return m_device_queues.graphics_queue;\n        }\n\n        uint32_t select_memory_type(uint32_t p_type_filter,\n                                    VkMemoryPropertyFlags p_property_flag);\n\n        // This is just for specifically getting presentation queue\n        // Now that I think about this, I may as well use this to get our\n        // specific queue family from this logical device\n        VkQueue get_queue(const vk_queue_options&amp; p_present_queue);\n\n        void destroy();\n\n        [[nodiscard]] VkFormat depth_format() const;\n\n        operator VkDevice() const { return m_driver; }\n\n        operator VkDevice() { return m_driver; }\n\n    private:\n        static vk_driver* s_instance;\n        vk_physical_driver m_physical{};\n        VkDevice m_driver = nullptr;\n        device_queue_family m_device_queues{};\n        VkFormat m_depth_format_selected;\n    };\n\n};\n</code></pre>"},{"location":"References/vk__graphics__queue_8hpp/","title":"File vk_graphics_queue.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_graphics_queue.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_driver.hpp&gt;</code></li> </ul>"},{"location":"References/vk__graphics__queue_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__graphics__queue_8hpp/#classes","title":"Classes","text":"Type Name class vk_graphics_queue graphics queue mainly used for submitting to the graphics family specific queue <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_graphics_queue.hpp</code></p>"},{"location":"References/vk__graphics__queue_8hpp_source/","title":"File vk_graphics_queue.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_graphics_queue.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_driver.hpp&gt;\n\nnamespace atlas::vk {\n    class vk_graphics_queue {\n    public:\n        vk_graphics_queue() = default;\n\n        vk_graphics_queue(const vk_queue_options&amp; p_queue_options);\n\n        void immediate_submit_sync(const VkCommandBuffer&amp; p_command_buffer);\n\n        void immediate_submit_async(const VkCommandBuffer&amp; p_command_buffer);\n\n        void wait_idle();\n\n        void destroy();\n\n        operator VkQueue() { return m_graphics_queue_handler; }\n\n        operator VkQueue() const { return m_graphics_queue_handler; }\n\n    private:\n        vk_physical_driver m_physical{};\n        vk_driver m_driver{};\n        VkQueue m_graphics_queue_handler = nullptr;\n\n        VkSemaphore m_render_completed_semaphore = nullptr;\n        VkSemaphore m_present_completed_semaphore = nullptr;\n    };\n};\n</code></pre>"},{"location":"References/vk__imgui_8hpp/","title":"File vk_imgui.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_imgui.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_swapchain.hpp&gt;</code></li> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_driver.hpp&gt;</code></li> </ul>"},{"location":"References/vk__imgui_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__imgui_8hpp/#classes","title":"Classes","text":"Type Name struct hud_data class imgui_context <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_imgui.hpp</code></p>"},{"location":"References/vk__imgui_8hpp_source/","title":"File vk_imgui.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_imgui.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n#include &lt;vulkan/vulkan.h&gt;\n#include &lt;drivers/vulkan-cpp/vk_swapchain.hpp&gt;\n#include &lt;GLFW/glfw3.h&gt;\n#include &lt;drivers/vulkan-cpp/vk_driver.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_swapchain.hpp&gt;\n\nnamespace atlas::vk {\n    struct hud_data {\n        float playerHealth = 100.0f;\n        int playerScore = 0;\n        float fps = 0.0f;\n        std::string currentWeapon = \"Assault Rifle\";\n        // Add more data as needed\n    };\n\n    class imgui_context {\n    public:\n        imgui_context() = default;\n        imgui_context(GLFWwindow* p_window_handler,\n                      const vk_swapchain&amp; p_current_swapchain_handler,\n                      const VkRenderPass&amp; p_current_renderpass);\n\n        void recreate(GLFWwindow* p_window_handler,\n                      const uint32_t&amp; p_image_size,\n                      const VkRenderPass&amp; p_current_renderpass);\n\n        void begin(const VkCommandBuffer&amp; p_current,\n                   const uint32_t&amp; p_current_frame_idx);\n        void end();\n\n        // HUD Example, using this to test if imgui initialization works\n        // note: experiemental, for testing imgui with new vulkan implementation\n        // Proper API I want to have this be in atlas::ui::hud namespace\n        // API Usage: ui::hud::health_bar(float)\n        // If users have custom components they want to register to the UI, then\n        // do:\n        /*\n            template&lt;typename UComponent, typename UType&gt;\n            void custom_hud_component(UComponent* p_component,, UType p_type) {\n                // then prob do something lik this: use template to associate\n           struct component and the data, with type specified\n                imgui::progress_bar((p_component)-&gt;*p_data);\n            }\n\n            User-side would be the following:\n            struct custom_component_heatlh {\n                uint32_t health_data = 10;\n            };\n            some_entity-&gt;set&lt;custom_component_heatlh&gt;({});\n            const custom_component_health* player_hp =\n           some_entity.get&lt;custom_component_heatlh&gt;();\n\n            // Through this specifications the UI will now apply this to the hud\n            // Questions that needs to be talked here are the following points:\n            1.) How will users specify UI component uses?\n                * Position of HUD\n                * Handling alignment of the HUD\n            2.) Ease of usability with minimal specifications on user-side for\n           getting HUD's to work 3.) Making a class be optional, meaning have\n           this be through imgui's API's as a function 4.) Asking if its needed\n           to be represented as a class atlas::ui::hud::health_bar(player_hp,\n           &amp;custom_component_health::health_data)\n        */\n        void draw_hud(const hud_data&amp; p_test,\n                      const window_settings&amp; p_settings);\n\n    private:\n        VkInstance m_instance = nullptr;\n        VkPhysicalDevice m_physical = nullptr;\n        vk_driver m_driver{};\n        VkSwapchainKHR m_current_swapchain_handler = nullptr;\n\n        VkDescriptorPool m_desc_pool = nullptr;\n        VkCommandBuffer m_current_command = nullptr;\n    };\n};\n</code></pre>"},{"location":"References/vk__index__buffer_8hpp/","title":"File vk_index_buffer.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_index_buffer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;</code></li> </ul>"},{"location":"References/vk__index__buffer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__index__buffer_8hpp/#classes","title":"Classes","text":"Type Name class vk_index_buffer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_index_buffer.hpp</code></p>"},{"location":"References/vk__index__buffer_8hpp_source/","title":"File vk_index_buffer.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_index_buffer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;span&gt;\n#include &lt;vulkan/vulkan.h&gt;\n#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;\n\nnamespace atlas::vk {\n    class vk_index_buffer {\n    public:\n        vk_index_buffer() = default;\n        vk_index_buffer(const std::span&lt;uint32_t&gt;&amp; p_indices);\n\n        void bind(const VkCommandBuffer&amp; p_current);\n\n        void draw(const VkCommandBuffer&amp; p_current);\n\n        void destroy();\n\n        [[nodiscard]] size_t size() const { return m_indices_count; }\n\n    private:\n        VkDevice m_driver = nullptr;\n        uint32_t m_indices_count = 0;\n        vk_buffer m_index_buffer_handler{};\n    };\n};\n</code></pre>"},{"location":"References/vk__physical__driver_8hpp/","title":"File vk_physical_driver.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_physical_driver.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"References/vk__physical__driver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__physical__driver_8hpp/#classes","title":"Classes","text":"Type Name struct surface_properties class vk_physical_driver <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_physical_driver.hpp</code></p>"},{"location":"References/vk__physical__driver_8hpp_source/","title":"File vk_physical_driver.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_physical_driver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;vulkan/vulkan.h&gt;\n#include &lt;vector&gt;\n\nnamespace atlas::vk {\n\n    struct surface_properties {\n        VkSurfaceCapabilitiesKHR surface_capabilities;\n        VkSurfaceFormatKHR surface_format;\n    };\n\n    class vk_physical_driver {\n        struct queue_family_indices {\n            uint32_t graphics = -1;\n            uint32_t compute = -1;\n            uint32_t transfer = -1;\n        };\n\n    public:\n        vk_physical_driver() = default;\n        vk_physical_driver(const VkInstance&amp; p_instance);\n        ~vk_physical_driver();\n\n        [[nodiscard]] queue_family_indices read_queue_family_indices() const {\n            return m_queue_indices;\n        }\n\n        [[nodiscard]] uint32_t read_presentation_index(\n          const VkSurfaceKHR&amp; p_surface);\n\n        [[nodiscard]] surface_properties get_surface_properties(\n          const VkSurfaceKHR&amp; p_surface);\n\n        operator VkPhysicalDevice() { return m_physical_driver; }\n\n        operator VkPhysicalDevice() const { return m_physical_driver; }\n\n    private:\n        queue_family_indices select_queue_family_indices();\n\n    private:\n        static vk_physical_driver* s_instance;\n        VkPhysicalDevice m_physical_driver = nullptr;\n        queue_family_indices m_queue_indices{};\n        std::vector&lt;VkQueueFamilyProperties&gt; m_queue_family_properties{};\n        surface_properties m_surface_properties{};\n    };\n};\n</code></pre>"},{"location":"References/vk__pipeline_8hpp/","title":"File vk_pipeline.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_pipeline.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_shader_group.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_descriptor_set.hpp&gt;</code></li> </ul>"},{"location":"References/vk__pipeline_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__pipeline_8hpp/#classes","title":"Classes","text":"Type Name class vk_pipeline <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_pipeline.hpp</code></p>"},{"location":"References/vk__pipeline_8hpp_source/","title":"File vk_pipeline.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_pipeline.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;vulkan/vulkan.h&gt;\n#include &lt;drivers/vulkan-cpp/vk_shader_group.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_descriptor_set.hpp&gt;\n\nnamespace atlas::vk {\n\n    class vk_pipeline {\n    public:\n        vk_pipeline() = default;\n        vk_pipeline(const VkRenderPass&amp; p_renderpass,\n                    vk_shader_group&amp; p_shader_group);\n        vk_pipeline(\n          const VkRenderPass&amp; p_renderpass,\n          const vk_shader_group&amp; p_shader_group,\n          const std::span&lt;VkDescriptorSetLayout&gt;&amp; p_descriptor_layout);\n\n        void create(const VkRenderPass&amp; p_renderpass);\n\n        void bind(const VkCommandBuffer&amp; p_current);\n\n        void destroy();\n\n        [[nodiscard]] VkPipelineLayout get_layout() const {\n            return m_pipeline_layout;\n        }\n\n        [[nodiscard]] VkPipelineLayout layout() const {\n            return m_pipeline_layout;\n        }\n\n        operator VkPipeline() { return m_pipeline_handler; }\n\n        operator VkPipeline() const { return m_pipeline_handler; }\n\n    private:\n        VkDevice m_driver = nullptr;\n        VkPipelineLayout m_pipeline_layout = nullptr;\n        VkPipeline m_pipeline_handler = nullptr;\n        vk_shader_group m_shader_group;\n        // VkDescriptorSetLayout m_descriptor_set_layout=nullptr;\n        std::span&lt;VkDescriptorSetLayout&gt; m_descriptor_layouts{};\n    };\n};\n</code></pre>"},{"location":"References/vk__present__queue_8hpp/","title":"File vk_present_queue.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_present_queue.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_driver.hpp&gt;</code></li> </ul>"},{"location":"References/vk__present__queue_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__present__queue_8hpp/#classes","title":"Classes","text":"Type Name class vk_present_queue Handles submissions to the specific queue for presentation. <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_present_queue.hpp</code></p>"},{"location":"References/vk__present__queue_8hpp_source/","title":"File vk_present_queue.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_present_queue.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_driver.hpp&gt;\n\nnamespace atlas::vk {\n\n    class vk_present_queue {\n    public:\n        vk_present_queue() = default;\n\n        vk_present_queue(const VkSwapchainKHR&amp; p_swapchain,\n                         const vk_queue_options&amp; p_queue_options);\n\n        void submit_immediate_async(const VkCommandBuffer&amp; p_command);\n\n        void submit_immediate_sync(const VkCommandBuffer&amp; p_command);\n\n        // These are ??? atm because the idea is we submit commands to the\n        // presentation queue's then flush them at once\n        // void submit(const VkCommandBuffer&amp; p_command);\n\n        // void execute();\n\n        void present_frame(const uint32_t&amp; p_current_frame);\n\n        void wait_idle();\n\n        uint32_t acquired_frame();\n\n        [[nodiscard]] bool resize_requested() const {\n            return m_resize_requested;\n        }\n\n        void set_resize_status(bool p_status) { m_resize_requested = p_status; }\n\n        [[nodiscard]] bool is_alive() const {\n            return (m_present_queue_handler != nullptr);\n        }\n\n        void destroy();\n\n        operator VkQueue() { return m_present_queue_handler; }\n\n        operator VkQueue() const { return m_present_queue_handler; }\n\n    private:\n        vk_driver m_driver{};\n        VkQueue m_present_queue_handler = nullptr;\n        VkSwapchainKHR m_swapchain_handler = nullptr;\n        VkSemaphore m_render_completed_semaphore = nullptr;\n        VkSemaphore m_present_completed_semaphore = nullptr;\n        bool m_resize_requested = false;\n    };\n};\n</code></pre>"},{"location":"References/vk__renderer_8hpp/","title":"File vk_renderer.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_renderer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;drivers/renderer_context.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_swapchain.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_command_buffer.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_shader_group.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_pipeline.hpp&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/mesh.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_uniform_buffer.hpp&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;core/scene/components.hpp&gt;</code></li> </ul>"},{"location":"References/vk__renderer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__renderer_8hpp/#classes","title":"Classes","text":"Type Name class vk_renderer Something to consider for mesh loading. <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_renderer.hpp</code></p>"},{"location":"References/vk__renderer_8hpp_source/","title":"File vk_renderer.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_renderer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n#include &lt;drivers/renderer_context.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_swapchain.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_command_buffer.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_shader_group.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_pipeline.hpp&gt;\n#include &lt;vector&gt;\n#include &lt;drivers/vulkan-cpp/mesh.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_uniform_buffer.hpp&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;core/scene/components.hpp&gt;\n\nnamespace atlas::vk {\n    class vk_renderer : public render_context {\n    public:\n        vk_renderer(const vk_swapchain&amp; p_swapchain, const std::string&amp; p_tag);\n\n        ~vk_renderer() override = default;\n\n    private:\n        void start_frame(const vk_command_buffer&amp; p_current,\n                         const vk_swapchain&amp; p_swapchain_handler) override;\n        void post_frame() override;\n        void background_color(const std::array&lt;float, 4&gt;&amp; p_color) override;\n\n    private:\n        vk_swapchain m_main_swapchain{};\n        vk_command_buffer m_current_command_buffer{};\n        VkClearColorValue m_color;\n\n        vk_shader_group m_shader_group;\n        vk_pipeline m_main_pipeline{};\n        uint32_t m_image_count = 0;\n\n        // descriptors for global uniforms for global camera data\n        std::vector&lt;vk_uniform_buffer&gt; m_global_uniforms{};\n        descriptor_set m_global_descriptor{};\n\n        // Contain descriptor layouts that gets used by the main VkPipeline\n        // (graphics pipeline)\n        std::vector&lt;VkDescriptorSetLayout&gt; m_geometry_descriptor_layout;\n\n        // This is for caching any loaded mesh and only modifying this mesh if\n        // that entity is there. It is for this vk_renderer to manage\n        // std::string = the name of the entity\n        // mesh = corresponding to the entity that is being loaded\n        std::map&lt;std::string, mesh&gt; m_cached_meshes;\n\n        // std::string = entity name\n        // descriptor_set for now will represent the material descriptor set\n        // std::map&lt;std::string, descriptor_set&gt; m_geometry_descriptor;\n\n        std::map&lt;std::string, std::map&lt;std::string, descriptor_set&gt;&gt;\n          m_mesh_descriptors;\n        descriptor_set_layout m_material_descriptor_layout;\n\n        bool m_begin_initialize = true;\n        uint32_t m_current_frame = 0;\n        camera m_camera;\n        glm::mat4 m_model = { 1.f };\n    };\n};\n</code></pre>"},{"location":"References/vk__renderpass_8hpp/","title":"File vk_renderpass.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_renderpass.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_driver.hpp&gt;</code></li> </ul>"},{"location":"References/vk__renderpass_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__renderpass_8hpp/#classes","title":"Classes","text":"Type Name class vk_renderpass defines a renderpass operation <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_renderpass.hpp</code></p>"},{"location":"References/vk__renderpass_8hpp_source/","title":"File vk_renderpass.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_renderpass.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;\n#include &lt;vulkan/vulkan.h&gt;\n#include &lt;drivers/vulkan-cpp/vk_driver.hpp&gt;\n\nnamespace atlas::vk {\n\n    class vk_renderpass {\n    public:\n        vk_renderpass() = default;\n\n        vk_renderpass(const vk_renderpass_options&amp; p_renderpass_options);\n\n        // TODO: Add this constructor once renderpass_options is implemented to\n        // handle VkAttachmentReference vk_renderpass(const renderpass_options&amp;\n        // p_renderpass_configuration);\n\n        // Used when needing to reconstruct the renderpass state\n        // Usable when resizing event occurs and renderpass state of the handler\n        // needs to match the swapchain during resizing\n        void configure(const vk_renderpass_options&amp; p_renderpass_options);\n\n        // TODO: Implement this function to setup renderpass attachments and\n        // handle VkAttachmentReference void configure(const renderpass_options&amp;\n        // p_renderpass_options);\n\n        void destroy();\n\n        operator VkRenderPass() const { return m_renderpass_handler; }\n\n        operator VkRenderPass() { return m_renderpass_handler; }\n\n    private:\n        vk_driver m_driver{};\n        vk_renderpass_options m_renderpass_options{};\n        VkRenderPass m_renderpass_handler = nullptr;\n    };\n};\n</code></pre>"},{"location":"References/vk__shader__group_8hpp/","title":"File vk_shader_group.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_shader_group.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;initializer_list&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_driver.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;</code></li> </ul>"},{"location":"References/vk__shader__group_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__shader__group_8hpp/#classes","title":"Classes","text":"Type Name class vk_shader_group <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_shader_group.hpp</code></p>"},{"location":"References/vk__shader__group_8hpp_source/","title":"File vk_shader_group.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_shader_group.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;initializer_list&gt;\n#include &lt;span&gt;\n#include &lt;vector&gt;\n#include &lt;vulkan/vulkan.h&gt;\n#include &lt;drivers/vulkan-cpp/vk_driver.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;\n\nnamespace atlas::vk {\n\n    class vk_shader_group {\n    public:\n        vk_shader_group() = default;\n\n        vk_shader_group(const std::initializer_list&lt;shader_info&gt;&amp; p_list);\n\n        // Does not limit users to the data structure type they need to pass in\n        // for the shader sources\n        vk_shader_group(const std::span&lt;shader_info&gt;&amp; p_shader_sources);\n\n        void set_vertex_attributes(\n          const std::initializer_list&lt;VkVertexInputAttributeDescription&gt;&amp;\n            p_attributes);\n\n        void set_vertex_bind_attributes(\n          const std::initializer_list&lt;VkVertexInputBindingDescription&gt;&amp;\n            p_bind_attributes);\n\n        void set_vertex_attributes(\n          const std::span&lt;VkVertexInputAttributeDescription&gt;&amp; p_attributes);\n\n        void set_vertex_bind_attributes(\n          const std::span&lt;VkVertexInputBindingDescription&gt;&amp; p_bind_attributes);\n\n        void vertex_attributes(\n          const std::span&lt;vertex_attribute&gt;&amp; p_vertex_attributes);\n\n        [[nodiscard]] std::span&lt;const vk_shader_module&gt; data() const {\n            return m_shader_modules;\n        }\n\n        [[nodiscard]] std::span&lt;VkVertexInputAttributeDescription&gt;\n        vertex_attributes() {\n            return m_vertex_attributes;\n        }\n\n        [[nodiscard]] std::span&lt;VkVertexInputBindingDescription&gt;\n        vertex_bind_attributes() {\n            return m_vertex_binding_attributes;\n        }\n\n        [[nodiscard]] uint32_t size() const { return m_shader_modules.size(); }\n\n        void compile();\n\n        void destroy();\n\n    private:\n        vk_driver m_driver{};\n        std::vector&lt;shader_info&gt; m_shader_sources{};\n        std::vector&lt;vk_shader_module&gt; m_shader_modules{};\n\n        std::vector&lt;VkVertexInputAttributeDescription&gt; m_vertex_attributes{};\n        std::vector&lt;VkVertexInputBindingDescription&gt;\n          m_vertex_binding_attributes{};\n    };\n};\n</code></pre>"},{"location":"References/vk__swapchain_8hpp/","title":"File vk_swapchain.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_swapchain.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/utilities/types.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_driver.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_command_buffer.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_present_queue.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_renderpass.hpp&gt;</code></li> </ul>"},{"location":"References/vk__swapchain_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__swapchain_8hpp/#classes","title":"Classes","text":"Type Name class vk_swapchain <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_swapchain.hpp</code></p>"},{"location":"References/vk__swapchain_8hpp_source/","title":"File vk_swapchain.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_swapchain.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/utilities/types.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_driver.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_command_buffer.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_present_queue.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_renderpass.hpp&gt;\n\nnamespace atlas::vk {\n    class vk_swapchain {\n    public:\n        vk_swapchain() = default;\n\n        vk_swapchain(const VkSurfaceKHR&amp; p_surface,\n                     const window_settings&amp; p_settings);\n\n        void configure(const window_settings&amp; p_settings);\n\n        // NOTE: Should remove this. Leaving this here is because currently\n        // deciding what might be an approach for setting up swapchain void\n        // reconfigure(const window_settings&amp; p_settings);\n\n        uint32_t read_acquired_image();\n\n        [[nodiscard]] vk_command_buffer active_command_buffer(\n          uint32_t p_frame) const {\n            return m_swapchain_command_buffers[p_frame];\n        }\n\n        [[nodiscard]] VkFramebuffer active_framebuffer(uint32_t p_frame) const {\n            return m_swapchain_framebuffers[p_frame];\n        }\n\n        [[nodiscard]] VkRenderPass swapchain_renderpass() const {\n            return m_swapchain_main_renderpass;\n        }\n\n        [[nodiscard]] window_settings settings() const {\n            return m_window_settings;\n        }\n\n        [[nodiscard]] uint32_t image_size() const { return m_image_size; }\n\n        [[nodiscard]] surface_properties data() const {\n            return m_surface_properties;\n        }\n\n        void destroy();\n\n        void submit(const VkCommandBuffer&amp; p_command);\n\n        operator VkSwapchainKHR() const { return m_swapchain_handler; }\n\n        operator VkSwapchainKHR() { return m_swapchain_handler; }\n\n        void present(const uint32_t&amp; p_current_frame);\n\n    private:\n        void recreate();\n        void on_create();\n\n    private:\n        vk_physical_driver m_physical{};\n        vk_driver m_driver{};\n        VkSurfaceKHR m_current_surface_handler = nullptr;\n        VkSwapchainKHR m_swapchain_handler = nullptr;\n        VkExtent2D m_swapchain_extent{};\n        window_settings m_window_settings{};\n\n        uint32_t m_image_size = 0;\n\n        VkRenderPass m_color_renderpass = nullptr;\n\n        VkSurfaceKHR m_current_surface = nullptr;\n        surface_properties m_surface_properties{};\n        std::vector&lt;vk_command_buffer&gt; m_swapchain_command_buffers{};\n        std::vector&lt;VkFramebuffer&gt; m_swapchain_framebuffers{};\n\n        std::vector&lt;vk_image_handle&gt; m_swapchain_images{};\n        std::vector&lt;vk_image&gt; m_swapchain_depth_images{};\n\n        // VkRenderPass m_swapchain_renderpass=nullptr;\n        vk_renderpass m_swapchain_main_renderpass{};\n\n        vk_present_queue m_present_to_queue{};\n    };\n\n};\n</code></pre>"},{"location":"References/vk__texture_8hpp/","title":"File vk_texture.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_texture.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_command_buffer.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_graphics_queue.hpp&gt;</code></li> </ul>"},{"location":"References/vk__texture_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__texture_8hpp/#classes","title":"Classes","text":"Type Name class texture struct texture_extent <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_texture.hpp</code></p>"},{"location":"References/vk__texture_8hpp_source/","title":"File vk_texture.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_texture.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;filesystem&gt;\n#include &lt;vulkan/vulkan.h&gt;\n#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_command_buffer.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_graphics_queue.hpp&gt;\n\nnamespace atlas::vk {\n    struct texture_extent {\n        uint32_t width;\n        uint32_t height;\n        // Considering parameters here for setting mipmap parameters (??)\n        // bool mipmap_enabled=false;\n        // uint32_t mipmappings=0;\n    };\n    class texture {\n    public:\n        texture() = default;\n        texture(const texture_extent&amp; p_extent);\n        texture(const std::filesystem::path&amp; p_filepath);\n\n        void create(const std::filesystem::path&amp; p_path);\n\n        [[nodiscard]] bool loaded() const { return m_is_image_loaded; }\n\n        [[nodiscard]] vk_image data() const { return m_texture_image; }\n\n        [[nodiscard]] VkImageView image_view() const {\n            return m_texture_image.image_view;\n        }\n\n        [[nodiscard]] VkImage image() const { return m_texture_image.image; }\n\n        [[nodiscard]] VkSampler sampler() const {\n            return m_texture_image.sampler;\n        }\n\n        void destroy();\n\n        [[nodiscard]] uint32_t width() const;\n\n        [[nodiscard]] uint32_t height() const;\n\n    private:\n        VkDevice m_driver = {};\n        bool m_is_image_loaded = false;\n        vk_image m_texture_image{};\n\n        uint32_t m_width = 0;\n        uint32_t m_height = 0;\n    };\n};\n</code></pre>"},{"location":"References/vk__types_8hpp/","title":"File vk_types.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_types.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/vk__types_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__types_8hpp/#classes","title":"Classes","text":"Type Name struct camera_ubo Going to remove this. struct command_buffer_settings settings for specifying command buffers to construct struct descriptor_binding_entry struct descriptor_binding_point struct descriptor_set_layout struct global_ubo Just for testing purposes for sending this struct over to the shader. struct image_extent struct material_uniform material is going to define properties about how a scene object itself gets rendered struct renderpass_attachment struct renderpass_options struct shader_info struct texture_properties struct vertex_attribute struct vertex_attribute_entry struct vertex_input struct vk_buffer vulkan buffer struct to define the handlers and memory specifications required for buffer handlers in vulkan struct vk_buffer_info Specifications of the vulkan buffer handlers and the use and memory bits associated with the buffer handlers. struct vk_filter_range Range between min and max for the VkFilter. struct vk_image vulkan image handler with resources; used when handling textures struct vk_image_handle struct vk_queue_options struct vk_renderpass_options Renderpass specifictations for VkRenderpass. struct vk_shader_module <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_types.hpp</code></p>"},{"location":"References/vk__types_8hpp_source/","title":"File vk_types.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_types.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;vulkan/vulkan.h&gt;\n#include &lt;span&gt;\n#include &lt;glm/glm.hpp&gt;\n#include &lt;string&gt;\n\nnamespace atlas::vk {\n    enum command_buffer_levels : uint8_t {\n        primary = 0,\n        secondary = 1,\n        max_enum = 2\n    };\n\n    struct command_buffer_settings {\n        command_buffer_settings(uint32_t p_queue_family,\n                                const command_buffer_levels&amp; p_levels,\n                                const VkCommandPoolCreateFlagBits&amp; p_pool_flags)\n          : levels(p_levels)\n          , queue_index(p_queue_family)\n          , pool_flag(p_pool_flags) {}\n\n        command_buffer_levels levels;\n        uint32_t queue_index = -1;\n        VkCommandPoolCreateFlagBits pool_flag;\n    };\n\n    struct image_extent {\n        uint32_t width;\n        uint32_t height;\n        VkDeviceMemory device_memory;\n        uint32_t mip_level = 1;\n    };\n\n    struct vk_image_handle {\n        VkImage image = nullptr;\n        VkImageView image_view = nullptr;\n    };\n\n    struct vk_image {\n        VkImage image = nullptr;\n        VkImageView image_view = nullptr;\n        VkSampler sampler = nullptr;\n        VkDeviceMemory device_memory = nullptr;\n    };\n\n    struct vk_filter_range {\n        VkFilter min;\n        VkFilter max;\n    };\n\n    struct vk_queue_options {\n        // uint32_t device_index=0; // device num\n        uint32_t family_index = -1;\n        uint32_t queue_index = 0;\n    };\n\n    enum class format : uint64_t {\n        rgb32_sfloat, // Represent R32G32B32_SFLOAT\n        rg32_sfloat,  // Represent R32G32_SFLOAT\n    };\n\n    enum buffer : uint8_t {\n        uniform = 0,\n        storage = 1,\n        combined_image_sampler = 2,\n        sampled_image = 3\n    };\n\n    enum shader_stage { undefined = -1, vertex = 0, fragment = 1 };\n\n    enum class input_rate : uint8_t { vertex, instance, max_enum };\n\n    enum class image_layout : uint8_t {\n        undefined = 0,     // VK_IMAGE_LAYOUT_UNDEFINED\n        general = 1,       // VK_IMAGE_LAYOUT_GENERAL\n        color_optimal = 2, // VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL\n        depth_stencil_optimal =\n          3, // VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL\n        depth_stencil_read_only_optimal =\n          4, // VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_READ_ONLY_OPTIMAL\n    };\n\n    enum class sample_bit : uint8_t {\n        count_1,\n        count_2,\n        count_4,\n        count_8,\n        count_16,\n        count_32,\n        count_64,\n        max_enum\n    };\n\n    enum class attachment_load : uint8_t {\n        load = 0,  // LOAD_OP_LOAD\n        clear,     // LOAD_OP_CLEAR\n        dont_care, // lOAD_OP_DONT_CARE\n        none_khr,  // LOAD_OP_NONE_KHR\n        none_ext,  // LOAD_OP_NONE_EXT\n        max_enum,  // LOAD_OP_MAX_ENUM\n    };\n\n    enum class attachment_store : uint8_t {\n        store = 0, // STORE_OP_STORE\n        dont_care, // STORE_OP_CLEAR\n        none_khr,  // STORE_OP_NONE\n        none_qcom, // STORE_OP_NONE_EXT\n        none_ext,  // STORE_OP_NONE_KHR\n        max_enum,  // STORE_OP_MAX_ENUM\n    };\n\n    enum class pipeline_bind_point : uint8_t {\n        graphics = 0,           // VK_PIPELINE_BIND_POINT_GRAPHICS\n        compute = 1,            // VK_PIPELINE_BIND_POINT_COMPUTE\n        ray_tracing_khr,        // VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR\n        subpass_shading_hauwei, // VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI\n        ray_tracing_nv,         // VK_PIPELINE_BIND_POINT_RAY_TRACING_NV\n        max_enum                // VK_PIPELINE_BIND_POINT_MAX_ENUM\n    };\n\n    // TODO: Find a way to differentiate the different VkAttachmentReference\n    // specifications of color and depth attachments that get referenced\n    /*\n\n        std::array&lt;renderpass_attachment, 2&gt; renderpass_attachments = {\n            renderpass_attachment{ // this sets up the VkAttachmentDescription\n       and VkAttachmentReference .layout = image_layout::color_optimal, .format\n       = surface_format, .sample_count = sample_bit::count_1, .load =\n       attachment_load::load, .store = attachment_store::store, .stencil_load =\n       attachment_load::load, .stencil_store = attachment_store::store, .initial\n       = image_layout::undefined, .finalize = image_layout::present_src\n            },\n            renderpass_attachment{\n                .layout = image_layout::depth_optimal, // this sets up the\n       VkAttachmentDescription and VkAttachmentReference .format = depth_format,\n                .sample_count = sample_bit::count_1,\n                .load = attachment_load::load,\n                .store = attachment_store::store,\n                .stencil_load = attachment_load::load,\n                .stencil_store = attachment_store::store,\n                .initial = image_layout::undefined,\n                .finalize = image_layout::present_src\n            }\n        };\n\n    */\n\n    enum class renderpass_type : uint8_t { color, depth };\n\n    struct renderpass_attachment {\n        renderpass_type type;\n        image_layout layout;\n        format format;\n        sample_bit sample_count;\n        attachment_load load;\n        attachment_store store;\n        attachment_load stencil_load;\n        attachment_store stencil_store;\n        image_layout initial;  // initial starting layout\n        image_layout finalize; // final layout\n    };\n\n    struct vk_renderpass_options {\n        bool cache = false; // set this to true if you want to use the default\n                            // constructed configuration\n        std::span&lt;VkClearColorValue&gt; clear_values{};\n        std::span&lt;VkAttachmentDescription&gt; attachments{};\n        std::span&lt;VkSubpassDescription&gt; subpass_descriptions{};\n        std::span&lt;VkSubpassDependency&gt; dependencies{};\n    };\n\n    struct renderpass_options {\n        std::span&lt;VkClearColorValue&gt; clear_values{};\n        std::span&lt;renderpass_attachment&gt; color_attachments{};\n        std::span&lt;renderpass_attachment&gt; depth_attachments{};\n    };\n\n    struct vk_buffer {\n        VkBuffer handler = nullptr;\n        VkDeviceMemory device_memory = nullptr;\n        uint32_t allocation_size = 0; // device allocation size\n    };\n\n    struct vk_buffer_info {\n        uint32_t device_size = 0;\n        VkBufferUsageFlags usage;\n        VkMemoryPropertyFlags memory_property_flag;\n    };\n\n    struct vertex_attribute_entry {\n        uint32_t location;\n        format format;\n        uint32_t stride;\n    };\n\n    struct vertex_attribute {\n        uint32_t binding;\n        std::span&lt;vertex_attribute_entry&gt; entries;\n        uint32_t stride;\n        input_rate input_rate;\n    };\n\n    struct shader_info {\n        std::string source = \"\";\n        shader_stage stage = undefined;\n    };\n\n    struct vk_shader_module {\n        VkShaderModule module_handler = nullptr;\n        shader_stage stage = undefined;\n    };\n\n    struct texture_properties {\n        uint32_t width;\n        uint32_t height;\n        VkImageUsageFlagBits usage;\n        VkMemoryPropertyFlagBits property;\n        VkFormat format;\n    };\n\n    struct descriptor_binding_point {\n        uint32_t binding;\n        shader_stage stage;\n    };\n\n    struct descriptor_binding_entry {\n        buffer type;\n        descriptor_binding_point binding_point;\n        uint32_t descriptor_count;\n    };\n\n    struct descriptor_set_layout {\n        uint32_t allocate_count = 0;\n        uint32_t max_sets = 0;\n        uint32_t size_bytes = 0;\n        std::span&lt;descriptor_binding_entry&gt; entry;\n    };\n\n    struct vertex_input {\n        glm::vec3 position;\n        glm::vec3 color;\n        glm::vec3 normals;\n        glm::vec2 uv;\n\n        bool operator==(const vertex_input&amp; other) const {\n            return position == other.position and color == other.color and\n                   uv == other.uv and normals == other.normals;\n        }\n    };\n\n    struct camera_ubo {\n        glm::mat4 projection{ 1.f };\n        glm::mat4 view{ 1.f };\n    };\n\n    struct global_ubo {\n        glm::mat4 mvp = { 1.f };\n    };\n\n    struct material_uniform {\n        glm::mat4 model{ 1.f };\n        glm::vec4 color{ 1.f };\n        // std::vector&lt;std::string&gt; texture_paths;\n    };\n\n};\n</code></pre>"},{"location":"References/vk__uniform__buffer_8hpp/","title":"File vk_uniform_buffer.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_uniform_buffer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;</code></li> </ul>"},{"location":"References/vk__uniform__buffer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__uniform__buffer_8hpp/#classes","title":"Classes","text":"Type Name class vk_uniform_buffer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_uniform_buffer.hpp</code></p>"},{"location":"References/vk__uniform__buffer_8hpp_source/","title":"File vk_uniform_buffer.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_uniform_buffer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n#include &lt;vulkan/vulkan.h&gt;\n#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;\n\nnamespace atlas::vk {\n\n    class vk_uniform_buffer {\n    public:\n        vk_uniform_buffer() = default;\n\n        vk_uniform_buffer(uint32_t p_size_in_bytes);\n\n        [[nodiscard]] uint32_t size_bytes() const { return m_size_bytes; }\n\n        void update(const void* p_data);\n\n        operator VkBuffer() const { return m_uniform_buffer_data.handler; }\n\n        operator VkBuffer() { return m_uniform_buffer_data.handler; }\n\n        void destroy();\n\n    private:\n        VkDevice m_driver = nullptr;\n        uint32_t m_size_bytes = 0;\n        vk_buffer m_uniform_buffer_data{};\n    };\n};\n</code></pre>"},{"location":"References/vk__vertex__buffer_8hpp/","title":"File vk_vertex_buffer.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_vertex_buffer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;</code></li> </ul>"},{"location":"References/vk__vertex__buffer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__vertex__buffer_8hpp/#classes","title":"Classes","text":"Type Name class vk_vertex_buffer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_vertex_buffer.hpp</code></p>"},{"location":"References/vk__vertex__buffer_8hpp_source/","title":"File vk_vertex_buffer.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_vertex_buffer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;span&gt;\n#include &lt;drivers/vulkan-cpp/vk_types.hpp&gt;\n\nnamespace atlas::vk {\n\n    class vk_vertex_buffer {\n    public:\n        vk_vertex_buffer() = default;\n\n        vk_vertex_buffer(const std::span&lt;vertex_input&gt;&amp; p_vertices);\n\n        ~vk_vertex_buffer() = default;\n\n        void bind(const VkCommandBuffer&amp; p_current);\n\n        void draw(const VkCommandBuffer&amp; p_current);\n\n        [[nodiscard]] size_t size() const { return m_vertices_count; }\n\n        [[nodiscard]] size_t size_bytes() const {\n            return m_vertices_byte_size_count;\n        }\n\n        void destroy();\n\n        operator VkBuffer() { return m_vertex_handler.handler; }\n\n        operator VkBuffer() const { return m_vertex_handler.handler; }\n\n    private:\n        VkDevice m_driver = nullptr;\n        uint32_t m_vertices_count = 0;\n        uint32_t m_vertices_byte_size_count = 0;\n        vk_buffer m_vertex_handler{};\n    };\n};\n</code></pre>"},{"location":"References/vk__window_8hpp/","title":"File vk_window.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_window.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/window.hpp&gt;</code></li> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_swapchain.hpp&gt;</code></li> </ul>"},{"location":"References/vk__window_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vk__window_8hpp/#classes","title":"Classes","text":"Type Name class vk_window <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vk_window.hpp</code></p>"},{"location":"References/vk__window_8hpp_source/","title":"File vk_window.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_window.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/window.hpp&gt;\n#include &lt;GLFW/glfw3.h&gt;\n#include &lt;drivers/vulkan-cpp/vk_swapchain.hpp&gt;\n\nnamespace atlas::vk {\n    class vk_window : public window {\n    public:\n        vk_window(const window_settings&amp; p_settings);\n        ~vk_window() override;\n\n    private:\n        void center_window();\n\n    private:\n        [[nodiscard]] window_settings settings() const override;\n        [[nodiscard]] vk_swapchain window_swapchain() const override {\n            return m_swapchain;\n        }\n        [[nodiscard]] uint32_t read_acquired_next_frame() override;\n        [[nodiscard]] GLFWwindow* native_window() const override;\n        void presentation_process(const uint32_t&amp; p_current_frame) override;\n        [[nodiscard]] vk::vk_command_buffer current_active_command_buffer(\n          const uint32_t&amp; p_frame_idx) override {\n            return m_swapchain.active_command_buffer(p_frame_idx);\n        }\n\n    private:\n        VkInstance m_instance_handler = nullptr;\n        GLFWwindow* m_window_handler = nullptr;\n        VkSurfaceKHR m_window_surface = nullptr;\n        window_settings m_settings{};\n\n        vk_swapchain m_swapchain{};\n        static vk_window* s_instance;\n    };\n};\n</code></pre>"},{"location":"References/vulkan-imports_8hpp/","title":"File vulkan-imports.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vulkan-imports.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> </ul>"},{"location":"References/vulkan-imports_8hpp/#macros","title":"Macros","text":"Type Name define GLFW_INCLUDE_VULKAN"},{"location":"References/vulkan-imports_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"References/vulkan-imports_8hpp/#define-glfw_include_vulkan","title":"define GLFW_INCLUDE_VULKAN","text":"<pre><code>#define GLFW_INCLUDE_VULKAN \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan-cpp/vulkan-imports.hpp</code></p>"},{"location":"References/vulkan-imports_8hpp_source/","title":"File vulkan-imports.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vulkan-imports.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#define GLFW_INCLUDE_VULKAN\n#if _WIN32\n#define VK_USE_PLATFORM_WIN32_KHR\n#include &lt;GLFW/glfw3.h&gt;\n#define GLFW_EXPOSE_NATIVE_WIN32\n#include &lt;GLFW/glfw3native.h&gt;\n#include &lt;vulkan/vulkan.h&gt;\n#else\n#include &lt;GLFW/glfw3.h&gt;\n#include &lt;vulkan/vulkan.h&gt;\n#endif\n</code></pre>"},{"location":"References/graphics__context_8hpp/","title":"File graphics_context.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; graphics_context.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> </ul>"},{"location":"References/graphics__context_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/graphics__context_8hpp/#classes","title":"Classes","text":"Type Name class graphics_context <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/graphics_context.hpp</code></p>"},{"location":"References/graphics__context_8hpp_source/","title":"File graphics_context.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; graphics_context.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n\nnamespace atlas {\n    class graphics_context {\n    public:\n        virtual ~graphics_context() = default;\n\n        void destroy() { return destroy_context(); }\n\n    private:\n        virtual void destroy_context() = 0;\n    };\n\n    ref&lt;graphics_context&gt; initialize_context(const std::string&amp; p_tag);\n\n};\n</code></pre>"},{"location":"References/renderer__context_8hpp/","title":"File renderer_context.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; renderer_context.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_swapchain.hpp&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_command_buffer.hpp&gt;</code></li> </ul>"},{"location":"References/renderer__context_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/renderer__context_8hpp/#classes","title":"Classes","text":"Type Name class render_context <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/renderer_context.hpp</code></p>"},{"location":"References/renderer__context_8hpp_source/","title":"File renderer_context.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; renderer_context.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n#include &lt;core/core.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_swapchain.hpp&gt;\n#include &lt;span&gt;\n#include &lt;drivers/vulkan-cpp/vk_command_buffer.hpp&gt;\n\nnamespace atlas {\n    class render_context {\n    public:\n        virtual ~render_context() = default;\n\n        void begin_frame(const vk::vk_command_buffer&amp; p_current,\n                         const vk::vk_swapchain&amp; p_swapchain_handler) {\n            return start_frame(p_current, p_swapchain_handler);\n        }\n\n        void end_frame() { return post_frame(); }\n\n        void set_background_color(const std::array&lt;float, 4&gt;&amp; p_color) {\n            return background_color(p_color);\n        }\n\n    private:\n        virtual void start_frame(\n          const vk::vk_command_buffer&amp; p_current,\n          const vk::vk_swapchain&amp; p_swapchain_handler) = 0;\n        virtual void post_frame() = 0;\n\n        virtual void background_color(const std::array&lt;float, 4&gt;&amp; p_color) = 0;\n    };\n\n    scope&lt;render_context&gt; initialize_renderer(\n      const vk::vk_swapchain&amp; p_swapchain,\n      const std::string&amp; p_tag);\n};\n</code></pre>"},{"location":"References/dir_40e4880a491f87475db52b6f14fdb765/","title":"Dir TheAtlasEngine/atlas/physics","text":"<p>FileList &gt; atlas &gt; physics</p>"},{"location":"References/dir_40e4880a491f87475db52b6f14fdb765/#files","title":"Files","text":"Type Name file types.hpp"},{"location":"References/dir_40e4880a491f87475db52b6f14fdb765/#directories","title":"Directories","text":"Type Name dir jolt-cpp dir physics_3d <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/</code></p>"},{"location":"References/dir_4275702edcca8362402a3c9bf0161df7/","title":"Dir TheAtlasEngine/atlas/physics/jolt-cpp","text":"<p>FileList &gt; atlas &gt; physics &gt; jolt-cpp</p>"},{"location":"References/dir_4275702edcca8362402a3c9bf0161df7/#files","title":"Files","text":"Type Name file jolt-imports.hpp file jolt_api.hpp file jolt_collision.hpp file jolt_collision_manager.hpp file jolt_components.hpp file jolt_contact_listener.hpp file jolt_error_handler.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/</code></p>"},{"location":"References/jolt-imports_8hpp/","title":"File jolt-imports.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt-imports.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;Jolt/Jolt.h&gt;</code></li> <li><code>#include &lt;Jolt/Core/Core.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Body/BodyInterface.h&gt;</code></li> <li><code>#include &lt;Jolt/Core/JobSystemThreadPool.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/PhysicsSettings.h&gt;</code></li> <li><code>#include &lt;Jolt/Core/IssueReporting.h&gt;</code></li> <li><code>#include &lt;Jolt/Core/TempAllocator.h&gt;</code></li> <li><code>#include &lt;Jolt/RegisterTypes.h&gt;</code></li> <li><code>#include &lt;Jolt/Core/Factory.h&gt;</code></li> <li><code>#include &lt;Jolt/Core/Memory.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/ContactListener.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/PhysicsSystem.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/ObjectLayer.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/BroadPhase/BroadPhaseLayer.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Body/BodyCreationSettings.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/Shape/Shape.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/Shape/BoxShape.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/Shape/ConvexShape.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/Shape/CapsuleShape.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/Shape/ScaledShape.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/Shape/SphereShape.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/EActivation.h&gt;</code></li> <li><code>#include &lt;Jolt/Math/MathTypes.h&gt;</code></li> <li><code>#include &lt;Jolt/Math/Real.h&gt;</code></li> <li><code>#include &lt;Jolt/Math/Quat.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt-imports.hpp</code></p>"},{"location":"References/jolt-imports_8hpp_source/","title":"File jolt-imports.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt-imports.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;type_traits&gt;\n\n#include &lt;Jolt/Jolt.h&gt;\n#include &lt;Jolt/Core/Core.h&gt;\n#include &lt;Jolt/Physics/Body/BodyInterface.h&gt;\n#include &lt;Jolt/Core/JobSystemThreadPool.h&gt;\n#include &lt;Jolt/Physics/PhysicsSettings.h&gt;\n#include &lt;Jolt/Core/IssueReporting.h&gt;\n#include &lt;Jolt/Core/TempAllocator.h&gt;\n#include &lt;Jolt/RegisterTypes.h&gt;\n#include &lt;Jolt/Core/Factory.h&gt;\n#include &lt;Jolt/Core/Memory.h&gt;\n#include &lt;Jolt/Physics/Collision/ContactListener.h&gt;\n#include &lt;Jolt/Physics/PhysicsSystem.h&gt;\n#include &lt;Jolt/Physics/Collision/ObjectLayer.h&gt;\n#include &lt;Jolt/Physics/Collision/BroadPhase/BroadPhaseLayer.h&gt;\n#include &lt;Jolt/Core/IssueReporting.h&gt;\n\n#include &lt;Jolt/Physics/Body/BodyCreationSettings.h&gt;\n\n#include &lt;Jolt/Physics/Collision/Shape/Shape.h&gt;\n#include &lt;Jolt/Physics/Collision/Shape/BoxShape.h&gt;\n#include &lt;Jolt/Physics/Collision/Shape/ConvexShape.h&gt;\n#include &lt;Jolt/Physics/Collision/Shape/CapsuleShape.h&gt;\n#include &lt;Jolt/Physics/Collision/Shape/ScaledShape.h&gt;\n#include &lt;Jolt/Physics/Collision/Shape/SphereShape.h&gt;\n\n#include &lt;Jolt/Physics/EActivation.h&gt;\n\n// jolt's math includes\n#include &lt;Jolt/Math/MathTypes.h&gt;\n#include &lt;Jolt/Math/Real.h&gt;\n#include &lt;Jolt/Math/Quat.h&gt;\n</code></pre>"},{"location":"References/jolt-cpp_2jolt__api_8hpp/","title":"File jolt_api.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt_api.hpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_api.hpp</code></p>"},{"location":"References/jolt-cpp_2jolt__api_8hpp_source/","title":"File jolt_api.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt_api.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Need not be here except application uses it\n</code></pre>"},{"location":"References/jolt__collision_8hpp/","title":"File jolt_collision.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt_collision.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/scene/scene.hpp&gt;</code></li> <li><code>#include &lt;physics/jolt-cpp/jolt_contact_listener.hpp&gt;</code></li> <li><code>#include &lt;physics/jolt-cpp/jolt_components.hpp&gt;</code></li> </ul>"},{"location":"References/jolt__collision_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics Handles error handling with in jolt."},{"location":"References/jolt__collision_8hpp/#classes","title":"Classes","text":"Type Name class jolt_collision This is the collision api. It allows users to create children of this collision handler and write their own functions over the virtual ones. Then they can assign it to the engine. <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_collision.hpp</code></p>"},{"location":"References/jolt__collision_8hpp_source/","title":"File jolt_collision.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt_collision.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;core/scene/scene.hpp&gt;\n#include &lt;physics/jolt-cpp/jolt_contact_listener.hpp&gt;\n#include &lt;physics/jolt-cpp/jolt_components.hpp&gt;\nnamespace atlas::physics {\n    class jolt_collision {\n\n    public:\n        jolt_collision();\n        jolt_collision(flecs::entity_t p_entity_id);\n\n        void collision_added(contact_event&amp; p_event);\n\n        // void collision_removed();\n        // void collison_persisted();\n\n    private:\n        virtual void on_collision_added(contact_event&amp; p_event);\n\n        // virtual void on_collision_persisted() = 0;\n        // virtual void on_collision_removed() = 0;\n\n    protected:\n        uint64_t m_id;\n    };\n};\n</code></pre>"},{"location":"References/jolt__collision__manager_8hpp/","title":"File jolt_collision_manager.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt_collision_manager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;physics/jolt-cpp/jolt_collision.hpp&gt;</code></li> </ul>"},{"location":"References/jolt__collision__manager_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics Handles error handling with in jolt."},{"location":"References/jolt__collision__manager_8hpp/#classes","title":"Classes","text":"Type Name class jolt_collision_manager This allows users to make thier own version of jolt collition and run them their own way. It allows users to interact with the calls by creating a child class of jolt_collision and run whatever action they want. <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_collision_manager.hpp</code></p>"},{"location":"References/jolt__collision__manager_8hpp_source/","title":"File jolt_collision_manager.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt_collision_manager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cstdint&gt;\n#include &lt;physics/jolt-cpp/jolt_collision.hpp&gt;\nnamespace atlas::physics {\n\n    class jolt_collision_manager {\n    public:\n        jolt_collision_manager() = default;\n\n        static scope&lt;jolt_collision_manager&gt; initialize(\n          const std::string&amp; p_tag);\n\n        void run_collision_added(uint64_t p_id, contact_event&amp; p_event);\n\n        // run_collision_persisted(uint64_t id);\n        // run_collision_removed(uint64_t id);\n\n        static void subscribe_action(uint64_t p_id,\n                                     jolt_collision&amp; p_collision_action);\n\n    private:\n        static std::unordered_map&lt;uint64_t, jolt_collision&gt; m_handlers;\n\n        static std::string m_tag;\n    };\n};\n</code></pre>"},{"location":"References/jolt__components_8hpp/","title":"File jolt_components.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt_components.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;Jolt/Jolt.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/PhysicsSystem.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/ContactListener.h&gt;</code></li> </ul>"},{"location":"References/jolt__components_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics Handles error handling with in jolt."},{"location":"References/jolt__components_8hpp/#classes","title":"Classes","text":"Type Name struct collider_body struct collider_event This is a replacement for an event system to handle collider. It will be replaced by an event system once we have functional one up and running. struct contact_event struct jolt_config Used to keep global data for player access and use. Tells how physics bodies should act within a given scene by default. struct jolt_settings This includes global configs for each scene and how the physics engine will behave in a paticular scene. struct physics_body"},{"location":"References/jolt__components_8hpp/#public-types","title":"Public Types","text":"Type Name enum uint8_t combine_friction created for future use of dynamic physics material enum uint8_t combine_restitution Created for future use of dynamic physics material."},{"location":"References/jolt__components_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"References/jolt__components_8hpp/#enum-combine_friction","title":"enum combine_friction","text":"<p>created for future use of dynamic physics material <pre><code>enum combine_friction {\n    FrictionDefualt = 0,\n    FrictionMax = 1,\n    FrictionMin = 2,\n    FrictionNumTypes = 3\n};\n</code></pre></p> <p>Remark:</p> <p>FIXME: This needs to be associated with our own interpretations of how friction should work. Or have a way for users to override these functions. Do not delete for it will be needed in the near furture. </p>"},{"location":"References/jolt__components_8hpp/#enum-combine_restitution","title":"enum combine_restitution","text":"<p>Created for future use of dynamic physics material. <pre><code>enum combine_restitution {\n    RestitutionDefualt = 0,\n    RestitutionMax = 1,\n    RestitutionMin = 2,\n    RestitutionNumTypes = 3\n};\n</code></pre></p> <p>Remark:</p> <p>FIXME: Same thing here, this will be used in the near future. As it is required by the basic jolt system. However, disccussion need to be made about how we allow users to overwrite resititution. </p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_components.hpp</code></p>"},{"location":"References/jolt__components_8hpp_source/","title":"File jolt_components.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt_components.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;glm/glm.hpp&gt;\n#include &lt;cstdint&gt;\n#include &lt;thread&gt;\n#include &lt;Jolt/Jolt.h&gt;\n#include &lt;Jolt/Physics/PhysicsSystem.h&gt;\n#include &lt;Jolt/Physics/Collision/ContactListener.h&gt;\n\nnamespace atlas::physics {\n\n    enum class collider_shape : uint8_t {\n        Box,\n        Sphere,\n        Capsule,\n    };\n\n    enum thread_system : uint8_t {\n        Default = 0,\n        JobSystem = 1,\n    };\n\n    struct collider_body {\n        bool collision_enabled = true;\n\n        collider_shape shape_type = collider_shape::Box;\n\n        glm::vec3 half_extents = glm::vec3(0.5f);\n        float radius = 0.5f;\n        float capsule_half_height = 0.5f;\n\n        // The id of the actuall JPH physics body\n        uint32_t body_id = 0;\n    };\n\n    enum body_type : uint8_t { Static = 0, Kenmatic = 1, Dynamic = 2, BodyNum };\n\n    enum body_layer : uint8_t { NonMoving = 0, Moving = 1, LayerNum };\n\n    struct physics_body {\n        glm::vec3 linear_velocity = glm::vec3(0.0);\n        glm::vec3 angular_velocity = glm::vec3(0.0f);\n\n        glm::vec3 cumulative_force = glm::vec3(0.0);\n        glm::vec3 cumulative_torque = glm::vec3(0.0);\n\n        float mass_factor = 1.0f;\n        glm::vec3 center_mass_position = glm::vec3(0.0);\n        float linear_damping = 0.0f;\n        float angular_damping = 0.0f;\n\n        bool use_gravity = true;\n        float gravity_factor = 1.0f;\n\n        uint8_t body_type = 2;\n        float friction = 0.8f;\n        float restitution = 0.2f;\n\n        uint8_t body_movement_type = body_type::Static;\n        uint8_t body_layer_type = body_layer::Moving;\n\n        uint32_t body_id = 0;\n        int count = 0;\n    };\n\n    struct collider_event {\n        uint64_t id = 0;\n    };\n}\n\nenum combine_friction : uint8_t {\n    FrictionDefualt = 0,\n    FrictionMax = 1,\n    FrictionMin = 2,\n    FrictionNumTypes = 3,\n};\n\nenum combine_restitution : uint8_t {\n    RestitutionDefualt = 0,\n    RestitutionMax = 1,\n    RestitutionMin = 2,\n    RestitutionNumTypes = 3,\n};\n\nnamespace atlas::physics {\n\n    struct jolt_config {\n        // Global gravity vector for all in scene\n        glm::vec3 gravity = glm::vec3(0.0f, -9.80665f, 0.0f);\n\n        // Friction Setting\n        // This needs to be set to a function which makes it harder\n        combine_friction friction_type = combine_friction::FrictionDefualt;\n\n        // Restitution Settings\n        // Same thing need functions for each.\n        combine_restitution restitution_type =\n          combine_restitution::RestitutionDefualt;\n\n        float time_before_sleep = 5.0f;\n\n        // What 1 unit refers to in meters\n        float world_unit_scale = 1.0f;\n\n        // Helps stop the lauching of objects during numerical/flaoting point\n        // errors when collision happen bertween to objects.\n        float contact_bias_factor = 0.2f;\n        float restitution_threshold = 1.0f;\n\n        bool enable_constraints = true;\n        bool enable_collision_callbacks = true;\n    };\n\n    struct jolt_settings {\n\n        unsigned int allocation_amount = 10 * 1024 * 1024;\n\n        // For job system\n        thread_system thread_type = Default;\n\n        uint32_t physics_threads =\n          std::max(1u, std::thread::hardware_concurrency() - 2);\n\n        uint32_t max_jobs_power = 10;\n        uint32_t max_barriers = physics_threads * 16;\n        bool is_multithreaded = true;\n\n        // Collision detection\n        float broadphase_scale = 1.0f;\n        bool use_4_layer_broadphase = true;\n        uint32_t default_collision_group = 0;\n\n        // Filtering out specifica collisions\n        uint32_t collision_filter_layer_count = 32;\n        uint32_t default_filter_mask = 0xFFFFFFFF;\n\n        // Scene position in the world\n        glm::vec3 physics_scene_position = glm::vec3(0.0f, 0.0f, 0.0f);\n\n        glm::vec3 world_bounds_min = glm::vec3(-500.0f, -500.0f, -500.0f);\n\n        glm::vec3 world_bounds_max = glm::vec3(500.0f, 500.0f, 500.0f);\n        // Max memory size per scene\n        uint32_t max_bodies = 16384;\n        uint32_t max_body_pairs = 32768;\n        uint32_t max_contact_constraints = 8192;\n\n        // Time step for fps within the physics\n        // If false set to 1/maxFps\n        float fixed_time_step = 1.0f / 60.0f;\n        bool use_fixed_timestep = false;\n\n        // solver for velocity and position\n        uint32_t position_iterations = 1;\n        uint32_t velocity_iterations = 8;\n\n        // When to turn objects on and off depending on speed\n        float sleep_velocity_threshold = 0.05f;\n        float sleep_angular_velocity_threshold = 0.05f;\n\n    };\n\n    // This might be able to be generalized eventually but we will have to\n    // create our own manifold before that happens.\n    struct contact_event {\n        uint64_t entity_a = 0;\n        uint64_t entity_b = 0;\n        JPH::ContactManifold manifold;\n        JPH::ContactSettings settings;\n    };\n\n};\n</code></pre>"},{"location":"References/jolt__contact__listener_8hpp/","title":"File jolt_contact_listener.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt_contact_listener.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;Jolt/Jolt.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/ContactListener.h&gt;</code></li> <li><code>#include &lt;physics/jolt-cpp/jolt_components.hpp&gt;</code></li> <li><code>#include &lt;core/scene/scene.hpp&gt;</code></li> </ul>"},{"location":"References/jolt__contact__listener_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics Handles error handling with in jolt."},{"location":"References/jolt__contact__listener_8hpp/#classes","title":"Classes","text":"Type Name class contact_listener This is the glue between contact events and jolts contact listener. It takes the calls from jolt through virtual functions and allows users to create children for jolt collision. <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_contact_listener.hpp</code></p>"},{"location":"References/jolt__contact__listener_8hpp_source/","title":"File jolt_contact_listener.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt_contact_listener.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;Jolt/Jolt.h&gt;\n#include &lt;Jolt/Physics/Collision/ContactListener.h&gt;\n#include &lt;physics/jolt-cpp/jolt_components.hpp&gt;\n#include &lt;core/scene/scene.hpp&gt;\n\nnamespace atlas::physics {\n    class contact_listener : public JPH::ContactListener {\n    private:\n        JPH::ValidateResult OnContactValidate(\n          const JPH::Body&amp; in_body1,\n          const JPH::Body&amp; in_body2,\n          JPH::RVec3Arg in_base_offset,\n          const JPH::CollideShapeResult&amp; in_collision_result) override;\n\n        void OnContactAdded(const JPH::Body&amp; body1,\n                            const JPH::Body&amp; body2,\n                            const JPH::ContactManifold&amp; manifold,\n                            JPH::ContactSettings&amp; settings) override;\n\n        void OnContactPersisted(const JPH::Body&amp; in_body1,\n                                const JPH::Body&amp; in_body2,\n                                const JPH::ContactManifold&amp; in_manifold,\n                                JPH::ContactSettings&amp; io_settings) override;\n        void OnContactRemoved(\n          const JPH::SubShapeIDPair&amp; in_sub_shape_pair) override;\n\n    public:\n        contact_listener();\n\n        void clear_events();\n\n        void run_events_added();\n\n        void run_events_persisted();\n\n        void run_events_removed();\n\n    private:\n        std::vector&lt;contact_event&gt; m_contacts_added;\n\n        std::vector&lt;contact_event&gt; m_contacts_persisted;\n        std::vector&lt;contact_event&gt; m_contacts_removed;\n\n        ref&lt;scene_scope&gt; m_scene;\n        flecs::world m_registry;\n    };\n};\n</code></pre>"},{"location":"References/jolt__error__handler_8hpp/","title":"File jolt_error_handler.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt_error_handler.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;physics/jolt-cpp/jolt-imports.hpp&gt;</code></li> </ul>"},{"location":"References/jolt__error__handler_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics Handles error handling with in jolt. <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_error_handler.hpp</code></p>"},{"location":"References/jolt__error__handler_8hpp_source/","title":"File jolt_error_handler.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt_error_handler.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;physics/jolt-cpp/jolt-imports.hpp&gt;\n\nnamespace atlas::physics {\n\n    void trace_impl(const char* p_in_fmt, ...);\n\n    bool assert_failed_impl(const char* p_in_expression,\n                            const char* p_in_message,\n                            const char* p_in_file,\n                            unsigned int p_in_line);\n}\n</code></pre>"},{"location":"References/dir_ab5034a21b7aebf79f76e5e8638ac885/","title":"Dir TheAtlasEngine/atlas/physics/physics_3d","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d</p>"},{"location":"References/dir_ab5034a21b7aebf79f76e5e8638ac885/#files","title":"Files","text":"Type Name file physics.hpp file physics_api.hpp file physics_context.hpp file physics_engine.hpp"},{"location":"References/dir_ab5034a21b7aebf79f76e5e8638ac885/#directories","title":"Directories","text":"Type Name dir jolt <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/</code></p>"},{"location":"References/dir_3d876be8cd66de39c1e103aa97223d9b/","title":"Dir TheAtlasEngine/atlas/physics/physics_3d/jolt","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; jolt</p>"},{"location":"References/dir_3d876be8cd66de39c1e103aa97223d9b/#files","title":"Files","text":"Type Name file jolt_api.hpp file jolt_context.hpp file jolt_helper.hpp"},{"location":"References/dir_3d876be8cd66de39c1e103aa97223d9b/#directories","title":"Directories","text":"Type Name dir interface <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/jolt/</code></p>"},{"location":"References/dir_6170caab3d86040ff713c96f30038a01/","title":"Dir TheAtlasEngine/atlas/physics/physics_3d/jolt/interface","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; jolt &gt; interface</p>"},{"location":"References/dir_6170caab3d86040ff713c96f30038a01/#files","title":"Files","text":"Type Name file jolt_broad_phase.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/jolt/interface/</code></p>"},{"location":"References/jolt__broad__phase_8hpp/","title":"File jolt_broad_phase.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; jolt &gt; interface &gt; jolt_broad_phase.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;physics/jolt-cpp/jolt-imports.hpp&gt;</code></li> </ul>"},{"location":"References/jolt__broad__phase_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics Handles error handling with in jolt."},{"location":"References/jolt__broad__phase_8hpp/#classes","title":"Classes","text":"Type Name class broad_phase_layer_interface This class is made to control the broadphase layer. Filters can be added to it to create a better and more organized broadphase. Ass well as giving some control to the user on how the broadphase should be organized. This requires dynamic masking however, which is not currently running. class object_layer_pair_filter This goes into more detailed ways of filtering, where the object collisions may be defined be what the other object is. In this case a static setup allows static object to trigger collision only when it is touched by a dynamic target. class object_vs_broadphase_layer This is used to tell Jolt what can or cannot collide. As of right now the list is static therfore the layers do not need a dynamic set up. This will change when the object layers become user definable. <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/jolt/interface/jolt_broad_phase.hpp</code></p>"},{"location":"References/jolt__broad__phase_8hpp_source/","title":"File jolt_broad_phase.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; physics_3d &gt; jolt &gt; interface &gt; jolt_broad_phase.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;physics/jolt-cpp/jolt-imports.hpp&gt;\n\nnamespace atlas::physics {\n\n    // This should eventually have a pipeline for the user to create masks.\n    enum class ObjectLayer : std::uint8_t {\n        NonMoving = 0,\n        Moving = 1,\n        NumLayers\n    };\n\n    enum class BroadPhaseLayers : std::uint8_t {\n        NonMoving = 0,\n        Moving = 1,\n        NumLayers\n    };\n\n    class broad_phase_layer_interface final\n      : public JPH::BroadPhaseLayerInterface {\n    public:\n        broad_phase_layer_interface() = default;\n\n        [[nodiscard]] uint32_t GetNumBroadPhaseLayers() const override {\n            return (uint32_t)(BroadPhaseLayers::NumLayers);\n        }\n\n        [[nodiscard]] JPH::BroadPhaseLayer GetBroadPhaseLayer(\n          JPH::ObjectLayer p_in_layer) const override {\n            JPH_ASSERT(p_in_layer &lt; (JPH::ObjectLayer)ObjectLayer::NumLayers);\n            return m_object_to_broadphase[p_in_layer];\n        }\n\n#if defined(JPH_EXTERNAL_PROFILE) || defined(JPH_PROFILE_ENABLED)\n        [[nodiscard]] const char* GetBroadPhaseLayerName(\n          JPH::BroadPhaseLayer p_in_layer) const override {\n            switch (p_in_layer.GetValue()) {\n                case (JPH::BroadPhaseLayer::Type)(BroadPhaseLayers::NonMoving):\n                    return \"NonMoving\";\n                case (JPH::BroadPhaseLayer::Type)(BroadPhaseLayers::Moving):\n                    return \"Moving\";\n                default:\n                    JPH_ASSERT(false);\n                    return \"Unknown\";\n            }\n        }\n#endif\n\n    private:\n        // The list of organizational layers\n        std::vector&lt;JPH::BroadPhaseLayer&gt; m_object_to_broadphase{\n            JPH::BroadPhaseLayer((uint8_t)(BroadPhaseLayers::NonMoving)),\n            JPH::BroadPhaseLayer((uint8_t)(BroadPhaseLayers::Moving))\n\n        };\n    };\n\n    class object_vs_broadphase_layer final\n      : public JPH::ObjectVsBroadPhaseLayerFilter {\n    public:\n        [[nodiscard]] bool ShouldCollide(\n          JPH::ObjectLayer p_in_layer1,\n          JPH::BroadPhaseLayer p_in_layer2) const override {\n            switch (p_in_layer1) {\n                case (int)(ObjectLayer::NonMoving):\n                    return p_in_layer2 ==\n                           JPH::BroadPhaseLayer((JPH::BroadPhaseLayer::Type)(\n                             BroadPhaseLayers::Moving));\n                case (int)ObjectLayer::Moving:\n                    return true;\n                default:\n                    JPH_ASSERT(false);\n                    return false;\n            }\n        }\n    };\n\n    class object_layer_pair_filter final : public JPH::ObjectLayerPairFilter {\n    public:\n        [[nodiscard]] bool ShouldCollide(\n          JPH::ObjectLayer p_in_object1,\n          JPH::ObjectLayer p_in_object2) const override {\n            switch (p_in_object1) {\n                case (int)(ObjectLayer::NonMoving):\n                    return p_in_object2 == (int)(ObjectLayer::Moving);\n                case (int)(ObjectLayer::Moving):\n                    return true;\n                default:\n                    JPH_ASSERT(false);\n                    return false;\n            }\n        }\n    };\n\n}\n</code></pre>"},{"location":"References/physics__3d_2jolt_2jolt__api_8hpp/","title":"File jolt_api.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; jolt &gt; jolt_api.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;flecs.h&gt;</code></li> <li><code>#include &lt;physics/physics_3d/physics_api.hpp&gt;</code></li> <li><code>#include &lt;scene/components.hpp&gt;</code></li> <li><code>#include &lt;physics/jolt-cpp/jolt_components.hpp&gt;</code></li> </ul>"},{"location":"References/physics__3d_2jolt_2jolt__api_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics Handles error handling with in jolt."},{"location":"References/physics__3d_2jolt_2jolt__api_8hpp/#classes","title":"Classes","text":"Type Name class jolt_api <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/jolt/jolt_api.hpp</code></p>"},{"location":"References/physics__3d_2jolt_2jolt__api_8hpp_source/","title":"File jolt_api.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; physics_3d &gt; jolt &gt; jolt_api.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;flecs.h&gt;\n#include &lt;physics/physics_3d/physics_api.hpp&gt;\n#include &lt;scene/components.hpp&gt;\n#include &lt;physics/jolt-cpp/jolt_components.hpp&gt;\n\nnamespace atlas::physics {\n    class jolt_api : public physics_api {\n    public:\n        jolt_api(const jolt_config&amp; p_config,\n                 const ref&lt;JPH::PhysicsSystem&gt;&amp; p_physics_system,\n                 const flecs::world&amp; p_registery);\n\n    private:\n        void retrieve_values() override;\n\n        void return_values() override;\n\n        void add_force(const glm::vec3&amp; p_force,\n                       const uint32_t&amp; p_body_id) override;\n\n        void add_linear_velocity(const glm::vec3&amp; p_linear_velocity,\n                                 const uint32_t&amp; p_body_id) override;\n        void add_angular_velocity(const glm::vec3&amp; p_angular_velocity,\n                                  const uint32_t&amp; p_body_id) override;\n\n        void set_linear_velocity(const glm::vec3&amp; p_velocity,\n                                 const uint32_t&amp; p_body_id) override;\n\n        void set_angular_velocity(const glm::vec3&amp; p_angular_velocity,\n                                  const uint32_t&amp; p_body_id) override;\n\n        jolt_config m_config;\n        ref&lt;JPH::PhysicsSystem&gt; m_physics_system;\n        flecs::world m_registery;\n\n        flecs::query&lt;transform, collider_body&gt; m_read_transform;\n        flecs::query&lt;physics_body&gt; m_read_body;\n\n        flecs::query&lt;transform, collider_body&gt; m_query_transform;\n        flecs::query&lt;physics_body&gt; m_query_body;\n    };\n};\n</code></pre>"},{"location":"References/jolt__context_8hpp/","title":"File jolt_context.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; jolt &gt; jolt_context.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;physics/jolt-cpp/jolt_contact_listener.hpp&gt;</code></li> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;physics/physics_3d/physics_context.hpp&gt;</code></li> <li><code>#include &lt;physics/jolt-cpp/jolt_components.hpp&gt;</code></li> <li><code>#include &lt;components/transform.hpp&gt;</code></li> <li><code>#include &lt;physics/physics_3d/jolt/interface/jolt_broad_phase.hpp&gt;</code></li> </ul>"},{"location":"References/jolt__context_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics Handles error handling with in jolt."},{"location":"References/jolt__context_8hpp/#classes","title":"Classes","text":"Type Name class jolt_context This class is made to be 1 of three api wrappers for jolt. Jolt context is specifically for engine only use of the api. It wraps the inititialization, the physics step and the clean up. Allow use not to have to write batching algorithms for each time we want to change the settings of jolt physics. <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/jolt/jolt_context.hpp</code></p>"},{"location":"References/jolt__context_8hpp_source/","title":"File jolt_context.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; physics_3d &gt; jolt &gt; jolt_context.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;physics/jolt-cpp/jolt_contact_listener.hpp&gt;\n#include &lt;core/core.hpp&gt;\n\n#include &lt;physics/physics_3d/physics_context.hpp&gt;\n#include &lt;physics/jolt-cpp/jolt_components.hpp&gt;\n#include &lt;components/transform.hpp&gt;\n#include &lt;physics/physics_3d/jolt/interface/jolt_broad_phase.hpp&gt;\n\nnamespace atlas::physics {\n    class jolt_context : public physics_context {\n    public:\n        jolt_context(const jolt_settings&amp; p_settings);\n        ~jolt_context() override;\n\n        ref&lt;JPH::PhysicsSystem&gt; m_physics_system;\n\n    private:\n        void engine_create_physics_bodies() override;\n\n        void engine_clean_physics_bodies() override;\n\n        void engine_run_physics_step() override;\n\n        void engine_run_contact_added() override;\n\n        void store_shape(uint64_t id, const JPH::RefConst&lt;JPH::Shape&gt;&amp; shape);\n\n        JPH::RefConst&lt;JPH::Shape&gt; create_shape_from_collider(\n          flecs::entity e,\n          const collider_body&amp; collider);\n\n        void add_body(flecs::entity e,\n                      const physics_body* body_opt,\n                      const collider_body&amp; collider,\n                      const transform_physics&amp; location,\n                      std::vector&lt;JPH::BodyCreationSettings&gt;&amp; settings_list,\n                      std::vector&lt;flecs::entity&gt;&amp; entity_list);\n\n        jolt_settings m_settings;\n\n        ref&lt;JPH::TempAllocatorImpl&gt; m_temp_allocator;\n\n        scope&lt;JPH::JobSystemThreadPool&gt; m_thread_system;\n\n        ref&lt;broad_phase_layer_interface&gt; m_broad_phase_layer_interface;\n\n        ref&lt;object_vs_broadphase_layer&gt; m_object_vs_broadphase_filter;\n\n        ref&lt;object_layer_pair_filter&gt; m_object_layer_pair_filter;\n\n        ref&lt;contact_listener&gt; m_contact_listener;\n\n        std::unordered_map&lt;uint64_t, JPH::RefConst&lt;JPH::Shape&gt;&gt;\n          m_shape_registry;\n    };\n};\n</code></pre>"},{"location":"References/jolt__helper_8hpp/","title":"File jolt_helper.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; jolt &gt; jolt_helper.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;Jolt/Jolt.h&gt;</code></li> <li><code>#include &lt;core/math/types.hpp&gt;</code></li> <li><code>#include &lt;glm/gtc/quaternion.hpp&gt;</code></li> <li><code>#include &lt;glm/fwd.hpp&gt;</code></li> </ul>"},{"location":"References/jolt__helper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics Handles error handling with in jolt."},{"location":"References/jolt__helper_8hpp/#classes","title":"Classes","text":"Type Name struct vector3&lt; JPH::Vec3 &gt; &lt;&gt; <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/jolt/jolt_helper.hpp</code></p>"},{"location":"References/jolt__helper_8hpp_source/","title":"File jolt_helper.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; physics_3d &gt; jolt &gt; jolt_helper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;type_traits&gt;\n#include &lt;Jolt/Jolt.h&gt;\n#include &lt;core/math/types.hpp&gt;\n#include &lt;glm/gtc/quaternion.hpp&gt;\n#include &lt;glm/fwd.hpp&gt;\n\nnamespace atlas {\n    template&lt;&gt;\n    struct vector3&lt;JPH::Vec3&gt; {\n        vector3() = default;\n\n        vector3(const JPH::Vec3&amp; p_other) {\n            m_value = { p_other.GetX(), p_other.GetY(), p_other.GetZ() };\n        }\n\n        operator glm::vec3() { return m_value; }\n\n        glm::vec3 operator=(const JPH::Vec3&amp; p_other) {\n            return { p_other.GetX(), p_other.GetY(), p_other.GetZ() };\n        }\n\n        bool operator==(const glm::vec3&amp; p_other) {\n            return (m_value.x == p_other.x and m_value.y == p_other.y and\n                    m_value.z == p_other.z);\n        }\n\n    private:\n        glm::vec3 m_value;\n    };\n};\n\nnamespace atlas::physics {\n\n    inline JPH::Vec3 to_jph(const glm::vec3&amp; v) {\n        return { v.x, v.y, v.z };\n    }\n\n    inline JPH::Quat to_jph(const glm::vec4&amp; q) {\n        return { q.x, q.y, q.z, q.w };\n    }\n};\n</code></pre>"},{"location":"References/physics_8hpp/","title":"File physics.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; physics.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;physics/physics_3d/physics_engine.hpp&gt;</code></li> <li><code>#include &lt;physics/jolt-cpp/jolt_components.hpp&gt;</code></li> <li><code>#include &lt;core/scene/scene_object.hpp&gt;</code></li> </ul>"},{"location":"References/physics_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics Handles error handling with in jolt. <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/physics.hpp</code></p>"},{"location":"References/physics_8hpp_source/","title":"File physics.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; physics_3d &gt; physics.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;physics/physics_3d/physics_engine.hpp&gt;\n#include &lt;physics/jolt-cpp/jolt_components.hpp&gt;\n#include &lt;core/scene/scene_object.hpp&gt;\n\nnamespace atlas::physics {\n    enum physics_backend : uint8_t { JoltBackend };\n\n    ref&lt;physics_engine&gt; initialize_engine(\n      const ref&lt;scene_object&gt;&amp; p_physics_object,\n      flecs::world&amp; p_registery);\n\n    void add_force(const glm::vec3&amp; force, const physics_body&amp; body);\n\n    // void add_force_world_point(glm::vec3 force,\n    //   glm::vec3 position,\n    //   physics_body body);\n\n    void add_velocity(const glm::vec3&amp; velocity, const physics_body&amp; body);\n\n    void add_angular_velocity(const glm::vec3&amp; angular_velocity,\n                              const physics_body&amp; body);\n\n    void set_velocity(const glm::vec3&amp; velocity, const physics_body&amp; body);\n\n    void set_angular_velocity(const glm::vec3&amp; angular_velocity,\n                              const physics_body&amp; body);\n\n};\n</code></pre>"},{"location":"References/physics__api_8hpp/","title":"File physics_api.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; physics_api.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;physics/jolt-cpp/jolt_components.hpp&gt;</code></li> </ul>"},{"location":"References/physics__api_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics Handles error handling with in jolt."},{"location":"References/physics__api_8hpp/#classes","title":"Classes","text":"Type Name class physics_api <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/physics_api.hpp</code></p>"},{"location":"References/physics__api_8hpp_source/","title":"File physics_api.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; physics_3d &gt; physics_api.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;physics/jolt-cpp/jolt_components.hpp&gt;\n\nnamespace atlas::physics {\n\n    class physics_api {\n    public:\n        void update_jolt_values();\n\n        void update_atlas_values();\n\n        void add_force_by_body(const glm::vec3&amp; p_force,\n                               const physics_body&amp; p_body);\n\n        // void add_force_by_world_point();\n\n        void add_linear_velocity_by_body(const glm::vec3&amp; p_velocity,\n                                         const physics_body&amp; p_body);\n\n        void add_angular_velocity_by_body(const glm::vec3&amp; p_angular_velocity,\n                                          const physics_body&amp; p_body);\n\n        void set_linear_velocity_by_body(const glm::vec3&amp; p_velocity,\n                                         const physics_body&amp; p_body);\n\n        void set_angular_velocity_by_body(const glm::vec3&amp; p_angular_velocity,\n                                          const physics_body&amp; p_body);\n\n        virtual ~physics_api() = default;\n\n    private:\n        virtual void retrieve_values() = 0;\n\n        virtual void return_values() = 0;\n\n        virtual void add_force(const glm::vec3&amp; p_force,\n                               const uint32_t&amp; p_body_id) = 0;\n\n        // virtual void add_force_world_point(const glm::vec3&amp; force,\n        //                                    const glm::vec3&amp; position,\n        //                                    const uint32_t&amp; body_id) = 0;\n\n        virtual void add_linear_velocity(const glm::vec3&amp; p_velocity,\n                                         const uint32_t&amp; p_body_id) = 0;\n\n        virtual void add_angular_velocity(const glm::vec3&amp; angular_velocity,\n                                          const uint32_t&amp; body_id) = 0;\n\n        virtual void set_linear_velocity(const glm::vec3&amp; p_velocity,\n                                         const uint32_t&amp; p_body_id) = 0;\n\n        virtual void set_angular_velocity(const glm::vec3&amp; angular_velocity,\n                                          const uint32_t&amp; body_id) = 0;\n    };\n};\n</code></pre>"},{"location":"References/physics__context_8hpp/","title":"File physics_context.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; physics_context.hpp</p> <p>Go to the source code of this file</p>"},{"location":"References/physics__context_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics Handles error handling with in jolt."},{"location":"References/physics__context_8hpp/#classes","title":"Classes","text":"Type Name class physics_context The context is the way to interact with only the engine. It is the api for all the background funcitons and information that the user shouldn not see. It is a virtual based type erasure class so thatmany engines can implement the same functions. Specifically realted to backend engine creation like batching, starting runtime, etc... <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/physics_context.hpp</code></p>"},{"location":"References/physics__context_8hpp_source/","title":"File physics_context.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; physics_3d &gt; physics_context.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\nnamespace atlas::physics {\n    class physics_context {\n    public:\n        // Pass through function to allow private virtual functions to be called\n        // publically without messing up the virtual table.\n        void create_bodies();\n        void clean_bodies();\n        void run_physics_step();\n        void contact_added_event();\n\n        virtual ~physics_context() = default;\n\n    private:\n        virtual void engine_create_physics_bodies() = 0;\n        virtual void engine_clean_physics_bodies() = 0;\n        virtual void engine_run_physics_step() = 0;\n        virtual void engine_run_contact_added() = 0;\n    };\n};\n</code></pre>"},{"location":"References/physics__engine_8hpp/","title":"File physics_engine.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; physics_engine.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;physics/jolt-cpp/jolt_components.hpp&gt;</code></li> <li><code>#include &lt;physics/physics_3d/jolt/jolt_context.hpp&gt;</code></li> <li><code>#include &lt;physics/physics_3d/physics_api.hpp&gt;</code></li> </ul>"},{"location":"References/physics__engine_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics Handles error handling with in jolt."},{"location":"References/physics__engine_8hpp/#classes","title":"Classes","text":"Type Name class physics_engine The manager class for all physics engines. Manages the physics contexts and the collision engines. <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/physics_engine.hpp</code></p>"},{"location":"References/physics__engine_8hpp_source/","title":"File physics_engine.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; physics_3d &gt; physics_engine.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;physics/jolt-cpp/jolt_components.hpp&gt;\n#include &lt;physics/physics_3d/jolt/jolt_context.hpp&gt;\n#include &lt;physics/physics_3d/physics_api.hpp&gt;\n\nnamespace atlas::physics {\n\n    class physics_engine {\n    public:\n        // Required by maps but should not be used in anyother circumstance.\n        physics_engine() = default;\n        physics_engine(const jolt_settings&amp; p_settings,\n                       const ref&lt;physics_context&gt;&amp; p_engine,\n                       const ref&lt;physics_api&gt;&amp; p_user_api);\n\n        void start_runtime();\n\n        void physics_step();\n\n        void stop_runtime();\n\n        void run_contact_add();\n\n    private:\n        jolt_settings m_settings;\n        ref&lt;physics_context&gt; m_engine_api;\n        ref&lt;physics_api&gt; m_backend_api;\n    };\n};\n</code></pre>"},{"location":"References/physics_2types_8hpp/","title":"File types.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; types.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;physics/jolt-cpp/jolt-imports.hpp&gt;</code></li> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> </ul>"},{"location":"References/physics_2types_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics Handles error handling with in jolt."},{"location":"References/physics_2types_8hpp/#classes","title":"Classes","text":"Type Name struct matrix4&lt; JPH::Mat44 &gt; &lt;&gt; struct vector3&lt; JPH::DVec3 &gt; &lt;&gt; struct vector3&lt; JPH::Double3 &gt; &lt;&gt; struct vector3&lt; JPH::Float3 &gt; &lt;&gt; struct vector3&lt; JPH::Vec3 &gt; &lt;&gt; struct vector4&lt; JPH::Float4 &gt; &lt;&gt; struct vector4&lt; JPH::Vec4 &gt; &lt;&gt; <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/types.hpp</code></p>"},{"location":"References/physics_2types_8hpp_source/","title":"File types.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; types.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;physics/jolt-cpp/jolt-imports.hpp&gt;\n#include &lt;glm/glm.hpp&gt;\n\nnamespace atlas::physics {\n\n    template&lt;typename T&gt;\n    struct vector3;\n\n    template&lt;&gt;\n    struct vector3&lt;JPH::Vec3&gt; {\n        vector3() = default;\n\n        vector3(const JPH::Vec3&amp; v) {\n            m_value = { v.GetX(), v.GetY(), v.GetZ() };\n        }\n\n        operator glm::vec3() const { return m_value; }\n\n        glm::vec3 operator=(const JPH::Vec3&amp; v) {\n            m_value = { v.GetX(), v.GetY(), v.GetZ() };\n            return m_value;\n        }\n\n        bool operator==(const glm::vec3&amp; other) const {\n            return m_value == other;\n        }\n\n    private:\n        glm::vec3 m_value;\n    };\n\n    template&lt;&gt;\n    struct vector3&lt;JPH::Float3&gt; {\n        vector3() = default;\n\n        vector3(const JPH::Float3&amp; v) { m_value = { v.x, v.y, v.z }; }\n\n        operator glm::vec3() const { return m_value; }\n\n        glm::vec3 operator=(const JPH::Float3&amp; v) {\n            m_value = { v.x, v.y, v.z };\n            return m_value;\n        }\n\n        bool operator==(const glm::vec3&amp; other) const {\n            return m_value == other;\n        }\n\n    private:\n        glm::vec3 m_value;\n    };\n\n    template&lt;&gt;\n    struct vector3&lt;JPH::DVec3&gt; {\n        vector3() = default;\n\n        vector3(const JPH::DVec3&amp; v) {\n            m_value = { v.GetX(), v.GetY(), v.GetZ() };\n        }\n\n        operator glm::dvec3() const { return m_value; }\n\n        glm::dvec3 operator=(const JPH::DVec3&amp; v) {\n            m_value = { v.GetX(), v.GetY(), v.GetZ() };\n            return m_value;\n        }\n\n        bool operator==(const glm::dvec3&amp; other) const {\n            return m_value == other;\n        }\n\n    private:\n        glm::dvec3 m_value;\n    };\n\n    template&lt;&gt;\n    struct vector3&lt;JPH::Double3&gt; {\n        vector3() = default;\n\n        vector3(const JPH::Double3&amp; v) { m_value = { v.x, v.y, v.z }; }\n\n        operator glm::dvec3() const { return m_value; }\n\n        glm::dvec3 operator=(const JPH::Double3&amp; v) {\n            m_value = { v.x, v.y, v.z };\n            return m_value;\n        }\n\n        bool operator==(const glm::dvec3&amp; other) const {\n            return m_value == other;\n        }\n\n    private:\n        glm::dvec3 m_value;\n    };\n\n    // === VECTOR4 ADAPTER ===\n    template&lt;typename T&gt;\n    struct vector4;\n\n    template&lt;&gt;\n    struct vector4&lt;JPH::Vec4&gt; {\n        vector4() = default;\n\n        vector4(const JPH::Vec4&amp; v) {\n            m_value = { v.GetX(), v.GetY(), v.GetZ(), v.GetW() };\n        }\n\n        operator glm::vec4() const { return m_value; }\n\n        glm::vec4 operator=(const JPH::Vec4&amp; v) {\n            m_value = { v.GetX(), v.GetY(), v.GetZ(), v.GetW() };\n            return m_value;\n        }\n\n        bool operator==(const glm::vec4&amp; other) const {\n            return m_value == other;\n        }\n\n    private:\n        glm::vec4 m_value;\n    };\n\n    template&lt;&gt;\n    struct vector4&lt;JPH::Float4&gt; {\n        vector4() = default;\n\n        vector4(const JPH::Float4&amp; v) { m_value = { v.x, v.y, v.z, v.w }; }\n\n        operator glm::vec4() const { return m_value; }\n\n        glm::vec4 operator=(const JPH::Float4&amp; v) {\n            m_value = { v.x, v.y, v.z, v.w };\n            return m_value;\n        }\n\n        bool operator==(const glm::vec4&amp; other) const {\n            return m_value == other;\n        }\n\n    private:\n        glm::vec4 m_value;\n    };\n\n    // === QUATERNION ADAPTER ===\n    template&lt;typename T&gt;\n    struct quaternion;\n\n    // === MATRIX4 ADAPTER ===\n    template&lt;typename T&gt;\n    struct matrix4;\n\n    template&lt;&gt;\n    struct matrix4&lt;JPH::Mat44&gt; {\n        matrix4() = default;\n\n        matrix4(const JPH::Mat44&amp; m) {\n            for (int i = 0; i &lt; 4; ++i) {\n                const auto col = m.GetColumn4(i);\n                m_value[i] =\n                  glm::vec4(col.GetX(), col.GetY(), col.GetZ(), col.GetW());\n            }\n        }\n\n        operator glm::mat4() const { return m_value; }\n\n        glm::mat4 operator=(const JPH::Mat44&amp; m) {\n            for (int i = 0; i &lt; 4; ++i) {\n                const auto col = m.GetColumn4(i);\n                m_value[i] =\n                  glm::vec4(col.GetX(), col.GetY(), col.GetZ(), col.GetW());\n            }\n            return m_value;\n        }\n\n        bool operator==(const glm::mat4&amp; other) const {\n            return m_value == other;\n        }\n\n    private:\n        glm::mat4 m_value;\n    };\n};\n</code></pre>"},{"location":"References/dir_8ab98dc538dea21b0c00575cec6c8f5c/","title":"Dir TheAtlasEngine/atlas/renderer","text":"<p>FileList &gt; atlas &gt; renderer</p>"},{"location":"References/dir_8ab98dc538dea21b0c00575cec6c8f5c/#files","title":"Files","text":"Type Name file renderer.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/renderer/</code></p>"},{"location":"References/renderer_8hpp/","title":"File renderer.hpp","text":"<p>FileList &gt; atlas &gt; renderer &gt; renderer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.hpp&gt;</code></li> <li><code>#include &lt;drivers/renderer_context.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_swapchain.hpp&gt;</code></li> </ul>"},{"location":"References/renderer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/renderer_8hpp/#classes","title":"Classes","text":"Type Name class renderer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/renderer/renderer.hpp</code></p>"},{"location":"References/renderer_8hpp_source/","title":"File renderer.hpp","text":"<p>File List &gt; atlas &gt; renderer &gt; renderer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;vulkan/vulkan.hpp&gt;\n#include &lt;drivers/renderer_context.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_swapchain.hpp&gt;\n\nnamespace atlas {\n    class renderer {\n    public:\n        renderer() = default;\n        renderer(const vk::vk_swapchain&amp; p_swapchain,\n                 const std::string&amp; p_tag = \"Renderer\");\n        void begin(const vk::vk_command_buffer&amp; p_current,\n                   const vk::vk_swapchain&amp; p_current_rp);\n\n        void end();\n\n        void set_background_color(const std::array&lt;float, 4&gt;&amp; p_color);\n\n    private:\n        static renderer* s_instance;\n        scope&lt;render_context&gt; m_render_context = nullptr;\n    };\n};\n</code></pre>"},{"location":"References/dir_2d188042b35c07e13e36a6d5b630b30a/","title":"Dir TheAtlasEngine/atlas/thread_utils","text":"<p>FileList &gt; atlas &gt; thread_utils</p>"},{"location":"References/dir_2d188042b35c07e13e36a6d5b630b30a/#files","title":"Files","text":"Type Name file thread.hpp file thread_utils.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/thread_utils/</code></p>"},{"location":"References/thread__utils_2thread_8hpp/","title":"File thread.hpp","text":"<p>FileList &gt; atlas &gt; thread_utils &gt; thread.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"References/thread__utils_2thread_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/thread__utils_2thread_8hpp/#classes","title":"Classes","text":"Type Name class thread <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/thread_utils/thread.hpp</code></p>"},{"location":"References/thread__utils_2thread_8hpp_source/","title":"File thread.hpp","text":"<p>File List &gt; atlas &gt; thread_utils &gt; thread.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;thread&gt;\n\nnamespace atlas {\n    class thread {\n    public:\n        thread() = delete;\n        thread(const std::string&amp; p_tag = \"Undefined\")\n          : m_tag(p_tag) {}\n\n        ~thread() {\n            console_log_info(\"Are you destructed!\");\n            if (this-&gt;Joinable()) {\n                this-&gt;Join();\n            }\n        }\n\n        template&lt;typename T, typename... Args&gt;\n        void dispatch(T&amp;&amp; func, Args&amp;&amp;... args) {\n            m_thread = std::thread(func, std::forward&lt;Args&gt;(args)...);\n        }\n\n        bool Joinable() { return m_thread.joinable(); }\n\n        void Join() { m_thread.join(); }\n\n    private:\n        std::string m_tag;\n        std::thread m_thread;\n    };\n};\n</code></pre>"},{"location":"References/thread__utils_8hpp/","title":"File thread_utils.hpp","text":"<p>FileList &gt; atlas &gt; thread_utils &gt; thread_utils.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"References/thread__utils_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/thread_utils/thread_utils.hpp</code></p>"},{"location":"References/thread__utils_8hpp_source/","title":"File thread_utils.hpp","text":"<p>File List &gt; atlas &gt; thread_utils &gt; thread_utils.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n\nnamespace atlas {\n    uint32_t get_thread_count();\n};\n</code></pre>"},{"location":"References/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace JPH </li> <li>namespace atlas <ul> <li>namespace event </li> <li>namespace filesystem </li> <li>namespace physics Handles error handling with in jolt. </li> <li>namespace sync_update </li> <li>namespace ui </li> <li>namespace vk </li> </ul> </li> <li>namespace std </li> </ul>"},{"location":"References/classes/","title":"Class Index","text":""},{"location":"References/classes/#a","title":"a","text":"<ul> <li>application (atlas)</li> <li>application_settings (atlas)</li> </ul>"},{"location":"References/classes/#b","title":"b","text":"<ul> <li>box_collider3d (atlas)</li> <li>broad_phase_layer_interface (atlas::physics)</li> </ul>"},{"location":"References/classes/#c","title":"c","text":"<ul> <li>camera (atlas)</li> <li>camera_ubo (atlas::vk)</li> <li>collider_body (atlas::physics)</li> <li>collider_event (atlas::physics)</li> <li>command_buffer_settings (atlas::vk)</li> <li>console_log_manager (atlas)</li> <li>contact_event (atlas::physics)</li> <li>contact_listener (atlas::physics)</li> </ul>"},{"location":"References/classes/#d","title":"d","text":"<ul> <li>descriptor_binding_entry (atlas::vk)</li> <li>descriptor_binding_point (atlas::vk)</li> <li>descriptor_set (atlas::vk)</li> <li>descriptor_set_layout (atlas::vk)</li> <li>device_queue_family</li> </ul>"},{"location":"References/classes/#e","title":"e","text":"<ul> <li>entity_t (atlas)</li> </ul>"},{"location":"References/classes/#g","title":"g","text":"<ul> <li>global_ubo (atlas::vk)</li> <li>graphics_context (atlas)</li> </ul>"},{"location":"References/classes/#h","title":"h","text":"<ul> <li>hash&lt; atlas::vk::vertex_input &gt; (std)</li> <li>hud_data (atlas::vk)</li> </ul>"},{"location":"References/classes/#i","title":"i","text":"<ul> <li>image_extent (atlas::vk)</li> <li>imgui_context (atlas::vk)</li> <li>interpolation (atlas)</li> </ul>"},{"location":"References/classes/#j","title":"j","text":"<ul> <li>jolt_api (atlas::physics)</li> <li>jolt_collision (atlas::physics)</li> <li>jolt_collision_manager (atlas::physics)</li> <li>jolt_config (atlas::physics)</li> <li>jolt_context (atlas::physics)</li> <li>jolt_settings (atlas::physics)</li> <li>joystick_button (atlas::event)</li> <li>joystick_info (atlas::event)</li> </ul>"},{"location":"References/classes/#l","title":"l","text":"<ul> <li>light (atlas)</li> </ul>"},{"location":"References/classes/#m","title":"m","text":"<ul> <li>material (atlas)</li> <li>material_uniform (atlas::vk)</li> <li>math_generic (atlas)</li> <li>matrix2 (atlas)</li> <li>matrix3 (atlas)</li> <li>matrix4 (atlas)</li> <li>matrix4 (atlas::physics)</li> <li>matrix4&lt; JPH::Mat44 &gt; (atlas::physics)</li> <li>mesh (atlas)</li> <li>mesh (atlas::vk)</li> </ul>"},{"location":"References/classes/#o","title":"o","text":"<ul> <li>object_layer_pair_filter (atlas::physics)</li> <li>object_vs_broadphase_layer (atlas::physics)</li> </ul>"},{"location":"References/classes/#p","title":"p","text":"<ul> <li>physics_api (atlas::physics)</li> <li>physics_body (atlas::physics)</li> <li>physics_context (atlas::physics)</li> <li>physics_engine (atlas::physics)</li> </ul>"},{"location":"References/classes/#q","title":"q","text":"<ul> <li>quaternion (atlas::physics)</li> <li>queue_family_indices</li> </ul>"},{"location":"References/classes/#r","title":"r","text":"<ul> <li>reload (atlas)</li> <li>render_context (atlas)</li> <li>renderer (atlas)</li> <li>renderpass_attachment (atlas::vk)</li> <li>renderpass_options (atlas::vk)</li> <li>rigidbody3d (atlas)</li> </ul>"},{"location":"References/classes/#s","title":"s","text":"<ul> <li>scene_object (atlas)</li> <li>scene_scope (atlas)</li> <li>serializer (atlas)</li> <li>shader_info (atlas::vk)</li> <li>surface_properties (atlas::vk)</li> <li>system_registry (atlas)</li> </ul>"},{"location":"References/classes/#t","title":"t","text":"<ul> <li>tag (atlas)</li> <li>texture (atlas::vk)</li> <li>texture_extent (atlas::vk)</li> <li>texture_properties (atlas::vk)</li> <li>thread (atlas)</li> <li>timer (atlas)</li> <li>transform (atlas)</li> <li>transform_physics (atlas)</li> </ul>"},{"location":"References/classes/#v","title":"v","text":"<ul> <li>vector2 (atlas)</li> <li>vector2&lt; glm::highp_vec2 &gt; (atlas)</li> <li>vector3 (atlas::physics)</li> <li>vector3 (atlas)</li> <li>vector3&lt; glm::highp_vec3 &gt; (atlas)</li> <li>vector3&lt; JPH::Double3 &gt; (atlas::physics)</li> <li>vector3&lt; JPH::DVec3 &gt; (atlas::physics)</li> <li>vector3&lt; JPH::Float3 &gt; (atlas::physics)</li> <li>vector3&lt; JPH::Vec3 &gt; (atlas::physics)</li> <li>vector3&lt; JPH::Vec3 &gt; (atlas)</li> <li>vector4 (atlas::physics)</li> <li>vector4 (atlas)</li> <li>vector4&lt; glm::highp_vec4 &gt; (atlas)</li> <li>vector4&lt; JPH::Float4 &gt; (atlas::physics)</li> <li>vector4&lt; JPH::Vec4 &gt; (atlas::physics)</li> <li>vertex_attribute (atlas::vk)</li> <li>vertex_attribute_entry (atlas::vk)</li> <li>vertex_input (atlas::vk)</li> <li>vk_buffer (atlas::vk)</li> <li>vk_buffer_info (atlas::vk)</li> <li>vk_command_buffer (atlas::vk)</li> <li>vk_context (atlas::vk)</li> <li>vk_driver (atlas::vk)</li> <li>vk_filter_range (atlas::vk)</li> <li>vk_graphics_queue (atlas::vk)</li> <li>vk_image (atlas::vk)</li> <li>vk_image_handle (atlas::vk)</li> <li>vk_index_buffer (atlas::vk)</li> <li>vk_physical_driver (atlas::vk)</li> <li>vk_pipeline (atlas::vk)</li> <li>vk_present_queue (atlas::vk)</li> <li>vk_queue_options (atlas::vk)</li> <li>vk_renderer (atlas::vk)</li> <li>vk_renderpass (atlas::vk)</li> <li>vk_renderpass_options (atlas::vk)</li> <li>vk_shader_group (atlas::vk)</li> <li>vk_shader_module (atlas::vk)</li> <li>vk_swapchain (atlas::vk)</li> <li>vk_uniform_buffer (atlas::vk)</li> <li>vk_vertex_buffer (atlas::vk)</li> <li>vk_window (atlas::vk)</li> </ul>"},{"location":"References/classes/#w","title":"w","text":"<ul> <li>window (atlas)</li> <li>window_settings (atlas)</li> <li>world_scope (atlas)</li> </ul>"},{"location":"References/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class atlas::application </li> <li>class atlas::camera </li> <li>class atlas::console_log_manager </li> <li>class atlas::entity_t </li> <li>class atlas::graphics_context <ul> <li>class atlas::vk::vk_context </li> </ul> </li> <li>class atlas::interpolation </li> <li>class atlas::mesh </li> <li>class atlas::physics::physics_api <ul> <li>class atlas::physics::jolt_api </li> </ul> </li> <li>class atlas::physics::jolt_collision This is the collision api. It allows users to create children of this collision handler and write their own functions over the virtual ones. Then they can assign it to the engine. </li> <li>class atlas::physics::jolt_collision_manager This allows users to make thier own version of jolt collition and run them their own way. It allows users to interact with the calls by creating a child class of jolt_collision and run whatever action they want.</li> <li>class atlas::physics::physics_context The context is the way to interact with only the engine. It is the api for all the background funcitons and information that the user shouldn not see. It is a virtual based type erasure class so thatmany engines can implement the same functions. Specifically realted to backend engine creation like batching, starting runtime, etc... <ul> <li>class atlas::physics::jolt_context This class is made to be 1 of three api wrappers for jolt. Jolt context is specifically for engine only use of the api. It wraps the inititialization, the physics step and the clean up. Allow use not to have to write batching algorithms for each time we want to change the settings of jolt physics. </li> </ul> </li> <li>class atlas::physics::physics_engine The manager class for all physics engines. Manages the physics contexts and the collision engines. </li> <li>class atlas::render_context <ul> <li>class atlas::vk::vk_renderer Something to consider for mesh loading. </li> </ul> </li> <li>class atlas::renderer </li> <li>class atlas::scene_object </li> <li>class atlas::scene_scope </li> <li>class atlas::serializer </li> <li>class atlas::system_registry </li> <li>class atlas::thread </li> <li>class atlas::timer </li> <li>class atlas::vk::descriptor_set </li> <li>class atlas::vk::imgui_context </li> <li>class atlas::vk::mesh mesh class specifically defined with vulkan implementations for specific primitives TODO: Whenever we load in a texture that will be laucnhed asyncronously </li> <li>class atlas::vk::texture </li> <li>class atlas::vk::vk_command_buffer Vulkan Command Buffers. </li> <li>class atlas::vk::vk_driver vulkan implementation of extracting a logical device </li> <li>class atlas::vk::vk_graphics_queue graphics queue mainly used for submitting to the graphics family specific queue </li> <li>class atlas::vk::vk_index_buffer </li> <li>class atlas::vk::vk_physical_driver </li> <li>class atlas::vk::vk_pipeline </li> <li>class atlas::vk::vk_present_queue Handles submissions to the specific queue for presentation. </li> <li>class atlas::vk::vk_renderpass defines a renderpass operation </li> <li>class atlas::vk::vk_shader_group </li> <li>class atlas::vk::vk_swapchain </li> <li>class atlas::vk::vk_uniform_buffer </li> <li>class atlas::vk::vk_vertex_buffer </li> <li>class atlas::window <ul> <li>class atlas::vk::vk_window </li> </ul> </li> <li>struct atlas::application_settings </li> <li>struct atlas::box_collider3d </li> <li>struct atlas::event::joystick_button </li> <li>struct atlas::event::joystick_info </li> <li>struct atlas::light TODO: Make this better (when we do lighting) </li> <li>struct atlas::material </li> <li>struct atlas::math_generic </li> <li>struct atlas::matrix2 </li> <li>struct atlas::matrix3 </li> <li>struct atlas::matrix4 </li> <li>struct atlas::physics::collider_body </li> <li>struct atlas::physics::collider_event This is a replacement for an event system to handle collider. It will be replaced by an event system once we have functional one up and running. </li> <li>struct atlas::physics::contact_event </li> <li>struct atlas::physics::jolt_config Used to keep global data for player access and use. Tells how physics bodies should act within a given scene by default. </li> <li>struct atlas::physics::jolt_settings This includes global configs for each scene and how the physics engine will behave in a paticular scene. </li> <li>struct atlas::physics::matrix4 </li> <li>struct atlas::physics::matrix4&lt; JPH::Mat44 &gt; </li> <li>struct atlas::physics::physics_body </li> <li>struct atlas::physics::quaternion </li> <li>struct atlas::physics::vector3 </li> <li>struct atlas::physics::vector3&lt; JPH::DVec3 &gt; </li> <li>struct atlas::physics::vector3&lt; JPH::Double3 &gt; </li> <li>struct atlas::physics::vector3&lt; JPH::Float3 &gt; </li> <li>struct atlas::physics::vector3&lt; JPH::Vec3 &gt; </li> <li>struct atlas::physics::vector4 </li> <li>struct atlas::physics::vector4&lt; JPH::Float4 &gt; </li> <li>struct atlas::physics::vector4&lt; JPH::Vec4 &gt; </li> <li>struct atlas::reload Actually might do a query for this along with rendertarget3d. </li> <li>struct atlas::rigidbody3d </li> <li>struct atlas::tag </li> <li>struct atlas::transform </li> <li>struct atlas::transform_physics </li> <li>struct atlas::vector2 </li> <li>struct atlas::vector2&lt; glm::highp_vec2 &gt; </li> <li>struct atlas::vector3 </li> <li>struct atlas::vector3&lt; JPH::Vec3 &gt; </li> <li>struct atlas::vector3&lt; glm::highp_vec3 &gt; </li> <li>struct atlas::vector4 </li> <li>struct atlas::vector4&lt; glm::highp_vec4 &gt; </li> <li>struct atlas::vk::camera_ubo Going to remove this. </li> <li>struct atlas::vk::command_buffer_settings settings for specifying command buffers to construct </li> <li>struct atlas::vk::descriptor_binding_entry </li> <li>struct atlas::vk::descriptor_binding_point </li> <li>struct atlas::vk::descriptor_set_layout </li> <li>struct atlas::vk::global_ubo Just for testing purposes for sending this struct over to the shader. </li> <li>struct atlas::vk::hud_data </li> <li>struct atlas::vk::image_extent </li> <li>struct atlas::vk::material_uniform material is going to define properties about how a scene object itself gets rendered </li> <li>struct atlas::vk::renderpass_attachment </li> <li>struct atlas::vk::renderpass_options </li> <li>struct atlas::vk::shader_info </li> <li>struct atlas::vk::surface_properties </li> <li>struct atlas::vk::texture_extent </li> <li>struct atlas::vk::texture_properties </li> <li>struct atlas::vk::vertex_attribute </li> <li>struct atlas::vk::vertex_attribute_entry </li> <li>struct atlas::vk::vertex_input </li> <li>struct atlas::vk::vk_buffer vulkan buffer struct to define the handlers and memory specifications required for buffer handlers in vulkan </li> <li>struct atlas::vk::vk_buffer_info Specifications of the vulkan buffer handlers and the use and memory bits associated with the buffer handlers. </li> <li>struct atlas::vk::vk_filter_range Range between min and max for the VkFilter. </li> <li>struct atlas::vk::vk_image vulkan image handler with resources; used when handling textures </li> <li>struct atlas::vk::vk_image_handle </li> <li>struct atlas::vk::vk_queue_options </li> <li>struct atlas::vk::vk_renderpass_options Renderpass specifictations for VkRenderpass. </li> <li>struct atlas::vk::vk_shader_module </li> <li>struct atlas::window_settings Specific settings to the window configuration. </li> <li>struct atlas::vk::vk_driver::device_queue_family </li> <li>struct atlas::vk::vk_physical_driver::queue_family_indices </li> <li>struct std::hash&lt; atlas::vk::vertex_input &gt; </li> <li>class JPH::BroadPhaseLayerInterface <ul> <li>class atlas::physics::broad_phase_layer_interface This class is made to control the broadphase layer. Filters can be added to it to create a better and more organized broadphase. Ass well as giving some control to the user on how the broadphase should be organized. This requires dynamic masking however, which is not currently running. </li> </ul> </li> <li>class JPH::ContactListener <ul> <li>class atlas::physics::contact_listener This is the glue between contact events and jolts contact listener. It takes the calls from jolt through virtual functions and allows users to create children for jolt collision. </li> </ul> </li> <li>class JPH::ObjectLayerPairFilter <ul> <li>class atlas::physics::object_layer_pair_filter This goes into more detailed ways of filtering, where the object collisions may be defined be what the other object is. In this case a static setup allows static object to trigger collision only when it is touched by a dynamic target. </li> </ul> </li> <li>class JPH::ObjectVsBroadPhaseLayerFilter <ul> <li>class atlas::physics::object_vs_broadphase_layer This is used to tell Jolt what can or cannot collide. As of right now the list is static therfore the layers do not need a dynamic set up. This will change when the object layers become user definable. </li> </ul> </li> <li>class std::enable_shared_from_this&lt; world_scope &gt; <ul> <li>class atlas::world_scope Lets rethink how world_scope gets created.</li> </ul> </li> </ul>"},{"location":"References/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"References/todo/","title":"Todo","text":"<p>Todo List</p>"},{"location":"References/todo/#member-atlasphysicsjolt_collision_managersubscribe_action-uint64_t-p_id-jolt_collision-p_collision_action","title":"Member atlas::physics::jolt_collision_manager::subscribe_action  (uint64_t p_id, jolt_collision &amp;p_collision_action)","text":"<p>We need to subscribe action. This might be fixed when we have events to take and subcribes their user actions with. Or this could be done like the other subscribes that exsist. </p>"},{"location":"References/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p> <ul> <li>Todo List </li> </ul>"},{"location":"References/class_members/","title":"Class Members","text":""},{"location":"References/class_members/#a","title":"a","text":"<ul> <li>application (atlas::application)</li> <li>aspect_ratio (atlas::application, atlas::window)</li> <li>AspectRatio (atlas::camera)</li> <li>add (atlas::entity_t, atlas::scene_object)</li> <li>AxesOfController (atlas::event::joystick_info)</li> <li>add_angular_velocity (atlas::physics::jolt_api, atlas::physics::physics_api)</li> <li>add_force (atlas::physics::jolt_api, atlas::physics::physics_api)</li> <li>add_linear_velocity (atlas::physics::jolt_api, atlas::physics::physics_api)</li> <li>add_body (atlas::physics::jolt_context)</li> <li>allocation_amount (atlas::physics::jolt_settings)</li> <li>add_angular_velocity_by_body (atlas::physics::physics_api)</li> <li>add_force_by_body (atlas::physics::physics_api)</li> <li>add_linear_velocity_by_body (atlas::physics::physics_api)</li> <li>angular_damping (atlas::physics::physics_body)</li> <li>angular_velocity (atlas::physics::physics_body)</li> <li>add_query (atlas::scene_object)</li> <li>append_world (atlas::system_registry)</li> <li>append_world_scope (atlas::system_registry)</li> <li>allocate_count (atlas::vk::descriptor_set_layout)</li> <li>add_texture (atlas::vk::mesh)</li> <li>allocation_size (atlas::vk::vk_buffer)</li> <li>acquired_frame (atlas::vk::vk_present_queue)</li> <li>attachments (atlas::vk::vk_renderpass_options)</li> <li>active_command_buffer (atlas::vk::vk_swapchain, atlas::window)</li> <li>active_framebuffer (atlas::vk::vk_swapchain)</li> <li>acquired_next_frame (atlas::window)</li> <li>available (atlas::window)</li> <li>add_scene (atlas::world_scope)</li> </ul>"},{"location":"References/class_members/#b","title":"b","text":"<ul> <li>box_collider3d (atlas::box_collider3d)</li> <li>ButtonState (atlas::event::joystick_button)</li> <li>Buttons (atlas::event::joystick_info)</li> <li>ButtonsDown (atlas::event::joystick_info)</li> <li>broad_phase_layer_interface (atlas::physics::broad_phase_layer_interface)</li> <li>body_id (atlas::physics::collider_body, atlas::physics::physics_body)</li> <li>broadphase_scale (atlas::physics::jolt_settings)</li> <li>body_layer_type (atlas::physics::physics_body)</li> <li>body_movement_type (atlas::physics::physics_body)</li> <li>body_type (atlas::physics::physics_body, atlas::rigidbody3d)</li> <li>background_color (atlas::render_context, atlas::vk::vk_renderer)</li> <li>begin_frame (atlas::render_context)</li> <li>begin (atlas::renderer, atlas::vk::imgui_context, atlas::vk::vk_command_buffer)</li> <li>body_at_runtime (atlas::rigidbody3d)</li> <li>binding_point (atlas::vk::descriptor_binding_entry)</li> <li>binding (atlas::vk::descriptor_binding_point, atlas::vk::vertex_attribute)</li> <li>bind (atlas::vk::descriptor_set, atlas::vk::vk_index_buffer, atlas::vk::vk_pipeline, atlas::vk::vk_vertex_buffer)</li> </ul>"},{"location":"References/class_members/#c","title":"c","text":"<ul> <li>current_api (atlas::application)</li> <li>current_frame (atlas::application)</li> <li>camera (atlas::camera)</li> <li>camera_mouse_sensitivity (atlas::camera)</li> <li>camera_movement_sensitivity (atlas::camera)</li> <li>camera_sensitivity (atlas::camera)</li> <li>create_new_logger (atlas::console_log_manager)</li> <li>color (atlas::material, atlas::vk::material_uniform, atlas::vk::vertex_input)</li> <li>capsule_half_height (atlas::physics::collider_body)</li> <li>collision_enabled (atlas::physics::collider_body)</li> <li>clear_events (atlas::physics::contact_listener)</li> <li>contact_listener (atlas::physics::contact_listener)</li> <li>collision_added (atlas::physics::jolt_collision)</li> <li>contact_bias_factor (atlas::physics::jolt_config)</li> <li>create_shape_from_collider (atlas::physics::jolt_context)</li> <li>collision_filter_layer_count (atlas::physics::jolt_settings)</li> <li>center_mass_position (atlas::physics::physics_body)</li> <li>count (atlas::physics::physics_body)</li> <li>cumulative_force (atlas::physics::physics_body)</li> <li>cumulative_torque (atlas::physics::physics_body)</li> <li>clean_bodies (atlas::physics::physics_context)</li> <li>contact_added_event (atlas::physics::physics_context)</li> <li>create_bodies (atlas::physics::physics_context)</li> <li>create_new_object (atlas::scene_scope)</li> <li>create_world (atlas::system_registry)</li> <li>current_time (atlas::timer)</li> <li>command_buffer_settings (atlas::vk::command_buffer_settings)</li> <li>currentWeapon (atlas::vk::hud_data)</li> <li>clear_values (atlas::vk::renderpass_options, atlas::vk::vk_renderpass_options)</li> <li>color_attachments (atlas::vk::renderpass_options)</li> <li>create (atlas::vk::texture, atlas::vk::vk_pipeline)</li> <li>configure (atlas::vk::vk_renderpass, atlas::vk::vk_swapchain)</li> <li>cache (atlas::vk::vk_renderpass_options)</li> <li>compile (atlas::vk::vk_shader_group)</li> <li>center_window (atlas::vk::vk_window)</li> <li>current_active_command_buffer (atlas::vk::vk_window, atlas::window)</li> <li>close (atlas::window)</li> <li>current_swapchain (atlas::window)</li> <li>compute_queue (atlas::vk::vk_driver::device_queue_family)</li> <li>compute (atlas::vk::vk_physical_driver::queue_family_indices)</li> </ul>"},{"location":"References/class_members/#d","title":"d","text":"<ul> <li>delta_time (atlas::application)</li> <li>destroy (atlas::application, atlas::graphics_context, atlas::vk::descriptor_set, atlas::vk::mesh, atlas::vk::texture, atlas::vk::vk_command_buffer, atlas::vk::vk_driver, atlas::vk::vk_graphics_queue, atlas::vk::vk_index_buffer, atlas::vk::vk_pipeline, atlas::vk::vk_present_queue, atlas::vk::vk_renderpass, atlas::vk::vk_shader_group, atlas::vk::vk_swapchain, atlas::vk::vk_uniform_buffer, atlas::vk::vk_vertex_buffer)</li> <li>density (atlas::box_collider3d)</li> <li>Down (atlas::camera)</li> <li>destroy_context (atlas::graphics_context, atlas::vk::vk_context)</li> <li>default_collision_group (atlas::physics::jolt_settings)</li> <li>default_filter_mask (atlas::physics::jolt_settings)</li> <li>dvec3 (atlas::physics::vector3&lt; JPH::DVec3 &gt;, atlas::physics::vector3&lt; JPH::Double3 &gt;)</li> <li>dispatch (atlas::thread)</li> <li>descriptor_count (atlas::vk::descriptor_binding_entry)</li> <li>descriptor_set (atlas::vk::descriptor_set)</li> <li>device_memory (atlas::vk::image_extent, atlas::vk::vk_buffer, atlas::vk::vk_image)</li> <li>draw_hud (atlas::vk::imgui_context)</li> <li>draw (atlas::vk::mesh, atlas::vk::vk_index_buffer, atlas::vk::vk_vertex_buffer)</li> <li>depth_attachments (atlas::vk::renderpass_options)</li> <li>data (atlas::vk::texture, atlas::vk::vk_shader_group, atlas::vk::vk_swapchain)</li> <li>device_size (atlas::vk::vk_buffer_info)</li> <li>driver_context (atlas::vk::vk_context)</li> <li>depth_format (atlas::vk::vk_driver)</li> <li>dependencies (atlas::vk::vk_renderpass_options)</li> </ul>"},{"location":"References/class_members/#e","title":"e","text":"<ul> <li>execute (atlas::application)</li> <li>EulerRotation (atlas::camera)</li> <li>entity_t (atlas::entity_t)</li> <li>entity (atlas::entity_t, atlas::scene_object)</li> <li>entity_a (atlas::physics::contact_event)</li> <li>entity_b (atlas::physics::contact_event)</li> <li>enable_collision_callbacks (atlas::physics::jolt_config)</li> <li>enable_constraints (atlas::physics::jolt_config)</li> <li>engine_clean_physics_bodies (atlas::physics::jolt_context, atlas::physics::physics_context)</li> <li>engine_create_physics_bodies (atlas::physics::jolt_context, atlas::physics::physics_context)</li> <li>engine_run_contact_added (atlas::physics::jolt_context, atlas::physics::physics_context)</li> <li>engine_run_physics_step (atlas::physics::jolt_context, atlas::physics::physics_context)</li> <li>end_frame (atlas::render_context)</li> <li>end (atlas::renderer, atlas::vk::imgui_context, atlas::vk::vk_command_buffer)</li> <li>elapsed (atlas::timer)</li> <li>entry (atlas::vk::descriptor_set_layout)</li> <li>entries (atlas::vk::vertex_attribute)</li> </ul>"},{"location":"References/class_members/#f","title":"f","text":"<ul> <li>friction (atlas::box_collider3d, atlas::physics::physics_body)</li> <li>friction_type (atlas::physics::jolt_config)</li> <li>fixed_time_step (atlas::physics::jolt_settings)</li> <li>fps (atlas::vk::hud_data)</li> <li>finalize (atlas::vk::renderpass_attachment)</li> <li>format (atlas::vk::renderpass_attachment, atlas::vk::texture_properties, atlas::vk::vertex_attribute_entry)</li> <li>family_index (atlas::vk::vk_queue_options)</li> <li>frames_in_flight (atlas::window_settings)</li> </ul>"},{"location":"References/class_members/#g","title":"g","text":"<ul> <li>get_current_swapchain (atlas::application)</li> <li>get_window (atlas::application)</li> <li>get_front (atlas::camera)</li> <li>get_projection (atlas::camera)</li> <li>get_view (atlas::camera)</li> <li>get (atlas::console_log_manager, atlas::entity_t, atlas::scene_object, atlas::world_scope)</li> <li>get_mut (atlas::entity_t, atlas::scene_object)</li> <li>GetBroadPhaseLayer (atlas::physics::broad_phase_layer_interface)</li> <li>GetNumBroadPhaseLayers (atlas::physics::broad_phase_layer_interface)</li> <li>gravity (atlas::physics::jolt_config)</li> <li>gravity_factor (atlas::physics::physics_body)</li> <li>get_tag (atlas::scene_scope, atlas::world_scope)</li> <li>get_world (atlas::system_registry)</li> <li>get_layout (atlas::vk::descriptor_set, atlas::vk::vk_pipeline)</li> <li>get_queue (atlas::vk::vk_driver)</li> <li>graphics_queue (atlas::vk::vk_driver, atlas::vk::vk_driver::device_queue_family)</li> <li>get_surface_properties (atlas::vk::vk_physical_driver)</li> <li>get_scene (atlas::world_scope)</li> <li>graphics (atlas::vk::vk_physical_driver::queue_family_indices)</li> </ul>"},{"location":"References/class_members/#h","title":"h","text":"<ul> <li>Height (atlas::application_settings)</li> <li>has (atlas::entity_t, atlas::scene_object)</li> <li>half_extents (atlas::physics::collider_body)</li> <li>hax_fixation (atlas::rigidbody3d)</li> <li>highp_vec2 (atlas::vector2&lt; glm::highp_vec2 &gt;)</li> <li>highp_vec3 (atlas::vector3&lt; glm::highp_vec3 &gt;)</li> <li>highp_vec4 (atlas::vector4&lt; glm::highp_vec4 &gt;)</li> <li>height (atlas::vk::image_extent, atlas::vk::texture, atlas::vk::texture_extent, atlas::vk::texture_properties, atlas::window, atlas::window_settings)</li> <li>handler (atlas::vk::vk_buffer, atlas::vk::vk_context)</li> </ul>"},{"location":"References/class_members/#i","title":"i","text":"<ul> <li>image_size (atlas::application, atlas::vk::vk_swapchain)</li> <li>IsMainCamera (atlas::camera)</li> <li>initialize_logger_manager (atlas::console_log_manager)</li> <li>is_alive (atlas::entity_t, atlas::vk::vk_present_queue)</li> <li>ID (atlas::event::joystick_button, atlas::event::joystick_info)</li> <li>interpolation (atlas::interpolation)</li> <li>id (atlas::physics::collider_event)</li> <li>initialize (atlas::physics::jolt_collision_manager)</li> <li>is_multithreaded (atlas::physics::jolt_settings)</li> <li>imgui_context (atlas::vk::imgui_context)</li> <li>initialize_uniforms (atlas::vk::mesh)</li> <li>initial (atlas::vk::renderpass_attachment)</li> <li>image (atlas::vk::texture, atlas::vk::vk_image, atlas::vk::vk_image_handle)</li> <li>image_view (atlas::vk::texture, atlas::vk::vk_image, atlas::vk::vk_image_handle)</li> <li>input_rate (atlas::vk::vertex_attribute)</li> <li>is_valid (atlas::vk::vk_command_buffer)</li> <li>immediate_submit_async (atlas::vk::vk_graphics_queue)</li> <li>immediate_submit_sync (atlas::vk::vk_graphics_queue)</li> </ul>"},{"location":"References/class_members/#j","title":"j","text":"<ul> <li>JoystickName (atlas::event::joystick_info)</li> <li>jolt_api (atlas::physics::jolt_api)</li> <li>jolt_collision (atlas::physics::jolt_collision)</li> <li>jolt_collision_manager (atlas::physics::jolt_collision_manager)</li> <li>jolt_context (atlas::physics::jolt_context)</li> <li>Join (atlas::thread)</li> <li>Joinable (atlas::thread)</li> </ul>"},{"location":"References/class_members/#l","title":"l","text":"<ul> <li>Left (atlas::camera)</li> <li>linear_interpolate (atlas::interpolation)</li> <li>linear_damping (atlas::physics::physics_body)</li> <li>linear_velocity (atlas::physics::physics_body)</li> <li>levels (atlas::vk::command_buffer_settings)</li> <li>load_gltf (atlas::vk::mesh)</li> <li>load_obj (atlas::vk::mesh)</li> <li>loaded (atlas::vk::mesh, atlas::vk::texture)</li> <li>layout (atlas::vk::renderpass_attachment, atlas::vk::vk_pipeline)</li> <li>load (atlas::vk::renderpass_attachment)</li> <li>location (atlas::vk::vertex_attribute_entry)</li> </ul>"},{"location":"References/class_members/#m","title":"m","text":"<ul> <li>m_current_frame_index (atlas::application)</li> <li>m_renderer (atlas::application)</li> <li>m_ui_context (atlas::application)</li> <li>m_window (atlas::application)</li> <li>MouseSensitivity (atlas::camera)</li> <li>MovementSpeed (atlas::camera)</li> <li>m_entity_id (atlas::entity_t)</li> <li>model_path (atlas::material)</li> <li>model_reload (atlas::material)</li> <li>mesh (atlas::mesh, atlas::vk::mesh)</li> <li>m_object_to_broadphase (atlas::physics::broad_phase_layer_interface)</li> <li>manifold (atlas::physics::contact_event)</li> <li>m_contacts_added (atlas::physics::contact_listener)</li> <li>m_contacts_persisted (atlas::physics::contact_listener)</li> <li>m_contacts_removed (atlas::physics::contact_listener)</li> <li>m_registry (atlas::physics::contact_listener, atlas::scene_scope)</li> <li>m_scene (atlas::physics::contact_listener)</li> <li>m_config (atlas::physics::jolt_api)</li> <li>m_physics_system (atlas::physics::jolt_api, atlas::physics::jolt_context)</li> <li>m_query_body (atlas::physics::jolt_api)</li> <li>m_query_transform (atlas::physics::jolt_api)</li> <li>m_read_body (atlas::physics::jolt_api)</li> <li>m_read_transform (atlas::physics::jolt_api)</li> <li>m_registery (atlas::physics::jolt_api)</li> <li>m_id (atlas::physics::jolt_collision)</li> <li>m_handlers (atlas::physics::jolt_collision_manager)</li> <li>m_tag (atlas::physics::jolt_collision_manager, atlas::scene_scope, atlas::system_registry, atlas::thread, atlas::world_scope)</li> <li>m_broad_phase_layer_interface (atlas::physics::jolt_context)</li> <li>m_contact_listener (atlas::physics::jolt_context)</li> <li>m_object_layer_pair_filter (atlas::physics::jolt_context)</li> <li>m_object_vs_broadphase_filter (atlas::physics::jolt_context)</li> <li>m_settings (atlas::physics::jolt_context, atlas::physics::physics_engine, atlas::vk::vk_window)</li> <li>m_shape_registry (atlas::physics::jolt_context)</li> <li>m_temp_allocator (atlas::physics::jolt_context)</li> <li>m_thread_system (atlas::physics::jolt_context)</li> <li>max_barriers (atlas::physics::jolt_settings)</li> <li>max_bodies (atlas::physics::jolt_settings)</li> <li>max_body_pairs (atlas::physics::jolt_settings)</li> <li>max_contact_constraints (atlas::physics::jolt_settings)</li> <li>max_jobs_power (atlas::physics::jolt_settings)</li> <li>m_value (atlas::physics::matrix4&lt; JPH::Mat44 &gt;, atlas::physics::vector3&lt; JPH::DVec3 &gt;, atlas::physics::vector3&lt; JPH::Double3 &gt;, atlas::physics::vector3&lt; JPH::Float3 &gt;, atlas::physics::vector3&lt; JPH::Vec3 &gt;, atlas::physics::vector4&lt; JPH::Float4 &gt;, atlas::physics::vector4&lt; JPH::Vec4 &gt;, atlas::vector2&lt; glm::highp_vec2 &gt;, atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;, atlas::vector3&lt; glm::highp_vec3 &gt;, atlas::vector4, atlas::vector4&lt; glm::highp_vec4 &gt;)</li> <li>matrix4 (atlas::physics::matrix4&lt; JPH::Mat44 &gt;)</li> <li>mat4 (atlas::physics::matrix4&lt; JPH::Mat44 &gt;)</li> <li>mass_factor (atlas::physics::physics_body)</li> <li>m_backend_api (atlas::physics::physics_engine)</li> <li>m_engine_api (atlas::physics::physics_engine)</li> <li>m_render_context (atlas::renderer)</li> <li>m_entity (atlas::scene_object)</li> <li>m_current_scene_ctx (atlas::serializer)</li> <li>m_world_registered (atlas::system_registry)</li> <li>m_thread (atlas::thread)</li> <li>m_stop_watch (atlas::timer)</li> <li>m_allocated_descriptors (atlas::vk::descriptor_set)</li> <li>m_descriptor_pool (atlas::vk::descriptor_set)</li> <li>m_descriptor_set_layout (atlas::vk::descriptor_set)</li> <li>m_descriptor_sets (atlas::vk::descriptor_set)</li> <li>m_driver (atlas::vk::descriptor_set, atlas::vk::imgui_context, atlas::vk::texture, atlas::vk::vk_command_buffer, atlas::vk::vk_context, atlas::vk::vk_driver, atlas::vk::vk_graphics_queue, atlas::vk::vk_index_buffer, atlas::vk::vk_pipeline, atlas::vk::vk_present_queue, atlas::vk::vk_renderpass, atlas::vk::vk_shader_group, atlas::vk::vk_swapchain, atlas::vk::vk_uniform_buffer, atlas::vk::vk_vertex_buffer)</li> <li>m_error_texture (atlas::vk::descriptor_set)</li> <li>m_set_slot (atlas::vk::descriptor_set)</li> <li>m_size_bytes (atlas::vk::descriptor_set, atlas::vk::vk_uniform_buffer)</li> <li>max_sets (atlas::vk::descriptor_set_layout)</li> <li>mvp (atlas::vk::global_ubo)</li> <li>mip_level (atlas::vk::image_extent)</li> <li>m_current_command (atlas::vk::imgui_context)</li> <li>m_current_swapchain_handler (atlas::vk::imgui_context)</li> <li>m_desc_pool (atlas::vk::imgui_context)</li> <li>m_instance (atlas::vk::imgui_context)</li> <li>m_physical (atlas::vk::imgui_context, atlas::vk::vk_context, atlas::vk::vk_driver, atlas::vk::vk_graphics_queue, atlas::vk::vk_swapchain)</li> <li>model (atlas::vk::material_uniform)</li> <li>m_geoemtry_ubo (atlas::vk::mesh)</li> <li>m_ibo (atlas::vk::mesh)</li> <li>m_model_loaded (atlas::vk::mesh)</li> <li>m_textures (atlas::vk::mesh)</li> <li>m_vbo (atlas::vk::mesh)</li> <li>material_ubo (atlas::vk::mesh)</li> <li>m_height (atlas::vk::texture)</li> <li>m_is_image_loaded (atlas::vk::texture)</li> <li>m_texture_image (atlas::vk::texture)</li> <li>m_width (atlas::vk::texture)</li> <li>memory_property_flag (atlas::vk::vk_buffer_info)</li> <li>m_begin_end_count (atlas::vk::vk_command_buffer)</li> <li>m_command_buffer_handler (atlas::vk::vk_command_buffer)</li> <li>m_command_pool (atlas::vk::vk_command_buffer)</li> <li>m_instance_handler (atlas::vk::vk_context, atlas::vk::vk_window)</li> <li>m_resources_free (atlas::vk::vk_context)</li> <li>m_depth_format_selected (atlas::vk::vk_driver)</li> <li>m_device_queues (atlas::vk::vk_driver)</li> <li>max (atlas::vk::vk_filter_range)</li> <li>min (atlas::vk::vk_filter_range)</li> <li>m_graphics_queue_handler (atlas::vk::vk_graphics_queue)</li> <li>m_present_completed_semaphore (atlas::vk::vk_graphics_queue, atlas::vk::vk_present_queue)</li> <li>m_render_completed_semaphore (atlas::vk::vk_graphics_queue, atlas::vk::vk_present_queue)</li> <li>m_index_buffer_handler (atlas::vk::vk_index_buffer)</li> <li>m_indices_count (atlas::vk::vk_index_buffer)</li> <li>m_physical_driver (atlas::vk::vk_physical_driver)</li> <li>m_queue_family_properties (atlas::vk::vk_physical_driver)</li> <li>m_queue_indices (atlas::vk::vk_physical_driver)</li> <li>m_surface_properties (atlas::vk::vk_physical_driver, atlas::vk::vk_swapchain)</li> <li>m_descriptor_layouts (atlas::vk::vk_pipeline)</li> <li>m_pipeline_handler (atlas::vk::vk_pipeline)</li> <li>m_pipeline_layout (atlas::vk::vk_pipeline)</li> <li>m_shader_group (atlas::vk::vk_pipeline, atlas::vk::vk_renderer)</li> <li>m_present_queue_handler (atlas::vk::vk_present_queue)</li> <li>m_resize_requested (atlas::vk::vk_present_queue)</li> <li>m_swapchain_handler (atlas::vk::vk_present_queue, atlas::vk::vk_swapchain)</li> <li>m_begin_initialize (atlas::vk::vk_renderer)</li> <li>m_cached_meshes (atlas::vk::vk_renderer)</li> <li>m_camera (atlas::vk::vk_renderer)</li> <li>m_color (atlas::vk::vk_renderer)</li> <li>m_current_command_buffer (atlas::vk::vk_renderer)</li> <li>m_current_frame (atlas::vk::vk_renderer)</li> <li>m_geometry_descriptor_layout (atlas::vk::vk_renderer)</li> <li>m_global_descriptor (atlas::vk::vk_renderer)</li> <li>m_global_uniforms (atlas::vk::vk_renderer)</li> <li>m_image_count (atlas::vk::vk_renderer)</li> <li>m_main_pipeline (atlas::vk::vk_renderer)</li> <li>m_main_swapchain (atlas::vk::vk_renderer)</li> <li>m_material_descriptor_layout (atlas::vk::vk_renderer)</li> <li>m_mesh_descriptors (atlas::vk::vk_renderer)</li> <li>m_model (atlas::vk::vk_renderer)</li> <li>m_renderpass_handler (atlas::vk::vk_renderpass)</li> <li>m_renderpass_options (atlas::vk::vk_renderpass)</li> <li>m_shader_modules (atlas::vk::vk_shader_group)</li> <li>m_shader_sources (atlas::vk::vk_shader_group)</li> <li>m_vertex_attributes (atlas::vk::vk_shader_group)</li> <li>m_vertex_binding_attributes (atlas::vk::vk_shader_group)</li> <li>module_handler (atlas::vk::vk_shader_module)</li> <li>m_color_renderpass (atlas::vk::vk_swapchain)</li> <li>m_current_surface (atlas::vk::vk_swapchain)</li> <li>m_current_surface_handler (atlas::vk::vk_swapchain)</li> <li>m_image_size (atlas::vk::vk_swapchain)</li> <li>m_present_to_queue (atlas::vk::vk_swapchain)</li> <li>m_swapchain_command_buffers (atlas::vk::vk_swapchain)</li> <li>m_swapchain_depth_images (atlas::vk::vk_swapchain)</li> <li>m_swapchain_extent (atlas::vk::vk_swapchain)</li> <li>m_swapchain_framebuffers (atlas::vk::vk_swapchain)</li> <li>m_swapchain_images (atlas::vk::vk_swapchain)</li> <li>m_swapchain_main_renderpass (atlas::vk::vk_swapchain)</li> <li>m_window_settings (atlas::vk::vk_swapchain)</li> <li>m_uniform_buffer_data (atlas::vk::vk_uniform_buffer)</li> <li>m_vertex_handler (atlas::vk::vk_vertex_buffer)</li> <li>m_vertices_byte_size_count (atlas::vk::vk_vertex_buffer)</li> <li>m_vertices_count (atlas::vk::vk_vertex_buffer)</li> <li>m_swapchain (atlas::vk::vk_window)</li> <li>m_window_handler (atlas::vk::vk_window)</li> <li>m_window_surface (atlas::vk::vk_window)</li> <li>m_scene_container (atlas::world_scope)</li> <li>m_scene_registry (atlas::world_scope)</li> <li>m_world_shared_instance (atlas::world_scope)</li> </ul>"},{"location":"References/class_members/#n","title":"n","text":"<ul> <li>Name (atlas::application_settings, atlas::event::joystick_button)</li> <li>normals (atlas::vk::vertex_input)</li> <li>native_window (atlas::vk::vk_window, atlas::window)</li> <li>name (atlas::window_settings)</li> </ul>"},{"location":"References/class_members/#o","title":"o","text":"<ul> <li>offset (atlas::box_collider3d)</li> <li>on_destruction (atlas::entity_t)</li> <li>OnContactAdded (atlas::physics::contact_listener)</li> <li>OnContactPersisted (atlas::physics::contact_listener)</li> <li>OnContactRemoved (atlas::physics::contact_listener)</li> <li>OnContactValidate (atlas::physics::contact_listener)</li> <li>on_collision_added (atlas::physics::jolt_collision)</li> <li>operator= (atlas::physics::matrix4&lt; JPH::Mat44 &gt;, atlas::physics::vector3&lt; JPH::DVec3 &gt;, atlas::physics::vector3&lt; JPH::Double3 &gt;, atlas::physics::vector3&lt; JPH::Float3 &gt;, atlas::physics::vector3&lt; JPH::Vec3 &gt;, atlas::physics::vector4&lt; JPH::Float4 &gt;, atlas::physics::vector4&lt; JPH::Vec4 &gt;, atlas::vector2&lt; glm::highp_vec2 &gt;, atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;, atlas::vector3&lt; glm::highp_vec3 &gt;, atlas::vector4, atlas::vector4&lt; glm::highp_vec4 &gt;)</li> <li>operator== (atlas::physics::matrix4&lt; JPH::Mat44 &gt;, atlas::physics::vector3&lt; JPH::DVec3 &gt;, atlas::physics::vector3&lt; JPH::Double3 &gt;, atlas::physics::vector3&lt; JPH::Float3 &gt;, atlas::physics::vector3&lt; JPH::Vec3 &gt;, atlas::physics::vector4&lt; JPH::Float4 &gt;, atlas::physics::vector4&lt; JPH::Vec4 &gt;, atlas::vector2&lt; glm::highp_vec2 &gt;, atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;, atlas::vector3&lt; glm::highp_vec3 &gt;, atlas::vector4, atlas::vector4&lt; glm::highp_vec4 &gt;, atlas::vk::vertex_input)</li> <li>on_reload (atlas::reload)</li> <li>on_texture_reload (atlas::reload)</li> <li>operator VkCommandBuffer (atlas::vk::vk_command_buffer)</li> <li>operator VkDevice (atlas::vk::vk_driver)</li> <li>operator VkQueue (atlas::vk::vk_graphics_queue, atlas::vk::vk_present_queue)</li> <li>operator VkPhysicalDevice (atlas::vk::vk_physical_driver)</li> <li>operator VkPipeline (atlas::vk::vk_pipeline)</li> <li>operator VkRenderPass (atlas::vk::vk_renderpass)</li> <li>on_create (atlas::vk::vk_swapchain)</li> <li>operator VkSwapchainKHR (atlas::vk::vk_swapchain)</li> <li>operator VkBuffer (atlas::vk::vk_uniform_buffer, atlas::vk::vk_vertex_buffer)</li> <li>operator GLFWwindow * (atlas::window)</li> <li>operator() (std::hash&lt; atlas::vk::vertex_input &gt;)</li> </ul>"},{"location":"References/class_members/#p","title":"p","text":"<ul> <li>physics_step (atlas::application, atlas::physics::physics_engine)</li> <li>post_destroy (atlas::application)</li> <li>Position (atlas::camera, atlas::light, atlas::transform)</li> <li>Projection (atlas::camera)</li> <li>process_keyboard (atlas::camera)</li> <li>process_mouse_movement (atlas::camera)</li> <li>process_mouse_scroll (atlas::camera)</li> <li>PreviousButtonState (atlas::event::joystick_button)</li> <li>physics_scene_position (atlas::physics::jolt_settings)</li> <li>physics_threads (atlas::physics::jolt_settings)</li> <li>position_iterations (atlas::physics::jolt_settings)</li> <li>physics_engine (atlas::physics::physics_engine)</li> <li>post_frame (atlas::render_context, atlas::vk::vk_renderer)</li> <li>position (atlas::transform_physics, atlas::vk::vertex_input)</li> <li>projection (atlas::vk::camera_ubo)</li> <li>pool_flag (atlas::vk::command_buffer_settings)</li> <li>playerHealth (atlas::vk::hud_data)</li> <li>playerScore (atlas::vk::hud_data)</li> <li>property (atlas::vk::texture_properties)</li> <li>physical_driver (atlas::vk::vk_context)</li> <li>present_frame (atlas::vk::vk_present_queue)</li> <li>present (atlas::vk::vk_swapchain, atlas::window)</li> <li>presentation_process (atlas::vk::vk_window, atlas::window)</li> </ul>"},{"location":"References/class_members/#q","title":"q","text":"<ul> <li>query_builder (atlas::scene_scope)</li> <li>QuaternionRotation (atlas::transform)</li> <li>quaterion_rotation (atlas::transform_physics)</li> <li>queue_index (atlas::vk::command_buffer_settings, atlas::vk::vk_queue_options)</li> </ul>"},{"location":"References/class_members/#r","title":"r","text":"<ul> <li>restitution (atlas::box_collider3d, atlas::physics::physics_body)</li> <li>restitutionThreshold (atlas::box_collider3d)</li> <li>Right (atlas::camera)</li> <li>remove (atlas::entity_t, atlas::scene_object)</li> <li>radius (atlas::physics::collider_body)</li> <li>run_events_added (atlas::physics::contact_listener)</li> <li>run_events_persisted (atlas::physics::contact_listener)</li> <li>run_events_removed (atlas::physics::contact_listener)</li> <li>retrieve_values (atlas::physics::jolt_api, atlas::physics::physics_api)</li> <li>return_values (atlas::physics::jolt_api, atlas::physics::physics_api)</li> <li>run_collision_added (atlas::physics::jolt_collision_manager)</li> <li>restitution_threshold (atlas::physics::jolt_config)</li> <li>restitution_type (atlas::physics::jolt_config)</li> <li>run_physics_step (atlas::physics::physics_context)</li> <li>run_contact_add (atlas::physics::physics_engine)</li> <li>renderer (atlas::renderer)</li> <li>rigidbody3d (atlas::rigidbody3d)</li> <li>reset (atlas::timer)</li> <li>Rotation (atlas::transform)</li> <li>rotation (atlas::transform_physics)</li> <li>recreate (atlas::vk::imgui_context, atlas::vk::vk_swapchain)</li> <li>read_textures (atlas::vk::mesh)</li> <li>reload_mesh (atlas::vk::mesh)</li> <li>resource_free (atlas::vk::vk_context)</li> <li>read_presentation_index (atlas::vk::vk_physical_driver)</li> <li>read_queue_family_indices (atlas::vk::vk_physical_driver)</li> <li>resize_requested (atlas::vk::vk_present_queue)</li> <li>read_acquired_image (atlas::vk::vk_swapchain)</li> <li>read_acquired_next_frame (atlas::vk::vk_window, atlas::window)</li> </ul>"},{"location":"References/class_members/#s","title":"s","text":"<ul> <li>s_instance (atlas::application, atlas::renderer, atlas::system_registry, atlas::vk::vk_context, atlas::vk::vk_driver, atlas::vk::vk_physical_driver, atlas::vk::vk_window)</li> <li>set_current_api (atlas::application)</li> <li>size (atlas::box_collider3d, atlas::vk::vk_index_buffer, atlas::vk::vk_shader_group, atlas::vk::vk_vertex_buffer)</li> <li>set_mouse_speed (atlas::camera)</li> <li>set_movement_speed (atlas::camera)</li> <li>s_loggers (atlas::console_log_manager)</li> <li>set_current_logger (atlas::console_log_manager)</li> <li>set (atlas::entity_t, atlas::scene_object)</li> <li>shape_type (atlas::physics::collider_body)</li> <li>settings (atlas::physics::contact_event, atlas::vk::vk_swapchain, atlas::vk::vk_window, atlas::window)</li> <li>set_angular_velocity (atlas::physics::jolt_api, atlas::physics::physics_api)</li> <li>set_linear_velocity (atlas::physics::jolt_api, atlas::physics::physics_api)</li> <li>subscribe_action (atlas::physics::jolt_collision_manager)</li> <li>store_shape (atlas::physics::jolt_context)</li> <li>sleep_angular_velocity_threshold (atlas::physics::jolt_settings)</li> <li>sleep_velocity_threshold (atlas::physics::jolt_settings)</li> <li>ShouldCollide (atlas::physics::object_layer_pair_filter, atlas::physics::object_vs_broadphase_layer)</li> <li>set_angular_velocity_by_body (atlas::physics::physics_api)</li> <li>set_linear_velocity_by_body (atlas::physics::physics_api)</li> <li>start_runtime (atlas::physics::physics_engine)</li> <li>stop_runtime (atlas::physics::physics_engine)</li> <li>set_background_color (atlas::render_context, atlas::renderer)</li> <li>start_frame (atlas::render_context, atlas::vk::vk_renderer)</li> <li>scene_object (atlas::scene_object)</li> <li>scene_scope (atlas::scene_scope)</li> <li>save_as (atlas::serializer)</li> <li>serializer (atlas::serializer)</li> <li>search_world (atlas::system_registry)</li> <li>system_registry (atlas::system_registry)</li> <li>seconds (atlas::timer)</li> <li>Scale (atlas::transform)</li> <li>scale (atlas::transform_physics)</li> <li>stage (atlas::vk::descriptor_binding_point, atlas::vk::shader_info, atlas::vk::vk_shader_module)</li> <li>size_bytes (atlas::vk::descriptor_set_layout, atlas::vk::vk_uniform_buffer, atlas::vk::vk_vertex_buffer)</li> <li>sample_count (atlas::vk::renderpass_attachment)</li> <li>stencil_load (atlas::vk::renderpass_attachment)</li> <li>stencil_store (atlas::vk::renderpass_attachment)</li> <li>store (atlas::vk::renderpass_attachment)</li> <li>source (atlas::vk::shader_info)</li> <li>surface_capabilities (atlas::vk::surface_properties)</li> <li>surface_format (atlas::vk::surface_properties)</li> <li>sampler (atlas::vk::texture, atlas::vk::vk_image)</li> <li>stride (atlas::vk::vertex_attribute, atlas::vk::vertex_attribute_entry)</li> <li>submit_resource_free (atlas::vk::vk_context)</li> <li>select_memory_type (atlas::vk::vk_driver)</li> <li>select_queue_family_indices (atlas::vk::vk_physical_driver)</li> <li>set_resize_status (atlas::vk::vk_present_queue)</li> <li>submit_immediate_async (atlas::vk::vk_present_queue)</li> <li>submit_immediate_sync (atlas::vk::vk_present_queue)</li> <li>subpass_descriptions (atlas::vk::vk_renderpass_options)</li> <li>set_vertex_attributes (atlas::vk::vk_shader_group)</li> <li>set_vertex_bind_attributes (atlas::vk::vk_shader_group)</li> <li>submit (atlas::vk::vk_swapchain)</li> <li>swapchain_renderpass (atlas::vk::vk_swapchain)</li> </ul>"},{"location":"References/class_members/#t","title":"t","text":"<ul> <li>texture_filepaths (atlas::material)</li> <li>texture_path (atlas::material)</li> <li>texture_reload (atlas::material)</li> <li>time_before_sleep (atlas::physics::jolt_config)</li> <li>thread_type (atlas::physics::jolt_settings)</li> <li>type (atlas::rigidbody3d, atlas::vk::descriptor_binding_entry, atlas::vk::renderpass_attachment)</li> <li>TagMetadata (atlas::tag)</li> <li>thread (atlas::thread)</li> <li>timer (atlas::timer)</li> <li>texture (atlas::vk::texture)</li> <li>transfer_queue (atlas::vk::vk_driver::device_queue_family)</li> <li>transfer (atlas::vk::vk_physical_driver::queue_family_indices)</li> </ul>"},{"location":"References/class_members/#u","title":"u","text":"<ul> <li>Up (atlas::camera)</li> <li>update_camera (atlas::camera)</li> <li>update_proj_view (atlas::camera)</li> <li>use_4_layer_broadphase (atlas::physics::jolt_settings)</li> <li>use_fixed_timestep (atlas::physics::jolt_settings)</li> <li>update_atlas_values (atlas::physics::physics_api)</li> <li>update_jolt_values (atlas::physics::physics_api)</li> <li>use_gravity (atlas::physics::physics_body)</li> <li>update (atlas::vk::descriptor_set, atlas::vk::vk_uniform_buffer)</li> <li>update_uniform (atlas::vk::mesh)</li> <li>usage (atlas::vk::texture_properties, atlas::vk::vk_buffer_info)</li> <li>uv (atlas::vk::vertex_input)</li> </ul>"},{"location":"References/class_members/#v","title":"v","text":"<ul> <li>View (atlas::camera)</li> <li>velocity_iterations (atlas::physics::jolt_settings)</li> <li>vector3 (atlas::physics::vector3&lt; JPH::DVec3 &gt;, atlas::physics::vector3&lt; JPH::Double3 &gt;, atlas::physics::vector3&lt; JPH::Float3 &gt;, atlas::physics::vector3&lt; JPH::Vec3 &gt;, atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;, atlas::vector3&lt; glm::highp_vec3 &gt;)</li> <li>vec3 (atlas::physics::vector3&lt; JPH::Float3 &gt;, atlas::physics::vector3&lt; JPH::Vec3 &gt;, atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;)</li> <li>vec4 (atlas::physics::vector4&lt; JPH::Float4 &gt;, atlas::physics::vector4&lt; JPH::Vec4 &gt;, atlas::vector4)</li> <li>vector4 (atlas::physics::vector4&lt; JPH::Float4 &gt;, atlas::physics::vector4&lt; JPH::Vec4 &gt;, atlas::vector4, atlas::vector4&lt; glm::highp_vec4 &gt;)</li> <li>vector2 (atlas::vector2&lt; glm::highp_vec2 &gt;)</li> <li>view (atlas::vk::camera_ubo)</li> <li>vk_command_buffer (atlas::vk::vk_command_buffer)</li> <li>vk_context (atlas::vk::vk_context)</li> <li>vk_driver (atlas::vk::vk_driver)</li> <li>vk_graphics_queue (atlas::vk::vk_graphics_queue)</li> <li>vk_index_buffer (atlas::vk::vk_index_buffer)</li> <li>vk_physical_driver (atlas::vk::vk_physical_driver)</li> <li>vk_pipeline (atlas::vk::vk_pipeline)</li> <li>vk_present_queue (atlas::vk::vk_present_queue)</li> <li>vk_renderer (atlas::vk::vk_renderer)</li> <li>vk_renderpass (atlas::vk::vk_renderpass)</li> <li>vertex_attributes (atlas::vk::vk_shader_group)</li> <li>vertex_bind_attributes (atlas::vk::vk_shader_group)</li> <li>vk_shader_group (atlas::vk::vk_shader_group)</li> <li>vk_swapchain (atlas::vk::vk_swapchain)</li> <li>vk_uniform_buffer (atlas::vk::vk_uniform_buffer)</li> <li>vk_vertex_buffer (atlas::vk::vk_vertex_buffer)</li> <li>vk_window (atlas::vk::vk_window)</li> </ul>"},{"location":"References/class_members/#w","title":"w","text":"<ul> <li>Width (atlas::application_settings)</li> <li>WorldUp (atlas::camera)</li> <li>world_unit_scale (atlas::physics::jolt_config)</li> <li>world_bounds_max (atlas::physics::jolt_settings)</li> <li>world_bounds_min (atlas::physics::jolt_settings)</li> <li>world (atlas::scene_scope)</li> <li>width (atlas::vk::image_extent, atlas::vk::texture, atlas::vk::texture_extent, atlas::vk::texture_properties, atlas::window, atlas::window_settings)</li> <li>wait_idle (atlas::vk::vk_graphics_queue, atlas::vk::vk_present_queue)</li> <li>window_swapchain (atlas::vk::vk_window, atlas::window)</li> <li>world &amp; (atlas::world_scope)</li> <li>world_scope (atlas::world_scope)</li> </ul>"},{"location":"References/class_members/#z","title":"z","text":"<ul> <li>Zoom (atlas::camera)</li> </ul>"},{"location":"References/class_members/#_1","title":"~","text":"<ul> <li>~application (atlas::application)</li> <li>~entity_t (atlas::entity_t)</li> <li>~graphics_context (atlas::graphics_context)</li> <li>~jolt_context (atlas::physics::jolt_context)</li> <li>~physics_api (atlas::physics::physics_api)</li> <li>~physics_context (atlas::physics::physics_context)</li> <li>~render_context (atlas::render_context)</li> <li>~scene_object (atlas::scene_object)</li> <li>~scene_scope (atlas::scene_scope)</li> <li>~system_registry (atlas::system_registry)</li> <li>~thread (atlas::thread)</li> <li>~descriptor_set (atlas::vk::descriptor_set)</li> <li>~vk_driver (atlas::vk::vk_driver)</li> <li>~vk_physical_driver (atlas::vk::vk_physical_driver)</li> <li>~vk_renderer (atlas::vk::vk_renderer)</li> <li>~vk_vertex_buffer (atlas::vk::vk_vertex_buffer)</li> <li>~vk_window (atlas::vk::vk_window)</li> <li>~window (atlas::window)</li> <li>~world_scope (atlas::world_scope)</li> </ul>"},{"location":"References/class_member_functions/","title":"Class Member Functions","text":""},{"location":"References/class_member_functions/#a","title":"a","text":"<ul> <li>application (atlas::application)</li> <li>aspect_ratio (atlas::application, atlas::window)</li> <li>add (atlas::entity_t, atlas::scene_object)</li> <li>add_angular_velocity (atlas::physics::jolt_api, atlas::physics::physics_api)</li> <li>add_force (atlas::physics::jolt_api, atlas::physics::physics_api)</li> <li>add_linear_velocity (atlas::physics::jolt_api, atlas::physics::physics_api)</li> <li>add_body (atlas::physics::jolt_context)</li> <li>add_angular_velocity_by_body (atlas::physics::physics_api)</li> <li>add_force_by_body (atlas::physics::physics_api)</li> <li>add_linear_velocity_by_body (atlas::physics::physics_api)</li> <li>add_query (atlas::scene_object)</li> <li>append_world (atlas::system_registry)</li> <li>append_world_scope (atlas::system_registry)</li> <li>add_texture (atlas::vk::mesh)</li> <li>acquired_frame (atlas::vk::vk_present_queue)</li> <li>active_command_buffer (atlas::vk::vk_swapchain, atlas::window)</li> <li>active_framebuffer (atlas::vk::vk_swapchain)</li> <li>acquired_next_frame (atlas::window)</li> <li>available (atlas::window)</li> <li>add_scene (atlas::world_scope)</li> </ul>"},{"location":"References/class_member_functions/#b","title":"b","text":"<ul> <li>box_collider3d (atlas::box_collider3d)</li> <li>broad_phase_layer_interface (atlas::physics::broad_phase_layer_interface)</li> <li>background_color (atlas::render_context, atlas::vk::vk_renderer)</li> <li>begin_frame (atlas::render_context)</li> <li>begin (atlas::renderer, atlas::vk::imgui_context, atlas::vk::vk_command_buffer)</li> <li>bind (atlas::vk::descriptor_set, atlas::vk::vk_index_buffer, atlas::vk::vk_pipeline, atlas::vk::vk_vertex_buffer)</li> </ul>"},{"location":"References/class_member_functions/#c","title":"c","text":"<ul> <li>current_api (atlas::application)</li> <li>current_frame (atlas::application)</li> <li>camera (atlas::camera)</li> <li>camera_sensitivity (atlas::camera)</li> <li>create_new_logger (atlas::console_log_manager)</li> <li>clear_events (atlas::physics::contact_listener)</li> <li>contact_listener (atlas::physics::contact_listener)</li> <li>collision_added (atlas::physics::jolt_collision)</li> <li>create_shape_from_collider (atlas::physics::jolt_context)</li> <li>clean_bodies (atlas::physics::physics_context)</li> <li>contact_added_event (atlas::physics::physics_context)</li> <li>create_bodies (atlas::physics::physics_context)</li> <li>create_new_object (atlas::scene_scope)</li> <li>create_world (atlas::system_registry)</li> <li>current_time (atlas::timer)</li> <li>command_buffer_settings (atlas::vk::command_buffer_settings)</li> <li>create (atlas::vk::texture, atlas::vk::vk_pipeline)</li> <li>configure (atlas::vk::vk_renderpass, atlas::vk::vk_swapchain)</li> <li>compile (atlas::vk::vk_shader_group)</li> <li>center_window (atlas::vk::vk_window)</li> <li>current_active_command_buffer (atlas::vk::vk_window, atlas::window)</li> <li>close (atlas::window)</li> <li>current_swapchain (atlas::window)</li> </ul>"},{"location":"References/class_member_functions/#d","title":"d","text":"<ul> <li>delta_time (atlas::application)</li> <li>destroy (atlas::application, atlas::graphics_context, atlas::vk::descriptor_set, atlas::vk::mesh, atlas::vk::texture, atlas::vk::vk_command_buffer, atlas::vk::vk_driver, atlas::vk::vk_graphics_queue, atlas::vk::vk_index_buffer, atlas::vk::vk_pipeline, atlas::vk::vk_present_queue, atlas::vk::vk_renderpass, atlas::vk::vk_shader_group, atlas::vk::vk_swapchain, atlas::vk::vk_uniform_buffer, atlas::vk::vk_vertex_buffer)</li> <li>destroy_context (atlas::graphics_context, atlas::vk::vk_context)</li> <li>dvec3 (atlas::physics::vector3&lt; JPH::DVec3 &gt;, atlas::physics::vector3&lt; JPH::Double3 &gt;)</li> <li>dispatch (atlas::thread)</li> <li>descriptor_set (atlas::vk::descriptor_set)</li> <li>draw_hud (atlas::vk::imgui_context)</li> <li>draw (atlas::vk::mesh, atlas::vk::vk_index_buffer, atlas::vk::vk_vertex_buffer)</li> <li>data (atlas::vk::texture, atlas::vk::vk_shader_group, atlas::vk::vk_swapchain)</li> <li>driver_context (atlas::vk::vk_context)</li> <li>depth_format (atlas::vk::vk_driver)</li> </ul>"},{"location":"References/class_member_functions/#e","title":"e","text":"<ul> <li>execute (atlas::application)</li> <li>entity_t (atlas::entity_t)</li> <li>entity (atlas::entity_t, atlas::scene_object)</li> <li>engine_clean_physics_bodies (atlas::physics::jolt_context, atlas::physics::physics_context)</li> <li>engine_create_physics_bodies (atlas::physics::jolt_context, atlas::physics::physics_context)</li> <li>engine_run_contact_added (atlas::physics::jolt_context, atlas::physics::physics_context)</li> <li>engine_run_physics_step (atlas::physics::jolt_context, atlas::physics::physics_context)</li> <li>end_frame (atlas::render_context)</li> <li>end (atlas::renderer, atlas::vk::imgui_context, atlas::vk::vk_command_buffer)</li> <li>elapsed (atlas::timer)</li> </ul>"},{"location":"References/class_member_functions/#g","title":"g","text":"<ul> <li>get_current_swapchain (atlas::application)</li> <li>get_window (atlas::application)</li> <li>get_front (atlas::camera)</li> <li>get_projection (atlas::camera)</li> <li>get_view (atlas::camera)</li> <li>get (atlas::console_log_manager, atlas::entity_t, atlas::scene_object, atlas::world_scope)</li> <li>get_mut (atlas::entity_t, atlas::scene_object)</li> <li>GetBroadPhaseLayer (atlas::physics::broad_phase_layer_interface)</li> <li>GetNumBroadPhaseLayers (atlas::physics::broad_phase_layer_interface)</li> <li>get_tag (atlas::scene_scope, atlas::world_scope)</li> <li>get_world (atlas::system_registry)</li> <li>get_layout (atlas::vk::descriptor_set, atlas::vk::vk_pipeline)</li> <li>get_queue (atlas::vk::vk_driver)</li> <li>graphics_queue (atlas::vk::vk_driver)</li> <li>get_surface_properties (atlas::vk::vk_physical_driver)</li> <li>get_scene (atlas::world_scope)</li> </ul>"},{"location":"References/class_member_functions/#h","title":"h","text":"<ul> <li>has (atlas::entity_t, atlas::scene_object)</li> <li>highp_vec2 (atlas::vector2&lt; glm::highp_vec2 &gt;)</li> <li>highp_vec3 (atlas::vector3&lt; glm::highp_vec3 &gt;)</li> <li>highp_vec4 (atlas::vector4&lt; glm::highp_vec4 &gt;)</li> <li>height (atlas::vk::texture, atlas::window)</li> <li>handler (atlas::vk::vk_context)</li> </ul>"},{"location":"References/class_member_functions/#i","title":"i","text":"<ul> <li>image_size (atlas::application, atlas::vk::vk_swapchain)</li> <li>initialize_logger_manager (atlas::console_log_manager)</li> <li>is_alive (atlas::entity_t, atlas::vk::vk_present_queue)</li> <li>interpolation (atlas::interpolation)</li> <li>initialize (atlas::physics::jolt_collision_manager)</li> <li>imgui_context (atlas::vk::imgui_context)</li> <li>initialize_uniforms (atlas::vk::mesh)</li> <li>image (atlas::vk::texture)</li> <li>image_view (atlas::vk::texture)</li> <li>is_valid (atlas::vk::vk_command_buffer)</li> <li>immediate_submit_async (atlas::vk::vk_graphics_queue)</li> <li>immediate_submit_sync (atlas::vk::vk_graphics_queue)</li> </ul>"},{"location":"References/class_member_functions/#j","title":"j","text":"<ul> <li>jolt_api (atlas::physics::jolt_api)</li> <li>jolt_collision (atlas::physics::jolt_collision)</li> <li>jolt_collision_manager (atlas::physics::jolt_collision_manager)</li> <li>jolt_context (atlas::physics::jolt_context)</li> <li>Join (atlas::thread)</li> <li>Joinable (atlas::thread)</li> </ul>"},{"location":"References/class_member_functions/#l","title":"l","text":"<ul> <li>linear_interpolate (atlas::interpolation)</li> <li>load_gltf (atlas::vk::mesh)</li> <li>load_obj (atlas::vk::mesh)</li> <li>loaded (atlas::vk::mesh, atlas::vk::texture)</li> <li>layout (atlas::vk::vk_pipeline)</li> </ul>"},{"location":"References/class_member_functions/#m","title":"m","text":"<ul> <li>mesh (atlas::mesh, atlas::vk::mesh)</li> <li>matrix4 (atlas::physics::matrix4&lt; JPH::Mat44 &gt;)</li> <li>mat4 (atlas::physics::matrix4&lt; JPH::Mat44 &gt;)</li> <li>material_ubo (atlas::vk::mesh)</li> </ul>"},{"location":"References/class_member_functions/#n","title":"n","text":"<ul> <li>native_window (atlas::vk::vk_window, atlas::window)</li> </ul>"},{"location":"References/class_member_functions/#o","title":"o","text":"<ul> <li>on_destruction (atlas::entity_t)</li> <li>OnContactAdded (atlas::physics::contact_listener)</li> <li>OnContactPersisted (atlas::physics::contact_listener)</li> <li>OnContactRemoved (atlas::physics::contact_listener)</li> <li>OnContactValidate (atlas::physics::contact_listener)</li> <li>on_collision_added (atlas::physics::jolt_collision)</li> <li>operator= (atlas::physics::matrix4&lt; JPH::Mat44 &gt;, atlas::physics::vector3&lt; JPH::DVec3 &gt;, atlas::physics::vector3&lt; JPH::Double3 &gt;, atlas::physics::vector3&lt; JPH::Float3 &gt;, atlas::physics::vector3&lt; JPH::Vec3 &gt;, atlas::physics::vector4&lt; JPH::Float4 &gt;, atlas::physics::vector4&lt; JPH::Vec4 &gt;, atlas::vector2&lt; glm::highp_vec2 &gt;, atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;, atlas::vector3&lt; glm::highp_vec3 &gt;, atlas::vector4, atlas::vector4&lt; glm::highp_vec4 &gt;)</li> <li>operator== (atlas::physics::matrix4&lt; JPH::Mat44 &gt;, atlas::physics::vector3&lt; JPH::DVec3 &gt;, atlas::physics::vector3&lt; JPH::Double3 &gt;, atlas::physics::vector3&lt; JPH::Float3 &gt;, atlas::physics::vector3&lt; JPH::Vec3 &gt;, atlas::physics::vector4&lt; JPH::Float4 &gt;, atlas::physics::vector4&lt; JPH::Vec4 &gt;, atlas::vector2&lt; glm::highp_vec2 &gt;, atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;, atlas::vector3&lt; glm::highp_vec3 &gt;, atlas::vector4, atlas::vector4&lt; glm::highp_vec4 &gt;, atlas::vk::vertex_input)</li> <li>operator VkCommandBuffer (atlas::vk::vk_command_buffer)</li> <li>operator VkDevice (atlas::vk::vk_driver)</li> <li>operator VkQueue (atlas::vk::vk_graphics_queue, atlas::vk::vk_present_queue)</li> <li>operator VkPhysicalDevice (atlas::vk::vk_physical_driver)</li> <li>operator VkPipeline (atlas::vk::vk_pipeline)</li> <li>operator VkRenderPass (atlas::vk::vk_renderpass)</li> <li>on_create (atlas::vk::vk_swapchain)</li> <li>operator VkSwapchainKHR (atlas::vk::vk_swapchain)</li> <li>operator VkBuffer (atlas::vk::vk_uniform_buffer, atlas::vk::vk_vertex_buffer)</li> <li>operator GLFWwindow * (atlas::window)</li> <li>operator() (std::hash&lt; atlas::vk::vertex_input &gt;)</li> </ul>"},{"location":"References/class_member_functions/#p","title":"p","text":"<ul> <li>physics_step (atlas::application, atlas::physics::physics_engine)</li> <li>post_destroy (atlas::application)</li> <li>process_keyboard (atlas::camera)</li> <li>process_mouse_movement (atlas::camera)</li> <li>process_mouse_scroll (atlas::camera)</li> <li>physics_engine (atlas::physics::physics_engine)</li> <li>post_frame (atlas::render_context, atlas::vk::vk_renderer)</li> <li>physical_driver (atlas::vk::vk_context)</li> <li>present_frame (atlas::vk::vk_present_queue)</li> <li>present (atlas::vk::vk_swapchain, atlas::window)</li> <li>presentation_process (atlas::vk::vk_window, atlas::window)</li> </ul>"},{"location":"References/class_member_functions/#q","title":"q","text":"<ul> <li>query_builder (atlas::scene_scope)</li> </ul>"},{"location":"References/class_member_functions/#r","title":"r","text":"<ul> <li>remove (atlas::entity_t, atlas::scene_object)</li> <li>run_events_added (atlas::physics::contact_listener)</li> <li>run_events_persisted (atlas::physics::contact_listener)</li> <li>run_events_removed (atlas::physics::contact_listener)</li> <li>retrieve_values (atlas::physics::jolt_api, atlas::physics::physics_api)</li> <li>return_values (atlas::physics::jolt_api, atlas::physics::physics_api)</li> <li>run_collision_added (atlas::physics::jolt_collision_manager)</li> <li>run_physics_step (atlas::physics::physics_context)</li> <li>run_contact_add (atlas::physics::physics_engine)</li> <li>renderer (atlas::renderer)</li> <li>rigidbody3d (atlas::rigidbody3d)</li> <li>reset (atlas::timer)</li> <li>recreate (atlas::vk::imgui_context, atlas::vk::vk_swapchain)</li> <li>read_textures (atlas::vk::mesh)</li> <li>reload_mesh (atlas::vk::mesh)</li> <li>resource_free (atlas::vk::vk_context)</li> <li>read_presentation_index (atlas::vk::vk_physical_driver)</li> <li>read_queue_family_indices (atlas::vk::vk_physical_driver)</li> <li>resize_requested (atlas::vk::vk_present_queue)</li> <li>read_acquired_image (atlas::vk::vk_swapchain)</li> <li>read_acquired_next_frame (atlas::vk::vk_window, atlas::window)</li> </ul>"},{"location":"References/class_member_functions/#s","title":"s","text":"<ul> <li>set_current_api (atlas::application)</li> <li>set_mouse_speed (atlas::camera)</li> <li>set_movement_speed (atlas::camera)</li> <li>set_current_logger (atlas::console_log_manager)</li> <li>set (atlas::entity_t, atlas::scene_object)</li> <li>set_angular_velocity (atlas::physics::jolt_api, atlas::physics::physics_api)</li> <li>set_linear_velocity (atlas::physics::jolt_api, atlas::physics::physics_api)</li> <li>subscribe_action (atlas::physics::jolt_collision_manager)</li> <li>store_shape (atlas::physics::jolt_context)</li> <li>ShouldCollide (atlas::physics::object_layer_pair_filter, atlas::physics::object_vs_broadphase_layer)</li> <li>set_angular_velocity_by_body (atlas::physics::physics_api)</li> <li>set_linear_velocity_by_body (atlas::physics::physics_api)</li> <li>start_runtime (atlas::physics::physics_engine)</li> <li>stop_runtime (atlas::physics::physics_engine)</li> <li>set_background_color (atlas::render_context, atlas::renderer)</li> <li>start_frame (atlas::render_context, atlas::vk::vk_renderer)</li> <li>scene_object (atlas::scene_object)</li> <li>scene_scope (atlas::scene_scope)</li> <li>save_as (atlas::serializer)</li> <li>serializer (atlas::serializer)</li> <li>search_world (atlas::system_registry)</li> <li>system_registry (atlas::system_registry)</li> <li>seconds (atlas::timer)</li> <li>sampler (atlas::vk::texture)</li> <li>submit_resource_free (atlas::vk::vk_context)</li> <li>select_memory_type (atlas::vk::vk_driver)</li> <li>size (atlas::vk::vk_index_buffer, atlas::vk::vk_shader_group, atlas::vk::vk_vertex_buffer)</li> <li>select_queue_family_indices (atlas::vk::vk_physical_driver)</li> <li>set_resize_status (atlas::vk::vk_present_queue)</li> <li>submit_immediate_async (atlas::vk::vk_present_queue)</li> <li>submit_immediate_sync (atlas::vk::vk_present_queue)</li> <li>set_vertex_attributes (atlas::vk::vk_shader_group)</li> <li>set_vertex_bind_attributes (atlas::vk::vk_shader_group)</li> <li>settings (atlas::vk::vk_swapchain, atlas::vk::vk_window, atlas::window)</li> <li>submit (atlas::vk::vk_swapchain)</li> <li>swapchain_renderpass (atlas::vk::vk_swapchain)</li> <li>size_bytes (atlas::vk::vk_uniform_buffer, atlas::vk::vk_vertex_buffer)</li> </ul>"},{"location":"References/class_member_functions/#t","title":"t","text":"<ul> <li>thread (atlas::thread)</li> <li>timer (atlas::timer)</li> <li>texture (atlas::vk::texture)</li> </ul>"},{"location":"References/class_member_functions/#u","title":"u","text":"<ul> <li>update_camera (atlas::camera)</li> <li>update_proj_view (atlas::camera)</li> <li>update_atlas_values (atlas::physics::physics_api)</li> <li>update_jolt_values (atlas::physics::physics_api)</li> <li>update (atlas::vk::descriptor_set, atlas::vk::vk_uniform_buffer)</li> <li>update_uniform (atlas::vk::mesh)</li> </ul>"},{"location":"References/class_member_functions/#v","title":"v","text":"<ul> <li>vector3 (atlas::physics::vector3&lt; JPH::DVec3 &gt;, atlas::physics::vector3&lt; JPH::Double3 &gt;, atlas::physics::vector3&lt; JPH::Float3 &gt;, atlas::physics::vector3&lt; JPH::Vec3 &gt;, atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;, atlas::vector3&lt; glm::highp_vec3 &gt;)</li> <li>vec3 (atlas::physics::vector3&lt; JPH::Float3 &gt;, atlas::physics::vector3&lt; JPH::Vec3 &gt;, atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;)</li> <li>vec4 (atlas::physics::vector4&lt; JPH::Float4 &gt;, atlas::physics::vector4&lt; JPH::Vec4 &gt;, atlas::vector4)</li> <li>vector4 (atlas::physics::vector4&lt; JPH::Float4 &gt;, atlas::physics::vector4&lt; JPH::Vec4 &gt;, atlas::vector4, atlas::vector4&lt; glm::highp_vec4 &gt;)</li> <li>vector2 (atlas::vector2&lt; glm::highp_vec2 &gt;)</li> <li>vk_command_buffer (atlas::vk::vk_command_buffer)</li> <li>vk_context (atlas::vk::vk_context)</li> <li>vk_driver (atlas::vk::vk_driver)</li> <li>vk_graphics_queue (atlas::vk::vk_graphics_queue)</li> <li>vk_index_buffer (atlas::vk::vk_index_buffer)</li> <li>vk_physical_driver (atlas::vk::vk_physical_driver)</li> <li>vk_pipeline (atlas::vk::vk_pipeline)</li> <li>vk_present_queue (atlas::vk::vk_present_queue)</li> <li>vk_renderer (atlas::vk::vk_renderer)</li> <li>vk_renderpass (atlas::vk::vk_renderpass)</li> <li>vertex_attributes (atlas::vk::vk_shader_group)</li> <li>vertex_bind_attributes (atlas::vk::vk_shader_group)</li> <li>vk_shader_group (atlas::vk::vk_shader_group)</li> <li>vk_swapchain (atlas::vk::vk_swapchain)</li> <li>vk_uniform_buffer (atlas::vk::vk_uniform_buffer)</li> <li>vk_vertex_buffer (atlas::vk::vk_vertex_buffer)</li> <li>vk_window (atlas::vk::vk_window)</li> </ul>"},{"location":"References/class_member_functions/#w","title":"w","text":"<ul> <li>world (atlas::scene_scope)</li> <li>width (atlas::vk::texture, atlas::window)</li> <li>wait_idle (atlas::vk::vk_graphics_queue, atlas::vk::vk_present_queue)</li> <li>window_swapchain (atlas::vk::vk_window, atlas::window)</li> <li>world &amp; (atlas::world_scope)</li> <li>world_scope (atlas::world_scope)</li> </ul>"},{"location":"References/class_member_functions/#_1","title":"~","text":"<ul> <li>~application (atlas::application)</li> <li>~entity_t (atlas::entity_t)</li> <li>~graphics_context (atlas::graphics_context)</li> <li>~jolt_context (atlas::physics::jolt_context)</li> <li>~physics_api (atlas::physics::physics_api)</li> <li>~physics_context (atlas::physics::physics_context)</li> <li>~render_context (atlas::render_context)</li> <li>~scene_object (atlas::scene_object)</li> <li>~scene_scope (atlas::scene_scope)</li> <li>~system_registry (atlas::system_registry)</li> <li>~thread (atlas::thread)</li> <li>~descriptor_set (atlas::vk::descriptor_set)</li> <li>~vk_driver (atlas::vk::vk_driver)</li> <li>~vk_physical_driver (atlas::vk::vk_physical_driver)</li> <li>~vk_renderer (atlas::vk::vk_renderer)</li> <li>~vk_vertex_buffer (atlas::vk::vk_vertex_buffer)</li> <li>~vk_window (atlas::vk::vk_window)</li> <li>~window (atlas::window)</li> <li>~world_scope (atlas::world_scope)</li> </ul>"},{"location":"References/class_member_variables/","title":"Class Member Variables","text":""},{"location":"References/class_member_variables/#a","title":"a","text":"<ul> <li>AspectRatio (atlas::camera)</li> <li>AxesOfController (atlas::event::joystick_info)</li> <li>allocation_amount (atlas::physics::jolt_settings)</li> <li>angular_damping (atlas::physics::physics_body)</li> <li>angular_velocity (atlas::physics::physics_body)</li> <li>allocate_count (atlas::vk::descriptor_set_layout)</li> <li>allocation_size (atlas::vk::vk_buffer)</li> <li>attachments (atlas::vk::vk_renderpass_options)</li> </ul>"},{"location":"References/class_member_variables/#b","title":"b","text":"<ul> <li>ButtonState (atlas::event::joystick_button)</li> <li>Buttons (atlas::event::joystick_info)</li> <li>ButtonsDown (atlas::event::joystick_info)</li> <li>body_id (atlas::physics::collider_body, atlas::physics::physics_body)</li> <li>broadphase_scale (atlas::physics::jolt_settings)</li> <li>body_layer_type (atlas::physics::physics_body)</li> <li>body_movement_type (atlas::physics::physics_body)</li> <li>body_type (atlas::physics::physics_body)</li> <li>body_at_runtime (atlas::rigidbody3d)</li> <li>binding_point (atlas::vk::descriptor_binding_entry)</li> <li>binding (atlas::vk::descriptor_binding_point, atlas::vk::vertex_attribute)</li> </ul>"},{"location":"References/class_member_variables/#c","title":"c","text":"<ul> <li>camera_mouse_sensitivity (atlas::camera)</li> <li>camera_movement_sensitivity (atlas::camera)</li> <li>color (atlas::material, atlas::vk::material_uniform, atlas::vk::vertex_input)</li> <li>capsule_half_height (atlas::physics::collider_body)</li> <li>collision_enabled (atlas::physics::collider_body)</li> <li>contact_bias_factor (atlas::physics::jolt_config)</li> <li>collision_filter_layer_count (atlas::physics::jolt_settings)</li> <li>center_mass_position (atlas::physics::physics_body)</li> <li>count (atlas::physics::physics_body)</li> <li>cumulative_force (atlas::physics::physics_body)</li> <li>cumulative_torque (atlas::physics::physics_body)</li> <li>currentWeapon (atlas::vk::hud_data)</li> <li>clear_values (atlas::vk::renderpass_options, atlas::vk::vk_renderpass_options)</li> <li>color_attachments (atlas::vk::renderpass_options)</li> <li>cache (atlas::vk::vk_renderpass_options)</li> <li>compute_queue (atlas::vk::vk_driver::device_queue_family)</li> <li>compute (atlas::vk::vk_physical_driver::queue_family_indices)</li> </ul>"},{"location":"References/class_member_variables/#d","title":"d","text":"<ul> <li>density (atlas::box_collider3d)</li> <li>Down (atlas::camera)</li> <li>default_collision_group (atlas::physics::jolt_settings)</li> <li>default_filter_mask (atlas::physics::jolt_settings)</li> <li>descriptor_count (atlas::vk::descriptor_binding_entry)</li> <li>device_memory (atlas::vk::image_extent, atlas::vk::vk_buffer, atlas::vk::vk_image)</li> <li>depth_attachments (atlas::vk::renderpass_options)</li> <li>device_size (atlas::vk::vk_buffer_info)</li> <li>dependencies (atlas::vk::vk_renderpass_options)</li> </ul>"},{"location":"References/class_member_variables/#e","title":"e","text":"<ul> <li>EulerRotation (atlas::camera)</li> <li>entity_a (atlas::physics::contact_event)</li> <li>entity_b (atlas::physics::contact_event)</li> <li>enable_collision_callbacks (atlas::physics::jolt_config)</li> <li>enable_constraints (atlas::physics::jolt_config)</li> <li>entry (atlas::vk::descriptor_set_layout)</li> <li>entries (atlas::vk::vertex_attribute)</li> </ul>"},{"location":"References/class_member_variables/#f","title":"f","text":"<ul> <li>friction (atlas::box_collider3d, atlas::physics::physics_body)</li> <li>friction_type (atlas::physics::jolt_config)</li> <li>fixed_time_step (atlas::physics::jolt_settings)</li> <li>fps (atlas::vk::hud_data)</li> <li>finalize (atlas::vk::renderpass_attachment)</li> <li>format (atlas::vk::renderpass_attachment, atlas::vk::texture_properties, atlas::vk::vertex_attribute_entry)</li> <li>family_index (atlas::vk::vk_queue_options)</li> <li>frames_in_flight (atlas::window_settings)</li> </ul>"},{"location":"References/class_member_variables/#g","title":"g","text":"<ul> <li>gravity (atlas::physics::jolt_config)</li> <li>gravity_factor (atlas::physics::physics_body)</li> <li>graphics_queue (atlas::vk::vk_driver::device_queue_family)</li> <li>graphics (atlas::vk::vk_physical_driver::queue_family_indices)</li> </ul>"},{"location":"References/class_member_variables/#h","title":"h","text":"<ul> <li>Height (atlas::application_settings)</li> <li>half_extents (atlas::physics::collider_body)</li> <li>hax_fixation (atlas::rigidbody3d)</li> <li>height (atlas::vk::image_extent, atlas::vk::texture_extent, atlas::vk::texture_properties, atlas::window_settings)</li> <li>handler (atlas::vk::vk_buffer)</li> </ul>"},{"location":"References/class_member_variables/#i","title":"i","text":"<ul> <li>IsMainCamera (atlas::camera)</li> <li>ID (atlas::event::joystick_button, atlas::event::joystick_info)</li> <li>id (atlas::physics::collider_event)</li> <li>is_multithreaded (atlas::physics::jolt_settings)</li> <li>initial (atlas::vk::renderpass_attachment)</li> <li>input_rate (atlas::vk::vertex_attribute)</li> <li>image (atlas::vk::vk_image, atlas::vk::vk_image_handle)</li> <li>image_view (atlas::vk::vk_image, atlas::vk::vk_image_handle)</li> </ul>"},{"location":"References/class_member_variables/#j","title":"j","text":"<ul> <li>JoystickName (atlas::event::joystick_info)</li> </ul>"},{"location":"References/class_member_variables/#l","title":"l","text":"<ul> <li>Left (atlas::camera)</li> <li>linear_damping (atlas::physics::physics_body)</li> <li>linear_velocity (atlas::physics::physics_body)</li> <li>levels (atlas::vk::command_buffer_settings)</li> <li>layout (atlas::vk::renderpass_attachment)</li> <li>load (atlas::vk::renderpass_attachment)</li> <li>location (atlas::vk::vertex_attribute_entry)</li> </ul>"},{"location":"References/class_member_variables/#m","title":"m","text":"<ul> <li>m_current_frame_index (atlas::application)</li> <li>m_renderer (atlas::application)</li> <li>m_ui_context (atlas::application)</li> <li>m_window (atlas::application)</li> <li>MouseSensitivity (atlas::camera)</li> <li>MovementSpeed (atlas::camera)</li> <li>m_entity_id (atlas::entity_t)</li> <li>model_path (atlas::material)</li> <li>model_reload (atlas::material)</li> <li>m_object_to_broadphase (atlas::physics::broad_phase_layer_interface)</li> <li>manifold (atlas::physics::contact_event)</li> <li>m_contacts_added (atlas::physics::contact_listener)</li> <li>m_contacts_persisted (atlas::physics::contact_listener)</li> <li>m_contacts_removed (atlas::physics::contact_listener)</li> <li>m_registry (atlas::physics::contact_listener, atlas::scene_scope)</li> <li>m_scene (atlas::physics::contact_listener)</li> <li>m_config (atlas::physics::jolt_api)</li> <li>m_physics_system (atlas::physics::jolt_api, atlas::physics::jolt_context)</li> <li>m_query_body (atlas::physics::jolt_api)</li> <li>m_query_transform (atlas::physics::jolt_api)</li> <li>m_read_body (atlas::physics::jolt_api)</li> <li>m_read_transform (atlas::physics::jolt_api)</li> <li>m_registery (atlas::physics::jolt_api)</li> <li>m_id (atlas::physics::jolt_collision)</li> <li>m_handlers (atlas::physics::jolt_collision_manager)</li> <li>m_tag (atlas::physics::jolt_collision_manager, atlas::scene_scope, atlas::system_registry, atlas::thread, atlas::world_scope)</li> <li>m_broad_phase_layer_interface (atlas::physics::jolt_context)</li> <li>m_contact_listener (atlas::physics::jolt_context)</li> <li>m_object_layer_pair_filter (atlas::physics::jolt_context)</li> <li>m_object_vs_broadphase_filter (atlas::physics::jolt_context)</li> <li>m_settings (atlas::physics::jolt_context, atlas::physics::physics_engine, atlas::vk::vk_window)</li> <li>m_shape_registry (atlas::physics::jolt_context)</li> <li>m_temp_allocator (atlas::physics::jolt_context)</li> <li>m_thread_system (atlas::physics::jolt_context)</li> <li>max_barriers (atlas::physics::jolt_settings)</li> <li>max_bodies (atlas::physics::jolt_settings)</li> <li>max_body_pairs (atlas::physics::jolt_settings)</li> <li>max_contact_constraints (atlas::physics::jolt_settings)</li> <li>max_jobs_power (atlas::physics::jolt_settings)</li> <li>m_value (atlas::physics::matrix4&lt; JPH::Mat44 &gt;, atlas::physics::vector3&lt; JPH::DVec3 &gt;, atlas::physics::vector3&lt; JPH::Double3 &gt;, atlas::physics::vector3&lt; JPH::Float3 &gt;, atlas::physics::vector3&lt; JPH::Vec3 &gt;, atlas::physics::vector4&lt; JPH::Float4 &gt;, atlas::physics::vector4&lt; JPH::Vec4 &gt;, atlas::vector2&lt; glm::highp_vec2 &gt;, atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;, atlas::vector3&lt; glm::highp_vec3 &gt;, atlas::vector4, atlas::vector4&lt; glm::highp_vec4 &gt;)</li> <li>mass_factor (atlas::physics::physics_body)</li> <li>m_backend_api (atlas::physics::physics_engine)</li> <li>m_engine_api (atlas::physics::physics_engine)</li> <li>m_render_context (atlas::renderer)</li> <li>m_entity (atlas::scene_object)</li> <li>m_current_scene_ctx (atlas::serializer)</li> <li>m_world_registered (atlas::system_registry)</li> <li>m_thread (atlas::thread)</li> <li>m_stop_watch (atlas::timer)</li> <li>m_allocated_descriptors (atlas::vk::descriptor_set)</li> <li>m_descriptor_pool (atlas::vk::descriptor_set)</li> <li>m_descriptor_set_layout (atlas::vk::descriptor_set)</li> <li>m_descriptor_sets (atlas::vk::descriptor_set)</li> <li>m_driver (atlas::vk::descriptor_set, atlas::vk::imgui_context, atlas::vk::texture, atlas::vk::vk_command_buffer, atlas::vk::vk_context, atlas::vk::vk_driver, atlas::vk::vk_graphics_queue, atlas::vk::vk_index_buffer, atlas::vk::vk_pipeline, atlas::vk::vk_present_queue, atlas::vk::vk_renderpass, atlas::vk::vk_shader_group, atlas::vk::vk_swapchain, atlas::vk::vk_uniform_buffer, atlas::vk::vk_vertex_buffer)</li> <li>m_error_texture (atlas::vk::descriptor_set)</li> <li>m_set_slot (atlas::vk::descriptor_set)</li> <li>m_size_bytes (atlas::vk::descriptor_set, atlas::vk::vk_uniform_buffer)</li> <li>max_sets (atlas::vk::descriptor_set_layout)</li> <li>mvp (atlas::vk::global_ubo)</li> <li>mip_level (atlas::vk::image_extent)</li> <li>m_current_command (atlas::vk::imgui_context)</li> <li>m_current_swapchain_handler (atlas::vk::imgui_context)</li> <li>m_desc_pool (atlas::vk::imgui_context)</li> <li>m_instance (atlas::vk::imgui_context)</li> <li>m_physical (atlas::vk::imgui_context, atlas::vk::vk_context, atlas::vk::vk_driver, atlas::vk::vk_graphics_queue, atlas::vk::vk_swapchain)</li> <li>model (atlas::vk::material_uniform)</li> <li>m_geoemtry_ubo (atlas::vk::mesh)</li> <li>m_ibo (atlas::vk::mesh)</li> <li>m_model_loaded (atlas::vk::mesh)</li> <li>m_textures (atlas::vk::mesh)</li> <li>m_vbo (atlas::vk::mesh)</li> <li>m_height (atlas::vk::texture)</li> <li>m_is_image_loaded (atlas::vk::texture)</li> <li>m_texture_image (atlas::vk::texture)</li> <li>m_width (atlas::vk::texture)</li> <li>memory_property_flag (atlas::vk::vk_buffer_info)</li> <li>m_begin_end_count (atlas::vk::vk_command_buffer)</li> <li>m_command_buffer_handler (atlas::vk::vk_command_buffer)</li> <li>m_command_pool (atlas::vk::vk_command_buffer)</li> <li>m_instance_handler (atlas::vk::vk_context, atlas::vk::vk_window)</li> <li>m_resources_free (atlas::vk::vk_context)</li> <li>m_depth_format_selected (atlas::vk::vk_driver)</li> <li>m_device_queues (atlas::vk::vk_driver)</li> <li>max (atlas::vk::vk_filter_range)</li> <li>min (atlas::vk::vk_filter_range)</li> <li>m_graphics_queue_handler (atlas::vk::vk_graphics_queue)</li> <li>m_present_completed_semaphore (atlas::vk::vk_graphics_queue, atlas::vk::vk_present_queue)</li> <li>m_render_completed_semaphore (atlas::vk::vk_graphics_queue, atlas::vk::vk_present_queue)</li> <li>m_index_buffer_handler (atlas::vk::vk_index_buffer)</li> <li>m_indices_count (atlas::vk::vk_index_buffer)</li> <li>m_physical_driver (atlas::vk::vk_physical_driver)</li> <li>m_queue_family_properties (atlas::vk::vk_physical_driver)</li> <li>m_queue_indices (atlas::vk::vk_physical_driver)</li> <li>m_surface_properties (atlas::vk::vk_physical_driver, atlas::vk::vk_swapchain)</li> <li>m_descriptor_layouts (atlas::vk::vk_pipeline)</li> <li>m_pipeline_handler (atlas::vk::vk_pipeline)</li> <li>m_pipeline_layout (atlas::vk::vk_pipeline)</li> <li>m_shader_group (atlas::vk::vk_pipeline, atlas::vk::vk_renderer)</li> <li>m_present_queue_handler (atlas::vk::vk_present_queue)</li> <li>m_resize_requested (atlas::vk::vk_present_queue)</li> <li>m_swapchain_handler (atlas::vk::vk_present_queue, atlas::vk::vk_swapchain)</li> <li>m_begin_initialize (atlas::vk::vk_renderer)</li> <li>m_cached_meshes (atlas::vk::vk_renderer)</li> <li>m_camera (atlas::vk::vk_renderer)</li> <li>m_color (atlas::vk::vk_renderer)</li> <li>m_current_command_buffer (atlas::vk::vk_renderer)</li> <li>m_current_frame (atlas::vk::vk_renderer)</li> <li>m_geometry_descriptor_layout (atlas::vk::vk_renderer)</li> <li>m_global_descriptor (atlas::vk::vk_renderer)</li> <li>m_global_uniforms (atlas::vk::vk_renderer)</li> <li>m_image_count (atlas::vk::vk_renderer)</li> <li>m_main_pipeline (atlas::vk::vk_renderer)</li> <li>m_main_swapchain (atlas::vk::vk_renderer)</li> <li>m_material_descriptor_layout (atlas::vk::vk_renderer)</li> <li>m_mesh_descriptors (atlas::vk::vk_renderer)</li> <li>m_model (atlas::vk::vk_renderer)</li> <li>m_renderpass_handler (atlas::vk::vk_renderpass)</li> <li>m_renderpass_options (atlas::vk::vk_renderpass)</li> <li>m_shader_modules (atlas::vk::vk_shader_group)</li> <li>m_shader_sources (atlas::vk::vk_shader_group)</li> <li>m_vertex_attributes (atlas::vk::vk_shader_group)</li> <li>m_vertex_binding_attributes (atlas::vk::vk_shader_group)</li> <li>module_handler (atlas::vk::vk_shader_module)</li> <li>m_color_renderpass (atlas::vk::vk_swapchain)</li> <li>m_current_surface (atlas::vk::vk_swapchain)</li> <li>m_current_surface_handler (atlas::vk::vk_swapchain)</li> <li>m_image_size (atlas::vk::vk_swapchain)</li> <li>m_present_to_queue (atlas::vk::vk_swapchain)</li> <li>m_swapchain_command_buffers (atlas::vk::vk_swapchain)</li> <li>m_swapchain_depth_images (atlas::vk::vk_swapchain)</li> <li>m_swapchain_extent (atlas::vk::vk_swapchain)</li> <li>m_swapchain_framebuffers (atlas::vk::vk_swapchain)</li> <li>m_swapchain_images (atlas::vk::vk_swapchain)</li> <li>m_swapchain_main_renderpass (atlas::vk::vk_swapchain)</li> <li>m_window_settings (atlas::vk::vk_swapchain)</li> <li>m_uniform_buffer_data (atlas::vk::vk_uniform_buffer)</li> <li>m_vertex_handler (atlas::vk::vk_vertex_buffer)</li> <li>m_vertices_byte_size_count (atlas::vk::vk_vertex_buffer)</li> <li>m_vertices_count (atlas::vk::vk_vertex_buffer)</li> <li>m_swapchain (atlas::vk::vk_window)</li> <li>m_window_handler (atlas::vk::vk_window)</li> <li>m_window_surface (atlas::vk::vk_window)</li> <li>m_scene_container (atlas::world_scope)</li> <li>m_scene_registry (atlas::world_scope)</li> <li>m_world_shared_instance (atlas::world_scope)</li> </ul>"},{"location":"References/class_member_variables/#n","title":"n","text":"<ul> <li>Name (atlas::application_settings, atlas::event::joystick_button)</li> <li>normals (atlas::vk::vertex_input)</li> <li>name (atlas::window_settings)</li> </ul>"},{"location":"References/class_member_variables/#o","title":"o","text":"<ul> <li>offset (atlas::box_collider3d)</li> <li>on_reload (atlas::reload)</li> <li>on_texture_reload (atlas::reload)</li> </ul>"},{"location":"References/class_member_variables/#p","title":"p","text":"<ul> <li>Position (atlas::camera, atlas::light, atlas::transform)</li> <li>Projection (atlas::camera)</li> <li>PreviousButtonState (atlas::event::joystick_button)</li> <li>physics_scene_position (atlas::physics::jolt_settings)</li> <li>physics_threads (atlas::physics::jolt_settings)</li> <li>position_iterations (atlas::physics::jolt_settings)</li> <li>position (atlas::transform_physics, atlas::vk::vertex_input)</li> <li>projection (atlas::vk::camera_ubo)</li> <li>pool_flag (atlas::vk::command_buffer_settings)</li> <li>playerHealth (atlas::vk::hud_data)</li> <li>playerScore (atlas::vk::hud_data)</li> <li>property (atlas::vk::texture_properties)</li> </ul>"},{"location":"References/class_member_variables/#q","title":"q","text":"<ul> <li>QuaternionRotation (atlas::transform)</li> <li>quaterion_rotation (atlas::transform_physics)</li> <li>queue_index (atlas::vk::command_buffer_settings, atlas::vk::vk_queue_options)</li> </ul>"},{"location":"References/class_member_variables/#r","title":"r","text":"<ul> <li>restitution (atlas::box_collider3d, atlas::physics::physics_body)</li> <li>restitutionThreshold (atlas::box_collider3d)</li> <li>Right (atlas::camera)</li> <li>radius (atlas::physics::collider_body)</li> <li>restitution_threshold (atlas::physics::jolt_config)</li> <li>restitution_type (atlas::physics::jolt_config)</li> <li>Rotation (atlas::transform)</li> <li>rotation (atlas::transform_physics)</li> </ul>"},{"location":"References/class_member_variables/#s","title":"s","text":"<ul> <li>s_instance (atlas::application, atlas::renderer, atlas::system_registry, atlas::vk::vk_context, atlas::vk::vk_driver, atlas::vk::vk_physical_driver, atlas::vk::vk_window)</li> <li>size (atlas::box_collider3d)</li> <li>s_loggers (atlas::console_log_manager)</li> <li>shape_type (atlas::physics::collider_body)</li> <li>settings (atlas::physics::contact_event)</li> <li>sleep_angular_velocity_threshold (atlas::physics::jolt_settings)</li> <li>sleep_velocity_threshold (atlas::physics::jolt_settings)</li> <li>Scale (atlas::transform)</li> <li>scale (atlas::transform_physics)</li> <li>stage (atlas::vk::descriptor_binding_point, atlas::vk::shader_info, atlas::vk::vk_shader_module)</li> <li>size_bytes (atlas::vk::descriptor_set_layout)</li> <li>sample_count (atlas::vk::renderpass_attachment)</li> <li>stencil_load (atlas::vk::renderpass_attachment)</li> <li>stencil_store (atlas::vk::renderpass_attachment)</li> <li>store (atlas::vk::renderpass_attachment)</li> <li>source (atlas::vk::shader_info)</li> <li>surface_capabilities (atlas::vk::surface_properties)</li> <li>surface_format (atlas::vk::surface_properties)</li> <li>stride (atlas::vk::vertex_attribute, atlas::vk::vertex_attribute_entry)</li> <li>sampler (atlas::vk::vk_image)</li> <li>subpass_descriptions (atlas::vk::vk_renderpass_options)</li> </ul>"},{"location":"References/class_member_variables/#t","title":"t","text":"<ul> <li>texture_filepaths (atlas::material)</li> <li>texture_path (atlas::material)</li> <li>texture_reload (atlas::material)</li> <li>time_before_sleep (atlas::physics::jolt_config)</li> <li>thread_type (atlas::physics::jolt_settings)</li> <li>type (atlas::rigidbody3d, atlas::vk::descriptor_binding_entry, atlas::vk::renderpass_attachment)</li> <li>TagMetadata (atlas::tag)</li> <li>transfer_queue (atlas::vk::vk_driver::device_queue_family)</li> <li>transfer (atlas::vk::vk_physical_driver::queue_family_indices)</li> </ul>"},{"location":"References/class_member_variables/#u","title":"u","text":"<ul> <li>Up (atlas::camera)</li> <li>use_4_layer_broadphase (atlas::physics::jolt_settings)</li> <li>use_fixed_timestep (atlas::physics::jolt_settings)</li> <li>use_gravity (atlas::physics::physics_body)</li> <li>usage (atlas::vk::texture_properties, atlas::vk::vk_buffer_info)</li> <li>uv (atlas::vk::vertex_input)</li> </ul>"},{"location":"References/class_member_variables/#v","title":"v","text":"<ul> <li>View (atlas::camera)</li> <li>velocity_iterations (atlas::physics::jolt_settings)</li> <li>view (atlas::vk::camera_ubo)</li> </ul>"},{"location":"References/class_member_variables/#w","title":"w","text":"<ul> <li>Width (atlas::application_settings)</li> <li>WorldUp (atlas::camera)</li> <li>world_unit_scale (atlas::physics::jolt_config)</li> <li>world_bounds_max (atlas::physics::jolt_settings)</li> <li>world_bounds_min (atlas::physics::jolt_settings)</li> <li>width (atlas::vk::image_extent, atlas::vk::texture_extent, atlas::vk::texture_properties, atlas::window_settings)</li> </ul>"},{"location":"References/class_member_variables/#z","title":"z","text":"<ul> <li>Zoom (atlas::camera)</li> </ul>"},{"location":"References/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"References/class_member_enums/","title":"Class Member Enums","text":""},{"location":"References/class_member_enums/#b","title":"b","text":"<ul> <li>body_type (atlas::rigidbody3d)</li> </ul>"},{"location":"References/namespace_members/","title":"Namespace Members","text":""},{"location":"References/namespace_members/#a","title":"a","text":"<ul> <li>api (atlas)</li> <li>add_angular_velocity (atlas::physics)</li> <li>add_force (atlas::physics)</li> <li>add_velocity (atlas::physics)</li> <li>assert_failed_impl (atlas::physics)</li> <li>attach (atlas::sync_update, atlas)</li> <li>attachment_load (atlas::vk)</li> <li>attachment_store (atlas::vk)</li> </ul>"},{"location":"References/namespace_members/#b","title":"b","text":"<ul> <li>BroadPhaseLayers (atlas::physics)</li> <li>body_layer (atlas::physics)</li> <li>body_type (atlas::physics)</li> <li>begin_popup_context_window (atlas::ui)</li> <li>button_open_file_dialog (atlas::ui)</li> <li>begin_command_buffer (atlas::vk)</li> <li>buffer (atlas::vk)</li> <li>bytes_per_texture_format (atlas::vk)</li> </ul>"},{"location":"References/namespace_members/#c","title":"c","text":"<ul> <li>CameraMovement (atlas)</li> <li>cursor_position (atlas::event)</li> <li>collider_shape (atlas::physics)</li> <li>command_buffer_levels (atlas::vk)</li> <li>copy (atlas::vk)</li> <li>create_buffer (atlas::vk)</li> <li>create_image2d (atlas::vk)</li> <li>create_image_view (atlas::vk)</li> <li>create_sampler (atlas::vk)</li> <li>create_semaphore (atlas::vk)</li> <li>create_single_command_buffer (atlas::vk)</li> <li>create_single_command_pool (atlas::vk)</li> <li>create_uniform_buffer (atlas::vk)</li> <li>core_assert (atlas)</li> <li>create_ref (atlas)</li> <li>create_scope (atlas)</li> <li>create_weak_ptr (atlas)</li> <li>create_window (atlas)</li> </ul>"},{"location":"References/namespace_members/#d","title":"d","text":"<ul> <li>delta_time (atlas::sync_update)</li> <li>dockspace_window (atlas::ui)</li> <li>draw_float (atlas::ui)</li> <li>draw_panel_component (atlas::ui)</li> <li>draw_vec3 (atlas::ui)</li> <li>draw_vec4 (atlas::ui)</li> </ul>"},{"location":"References/namespace_members/#e","title":"e","text":"<ul> <li>end_command_buffer (atlas::vk)</li> </ul>"},{"location":"References/namespace_members/#f","title":"f","text":"<ul> <li>format (atlas::vk)</li> <li>free_buffer (atlas::vk)</li> <li>free_image (atlas::vk)</li> </ul>"},{"location":"References/namespace_members/#g","title":"g","text":"<ul> <li>get_joystic_axis (atlas::event)</li> <li>get_thread_count (atlas)</li> </ul>"},{"location":"References/namespace_members/#h","title":"h","text":"<ul> <li>has_stencil_attachment (atlas::vk)</li> <li>hash_combine (atlas)</li> <li>highp_vec2 (atlas)</li> <li>highp_vec3 (atlas)</li> <li>highp_vec4 (atlas)</li> </ul>"},{"location":"References/namespace_members/#i","title":"i","text":"<ul> <li>input_state (atlas::event)</li> <li>is_joystic_present (atlas::event)</li> <li>is_joystick_button_pressed (atlas::event)</li> <li>is_joystick_button_released (atlas::event)</li> <li>is_joystick_guid (atlas::event)</li> <li>is_key_pressed (atlas::event)</li> <li>is_key_released (atlas::event)</li> <li>is_mouse_pressed (atlas::event)</li> <li>is_mouse_released (atlas::event)</li> <li>initialize_engine (atlas::physics)</li> <li>initialize (atlas::sync_update)</li> <li>image_layout (atlas::vk)</li> <li>image_memory_barrier (atlas::vk)</li> <li>input_rate (atlas::vk)</li> <li>initialize_application (atlas)</li> <li>initialize_context (atlas)</li> <li>initialize_renderer (atlas)</li> </ul>"},{"location":"References/namespace_members/#j","title":"j","text":"<ul> <li>JoystickCodes (atlas::event)</li> </ul>"},{"location":"References/namespace_members/#k","title":"k","text":"<ul> <li>Key (atlas::event)</li> </ul>"},{"location":"References/namespace_members/#l","title":"l","text":"<ul> <li>load_from_file_dialog (atlas::filesystem)</li> </ul>"},{"location":"References/namespace_members/#m","title":"m","text":"<ul> <li>Mouse (atlas::event)</li> <li>mat (atlas)</li> <li>mat2 (atlas)</li> <li>mat3 (atlas)</li> <li>mat4 (atlas)</li> </ul>"},{"location":"References/namespace_members/#o","title":"o","text":"<ul> <li>ObjectLayer (atlas::physics)</li> <li>on_late_update (atlas::sync_update)</li> <li>on_physics_update (atlas::sync_update)</li> <li>on_ui_update (atlas::sync_update)</li> <li>on_update (atlas::sync_update)</li> </ul>"},{"location":"References/namespace_members/#p","title":"p","text":"<ul> <li>physics_backend (atlas::physics)</li> <li>post (atlas::sync_update, atlas)</li> <li>pipeline_bind_point (atlas::vk)</li> </ul>"},{"location":"References/namespace_members/#q","title":"q","text":"<ul> <li>queue_submit (atlas::vk)</li> </ul>"},{"location":"References/namespace_members/#r","title":"r","text":"<ul> <li>renderpass_type (atlas::vk)</li> <li>ref (atlas)</li> </ul>"},{"location":"References/namespace_members/#s","title":"s","text":"<ul> <li>save_to_file (atlas::filesystem)</li> <li>set_angular_velocity (atlas::physics)</li> <li>set_velocity (atlas::physics)</li> <li>s_late_update (atlas::sync_update)</li> <li>s_physica_update (atlas::sync_update)</li> <li>s_ui_update (atlas::sync_update)</li> <li>s_update (atlas::sync_update)</li> <li>sync (atlas::sync_update, atlas)</li> <li>sync_physics (atlas::sync_update, atlas)</li> <li>sample_bit (atlas::vk)</li> <li>select_compatible_present_mode (atlas::vk)</li> <li>select_images_size (atlas::vk)</li> <li>shader_stage (atlas::vk)</li> <li>scope (atlas)</li> </ul>"},{"location":"References/namespace_members/#t","title":"t","text":"<ul> <li>thread_system (atlas::physics)</li> <li>to_jph (atlas::physics)</li> <li>trace_impl (atlas::physics)</li> <li>to_vk_attachment_load (atlas::vk)</li> <li>to_vk_attachment_store (atlas::vk)</li> <li>to_vk_command_buffer_level (atlas::vk)</li> <li>to_vk_descriptor_type (atlas::vk)</li> <li>to_vk_format (atlas::vk)</li> <li>to_vk_image_layout (atlas::vk)</li> <li>to_vk_input_rate (atlas::vk)</li> <li>to_vk_pipeline_bind_point (atlas::vk)</li> <li>to_vk_sample_count_bits (atlas::vk)</li> <li>to_vk_shader_stage (atlas::vk)</li> <li>to_vk_shader_stage_bits (atlas::vk)</li> <li>transition_image_layout (atlas::vk)</li> <li>to_weak_ptr (atlas)</li> </ul>"},{"location":"References/namespace_members/#u","title":"u","text":"<ul> <li>update_events (atlas::event)</li> </ul>"},{"location":"References/namespace_members/#v","title":"v","text":"<ul> <li>vk_check (atlas::vk)</li> <li>vk_check_format (atlas::vk)</li> <li>vk_format_to_string (atlas::vk)</li> <li>vk_present_mode_to_string (atlas::vk)</li> <li>vec (atlas)</li> <li>vec2 (atlas)</li> <li>vec3 (atlas)</li> <li>vec4 (atlas)</li> </ul>"},{"location":"References/namespace_members/#w","title":"w","text":"<ul> <li>wait_for_events (atlas::event)</li> <li>write (atlas::vk)</li> <li>weak_ptr (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"References/namespace_member_functions/#a","title":"a","text":"<ul> <li>add_angular_velocity (atlas::physics)</li> <li>add_force (atlas::physics)</li> <li>add_velocity (atlas::physics)</li> <li>assert_failed_impl (atlas::physics)</li> <li>attach (atlas::sync_update, atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#b","title":"b","text":"<ul> <li>begin_popup_context_window (atlas::ui)</li> <li>button_open_file_dialog (atlas::ui)</li> <li>begin_command_buffer (atlas::vk)</li> <li>bytes_per_texture_format (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_functions/#c","title":"c","text":"<ul> <li>cursor_position (atlas::event)</li> <li>copy (atlas::vk)</li> <li>create_buffer (atlas::vk)</li> <li>create_image2d (atlas::vk)</li> <li>create_image_view (atlas::vk)</li> <li>create_sampler (atlas::vk)</li> <li>create_semaphore (atlas::vk)</li> <li>create_single_command_buffer (atlas::vk)</li> <li>create_single_command_pool (atlas::vk)</li> <li>create_uniform_buffer (atlas::vk)</li> <li>core_assert (atlas)</li> <li>create_ref (atlas)</li> <li>create_scope (atlas)</li> <li>create_weak_ptr (atlas)</li> <li>create_window (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#d","title":"d","text":"<ul> <li>delta_time (atlas::sync_update)</li> <li>dockspace_window (atlas::ui)</li> <li>draw_float (atlas::ui)</li> <li>draw_panel_component (atlas::ui)</li> <li>draw_vec3 (atlas::ui)</li> <li>draw_vec4 (atlas::ui)</li> </ul>"},{"location":"References/namespace_member_functions/#e","title":"e","text":"<ul> <li>end_command_buffer (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_functions/#f","title":"f","text":"<ul> <li>free_buffer (atlas::vk)</li> <li>free_image (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_functions/#g","title":"g","text":"<ul> <li>get_joystic_axis (atlas::event)</li> <li>get_thread_count (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#h","title":"h","text":"<ul> <li>has_stencil_attachment (atlas::vk)</li> <li>hash_combine (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#i","title":"i","text":"<ul> <li>is_joystic_present (atlas::event)</li> <li>is_joystick_button_pressed (atlas::event)</li> <li>is_joystick_button_released (atlas::event)</li> <li>is_joystick_guid (atlas::event)</li> <li>is_key_pressed (atlas::event)</li> <li>is_key_released (atlas::event)</li> <li>is_mouse_pressed (atlas::event)</li> <li>is_mouse_released (atlas::event)</li> <li>initialize_engine (atlas::physics)</li> <li>initialize (atlas::sync_update)</li> <li>image_memory_barrier (atlas::vk)</li> <li>initialize_application (atlas)</li> <li>initialize_context (atlas)</li> <li>initialize_renderer (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#l","title":"l","text":"<ul> <li>load_from_file_dialog (atlas::filesystem)</li> </ul>"},{"location":"References/namespace_member_functions/#o","title":"o","text":"<ul> <li>on_late_update (atlas::sync_update)</li> <li>on_physics_update (atlas::sync_update)</li> <li>on_ui_update (atlas::sync_update)</li> <li>on_update (atlas::sync_update)</li> </ul>"},{"location":"References/namespace_member_functions/#p","title":"p","text":"<ul> <li>post (atlas::sync_update, atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#q","title":"q","text":"<ul> <li>queue_submit (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_functions/#s","title":"s","text":"<ul> <li>save_to_file (atlas::filesystem)</li> <li>set_angular_velocity (atlas::physics)</li> <li>set_velocity (atlas::physics)</li> <li>sync (atlas::sync_update, atlas)</li> <li>sync_physics (atlas::sync_update, atlas)</li> <li>select_compatible_present_mode (atlas::vk)</li> <li>select_images_size (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_functions/#t","title":"t","text":"<ul> <li>to_jph (atlas::physics)</li> <li>trace_impl (atlas::physics)</li> <li>to_vk_attachment_load (atlas::vk)</li> <li>to_vk_attachment_store (atlas::vk)</li> <li>to_vk_command_buffer_level (atlas::vk)</li> <li>to_vk_descriptor_type (atlas::vk)</li> <li>to_vk_format (atlas::vk)</li> <li>to_vk_image_layout (atlas::vk)</li> <li>to_vk_input_rate (atlas::vk)</li> <li>to_vk_pipeline_bind_point (atlas::vk)</li> <li>to_vk_sample_count_bits (atlas::vk)</li> <li>to_vk_shader_stage (atlas::vk)</li> <li>to_vk_shader_stage_bits (atlas::vk)</li> <li>transition_image_layout (atlas::vk)</li> <li>to_weak_ptr (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#u","title":"u","text":"<ul> <li>update_events (atlas::event)</li> </ul>"},{"location":"References/namespace_member_functions/#v","title":"v","text":"<ul> <li>vk_check (atlas::vk)</li> <li>vk_check_format (atlas::vk)</li> <li>vk_format_to_string (atlas::vk)</li> <li>vk_present_mode_to_string (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_functions/#w","title":"w","text":"<ul> <li>wait_for_events (atlas::event)</li> <li>write (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"References/namespace_member_variables/#s","title":"s","text":"<ul> <li>s_late_update (atlas::sync_update)</li> <li>s_physica_update (atlas::sync_update)</li> <li>s_ui_update (atlas::sync_update)</li> <li>s_update (atlas::sync_update)</li> </ul>"},{"location":"References/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"References/namespace_member_typedefs/#h","title":"h","text":"<ul> <li>highp_vec2 (atlas)</li> <li>highp_vec3 (atlas)</li> <li>highp_vec4 (atlas)</li> </ul>"},{"location":"References/namespace_member_typedefs/#m","title":"m","text":"<ul> <li>mat (atlas)</li> <li>mat2 (atlas)</li> <li>mat3 (atlas)</li> <li>mat4 (atlas)</li> </ul>"},{"location":"References/namespace_member_typedefs/#r","title":"r","text":"<ul> <li>ref (atlas)</li> </ul>"},{"location":"References/namespace_member_typedefs/#s","title":"s","text":"<ul> <li>scope (atlas)</li> </ul>"},{"location":"References/namespace_member_typedefs/#v","title":"v","text":"<ul> <li>vec (atlas)</li> <li>vec2 (atlas)</li> <li>vec3 (atlas)</li> <li>vec4 (atlas)</li> </ul>"},{"location":"References/namespace_member_typedefs/#w","title":"w","text":"<ul> <li>weak_ptr (atlas)</li> </ul>"},{"location":"References/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"References/namespace_member_enums/#a","title":"a","text":"<ul> <li>api (atlas)</li> <li>attachment_load (atlas::vk)</li> <li>attachment_store (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_enums/#b","title":"b","text":"<ul> <li>BroadPhaseLayers (atlas::physics)</li> <li>body_layer (atlas::physics)</li> <li>body_type (atlas::physics)</li> <li>buffer (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_enums/#c","title":"c","text":"<ul> <li>CameraMovement (atlas)</li> <li>collider_shape (atlas::physics)</li> <li>command_buffer_levels (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_enums/#f","title":"f","text":"<ul> <li>format (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_enums/#i","title":"i","text":"<ul> <li>input_state (atlas::event)</li> <li>image_layout (atlas::vk)</li> <li>input_rate (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_enums/#j","title":"j","text":"<ul> <li>JoystickCodes (atlas::event)</li> </ul>"},{"location":"References/namespace_member_enums/#k","title":"k","text":"<ul> <li>Key (atlas::event)</li> </ul>"},{"location":"References/namespace_member_enums/#m","title":"m","text":"<ul> <li>Mouse (atlas::event)</li> </ul>"},{"location":"References/namespace_member_enums/#o","title":"o","text":"<ul> <li>ObjectLayer (atlas::physics)</li> </ul>"},{"location":"References/namespace_member_enums/#p","title":"p","text":"<ul> <li>physics_backend (atlas::physics)</li> <li>pipeline_bind_point (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_enums/#r","title":"r","text":"<ul> <li>renderpass_type (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_enums/#s","title":"s","text":"<ul> <li>sample_bit (atlas::vk)</li> <li>shader_stage (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_enums/#t","title":"t","text":"<ul> <li>thread_system (atlas::physics)</li> </ul>"},{"location":"References/functions/","title":"Functions","text":""},{"location":"References/functions/#c","title":"c","text":"<ul> <li>console_log_error (engine_logger.hpp)</li> <li>console_log_error_tagged (engine_logger.hpp)</li> <li>console_log_fatal (engine_logger.hpp)</li> <li>console_log_fatal_tagged (engine_logger.hpp)</li> <li>console_log_info (engine_logger.hpp)</li> <li>console_log_info_tagged (engine_logger.hpp)</li> <li>console_log_trace (engine_logger.hpp)</li> <li>console_log_trace_tagged (engine_logger.hpp)</li> <li>console_log_warn (engine_logger.hpp)</li> <li>console_log_warn_tagged (engine_logger.hpp)</li> </ul>"},{"location":"References/macros/","title":"Macros","text":""},{"location":"References/macros/#e","title":"e","text":"<ul> <li>ENGINE_API (core.hpp)</li> </ul>"},{"location":"References/macros/#g","title":"g","text":"<ul> <li>GLM_ENABLE_EXPERIMENTAL (components.hpp, hash.hpp, mesh.hpp)</li> <li>GLFW_INCLUDE_VULKAN (vulkan-imports.hpp)</li> </ul>"},{"location":"References/variables/","title":"Variables","text":""},{"location":"References/variables/#c","title":"c","text":"<ul> <li>combine_friction (jolt_components.hpp)</li> <li>combine_restitution (jolt_components.hpp)</li> </ul>"},{"location":"References/variables/#g","title":"g","text":"<ul> <li>g_asset_path (widgets.hpp)</li> </ul>"},{"location":"References/variables/#j","title":"j","text":"<ul> <li>joystick_1 (joystick_codes.hpp)</li> <li>joystick_10 (joystick_codes.hpp)</li> <li>joystick_11 (joystick_codes.hpp)</li> <li>joystick_12 (joystick_codes.hpp)</li> <li>joystick_13 (joystick_codes.hpp)</li> <li>joystick_14 (joystick_codes.hpp)</li> <li>joystick_15 (joystick_codes.hpp)</li> <li>joystick_16 (joystick_codes.hpp)</li> <li>joystick_2 (joystick_codes.hpp)</li> <li>joystick_3 (joystick_codes.hpp)</li> <li>joystick_4 (joystick_codes.hpp)</li> <li>joystick_5 (joystick_codes.hpp)</li> <li>joystick_6 (joystick_codes.hpp)</li> <li>joystick_7 (joystick_codes.hpp)</li> <li>joystick_8 (joystick_codes.hpp)</li> <li>joystick_9 (joystick_codes.hpp)</li> <li>joystick_last (joystick_codes.hpp)</li> </ul>"},{"location":"References/variables/#k","title":"k","text":"<ul> <li>key_0 (key_codes.hpp)</li> <li>key_1 (key_codes.hpp)</li> <li>key_2 (key_codes.hpp)</li> <li>key_3 (key_codes.hpp)</li> <li>key_4 (key_codes.hpp)</li> <li>key_5 (key_codes.hpp)</li> <li>key_6 (key_codes.hpp)</li> <li>key_7 (key_codes.hpp)</li> <li>key_8 (key_codes.hpp)</li> <li>key_9 (key_codes.hpp)</li> <li>key_a (key_codes.hpp)</li> <li>key_apostrophe (key_codes.hpp)</li> <li>key_b (key_codes.hpp)</li> <li>key_backslash (key_codes.hpp)</li> <li>key_backspace (key_codes.hpp)</li> <li>key_c (key_codes.hpp)</li> <li>key_caps_lock (key_codes.hpp)</li> <li>key_comma (key_codes.hpp)</li> <li>key_d (key_codes.hpp)</li> <li>key_delete (key_codes.hpp)</li> <li>key_down (key_codes.hpp)</li> <li>key_e (key_codes.hpp)</li> <li>key_end (key_codes.hpp)</li> <li>key_enter (key_codes.hpp)</li> <li>key_equal (key_codes.hpp)</li> <li>key_escape (key_codes.hpp)</li> <li>key_f (key_codes.hpp)</li> <li>key_f1 (key_codes.hpp)</li> <li>key_f10 (key_codes.hpp)</li> <li>key_f11 (key_codes.hpp)</li> <li>key_f12 (key_codes.hpp)</li> <li>key_f13 (key_codes.hpp)</li> <li>key_f14 (key_codes.hpp)</li> <li>key_f15 (key_codes.hpp)</li> <li>key_f16 (key_codes.hpp)</li> <li>key_f17 (key_codes.hpp)</li> <li>key_f18 (key_codes.hpp)</li> <li>key_f19 (key_codes.hpp)</li> <li>key_f2 (key_codes.hpp)</li> <li>key_f20 (key_codes.hpp)</li> <li>key_f21 (key_codes.hpp)</li> <li>key_f22 (key_codes.hpp)</li> <li>key_f23 (key_codes.hpp)</li> <li>key_f24 (key_codes.hpp)</li> <li>key_f25 (key_codes.hpp)</li> <li>key_f3 (key_codes.hpp)</li> <li>key_f4 (key_codes.hpp)</li> <li>key_f5 (key_codes.hpp)</li> <li>key_f6 (key_codes.hpp)</li> <li>key_f7 (key_codes.hpp)</li> <li>key_f8 (key_codes.hpp)</li> <li>key_f9 (key_codes.hpp)</li> <li>key_g (key_codes.hpp)</li> <li>key_gravity_accent (key_codes.hpp)</li> <li>key_h (key_codes.hpp)</li> <li>key_home (key_codes.hpp)</li> <li>key_i (key_codes.hpp)</li> <li>key_insert (key_codes.hpp)</li> <li>key_j (key_codes.hpp)</li> <li>key_k (key_codes.hpp)</li> <li>key_kp_0 (key_codes.hpp)</li> <li>key_kp_1 (key_codes.hpp)</li> <li>key_kp_2 (key_codes.hpp)</li> <li>key_kp_3 (key_codes.hpp)</li> <li>key_kp_4 (key_codes.hpp)</li> <li>key_kp_5 (key_codes.hpp)</li> <li>key_kp_6 (key_codes.hpp)</li> <li>key_kp_7 (key_codes.hpp)</li> <li>key_kp_8 (key_codes.hpp)</li> <li>key_kp_9 (key_codes.hpp)</li> <li>key_kp_add (key_codes.hpp)</li> <li>key_kp_decimal (key_codes.hpp)</li> <li>key_kp_divide (key_codes.hpp)</li> <li>key_kp_enter (key_codes.hpp)</li> <li>key_kp_equal (key_codes.hpp)</li> <li>key_kp_multiply (key_codes.hpp)</li> <li>key_kp_subtract (key_codes.hpp)</li> <li>key_l (key_codes.hpp)</li> <li>key_left (key_codes.hpp)</li> <li>key_left_alt (key_codes.hpp)</li> <li>key_left_bracket (key_codes.hpp)</li> <li>key_left_control (key_codes.hpp)</li> <li>key_left_shift (key_codes.hpp)</li> <li>key_left_super (key_codes.hpp)</li> <li>key_m (key_codes.hpp)</li> <li>key_menu (key_codes.hpp)</li> <li>key_minus (key_codes.hpp)</li> <li>key_n (key_codes.hpp)</li> <li>key_num_lock (key_codes.hpp)</li> <li>key_o (key_codes.hpp)</li> <li>key_p (key_codes.hpp)</li> <li>key_page_down (key_codes.hpp)</li> <li>key_page_up (key_codes.hpp)</li> <li>key_pause (key_codes.hpp)</li> <li>key_period (key_codes.hpp)</li> <li>key_print_screen (key_codes.hpp)</li> <li>key_q (key_codes.hpp)</li> <li>key_r (key_codes.hpp)</li> <li>key_right (key_codes.hpp)</li> <li>key_right_alt (key_codes.hpp)</li> <li>key_right_bracket (key_codes.hpp)</li> <li>key_right_control (key_codes.hpp)</li> <li>key_right_shift (key_codes.hpp)</li> <li>key_right_super (key_codes.hpp)</li> <li>key_s (key_codes.hpp)</li> <li>key_scroll_lock (key_codes.hpp)</li> <li>key_semicolon (key_codes.hpp)</li> <li>key_slash (key_codes.hpp)</li> <li>key_space (key_codes.hpp)</li> <li>key_tab (key_codes.hpp)</li> <li>key_u (key_codes.hpp)</li> <li>key_up (key_codes.hpp)</li> <li>key_v (key_codes.hpp)</li> <li>key_w (key_codes.hpp)</li> <li>key_world_1 (key_codes.hpp)</li> <li>key_world_2 (key_codes.hpp)</li> <li>key_x (key_codes.hpp)</li> <li>key_y (key_codes.hpp)</li> <li>key_z (key_codes.hpp)</li> </ul>"},{"location":"References/variables/#m","title":"m","text":"<ul> <li>mouse_button_0 (mouse_codes.hpp)</li> <li>mouse_button_1 (mouse_codes.hpp)</li> <li>mouse_button_2 (mouse_codes.hpp)</li> <li>mouse_button_3 (mouse_codes.hpp)</li> <li>mouse_button_4 (mouse_codes.hpp)</li> <li>mouse_button_5 (mouse_codes.hpp)</li> <li>mouse_button_6 (mouse_codes.hpp)</li> <li>mouse_button_7 (mouse_codes.hpp)</li> <li>mouse_button_last (mouse_codes.hpp)</li> <li>mouse_button_left (mouse_codes.hpp)</li> <li>mouse_button_middle (mouse_codes.hpp)</li> <li>mouse_button_right (mouse_codes.hpp)</li> </ul>"},{"location":"References/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}