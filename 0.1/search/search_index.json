{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udfe0 Home","text":"Welcome to Atlas's Home Page"},{"location":"#overview","title":"Overview","text":"<p>TheAtlasEngine is a cross-platform 3D game engine. That strives to be powerful with no restrictions to the user. Allowing to be used for educational, creative, and commerical purpose games.</p>"},{"location":"#the-basics","title":"The Basics","text":"<p>TheAtlasEngine is a 3D game engine that is comprised of variety of different systems. The engine aims to have the ability to make games and build cool projects with. The engine is built fully in C++. With an inetractive application that enables users to think of a different and creative way to making games.</p>"},{"location":"about/","title":"About TheAtlasEngine","text":"<p>Still in progress \ud83d\udea7</p> <p>Atlas started as a 2D interactive game engine that was built just for fun and to have a fun way of seeing how game engines are made. Using them to build fun games.</p> <p>Then Aaron (creator) of the project decided to on making this project now focused in 3D. Where it gives students the opportunities to work on a cool project. Then being able to seeing some great results and using them during game jam events.</p> <p>One of the most satisfying factors of building this project is being able to use them during game jams and submitting games developed by this engine. That is the feeling he wants to share with other students.</p>"},{"location":"getting_started/","title":"\ud83d\udcda Getting Started","text":""},{"location":"getting_started/#prerequisites","title":"\ud83d\udca5 Prerequisites","text":"<p>These are needed before working to get engine3d building successfully on your platform.</p> <ul> <li><code>python</code>: 3.12 or above</li> <li><code>conan</code>: 2.10.0 or above</li> <li><code>llvm</code>: 17 or above</li> <li><code>make</code>: CMake downloaded using conan to build Engine3D</li> <li><code>git</code>: Version control</li> </ul> WindowsUbuntu 20.0+MacOS X <p>Info</p> <p>Needs to install Visual Studio's installer before using the <code>winget</code> command</p> <p>Visual studio is required only on Windows for getting C++ to work</p> <p>Run this <code>winget</code> command to setup C++ with Visual Studio installer in powershell (in admin mode)</p> <pre><code>winget install Microsoft.VisualStudio.2022.BuildTools --override \"--add Microsoft.VisualStudio.Workload.VCTools --includeRecommended -p --installWhileDownloading\"\n</code></pre> <p>It is recommended to use Choco for an easy installation process on Windows.</p> <p>To install <code>choco</code>, open powershell with admin access and run the following command in your terminal (powershell must be admin):</p> <pre><code>Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n</code></pre> <p>Tip</p> <p>If <code>choco</code> command does not work after running this script try closing and reopening powershell again. When <code>choco</code> prompts you to run install scripts from the commands below, enter <code>all</code> so it can install everything.</p> <p>Install <code>git</code> (powershell must be admin): <pre><code>choco install git\n</code></pre></p> <p>Install <code>python</code> (powershell must be admin): <pre><code>choco install python --version=3.12.0\n</code></pre></p> <p>Install <code>llvm</code> (powershell must be admin):</p> <p>Error</p> <p>If you get this error make sure that your environment variable is set to LLVM's clang.exe and clang++.exe filepath.</p> <p>While also making sure </p> <pre><code>CMake Error at CMakeLists.txt:2 (project):\nThe CMAKE_CXX_COMPILER:\n\n    C:/Program Files/LLVM/bin/clang++.exe\n\nis not a full path to an existing compiler tool.\n</code></pre> <pre><code>choco install llvm\n</code></pre> <p>Install <code>conan</code> (powershell must be admin) <pre><code>pip install \"conan&gt;=2.10.2\"\n</code></pre></p> <p>Install cmake and make</p> <p>Error</p> <p>you can get this error if you DO NOT have 'make' installed via choco</p> <pre><code>CMake Error: CMake was unable to find a build program corresponding to \"Unix Makefiles\".  CMAKE_MAKE_PROGRAM is not set.  You probably need to select a different build tool.\n</code></pre> <p>Error</p> <p>you can get this error if you DO NOT have 'mingw' installed via choco</p> <p>CMake Error: CMake was unable to find a build program corresponding to \"MinGW Makefiles\".  CMAKE_MAKE_PROGRAM is not set.  You probably need to select a different build tool.</p> <pre><code>choco install make cmake\n</code></pre> <p>Info</p> <p>mingw is installed because we need <code>mingw32-make.exe</code> as dependencies will default to using \"MinGW Makefiles\" generator specified. which means that their CMake will look for <code>mingw32-make.exe</code> specific make executables instead of <code>make.exe</code></p> <p>Install mingw <pre><code>choco install mingw\n</code></pre></p> <p>Info</p> <p>Using this <code>winget</code> command will install Vulkan's installer, set it up for you, and set the environment path variable.</p> <p>Installing Vulkan's installer from the terminal in powershell. (in admin mode) <pre><code>winget install --id=KhronosGroup.VulkanSDK -e\n</code></pre></p> <p>Tip</p> <p>Once you have completely finish installing. DONT FORGET to refresh your powershell before building the engine3d project.</p> <p>Install wget if it isn't already on your system</p> <p><code>sudo apt-get install wget</code></p> <p>Install the latest version of <code>llvm</code></p> <pre><code>wget https://apt.llvm.org/llvm.sh\nchmod +x llvm.sh\nsudo ./llvm.sh\n</code></pre> <p>Install LLVM's C+ standard library (this will use the llvm apt repos)</p> <pre><code>sudo apt install libc++-17-dev libc++abi-17-dev\n</code></pre> <p>Installing Linux Prerequisites</p> <pre><code>sudo apt install -y lsb-release wget software-properties-common gnupg libgtk2.0-dev libgl1-mesa-dev\nsudo apt-get install -y libx11-dev libx11-xcb-dev libfontenc-dev libice-dev libsm-dev libxau-dev libxaw7-dev libxt-dev libxtst-dev libxrender-dev libxrandr-dev libxi-dev\nsudo apt install -y software-properties-common\nsudo add-apt-repository ppa:deadsnakes/ppa\n</code></pre> <p>Info</p> <p>If your using 20.04, you have to upgrade Python to 3.10</p> <pre><code>sudo apt update\nsudo apt install software-properties-common -y\nsudo add-apt-repository ppa:deadsnakes/ppa\nsudo apt install Python3.10\n</code></pre> <p>Install pipx which is used to install conan</p> <pre><code>sudo apt install pipx\n</code></pre> <p>Installing conan</p> <pre><code>pipx install \"conan&gt;=2.10.1\"\n</code></pre> <p>Tip</p> <p>On linux vulkan is not needed to be installed, conan handles that</p> <p>Install Homebrew:</p> <p><pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> Install latest version of Python &amp;&amp; llvm:</p> <pre><code>brew install python pipx llvm@17\n</code></pre> <p>Install conan:</p> <pre><code>pipx install \"conan&gt;=2.10.2\"\n</code></pre> <p>Make <code>clang-tidy</code> available on the command line:</p> <pre><code>sudo ln -s $(brew --prefix llvm)/bin/clang-tidy /usr/local/bin/\n</code></pre> <p>Install Rosetta (only required for M1 macs):</p> <pre><code>/usr/sbin/softwareupdate --install-rosetta --agree-to-license\n</code></pre> <p>Info</p> <p>metal-cpp does not need to be installed because conan handles this for you</p>"},{"location":"getting_started/#setting-up-conan","title":"\ud83d\udce6 Setting up Conan","text":"<p>Install host profiles for your specific platforms</p> WindowsX86 LinuxM1 Mac <p>If you are on an x86 architecture for Windows.</p> <pre><code>conan config install -sf profiles/x86_64/Windows/ -tf profiles https://github.com/engine3d-dev/conan-config.git\n</code></pre> <p>If you are on a linux platform that uses an x86 architecture.</p> <pre><code>conan config install -sf profiles/x86_64/linux/ -tf profiles https://github.com/engine3d-dev/conan-config.git\n</code></pre> <p>If you are on an M1 Mac OS.</p> <pre><code>conan config install -sf profiles/armv8/mac/ -tf profiles https://github.com/engine3d-dev/conan-config.git\n</code></pre>"},{"location":"getting_started/#getting-project-repositories-from-artifactory","title":"\ud83d\udce5 Getting project repositories from Artifactory","text":"<p>Add the engine3d-conan repository to your system. This repository holds all of the engine3d packages.</p> <pre><code>conan remote add engine3d-conan https://libhal.jfrog.io/artifactory/api/conan/engine3d-conan\n</code></pre>"},{"location":"getting_started/#development-environment-completed","title":"\u2705 Development Environment Completed!!","text":"<p>Once the development environment is completed. Then go to the repos to see the list of repositories that you plan to contribute to.</p>"},{"location":"summary/","title":"Summary","text":"<ul> <li>\ud83c\udfe0 Home</li> <li>\ud83d\udcda Getting Started</li> <li>\ud83d\udd79\ufe0f User Guide</li> <li>\ud83d\ude80 Contributor Guides</li> <li>\ud83c\udfa8 Style Guide</li> <li>\ud83d\udcdd Code Design</li> <li>\ud83d\udcdc Project Information</li> <li>About</li> <li>\ud83d\udcd6 APIs</li> </ul>"},{"location":"contributor_guide/code_design/","title":"\ud83d\udcdd Core Engine Design","text":""},{"location":"contributor_guide/code_design/#interfaces","title":"Interfaces","text":"<p>Interfaces are the foundation of how the api-agnostic API's may work if they have vary defined backends. They present a generalized ideal of a particular aspect of computing.</p> <p>For example, a graphics API such as vulkan, directX, and metal. They both contain their own varied version of a command buffer. In Vulkan it is referred to as VkCommandBuffer, DirectX referred to as ID3D12GraphicsCommandList, and metal it is referred to as MTLCommandBuffer.</p> <p>Which each of this implementation may be operated differently that is widely dependent on their API's.</p> <p>This following guideline should be kept in mind when creating interfaces.</p> <p>Here is an example of some interfaces in libhal. It is recommended to look at these to get an idea of how the interfaces could be written.</p> <ul> <li>atlas::render_context</li> </ul>"},{"location":"contributor_guide/code_design/#designing-and-making-interfaces","title":"Designing and Making Interfaces","text":"<p>Using vtables are quite small and only require a single pointer lookup. The initial idea that comes to mind with vtables is minimize least number of lookups that needs to be made to virtual functions if possible.</p> <p>why?</p> <p>Each virtual function in an interface will require a v-table entry (a pointer) in the v-table of each implementation of an interface. Specific sections of the binary. More you have to store in space.</p> <p>Consider</p> <p>Having an interface for graphics for supporting multiple graphics API called <code>render_context</code>. This render_context could be an interface that may be used for implement the different graphics-api backends such as Vulkan, Metal, and DirectX3D.</p> <p>These are implementations that will have common API's to do equivalent operations. The interface will have common API's for operations such as writing data to a vertex, index, or uniform buffer.</p> <p>The fundamental idea is interfaces should be used to allow a generalized API that internal state of the engine could interact without touching or using any api-dependent code within the engine. That should be completely handle and communicated via those abstraction layers around those API's.</p>"},{"location":"contributor_guide/code_design/#interfaces-not-used-for-actorsobjects","title":"Interfaces Not Used for Actors/Objects","text":"<p>Typically it is seen natural to have scene objects inherit from some virtual class to define a <code>UActor</code> (like unreal). As other engines will have their own variation of this.</p> <p>In this engine, I wanted to have a different look at building games, using a completely different approach in making games that does not have users by default be binded to a contract having them inherit a base class.</p> <p>These are caveuats I should mention below.</p> <ul> <li> <p>One of the biggest issue isn't just the binded contract devs have to make every time they need to make a new actor. Its also the size each actor now carries. What does this mean?</p> <ul> <li>This means that if you look at Unreal's and other engines they have their own variation of how they handle actors. Usually when creating custom actors that inherit, they carry the size of the objects they not only inherit of even if those functions do not get used.</li> <li>Which means bloated in class size in bytes.</li> </ul> </li> <li> <p>Amount of lookups in the vtable is quite high because lets look at particles for example.</p> <ul> <li>If we have particles that may vary in different aspects of geometry, mesh, assets, etc. The amount of difference in data can actually be widely expansive. What initially would happen is we'd have to lookup the vtable entry to get information about the actor every time we need something</li> <li>When we already know its memory location and where this scene object is located, we could minimize these caveuts and initially minimizing code bloatware of binary sizes because we are not creating actors through inheritance.</li> </ul> </li> </ul> <p>Given this example.</p> <p>In game engines today, you will have some variation following this approach.</p> <pre><code>class MyActor : public AActor {\npublic:\n    /* do other pre-init state initialization needed in implementation */\nprotected:\n    virtual void BeginPlay() override { /* do stuff when begin play ticked */ }\n};\n</code></pre>"},{"location":"contributor_guide/code_design/#different-perspective-creating-actors","title":"Different Perspective Creating Actors","text":"<p>In TheAtlasEngine rather then needing to inherit from some base class to define the actor. That ability should be open to the user in how they define what their actors are implemented.</p> <p>What the engine would be looking at when users create their own actors. Are the update logic, what time intervals these logic get updated, and how their scene objects get rendered. Currently these are what we are looking for and still defining other areas within developing atlas.</p> <p>As of the current time of writing this new approach. This approach is still early in it's development and there are a few factors that will be needed to consider as the engine goes through its development.</p> <p>Reasons currently why I made the decision to separate the two sync_* functions is because rather then having a single function to do the checking for us. I would prefer if that decision is given to the users giving them the option of when they would like their logic to be updated during update or physics time intervals.</p> <p>The main reason currently (will change indefinitely) is when inheriting a <code>atlas::scene_scope</code> this automatically registers to the defualt <code>atlas::world_scope</code> that is defined by default.</p> <p>In the future, I will provide a functionality to enable control over which world to register, as of right now this functionality only assumes their is one world that is created.</p> <p>Issues that are alleviated</p> <ul> <li>Bloat in the amount of bytes each custom actor contain when inheriting from a custom base class. Making binary sizes larger.</li> <li>Vtable Entry Lookups when needing an implementation detail for that actor</li> <li>Binded contract whenever a scene object is needed to be customizably created</li> </ul> <pre><code>class level_scene : public scene_scope{\npublic:\n    level_scene(const std::string&amp; p_tag) : scene_scope(p_tag) {\n        // Registrying entity \"Empty Entity\" to this scene its created in\n        m_object = empty_entity(\"Empty Entity\");\n\n        // Registrying entity \"Sphere\" to this scene its created in\n        m_sphere = sphere_entity(\"Sphere\");\n\n\n        // This registers our update callable and associates the address of our current scene\n        // then calling this function\n        atlas::sync(this, &amp;level_scene::update);\n\n        // physics() gets called during the interval of physics steps since the timing\n        // for physics can be different compared to logic during update\n        atlas::sync_physics(this, &amp;level_scene::physics);\n    }\n\n\n    void update() {\n        // Running our update logic for being called\n    }\n\n    void physics() {\n        // Running physics logic at the right time interval physics should run at.\n    }\n\nprivate:\n    atlas::scene_object m_object;\n    atlas::scene_object m_sphere;\n};\n</code></pre>"},{"location":"contributor_guide/philosophy/","title":"Code Design","text":"<p>The core design tenets of <code>atlas</code> and libraries extending must seek to achieve every design choice, line written, and architecture made.</p> <p>D.0. General</p> <p><code>atlas</code> abstraction API's such as <code>engine-audio</code> should focus on enabling configurational settings that does not have users directly writing backend code. If users decide to use <code>engine-audio</code> they should not be touching any piece of code or API of miniaudio.</p> <p>D.1 Minimalist</p> <p><code>atlas</code> aims to be as simple as possible and no simpler. Libraries, Classes, implementation, and features should be implemented to handle currend edge cases. Then focus on expanding afterwards.</p> <p>D.2 Safe &amp; Reliable</p> <p><code>atlas</code> and its style guide uses patterns, techniques, and documentation to reduce safety issues and improve reliability throught out its codebases.</p> <p>D.3 Tested &amp; Testable</p> <p><code>atlas</code> codebases should be as testable and unit tested.</p> <p>D.4 Portable</p> <p>NOTE: In-progress</p> <p>As of this current moment in the early development of <code>atlas</code>, we only support windows.</p> <p><code>atlas</code> will aim to support multiple OS's backends. Such as for Linux and Mac.</p>"},{"location":"contributor_guide/style/","title":"\ud83c\udfa8 Style Guide","text":""},{"location":"contributor_guide/style/#s0-code-guidelines","title":"S.0 Code Guidelines","text":"<p>All guides follow the C++ Core Guidelines.</p>"},{"location":"contributor_guide/style/#s1-code-guidelines","title":"S.1. Code Guidelines","text":"<ul> <li> <p>Code in the atlas organization will follow the <code>.clang-format</code> file, which uses the Mozilla's</p> </li> <li> <p>Code will follow the atlas organization's <code>.naming.style</code> file, which are similar to the standard library's naming convention.</p> </li> <li> <p>CAP_CASE for MACROs (avoid MACROs in general).</p> </li> <li> <p>CamelCase used for template parameters</p> </li> <li>lowercase snake_case for everything else</li> <li>prefix <code>p_</code> for function parameters</li> <li> <p>prefix <code>m_</code> for private/protected class members</p> </li> <li> <p>Refrain from abbreviated variable name. Don't do <code>m_cnt</code> and just write out <code>m_count</code>.</p> </li> <li>Every file must end with a newline character.</li> <li>Every line in a file must stay within 80 character limit.</li> <li>Include C++ header versions of C headers such as <code>&lt;cstdint&gt;</code> vs <code>&lt;stdint.h&gt;</code></li> </ul>"},{"location":"contributor_guide/style/#s2-refrain-from-using-macros","title":"S.2. Refrain from using MACROS","text":"<p>Usually macros are replaced with <code>constexpr</code> or const variables or function calls.</p> <p>Only use preprocessors <code>#if</code> and the like if it is impossible to use <code>if constexpr</code> to achieve the same behavior.</p>"},{"location":"contributor_guide/style/#s3-interfaces-should-follow-the-public-private-api-scheme","title":"S.3. Interfaces should follow the public private API scheme.","text":"<p>See private virtual methods for more details. Rationale can be found with that link as well.</p>"},{"location":"contributor_guide/style/#s4-avoid-using-bool-as","title":"S.4. Avoid using <code>bool</code> as","text":"<p>NOTE: This is still in-progress</p>"},{"location":"contributor_guide/style/#s5-include-guards","title":"S.5. Include guards","text":"<p>For ease of usage, use <code>#pragma once</code> as your include guard. Usage of classic include guards like:</p> <pre><code>#ifndef FOO\n#define FOO\n\n#endif // FOO\n</code></pre> <p>Are annoying and error prone. Do not use these!</p> <p>S.6. Include Ordering</p> <p>Headers should be included in your header and source files in the following order:</p> <ul> <li> <p>C standard library headers. Include using chevrons: <code>&lt;&gt;</code></p> </li> <li> <p>C++ 3rd party library packages. Include using chevrons: <code>&lt;&gt;</code></p> </li> <li> <p>C++ Standard library headers. Include using chevrons: <code>&lt;&gt;</code></p> </li> <li> <p>Local Header/Project Headers. Include using quotes <code>\"\"</code></p> </li> </ul> <p>For standard C headers use C++ <code>&lt;cstdio&gt;</code> style over the C <code>&lt;stdio.h&gt;</code> style.</p> <p>Example of how this should look:</p> <pre><code>#pragma once\n\n// C header first\n#include &lt;cstdio&gt;\n#include &lt;cstdint&gt;\n\n// C++ headers\n#include &lt;string_view&gt;\n#include &lt;span&gt;\n\n// C++ library header s\n#include &lt;atlas/application.hpp&gt;\n#include &lt;atlas/core/event/event.hpp&gt;\n\n// Local project\n#include \"game-template/content/custom_scene.hpp\"\n#include \"game-template/content/custom_actor.hpp\"\n\n// actual code goes here\n</code></pre> <p>Exception: <code>boost.ut</code> must ALWAYS be the last include in your code in order to allow <code>ostream operator&lt;&lt;</code> overloading to work.</p>"},{"location":"contributor_guide/style/#s6-classes","title":"S.6. Classes","text":""},{"location":"contributor_guide/style/#s61-declaration-order","title":"S.6.1. Declaration Order","text":"<p>Class's visibility specifiers and member sections should appear in the following order.</p> <ol> <li> <p>Public.</p> </li> <li> <p>Protected.</p> </li> <li> <p>Private.</p> </li> </ol> <p>Omit any sections that would be empty.</p> <p>Within each section, group similar declarations together this order and follow this order:</p> <ol> <li> <p>Types and type aliases</p> <ul> <li> <p>Using directives (<code>using</code>)</p> </li> <li> <p>Enum Classes</p> </li> <li> <p>Nested structs and classes</p> </li> <li> <p>Friend classes and structs</p> </li> </ul> </li> <li> <p>Static constants</p> </li> <li>Factory functions (if applicable)</li> <li>Constructors and assignment operators</li> <li>Destructor</li> <li>All other member functions (static and non static member functions, as well as friend functions)</li> <li>All other data members (static and non-static)</li> </ol> <p>Do not put large method definitions inline within the class definition. Typically only trivial or performance critical methods \\ that are very short may be defined inline. If the class as a template, then all functions must be defined inline in the\\ header file.</p> <p>Note</p> <p>if a friend is a class or class function, then the friend should appear under the same visibility \\ specifier as a friend. For example, if you are friending a private class function, then the friend \\ function delcaration should also appear in the private section of the friending class.</p>"},{"location":"contributor_guide/style/#s62-storing-references","title":"S.6.2. Storing References","text":"<p>Class within the project should not have reference member variables like so:</p> <pre><code>class my_scene {\npublic:\n    my_scene(flecs::registry&amp; p_registry) : m_registry(p_registry) {}\n\nprivate:\n    flecs::registry&amp; m_registry;\n};\n</code></pre> <p>Reference members implicitly delete copy constructors of a class they are within because they are themselves are not copyable. You cannot reassign a reference after it's made.</p> <p>Instead take the parameter as a reference but save its address as a pointer.</p> <pre><code>class my_scene {\npublic:\n    my_scene(flecs::registry&amp; p_registry) : m_registry(&amp;p_registry) {}\n\nprivate:\n    flecs::registry* m_registry;\n};\n</code></pre>"},{"location":"user_guide/setup_vscode/","title":"\ud83d\udd79\ufe0f Setting VSCode w/ <code>clangd</code>","text":"<p>The majority of the contributors and users uses Visual Studio Code. These guidelines should also help with non-vscoders as well.</p>"},{"location":"user_guide/setup_vscode/#setup-vscode-configuration","title":"Setup VSCode Configuration","text":"<p>Make sure you already install clang via getting started.</p> <ol> <li>Install VSCode if you haven't already done so.</li> <li>Go to the \"Extensions\" section on left-side of the bar. It looks like 4 blocks with the upper right-hand block disconnected from the other 3. Hover over the icons to get their name.</li> <li>Search for \"C/C++\" and disable the Windows intellisense extension if it is already installed and enabled.</li> <li>Search for the extension <code>clangd</code> and install the extension.</li> <li>Go to the <code>clangd</code> extension settings page. Find <code>clangd</code> extension and press the GEAR \u2699\ufe0f icon to open in settings.</li> <li>Find the settings <code>clangd: Arguments</code> and add:<ol> <li>In <code>Clangd: Arguments</code> input <code>--header-insertion=never</code></li> </ol> </li> </ol>"},{"location":"user_guide/setup_vscode/#disable-vscode-default-intellisense","title":"Disable VSCode Default Intellisense","text":"<p>When using <code>clangd</code> it will conflict with Visual Studio Code's default intellisense. This is how you can disable it.</p> <p>Follow the same setups above. In the intellisense sections in the extensions for \"C/C++\".</p> <p>Check the disable checkbox as shown below</p> <p></p>"},{"location":"user_guide/setup_vscode/#disable-auto-include-headers","title":"Disable auto-include headers","text":"<p>If you do not want auto-imported headers and are already including them if you have precompiled headers setup. This is how you can disable them.</p> <p>Clangd arguments should look like this:</p> <p></p>"},{"location":"user_guide/setup_vscode/#used-in-your-own-project","title":"Used in your own project","text":"<p>You can either add a <code>self.requires(\"engine3d-cmake-utils/3.0\")</code> to your project or add the following lines to your <code>CMakeLists.txt</code></p> <pre><code># Generate compile commands for anyone using our libraries.\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n\n# Always run this custom target by making it depend on ALL\nadd_custom_target(copy_compile_commands ALL\n    COMMAND ${CMAKE_COMMAND} -E copy_if_different\n    ${CMAKE_BINARY_DIR}/compile_commands.json\n    ${CMAKE_SOURCE_DIR}/compile_commands.json\n    DEPENDS ${CMAKE_BINARY_DIR}/compile_commands.json)\n</code></pre> <p>Run <code>conan build .</code> (where <code>.</code> is the path to your project/library) and it should generate the <code>compile_commands.json</code> file.</p> <p>To ensure that the dependencies in your <code>conanfile.py</code> file that uses <code>self.requires</code>.</p> <p>You can also run with <code>-b missing</code> (where <code>-b missing</code> indicates that to install any missing binary into the conan cache)</p> <pre><code>conan build . -b missing\n</code></pre>"},{"location":"user_guide/setup_vscode/#how-clangd-works","title":"How <code>clangd</code> works","text":"<p>Once you get <code>clangd</code> setup. Let me tell you how clangd works. Your workspace needs <code>compile_commands.json</code> file to be present or using <code>.clangd</code> in the root of your project's directory to be configured to know where to look for the location the <code>compile_commands.json</code> is located.</p> <p><code>compile_commands.json</code> tells <code>clangd</code> what commands you are using in order to determine exactly how your files are build and whjat commands are used to build them. Which provides the following benefits:</p> <ol> <li>More accurate warnings and error messages within your IDE.</li> <li>Faster response time because only the necessary includes for the specific version you are targeted will be used when evaluated.</li> </ol>"}]}