{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83c\udfe0 Home","text":"Welcome to Atlas's Home Page"},{"location":"#overview","title":"Overview","text":"<p>TheAtlasEngine is a cross-platform 3D game engine. That strives to be powerful with no restrictions to the user. Allowing to be used for educational, creative, and commerical purpose games.</p>"},{"location":"#the-basics","title":"The Basics","text":"<p>TheAtlasEngine is a 3D game engine that is comprised of variety of different systems. The engine aims to have the ability to make games and build cool projects with. The engine is built fully in C++. With an inetractive application that enables users to think of a different and creative way to making games.</p>"},{"location":"about/","title":"About TheAtlasEngine","text":"<p>Still in progress \ud83d\udea7</p> <p>Atlas started as a 2D interactive game engine that was built just for fun and to have a fun way of seeing how game engines are made. Using them to build fun games.</p> <p>Then Aaron (creator) of the project decided to on making this project now focused in 3D. Where it gives students the opportunities to work on a cool project. Then being able to seeing some great results and using them during game jam events.</p> <p>One of the most satisfying factors of building this project is being able to use them during game jams and submitting games developed by this engine. That is the feeling he wants to share with other students.</p>"},{"location":"getting_started/","title":"\ud83d\udcda Getting Started","text":""},{"location":"getting_started/#prerequisites","title":"\ud83d\udca5 Prerequisites","text":"<p>These are needed before working to get TheAtlasEngine building successfully on your platform.</p> <ul> <li><code>python</code>: 3.12 or above</li> <li><code>conan</code>: 2.18.0 or above</li> <li><code>llvm</code>: 17 or above</li> <li><code>CMake</code> Build tool for the project</li> <li><code>git</code>: Version control</li> </ul> WindowsUbuntu 20.0+MacOS X <p>Info</p> <p><code>winget</code> command is to install Visual Studio with minimal default C++ configurations installation</p> <p>Run this <code>winget</code> command to setup C++ with Visual Studio installer in powershell (in admin mode)</p> <pre><code>winget install Microsoft.VisualStudio.2022.BuildTools --override \"--add Microsoft.VisualStudio.Workload.VCTools --includeRecommended -p --installWhileDownloading\"\n</code></pre> <p>It is recommended to use Choco for an easy installation process on Windows.</p> <p>To install <code>choco</code>, open powershell with admin access and run the following command in your terminal (powershell must be admin):</p> <pre><code>Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n</code></pre> <p>Tip</p> <p>If <code>choco</code> command does not work after running this script try closing and reopening powershell again. When <code>choco</code> prompts you to run install scripts from the commands below, enter <code>all</code> so it can install everything.</p> <p>Install <code>git</code> (powershell must be admin): <pre><code>choco install git\n</code></pre></p> <p>Install <code>python</code> (powershell must be admin): <pre><code>choco install python --version=3.18.0\n</code></pre></p> <p>Install <code>llvm</code> (powershell must be admin):</p> <p>Error</p> <p>If you get this error make sure that your environment variable is set to LLVM's clang.exe and clang++.exe filepath.</p> <p>While also making sure </p> <pre><code>CMake Error at CMakeLists.txt:2 (project):\nThe CMAKE_CXX_COMPILER:\n\n    C:/Program Files/LLVM/bin/clang++.exe\n\nis not a full path to an existing compiler tool.\n</code></pre> <p>Installing llvm toolchain (powershell must be in admin) <pre><code>choco install llvm\n</code></pre></p> <p>Install <code>conan</code> (powershell must be admin) <pre><code>pip install \"conan&gt;=2.10.2\"\n</code></pre></p> <p>Install cmake and make</p> <p>Error</p> <p>you can get this error if you DO NOT have 'make' installed via choco</p> <pre><code>CMake Error: CMake was unable to find a build program corresponding to \"Unix Makefiles\".  CMAKE_MAKE_PROGRAM is not set.  You probably need to select a different build tool.\n</code></pre> <p>Error</p> <p>you can get this error if you DO NOT have 'mingw' installed via choco</p> <p>CMake Error: CMake was unable to find a build program corresponding to \"MinGW Makefiles\".  CMAKE_MAKE_PROGRAM is not set.  You probably need to select a different build tool.</p> <pre><code>choco install make cmake\n</code></pre> <p>Info</p> <p>mingw is installed because we need <code>mingw32-make.exe</code> as dependencies will default to using \"MinGW Makefiles\" generator specified. which means that their CMake will look for <code>mingw32-make.exe</code> specific make executables instead of <code>make.exe</code></p> <p>Install mingw (powershell must be in admin) <pre><code>choco install mingw\n</code></pre></p> <p>Info</p> <p>Using this <code>winget</code> command will install Vulkan's installer, set it up for you, and set the environment path variable.</p> <p>Get Vulkan's installer. (powershell must be in admin) <pre><code>winget install --id=KhronosGroup.VulkanSDK -e\n</code></pre></p> <p>Important</p> <p>DO NOT FORGET to refresh or close out of your terminal before compiling. Once installation has been completed.</p> <p>Install wget if it isn't already on your system</p> <p><code>sudo apt-get install wget</code></p> <p>Install the latest version of <code>llvm</code></p> <pre><code>wget https://apt.llvm.org/llvm.sh\nchmod +x llvm.sh\nsudo ./llvm.sh\n</code></pre> <p>Install LLVM's C+ standard library (this will use the llvm apt repos)</p> <pre><code>sudo apt install libc++-17-dev libc++abi-17-dev\n</code></pre> <p>  Installing Linux Prerequisites  <p><pre><code>sudo apt install -y lsb-release wget software-properties-common gnupg libgtk2.0-dev libgl1-mesa-dev\nsudo apt-get install -y libx11-dev libx11-xcb-dev libfontenc-dev libice-dev libsm-dev libxau-dev libxaw7-dev libxt-dev libxtst-dev libxrender-dev libxrandr-dev libxi-dev\nsudo apt install -y software-properties-common\nsudo add-apt-repository ppa:deadsnakes/ppa\n</code></pre> </p> <p>  If your using 20.04, you have to upgrade Python to 3.10  <p><pre><code>sudo apt update\nsudo apt install software-properties-common -y\nsudo add-apt-repository ppa:deadsnakes/ppa\nsudo apt install Python3.10\n</code></pre> </p> <p>Install pipx which is used to install conan</p> <pre><code>sudo apt install pipx\n</code></pre> <p>Installing conan</p> <pre><code>pipx install \"conan&gt;=2.18.1\"\n</code></pre> <p>Important</p> <p>If you are installing to compile TheAtlasEngine. Conan already installs Vulkan for you automatically.</p> <p>Install Homebrew:</p> <p><pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> Install latest version of Python &amp;&amp; llvm:</p> <pre><code>brew install python pipx llvm@17\n</code></pre> <p>Install conan:</p> <pre><code>pipx install \"conan&gt;=2.18.2\"\n</code></pre> <p>Make <code>clang-tidy</code> available on the command line:</p> <pre><code>sudo ln -s $(brew --prefix llvm)/bin/clang-tidy /usr/local/bin/\n</code></pre> <p>Install Rosetta (only required for M1 macs):</p> <pre><code>/usr/sbin/softwareupdate --install-rosetta --agree-to-license\n</code></pre> <p>Note</p> <p>On MacOS there are plans in using metal (metal-cpp) instead of Vulkan. Which conan also handles for you.</p>"},{"location":"getting_started/#setting-up-conan","title":"\ud83d\udce6 Setting up Conan","text":"<p>Install host profiles for your specific platforms</p> WindowsX86 LinuxM1 Mac <p>If you are on an x86 architecture for Windows.</p> <pre><code>conan config install -sf profiles/x86_64/Windows/ -tf profiles https://github.com/engine3d-dev/conan-config.git\n</code></pre> <p>If you are on a linux platform that uses an x86 architecture.</p> <pre><code>conan config install -sf profiles/x86_64/linux/ -tf profiles https://github.com/engine3d-dev/conan-config.git\n</code></pre> <p>If you are on an M1 Mac OS.</p> <pre><code>conan config install -sf profiles/armv8/mac/ -tf profiles https://github.com/engine3d-dev/conan-config.git\n</code></pre>"},{"location":"getting_started/#getting-project-repositories-from-artifactory","title":"\ud83d\udce5 Getting project repositories from Artifactory","text":"<p>Add the engine3d-conan repository to your system. This repository holds all of the TheAtlasEngine packages.</p> <pre><code>conan remote add engine3d-conan https://libhal.jfrog.io/artifactory/api/conan/engine3d-conan\n</code></pre>"},{"location":"getting_started/#development-environment-completed","title":"\u2705 Development Environment Completed!!","text":"<p>Once the development environment is completed. Then go to the repos to see the list of repositories that you plan to contribute to.</p>"},{"location":"getting_started/#changing-build-type","title":"Changing Build Type","text":"<p>The build type determines level of optimizations for the project you are building for. TheAtlasEngine by default is <code>Release</code> is because performance is one of the most important aspects of the project.</p> <p>It is highly recommended during developing of features to build with <code>Debug</code> enabled.</p> <p>Tip</p> <p><code>-b missing</code> only used during your first build.</p> <p>Means to install any missing dependency binaries into conan cache before compiling the project.</p> <p>You can change <code>build_type</code> to the following types:</p> <ul> <li> <p><code>Debug</code>: Turns on some optimizations to reduce binary size and improve performance while still maintaining the structure to make debugging easier. Recommended for testing and prototyping.</p> </li> <li> <p><code>Release</code>: Turns on optimizations and favors high-performance optimizations over space-saving optimizations.</p> </li> <li> <p><code>MinSizeRel</code>: Turns on optimizations and favor higher space saving optimizations over higher-performance.</p> </li> </ul>"},{"location":"summary/","title":"Summary","text":"<ul> <li>\ud83c\udfe0 Home</li> <li>\ud83d\udcda Getting Started</li> <li>\ud83d\udd79\ufe0f User Guide</li> <li>\ud83d\ude80 Contributor Guides</li> <li>\ud83c\udfa8 Style Guide</li> <li>\ud83d\udcdd Code Design</li> <li>philosophy</li> <li>\ud83d\udcdc Project Information</li> <li>About</li> <li>\ud83d\udcd6 Docs</li> </ul>"},{"location":"about/faq/","title":"Frequently Asked Questions","text":"<p>TheAtlasEngine is an open-source 3D game engine that are being developed by SF State computer science students. The project is open-source under the Apache 2.0 license.</p> <p>Some of the goals that we have in mind when designing TheAtlasEngine is to making game applications smaller without paying for any performance losses. Even if you do, the losses should not be that noticeable.</p>"},{"location":"about/faq/#what-platforms-does-theatlasengine-support","title":"What platforms does TheAtlasEngine support?","text":"<p>We only support Windows. Though do have plans to have support for Mac and Linux in the future.</p>"},{"location":"about/faq/#how-are-game-objects-represented-in-theatlasengine","title":"How are game objects represented in TheAtlasEngine?","text":"<p>We believe that using data-oriented design for your game objects allows for flexibility in specifying simple game objects to much more complexed game objects. This does not range from simply game objects, but their state is also handled quite differently</p> <p>Code design behind TheAtlasEngine strives to make use of callbacks for tracking game object state. As we believe that rather then having a heirarchy system to model your game object state around, this should fully be an option for the user to supply their game logic to TheAtlasEngine to be executed at different framerates.</p> <p>We provide a data-driven design for game objects and how their state get represented. This decision was to provide developers maximum flexibility, allowing you to easily build objects.</p> <p>Ranging from simple game objects to more complex game objects. Rather then forcing you into a heirarchy system for managing state, we use a registration callback system that represent your state.</p> <p>By using callbacks. This removes the need to have developers follow a heirarchy system rules to get their game logic to be executed. We allow you to simply call our registration API's that execute your game logic based on specific registration API you call.</p> <p>Providing this approach in handling game object state through callbacks, make it simpler for developers who want to have their game be executed at different framerates to still get that experience without needing to inherit from a base-class or go through a heirarchial system to get that to work.</p>"},{"location":"about/faq/#how-much-of-the-c-stl-does-theatlasengine-use","title":"How much of the C++ STL does TheAtlasEngine use?","text":"<p>TheAtlasEngine uses the standard C++ STL by default. We avoid \"reinventing the wheel\" to keep our codebase simpler and reduce complexity. The only time we should feel to replace parts of the STL we fully make use is if benchmarks clearly show details of bottlenecks in our codebase.</p> <p>This choice reduces the overhead of maintaining a separate, full-featured STL implementation that would require resources to continue maintaining.</p>"},{"location":"contributor_guide/code_design/","title":"\ud83d\udcdd Core Designs in TheAtlasEngine","text":""},{"location":"contributor_guide/code_design/#no-virtual-runtime-polymorphism-for-game-state","title":"No Virtual Runtime Polymorphism for game state","text":"<p>We do not use virtual runtime polymorphism to represent our game state. Reasons for this is because we believe that we did not want to use a heirarchy system to ensure the state of the user-defined game object are executed.</p> <p>If we used virtual polymorphism, what this would bring is the final object will carry the information of the base classes it inherits into the final object. Making the vtable larger because of the virtual API's that it needs to be aware of. I believe this can turn to be quite a complex approach to modeling game objects around.</p> <p>Here were reasons I chose not to leverage runtime polymorphism: * Large vtables carried to the final object at the bottom of the heirarchy system * Dependencies required to model around every known state a game object could potentially be in * Code bloat due to coupling the game object tied to a heirarchy system for also managing its state.</p> <p>Preface</p> <p>This DOES NOT mean we fully only use data-driven in our codebase, as we do use virtual polymorphism.</p>"},{"location":"contributor_guide/code_design/#game-objects-are-data-driven","title":"Game objects are Data-Driven","text":"<p>Game objects themselves are data-driven, which do not store any state related to the game logic behavior that is written by the user.</p> <p>Theses are both reasons I chose to move away from virtual runtime polymorphism for game objects: * Minimize and reduce dependencies needed for game object creation * Slim down dependencies which gets passed into the final object's vtable * Reduce code boilerplate by reducing decoupling from those dependencies * Use only what you need with creating game objects. * Game objects are data-driven that get processed</p>"},{"location":"contributor_guide/code_design/#callbacks-for-representing-game-state","title":"Callbacks for Representing Game State","text":"<p>Rather then modeling around using runtime polymorphism. Which relies in having a heirarchy system for every potential state a game object can be in.</p> <p>TheAtlasEngine makes use of callbacks to provide users the flexibility and minimal requirements in writing their game logic. While giving the choice to decide when their logic should be executed at different framerates.</p> <p>Registration Callbacks do not couple how you name your function, require you to specify any parameters for when your logic gets executed, or any other coupled requirements. Goal behind the callback was so as the user, you did not have to specify a requirements to get your logic to be executed.</p> <p>In the demonstration below, is how the callback system works. Removing</p>  Register Callbacks Code Example  <pre><code>class main_scene : public atlas::scene {\npublic:\n    main_scene(std::string_view p_name) : atlas::scene(p_name) {\n        // execution at scene pre-load stage\n        atlas::register_start(this, &amp;main_scene::preload);\n\n        // execute main_scene::game_inputs at general update framerate\n        atlas::register_update(this, &amp;main_scene::game_inputs);\n\n        // execute main_scene::physics_logic at fixed physics framerates\n        atlas::register_physics(this, &amp;main_scene::physics_logic);\n\n        // execute main_scene::ui_update at deferred frame update time\n        atlas::register_ui(this, &amp;main_scene::ui_update);\n    }\n\n    void preload() {\n        // execute during level's pre-load early on in the event execution process\n    }\n\n    void game_inputs() {\n        // code is ran during the runtime general framerate\n    }\n\n\n    void physics_logic() {\n        // code is ran during the physics fixed framerate\n    }\n\n    void ui_update() {\n        // code for UI such as HUD's or overlays can go here\n    }\n};\n</code></pre>"},{"location":"contributor_guide/philosophy/","title":"Code Design","text":"<p>The core design tenets of <code>atlas</code> and libraries extending must seek to achieve every design choice, line written, and architecture made.</p> <p>D.0. General</p> <p><code>atlas</code> abstraction API's such as <code>audio-cpp</code> should focus on enabling configurational settings that does not have users directly writing backend code. If users decide to use <code>engine-audio</code> they should not be touching any piece of code or API of miniaudio.</p> <p>D.1 Minimalist</p> <p><code>atlas</code> aims to be as simple as possible and no simpler. Libraries, Classes, implementation, and features should be implemented to handle current edge cases. Then focus on expanding afterwards.</p> <p>D.2 Safe &amp; Reliable</p> <p><code>atlas</code> and its style guide uses patterns, techniques, and documentation to reduce safety issues and improve reliability throught out its codebases.</p> <p>D.3 Tested &amp; Testable</p> <p><code>atlas</code> codebases should be as testable and unit tested.</p> <p>D.4 Portable</p> <p><code>atlas</code> aim to have cross-platform support, that is not just for Windows.</p> <p>In-progress</p> <p>Currently we only support Windows.</p>"},{"location":"contributor_guide/style/","title":"\ud83c\udfa8 Style Guide","text":""},{"location":"contributor_guide/style/#s0-code-guidelines","title":"S.0 Code Guidelines","text":"<p>All guides follow the C++ Core Guidelines.</p>"},{"location":"contributor_guide/style/#s1-code-guidelines","title":"S.1. Code Guidelines","text":"<ul> <li> <p>Code in the atlas organization will follow the <code>.clang-format</code> file, which uses the Mozilla's</p> </li> <li> <p>Code will follow the atlas organization's <code>.naming.style</code> file, which are similar to the standard library's naming convention.</p> </li> <li> <p>CAP_CASE for MACROs (avoid MACROs in general).</p> </li> <li> <p>CamelCase used for template parameters</p> </li> <li>lowercase snake_case for everything else</li> <li>prefix <code>p_</code> for function parameters</li> <li> <p>prefix <code>m_</code> for private/protected class members</p> </li> <li> <p>Refrain from abbreviated variable name. Don't do <code>m_cnt</code> and just write out <code>m_count</code>.</p> </li> <li>Every file must end with a newline character.</li> <li>Every line in a file must stay within 80 character limit.</li> <li>Include C++ header versions of C headers such as <code>&lt;cstdint&gt;</code> vs <code>&lt;stdint.h&gt;</code></li> </ul>"},{"location":"contributor_guide/style/#s2-refrain-from-using-macros","title":"S.2. Refrain from using MACROS","text":"<p>Usually macros are replaced with <code>constexpr</code> or const variables or function calls.</p> <p>Only use preprocessors <code>#if</code> and the like if it is impossible to use <code>if constexpr</code> to achieve the same behavior.</p>"},{"location":"contributor_guide/style/#s3-interfaces-should-follow-the-public-private-api-scheme","title":"S.3. Interfaces should follow the public private API scheme.","text":"<p>See private virtual methods for more details. Rationale can be found with that link as well.</p>"},{"location":"contributor_guide/style/#s4-avoid-using-bool-as","title":"S.4. Avoid using <code>bool</code> as","text":"<p><code>bool</code> is fine if it is the only parameter and it acts as a lexical switch, for an example:</p> <pre><code>// Resize window event has occurred\nm_swapchain.resize(true);\n\n// Resize window event has not occurred\nm_swapchain.resize(false);\n</code></pre> <p>See the article \"Clean code: The curse of a boolean parameter\" for why bool parameters are awful.</p>"},{"location":"contributor_guide/style/#s5-include-guards","title":"S.5. Include guards","text":"<p>For ease of usage, use <code>#pragma once</code> as your include guard. Usage of classic include guards like:</p> <pre><code>#ifndef FOO\n#define FOO\n\n#endif // FOO\n</code></pre> <p>Are annoying and error prone. Do not use these!</p> <p>S.6. Include Ordering</p> <p>Headers should be included in your header and source files in the following order:</p> <ul> <li> <p>C standard library headers. Include using chevrons: <code>&lt;&gt;</code></p> </li> <li> <p>C++ 3rd party library packages. Include using chevrons: <code>&lt;&gt;</code></p> </li> <li> <p>C++ Standard library headers. Include using chevrons: <code>&lt;&gt;</code></p> </li> <li> <p>Local Header/Project Headers. Include using quotes <code>\"\"</code></p> </li> </ul> <p>For standard C headers use C++ <code>&lt;cstdio&gt;</code> style over the C <code>&lt;stdio.h&gt;</code> style.</p> <p>Example of how this should look:</p> <pre><code>#pragma once\n\n// C header first\n#include &lt;cstdio&gt;\n#include &lt;cstdint&gt;\n\n// C++ headers\n#include &lt;string_view&gt;\n#include &lt;span&gt;\n\n// C++ library header s\n#include &lt;core/application.hpp&gt;\n#include &lt;core/event/event.hpp&gt;\n\n// Local project\n#include \"main_scene.hpp\"\n\n// actual code goes here\n</code></pre> <p>Exception: <code>boost.ut</code> must ALWAYS be the last include in your code in order to allow <code>ostream operator&lt;&lt;</code> overloading to work.</p>"},{"location":"contributor_guide/style/#s6-classes","title":"S.6. Classes","text":""},{"location":"contributor_guide/style/#s61-declaration-order","title":"S.6.1. Declaration Order","text":"<p>Class's visibility specifiers and member sections should appear in the following order.</p> <ol> <li> <p>Public.</p> </li> <li> <p>Protected.</p> </li> <li> <p>Private.</p> </li> </ol> <p>Omit any sections that would be empty.</p> <p>Within each section, group similar declarations together this order and follow this order:</p> <ol> <li> <p>Types and type aliases</p> <ul> <li> <p>Using directives (<code>using</code>)</p> </li> <li> <p>Enum Classes</p> </li> <li> <p>Nested structs and classes</p> </li> <li> <p>Friend classes and structs</p> </li> </ul> </li> <li> <p>Static constants</p> </li> <li>Factory functions (if applicable)</li> <li>Constructors and assignment operators</li> <li>Destructor</li> <li>All other member functions (static and non static member functions, as well as friend functions)</li> <li>All other data members (static and non-static)</li> </ol> <p>Do not put large method definitions inline within the class definition. Typically only trivial or performance critical methods \\ that are very short may be defined inline. If the class as a template, then all functions must be defined inline in the\\ header file.</p> <p>Note</p> <p>if a friend is a class or class function, then the friend should appear under the same visibility \\ specifier as a friend. For example, if you are friending a private class function, then the friend \\ function delcaration should also appear in the private section of the friending class.</p>"},{"location":"contributor_guide/style/#s62-storing-references","title":"S.6.2. Storing References","text":"<p>Class within the project should not have reference member variables like so:</p> <pre><code>class my_scene {\npublic:\n    my_scene(event::bus&amp; p_bus) : m_bus(p_bus) {}\n\nprivate:\n    event::bus&amp; m_bus; // \u274c Bad! Don't do this!\n};\n</code></pre> <p>Reference members implicitly delete copy constructors of a class they are within because they are themselves are not copyable. You cannot reassign a reference after it's made.</p> <p>Instead take the parameter as a reference but save its address as a pointer. Which contains the address to that object.</p> <pre><code>class scene {\npublic:\n    my_scene(event::bus&amp; p_bus) : m_bus(&amp;p_bus) {}\n\nprivate:\n    event::bus* m_bus; // \u2705 Good!\n};\n</code></pre>"},{"location":"user_guide/setup_vscode/","title":"\ud83d\udd79\ufe0f Setting VSCode w/ <code>clangd</code>","text":"<p>The majority of the contributors and users uses Visual Studio Code. These guidelines should also help with non-vscoders as well.</p>"},{"location":"user_guide/setup_vscode/#setup-vscode-configuration","title":"Setup VSCode Configuration","text":"<p>Make sure you already install clang via getting started.</p> <ol> <li>Install VSCode if you haven't already done so.</li> <li>Go to the \"Extensions\" section on left-side of the bar. It looks like 4 blocks with the upper right-hand block disconnected from the other 3. Hover over the icons to get their name.</li> <li>Search for \"C/C++\" and disable the Windows intellisense extension if it is already installed and enabled.</li> <li>Search for the extension <code>clangd</code> and install the extension.</li> <li>Go to the <code>clangd</code> extension settings page. Find <code>clangd</code> extension and press the GEAR \u2699\ufe0f icon to open in settings.</li> <li>Find the settings <code>clangd: Arguments</code> and add:<ol> <li>In <code>Clangd: Arguments</code> input <code>--header-insertion=never</code></li> </ol> </li> </ol>"},{"location":"user_guide/setup_vscode/#disable-vscode-default-intellisense","title":"Disable VSCode Default Intellisense","text":"<p>When using <code>clangd</code> it will conflict with Visual Studio Code's default intellisense. This is how you can disable it.</p> <p>Follow the same setups above. In the intellisense sections in the extensions for \"C/C++\".</p> <p>Check the disable checkbox as shown below</p> <p></p>"},{"location":"user_guide/setup_vscode/#disable-auto-include-headers","title":"Disable auto-include headers","text":"<p>If you do not want auto-imported headers and are already including them if you have precompiled headers setup. This is how you can disable them.</p> <p>Clangd arguments should look like this:</p> <p></p>"},{"location":"user_guide/setup_vscode/#used-in-your-own-project","title":"Used in your own project","text":"<p>You can either add a <code>self.requires(\"engine3d-cmake-utils/4.0\")</code> to your project or add the following lines to your <code>CMakeLists.txt</code></p> <pre><code># Generate compile commands for anyone using our libraries.\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n\n# Always run this custom target by making it depend on ALL\nadd_custom_target(copy_compile_commands ALL\n    COMMAND ${CMAKE_COMMAND} -E copy_if_different\n    ${CMAKE_BINARY_DIR}/compile_commands.json\n    ${CMAKE_SOURCE_DIR}/compile_commands.json\n    DEPENDS ${CMAKE_BINARY_DIR}/compile_commands.json)\n</code></pre> <p>Run <code>conan build .</code> (where <code>.</code> is the path to your project/library) and it should generate the <code>compile_commands.json</code> file.</p> <p>To ensure that the dependencies in your <code>conanfile.py</code> file that uses <code>self.requires</code> function.</p> <p>Tip</p> <p>-b missing indicates to install any missing binaries for third party libraries that are missing</p> <pre><code>conan build . -b missing\n</code></pre>"},{"location":"user_guide/setup_vscode/#how-clangd-works","title":"How <code>clangd</code> works","text":"<p>Once you get <code>clangd</code> setup. Let me tell you how clangd works. Your workspace needs <code>compile_commands.json</code> file to be present or using <code>.clangd</code> in the root of your project's directory to be configured to know where to look for the location the <code>compile_commands.json</code> is located.</p> <p><code>compile_commands.json</code> tells <code>clangd</code> what commands you are using in order to determine exactly how your files are build and whjat commands are used to build them. Which provides the following benefits:</p> <ol> <li>More accurate warnings and error messages within your IDE.</li> <li>Faster response time because only the necessary includes for the specific version you are targeted will be used when evaluated.</li> </ol>"},{"location":"References/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace atlas <ul> <li>namespace detail </li> <li>namespace event </li> <li>namespace filesystem </li> <li>namespace jolt </li> <li>namespace math </li> <li>namespace physics </li> <li>namespace ui </li> <li>namespace vk </li> </ul> </li> </ul>"},{"location":"References/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir TheAtlasEngine <ul> <li>dir src <ul> <li>dir atlas <ul> <li>dir core <ul> <li>dir editor <ul> <li>file dockspace.cpp </li> <li>file menu_item.cpp </li> </ul> </li> <li>dir event <ul> <li>file event.cpp </li> </ul> </li> <li>dir filesystem <ul> <li>file file_dialog.cpp </li> </ul> </li> <li>dir image <ul> <li>file stb_image.cpp </li> </ul> </li> <li>dir math <ul> <li>file utilities.cpp </li> </ul> </li> <li>dir platforms <ul> <li>file main.cpp </li> <li>file win32.cpp </li> </ul> </li> <li>dir scene <ul> <li>file game_object.cpp </li> <li>file scene.cpp </li> <li>file world.cpp </li> </ul> </li> <li>dir serialize <ul> <li>file serializer.cpp </li> <li>file types.cpp </li> </ul> </li> <li>dir system <ul> <li>file registry.cpp </li> </ul> </li> <li>dir ui <ul> <li>file widgets.cpp </li> </ul> </li> <li>dir utilities <ul> <li>file state.cpp </li> </ul> </li> <li>file application.cpp </li> <li>file engine_logger.cpp </li> <li>file timer.cpp </li> <li>file window.cpp </li> </ul> </li> <li>dir drivers <ul> <li>dir jolt-cpp <ul> <li>file jolt_contact_listener.cpp </li> <li>file jolt_context.cpp </li> <li>file types.cpp </li> </ul> </li> <li>dir vulkan-cpp <ul> <li>file mesh.cpp </li> <li>file shader_resource_group.cpp </li> <li>file utilities.cpp </li> <li>file vk_context.cpp </li> <li>file vk_driver.cpp </li> <li>file vk_imgui.cpp </li> <li>file vk_physical_driver.cpp </li> <li>file vk_renderer.cpp </li> <li>file vk_swapchain.cpp </li> <li>file vk_window.cpp </li> </ul> </li> <li>file graphics_context.cpp </li> <li>file render_context.cpp </li> </ul> </li> <li>dir physics <ul> <li>file physics_context.cpp </li> <li>file physics_engine.cpp </li> </ul> </li> <li>dir renderer <ul> <li>file renderer.cpp </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"References/namespaceatlas/","title":"Namespace atlas","text":"<p>Namespace List &gt; atlas</p>"},{"location":"References/namespaceatlas/#namespaces","title":"Namespaces","text":"Type Name namespace detail namespace event namespace filesystem namespace jolt namespace math namespace physics namespace ui namespace vk"},{"location":"References/namespaceatlas/#public-attributes","title":"Public Attributes","text":"Type Name std::string g_current_pattern_for_logs   = <code>\"Undefined Pattern Specified\"</code>"},{"location":"References/namespaceatlas/#public-static-attributes","title":"Public Static Attributes","text":"Type Name api g_graphics_backend_api   = <code>api::vulkan</code>"},{"location":"References/namespaceatlas/#public-functions","title":"Public Functions","text":"Type Name ref&lt; window &gt; create_window (const window_settings &amp; p_settings)  glm::highp_vec4 from_quat (const glm::vec3 &amp; p_values)  ref&lt; graphics_context &gt; initialize_context (const std::string &amp; p_tag)  ref&lt; render_context &gt; initialize_renderer (const window_settings &amp; p_window_extent, uint32_t p_image_size, const std::string &amp; p_tag)  YAML::Emitter &amp; operator&lt;&lt; (YAML::Emitter &amp; p_out, const glm::highp_vec2 &amp; p_values)  YAML::Emitter &amp; operator&lt;&lt; (YAML::Emitter &amp; p_out, const glm::highp_vec3 &amp; p_values)  YAML::Emitter &amp; operator&lt;&lt; (YAML::Emitter &amp; p_out, const glm::highp_vec4 &amp; p_values)  YAML::Emitter &amp; operator&lt;&lt; (YAML::Emitter &amp; p_output, const transform * p_transform)  YAML::Emitter &amp; operator&lt;&lt; (YAML::Emitter &amp; p_output, const perspective_camera * p_camera)  YAML::Emitter &amp; operator&lt;&lt; (YAML::Emitter &amp; p_output, const mesh_source * p_material)  YAML::Emitter &amp; operator&lt;&lt; (YAML::Emitter &amp; p_output, const point_light * p_material)  YAML::Emitter &amp; operator&lt;&lt; (YAML::Emitter &amp; p_output, const physics_body * p_body)  YAML::Emitter &amp; operator&lt;&lt; (YAML::Emitter &amp; p_output, const box_collider * p_body)  YAML::Emitter &amp; operator&lt;&lt; (YAML::Emitter &amp; p_output, const sphere_collider * p_body)  YAML::Emitter &amp; operator&lt;&lt; (YAML::Emitter &amp; p_output, const capsule_collider * p_body)  glm::quat to_quat (const glm::vec4 &amp; p_values)  glm::quat to_quat (const glm::vec3 &amp; p_values)  glm::quat to_quat (const JPH::Quat &amp; p_value)  glm::quat to_quathp (const glm::highp_vec4 &amp; p_values)  glm::vec3 to_vec3 (const JPH::Vec3 &amp; p_value)  glm::vec4 to_vec4 (const JPH::Quat &amp; p_value)"},{"location":"References/namespaceatlas/#public-static-functions","title":"Public Static Functions","text":"Type Name void deserialize_entity (YAML::iterator::value_type p_entity_value, flecs::entity &amp; p_deserialize_to_object)  void serialize_entity (YAML::Emitter &amp; output, const flecs::entity &amp; p_entity)"},{"location":"References/namespaceatlas/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/namespaceatlas/#variable-g_current_pattern_for_logs","title":"variable g_current_pattern_for_logs","text":"<pre><code>std::string atlas::g_current_pattern_for_logs;\n</code></pre>"},{"location":"References/namespaceatlas/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"References/namespaceatlas/#variable-g_graphics_backend_api","title":"variable g_graphics_backend_api","text":"<pre><code>api atlas::g_graphics_backend_api;\n</code></pre>"},{"location":"References/namespaceatlas/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas/#function-create_window","title":"function create_window","text":"<pre><code>ref&lt; window &gt; atlas::create_window (\n    const window_settings &amp; p_settings\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-from_quat","title":"function from_quat","text":"<pre><code>glm::highp_vec4 atlas::from_quat (\n    const glm::vec3 &amp; p_values\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-initialize_context","title":"function initialize_context","text":"<pre><code>ref&lt; graphics_context &gt; atlas::initialize_context (\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-initialize_renderer","title":"function initialize_renderer","text":"<pre><code>ref&lt; render_context &gt; atlas::initialize_renderer (\n    const window_settings &amp; p_window_extent,\n    uint32_t p_image_size,\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>YAML::Emitter &amp; atlas::operator&lt;&lt; (\n    YAML::Emitter &amp; p_out,\n    const glm::highp_vec2 &amp; p_values\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>YAML::Emitter &amp; atlas::operator&lt;&lt; (\n    YAML::Emitter &amp; p_out,\n    const glm::highp_vec3 &amp; p_values\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-operator_2","title":"function operator&lt;&lt;","text":"<pre><code>YAML::Emitter &amp; atlas::operator&lt;&lt; (\n    YAML::Emitter &amp; p_out,\n    const glm::highp_vec4 &amp; p_values\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-operator_3","title":"function operator&lt;&lt;","text":"<pre><code>YAML::Emitter &amp; atlas::operator&lt;&lt; (\n    YAML::Emitter &amp; p_output,\n    const transform * p_transform\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-operator_4","title":"function operator&lt;&lt;","text":"<pre><code>YAML::Emitter &amp; atlas::operator&lt;&lt; (\n    YAML::Emitter &amp; p_output,\n    const perspective_camera * p_camera\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-operator_5","title":"function operator&lt;&lt;","text":"<pre><code>YAML::Emitter &amp; atlas::operator&lt;&lt; (\n    YAML::Emitter &amp; p_output,\n    const mesh_source * p_material\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-operator_6","title":"function operator&lt;&lt;","text":"<pre><code>YAML::Emitter &amp; atlas::operator&lt;&lt; (\n    YAML::Emitter &amp; p_output,\n    const point_light * p_material\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-operator_7","title":"function operator&lt;&lt;","text":"<pre><code>YAML::Emitter &amp; atlas::operator&lt;&lt; (\n    YAML::Emitter &amp; p_output,\n    const physics_body * p_body\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-operator_8","title":"function operator&lt;&lt;","text":"<pre><code>YAML::Emitter &amp; atlas::operator&lt;&lt; (\n    YAML::Emitter &amp; p_output,\n    const box_collider * p_body\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-operator_9","title":"function operator&lt;&lt;","text":"<pre><code>YAML::Emitter &amp; atlas::operator&lt;&lt; (\n    YAML::Emitter &amp; p_output,\n    const sphere_collider * p_body\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-operator_10","title":"function operator&lt;&lt;","text":"<pre><code>YAML::Emitter &amp; atlas::operator&lt;&lt; (\n    YAML::Emitter &amp; p_output,\n    const capsule_collider * p_body\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-to_quat","title":"function to_quat","text":"<pre><code>glm::quat atlas::to_quat (\n    const glm::vec4 &amp; p_values\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-to_quat_1","title":"function to_quat","text":"<pre><code>glm::quat atlas::to_quat (\n    const glm::vec3 &amp; p_values\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-to_quat_2","title":"function to_quat","text":"<pre><code>glm::quat atlas::to_quat (\n    const JPH::Quat &amp; p_value\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-to_quathp","title":"function to_quathp","text":"<pre><code>glm::quat atlas::to_quathp (\n    const glm::highp_vec4 &amp; p_values\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-to_vec3","title":"function to_vec3","text":"<pre><code>glm::vec3 atlas::to_vec3 (\n    const JPH::Vec3 &amp; p_value\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-to_vec4","title":"function to_vec4","text":"<pre><code>glm::vec4 atlas::to_vec4 (\n    const JPH::Quat &amp; p_value\n) \n</code></pre>"},{"location":"References/namespaceatlas/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/namespaceatlas/#function-deserialize_entity","title":"function deserialize_entity","text":"<pre><code>static void atlas::deserialize_entity (\n    YAML::iterator::value_type p_entity_value,\n    flecs::entity &amp; p_deserialize_to_object\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-serialize_entity","title":"function serialize_entity","text":"<pre><code>static void atlas::serialize_entity (\n    YAML::Emitter &amp; output,\n    const flecs::entity &amp; p_entity\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/application.cpp</code></p>"},{"location":"References/namespaceatlas_1_1detail/","title":"Namespace atlas::detail","text":"<p>Namespace List &gt; atlas &gt; detail</p>"},{"location":"References/namespaceatlas_1_1detail/#public-attributes","title":"Public Attributes","text":"Type Name std::unordered_map&lt; void *, std::function&lt; void()&gt; &gt; s_defer_update   = <code>{}</code> std::unordered_map&lt; void *, std::function&lt; void()&gt; &gt; s_physica_update   = <code>{}</code> std::unordered_map&lt; void *, std::function&lt; void()&gt; &gt; s_start   = <code>{}</code> std::unordered_map&lt; void *, std::function&lt; void()&gt; &gt; s_ui_update   = <code>{}</code> std::unordered_map&lt; void *, std::function&lt; void()&gt; &gt; s_update   = <code>{}</code>"},{"location":"References/namespaceatlas_1_1detail/#public-functions","title":"Public Functions","text":"Type Name void invoke_defer_update ()  void invoke_on_update ()  void invoke_physics_update ()  void invoke_start ()  void invoke_ui_update ()  void poll_defer_update (void * p_address, const std::function&lt; void()&gt; &amp; p_callback)  void poll_physics_update (void * p_address, const std::function&lt; void()&gt; &amp; p_callback)  void poll_start (void * p_address, const std::function&lt; void()&gt; &amp; p_callback)  void poll_ui_update (void * p_address, const std::function&lt; void()&gt; &amp; p_callback)  void poll_update (void * p_address, const std::function&lt; void()&gt; &amp; p_callable)  void remove_defer_update (void * p_address)  void remove_physics_update (void * p_address)  void remove_start (void * p_address)  void remove_ui_update (void * p_address)  void remove_update (void * p_address)"},{"location":"References/namespaceatlas_1_1detail/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/namespaceatlas_1_1detail/#variable-s_defer_update","title":"variable s_defer_update","text":"<pre><code>std::unordered_map&lt;void*, std::function&lt;void()&gt; &gt; atlas::detail::s_defer_update;\n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#variable-s_physica_update","title":"variable s_physica_update","text":"<pre><code>std::unordered_map&lt;void*, std::function&lt;void()&gt; &gt; atlas::detail::s_physica_update;\n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#variable-s_start","title":"variable s_start","text":"<pre><code>std::unordered_map&lt;void*, std::function&lt;void()&gt; &gt; atlas::detail::s_start;\n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#variable-s_ui_update","title":"variable s_ui_update","text":"<pre><code>std::unordered_map&lt;void*, std::function&lt;void()&gt; &gt; atlas::detail::s_ui_update;\n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#variable-s_update","title":"variable s_update","text":"<pre><code>std::unordered_map&lt;void*, std::function&lt;void()&gt; &gt; atlas::detail::s_update;\n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1detail/#function-invoke_defer_update","title":"function invoke_defer_update","text":"<pre><code>void atlas::detail::invoke_defer_update () \n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#function-invoke_on_update","title":"function invoke_on_update","text":"<pre><code>void atlas::detail::invoke_on_update () \n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#function-invoke_physics_update","title":"function invoke_physics_update","text":"<pre><code>void atlas::detail::invoke_physics_update () \n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#function-invoke_start","title":"function invoke_start","text":"<pre><code>void atlas::detail::invoke_start () \n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#function-invoke_ui_update","title":"function invoke_ui_update","text":"<pre><code>void atlas::detail::invoke_ui_update () \n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#function-poll_defer_update","title":"function poll_defer_update","text":"<pre><code>void atlas::detail::poll_defer_update (\n    void * p_address,\n    const std::function&lt; void()&gt; &amp; p_callback\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#function-poll_physics_update","title":"function poll_physics_update","text":"<pre><code>void atlas::detail::poll_physics_update (\n    void * p_address,\n    const std::function&lt; void()&gt; &amp; p_callback\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#function-poll_start","title":"function poll_start","text":"<pre><code>void atlas::detail::poll_start (\n    void * p_address,\n    const std::function&lt; void()&gt; &amp; p_callback\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#function-poll_ui_update","title":"function poll_ui_update","text":"<pre><code>void atlas::detail::poll_ui_update (\n    void * p_address,\n    const std::function&lt; void()&gt; &amp; p_callback\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#function-poll_update","title":"function poll_update","text":"<pre><code>void atlas::detail::poll_update (\n    void * p_address,\n    const std::function&lt; void()&gt; &amp; p_callable\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#function-remove_defer_update","title":"function remove_defer_update","text":"<pre><code>void atlas::detail::remove_defer_update (\n    void * p_address\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#function-remove_physics_update","title":"function remove_physics_update","text":"<pre><code>void atlas::detail::remove_physics_update (\n    void * p_address\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#function-remove_start","title":"function remove_start","text":"<pre><code>void atlas::detail::remove_start (\n    void * p_address\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#function-remove_ui_update","title":"function remove_ui_update","text":"<pre><code>void atlas::detail::remove_ui_update (\n    void * p_address\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1detail/#function-remove_update","title":"function remove_update","text":"<pre><code>void atlas::detail::remove_update (\n    void * p_address\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/utilities/state.cpp</code></p>"},{"location":"References/namespaceatlas_1_1event/","title":"Namespace atlas::event","text":"<p>Namespace List &gt; atlas &gt; event</p>"},{"location":"References/namespaceatlas_1_1event/#public-types","title":"Public Types","text":"Type Name typedef int button_id typedef int controller_id"},{"location":"References/namespaceatlas_1_1event/#public-static-attributes","title":"Public Static Attributes","text":"Type Name std::map&lt; uint32_t, joystick_info &gt; s_controllers"},{"location":"References/namespaceatlas_1_1event/#public-functions","title":"Public Functions","text":"Type Name glm::vec2 cursor_position ()  float get_joystic_axis (int p_controller_id, int p_button)  bool is_joystic_present (int p_controller_id)  bool is_joystick_button_pressed (int p_button)  bool is_joystick_button_released (int p_button)  const char * is_joystick_guid (int p_controller_id)  bool is_key_pressed (int p_key)  bool is_key_released (int p_key)  bool is_mouse_pressed (int p_mouse_code)  bool is_mouse_released (int p_mouse_code)  void update_events ()  void wait_for_events ()"},{"location":"References/namespaceatlas_1_1event/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"References/namespaceatlas_1_1event/#typedef-button_id","title":"typedef button_id","text":"<pre><code>using atlas::event::button_id = typedef int;\n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#typedef-controller_id","title":"typedef controller_id","text":"<pre><code>using atlas::event::controller_id = typedef int;\n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"References/namespaceatlas_1_1event/#variable-s_controllers","title":"variable s_controllers","text":"<pre><code>std::map&lt;uint32_t, joystick_info&gt; atlas::event::s_controllers;\n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1event/#function-cursor_position","title":"function cursor_position","text":"<pre><code>glm::vec2 atlas::event::cursor_position () \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-get_joystic_axis","title":"function get_joystic_axis","text":"<pre><code>float atlas::event::get_joystic_axis (\n    int p_controller_id,\n    int p_button\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_joystic_present","title":"function is_joystic_present","text":"<pre><code>bool atlas::event::is_joystic_present (\n    int p_controller_id\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_joystick_button_pressed","title":"function is_joystick_button_pressed","text":"<pre><code>bool atlas::event::is_joystick_button_pressed (\n    int p_button\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_joystick_button_released","title":"function is_joystick_button_released","text":"<pre><code>bool atlas::event::is_joystick_button_released (\n    int p_button\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_joystick_guid","title":"function is_joystick_guid","text":"<pre><code>const char * atlas::event::is_joystick_guid (\n    int p_controller_id\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_key_pressed","title":"function is_key_pressed","text":"<pre><code>bool atlas::event::is_key_pressed (\n    int p_key\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_key_released","title":"function is_key_released","text":"<pre><code>bool atlas::event::is_key_released (\n    int p_key\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_mouse_pressed","title":"function is_mouse_pressed","text":"<pre><code>bool atlas::event::is_mouse_pressed (\n    int p_mouse_code\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_mouse_released","title":"function is_mouse_released","text":"<pre><code>bool atlas::event::is_mouse_released (\n    int p_mouse_code\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-update_events","title":"function update_events","text":"<pre><code>void atlas::event::update_events () \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-wait_for_events","title":"function wait_for_events","text":"<pre><code>void atlas::event::wait_for_events () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/event/event.cpp</code></p>"},{"location":"References/namespaceatlas_1_1filesystem/","title":"Namespace atlas::filesystem","text":"<p>Namespace List &gt; atlas &gt; filesystem</p>"},{"location":"References/namespaceatlas_1_1filesystem/#public-functions","title":"Public Functions","text":"Type Name std::string load_from_file_dialog (const std::string &amp; p_filter, const std::filesystem::path &amp; p_default_path)  std::string save_to_file (const std::string &amp; p_filter, const std::filesystem::path &amp; p_default)"},{"location":"References/namespaceatlas_1_1filesystem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1filesystem/#function-load_from_file_dialog","title":"function load_from_file_dialog","text":"<pre><code>std::string atlas::filesystem::load_from_file_dialog (\n    const std::string &amp; p_filter,\n    const std::filesystem::path &amp; p_default_path\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1filesystem/#function-save_to_file","title":"function save_to_file","text":"<pre><code>std::string atlas::filesystem::save_to_file (\n    const std::string &amp; p_filter,\n    const std::filesystem::path &amp; p_default\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/filesystem/file_dialog.cpp</code></p>"},{"location":"References/namespaceatlas_1_1jolt/","title":"Namespace atlas::jolt","text":"<p>Namespace List &gt; atlas &gt; jolt</p>"},{"location":"References/namespaceatlas_1_1jolt/#public-functions","title":"Public Functions","text":"Type Name JPH::Quat to_quat (const glm::vec4 &amp; q)  JPH::Quat to_quat (glm::quat &amp; p_value)  JPH::RVec3 to_rvec3 (const glm::vec3 &amp; p_value)  JPH::Vec3 to_vec3 (const glm::vec3 &amp; p_value)"},{"location":"References/namespaceatlas_1_1jolt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1jolt/#function-to_quat","title":"function to_quat","text":"<pre><code>JPH::Quat atlas::jolt::to_quat (\n    const glm::vec4 &amp; q\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1jolt/#function-to_quat_1","title":"function to_quat","text":"<pre><code>JPH::Quat atlas::jolt::to_quat (\n    glm::quat &amp; p_value\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1jolt/#function-to_rvec3","title":"function to_rvec3","text":"<pre><code>JPH::RVec3 atlas::jolt::to_rvec3 (\n    const glm::vec3 &amp; p_value\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1jolt/#function-to_vec3","title":"function to_vec3","text":"<pre><code>JPH::Vec3 atlas::jolt::to_vec3 (\n    const glm::vec3 &amp; p_value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/jolt-cpp/types.cpp</code></p>"},{"location":"References/namespaceatlas_1_1math/","title":"Namespace atlas::math","text":"<p>Namespace List &gt; atlas &gt; math</p>"},{"location":"References/namespaceatlas_1_1math/#public-functions","title":"Public Functions","text":"Type Name glm::vec3 backward ()  glm::vec3 down ()  glm::vec3 forward ()  glm::quat identity ()  glm::vec3 left ()  glm::vec3 ones ()  glm::vec3 right ()  glm::vec3 up ()  glm::vec3 zeroes ()"},{"location":"References/namespaceatlas_1_1math/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1math/#function-backward","title":"function backward","text":"<pre><code>glm::vec3 atlas::math::backward () \n</code></pre>"},{"location":"References/namespaceatlas_1_1math/#function-down","title":"function down","text":"<pre><code>glm::vec3 atlas::math::down () \n</code></pre>"},{"location":"References/namespaceatlas_1_1math/#function-forward","title":"function forward","text":"<pre><code>glm::vec3 atlas::math::forward () \n</code></pre>"},{"location":"References/namespaceatlas_1_1math/#function-identity","title":"function identity","text":"<pre><code>glm::quat atlas::math::identity () \n</code></pre>"},{"location":"References/namespaceatlas_1_1math/#function-left","title":"function left","text":"<pre><code>glm::vec3 atlas::math::left () \n</code></pre>"},{"location":"References/namespaceatlas_1_1math/#function-ones","title":"function ones","text":"<pre><code>glm::vec3 atlas::math::ones () \n</code></pre>"},{"location":"References/namespaceatlas_1_1math/#function-right","title":"function right","text":"<pre><code>glm::vec3 atlas::math::right () \n</code></pre>"},{"location":"References/namespaceatlas_1_1math/#function-up","title":"function up","text":"<pre><code>glm::vec3 atlas::math::up () \n</code></pre>"},{"location":"References/namespaceatlas_1_1math/#function-zeroes","title":"function zeroes","text":"<pre><code>glm::vec3 atlas::math::zeroes () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/math/utilities.cpp</code></p>"},{"location":"References/namespaceatlas_1_1physics/","title":"Namespace atlas::physics","text":"<p>Namespace List &gt; atlas &gt; physics</p>"},{"location":"References/namespaceatlas_1_1physics/#public-functions","title":"Public Functions","text":"Type Name ref&lt; physics_context &gt; initialize_physics_context (const jolt_settings &amp; p_settings, event::event_bus &amp; p_bus)"},{"location":"References/namespaceatlas_1_1physics/#public-static-functions","title":"Public Static Functions","text":"Type Name bool assert_failed_impl (const char * p_in_expression, const char * p_in_message, const char * p_in_file, unsigned int p_in_line)  void trace_impl (const char * p_in_fmt, ...)"},{"location":"References/namespaceatlas_1_1physics/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1physics/#function-initialize_physics_context","title":"function initialize_physics_context","text":"<pre><code>ref&lt; physics_context &gt; atlas::physics::initialize_physics_context (\n    const jolt_settings &amp; p_settings,\n    event::event_bus &amp; p_bus\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1physics/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1physics/#function-assert_failed_impl","title":"function assert_failed_impl","text":"<pre><code>static bool atlas::physics::assert_failed_impl (\n    const char * p_in_expression,\n    const char * p_in_message,\n    const char * p_in_file,\n    unsigned int p_in_line\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1physics/#function-trace_impl","title":"function trace_impl","text":"<pre><code>static void atlas::physics::trace_impl (\n    const char * p_in_fmt,\n    ...\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/jolt-cpp/jolt_contact_listener.cpp</code></p>"},{"location":"References/namespaceatlas_1_1ui/","title":"Namespace atlas::ui","text":"<p>Namespace List &gt; atlas &gt; ui</p>"},{"location":"References/namespaceatlas_1_1ui/#public-functions","title":"Public Functions","text":"Type Name bool begin_popup_context_window (const char * str_id, ImGuiMouseButton mb, bool over_items)  void button_open_file_dialog (const std::string &amp; p_tag, std::string &amp; p_filename, const std::string &amp; p_filter)  void dockspace_window (GLFWwindow * p_window)  void draw_float (const std::string &amp; p_tag, float &amp; p_value, float reset_value)  void draw_input_text (std::string &amp; p_dst, std::string &amp; p_src)  void draw_text (const std::string &amp; p_value)  void draw_vec3 (const std::string &amp; p_tag, glm::vec3 &amp; p_position, float p_reset_value)  void draw_vec4 (const std::string &amp; p_tag, glm::vec4 &amp; p_value, float p_reset_value)"},{"location":"References/namespaceatlas_1_1ui/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1ui/#function-begin_popup_context_window","title":"function begin_popup_context_window","text":"<pre><code>bool atlas::ui::begin_popup_context_window (\n    const char * str_id,\n    ImGuiMouseButton mb,\n    bool over_items\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1ui/#function-button_open_file_dialog","title":"function button_open_file_dialog","text":"<pre><code>void atlas::ui::button_open_file_dialog (\n    const std::string &amp; p_tag,\n    std::string &amp; p_filename,\n    const std::string &amp; p_filter\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1ui/#function-dockspace_window","title":"function dockspace_window","text":"<pre><code>void atlas::ui::dockspace_window (\n    GLFWwindow * p_window\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1ui/#function-draw_float","title":"function draw_float","text":"<pre><code>void atlas::ui::draw_float (\n    const std::string &amp; p_tag,\n    float &amp; p_value,\n    float reset_value\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1ui/#function-draw_input_text","title":"function draw_input_text","text":"<pre><code>void atlas::ui::draw_input_text (\n    std::string &amp; p_dst,\n    std::string &amp; p_src\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1ui/#function-draw_text","title":"function draw_text","text":"<pre><code>void atlas::ui::draw_text (\n    const std::string &amp; p_value\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1ui/#function-draw_vec3","title":"function draw_vec3","text":"<pre><code>void atlas::ui::draw_vec3 (\n    const std::string &amp; p_tag,\n    glm::vec3 &amp; p_position,\n    float p_reset_value\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1ui/#function-draw_vec4","title":"function draw_vec4","text":"<pre><code>void atlas::ui::draw_vec4 (\n    const std::string &amp; p_tag,\n    glm::vec4 &amp; p_value,\n    float p_reset_value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/editor/dockspace.cpp</code></p>"},{"location":"References/namespaceatlas_1_1vk/","title":"Namespace atlas::vk","text":"<p>Namespace List &gt; atlas &gt; vk</p>"},{"location":"References/namespaceatlas_1_1vk/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; const char * &gt; initialize_instance_extensions ()  std::span&lt; uint8_t &gt; to_bytes (T p_data)  void vk_check (const VkResult &amp; p_result, const std::string &amp; p_name, const std::source_location &amp; p_source)"},{"location":"References/namespaceatlas_1_1vk/#public-static-functions","title":"Public Static Functions","text":"Type Name std::vector&lt; char &gt; compile_binary_shader_source (const ::vk::shader_source &amp; p_shader_source) Ensure file reads are valid before reading raw .spv binaries. std::vector&lt; uint32_t &gt; compile_source_from_file (const ::vk::shader_source &amp; p_shader_source)  void im_gui_layout_color_modification ()  std::vector&lt; char &gt; read_raw_spirv (const std::string &amp; p_file)  std::string read_shader_source_code (const std::string &amp; p_filename)  VkFormat search_depth_format (const VkPhysicalDevice &amp; p_physical)  VkFormat search_supported_depth_format (const VkPhysicalDevice &amp; p_physical, std::span&lt; VkFormat &gt; p_formats, VkImageTiling p_tiling, VkFormatFeatureFlags p_feature_flag)"},{"location":"References/namespaceatlas_1_1vk/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1vk/#function-initialize_instance_extensions","title":"function initialize_instance_extensions","text":"<pre><code>std::vector&lt; const char * &gt; atlas::vk::initialize_instance_extensions () \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-to_bytes","title":"function to_bytes","text":"<pre><code>template&lt;typename T&gt;\nstd::span&lt; uint8_t &gt; atlas::vk::to_bytes (\n    T p_data\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-vk_check","title":"function vk_check","text":"<pre><code>void atlas::vk::vk_check (\n    const VkResult &amp; p_result,\n    const std::string &amp; p_name,\n    const std::source_location &amp; p_source\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1vk/#function-compile_binary_shader_source","title":"function compile_binary_shader_source","text":"<p>Ensure file reads are valid before reading raw .spv binaries. <pre><code>static std::vector&lt; char &gt; atlas::vk::compile_binary_shader_source (\n    const ::vk::shader_source &amp; p_shader_source\n) \n</code></pre></p>"},{"location":"References/namespaceatlas_1_1vk/#function-compile_source_from_file","title":"function compile_source_from_file","text":"<pre><code>static std::vector&lt; uint32_t &gt; atlas::vk::compile_source_from_file (\n    const ::vk::shader_source &amp; p_shader_source\n) \n</code></pre> <p>compiles source code from the shader directly without needing manual recompilation</p> <p>shaderc requires these parameters to compile text_source_code: the std::string version of the entire source code to compile type: shader stage this shader corresponds to filename: input filename text entry_point: the entry point to this shader options: compiler-specific options to enable when compiling the shader sources </p>"},{"location":"References/namespaceatlas_1_1vk/#function-im_gui_layout_color_modification","title":"function im_gui_layout_color_modification","text":"<pre><code>static void atlas::vk::im_gui_layout_color_modification () \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-read_raw_spirv","title":"function read_raw_spirv","text":"<pre><code>static std::vector&lt; char &gt; atlas::vk::read_raw_spirv (\n    const std::string &amp; p_file\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-read_shader_source_code","title":"function read_shader_source_code","text":"<pre><code>static std::string atlas::vk::read_shader_source_code (\n    const std::string &amp; p_filename\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-search_depth_format","title":"function search_depth_format","text":"<pre><code>static VkFormat atlas::vk::search_depth_format (\n    const VkPhysicalDevice &amp; p_physical\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-search_supported_depth_format","title":"function search_supported_depth_format","text":"<pre><code>static VkFormat atlas::vk::search_supported_depth_format (\n    const VkPhysicalDevice &amp; p_physical,\n    std::span&lt; VkFormat &gt; p_formats,\n    VkImageTiling p_tiling,\n    VkFormatFeatureFlags p_feature_flag\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/vulkan-cpp/mesh.cpp</code></p>"},{"location":"References/dir_b67f019f7e2fe784ec01f943d860c92a/","title":"Dir TheAtlasEngine","text":"<p>FileList &gt; TheAtlasEngine</p>"},{"location":"References/dir_b67f019f7e2fe784ec01f943d860c92a/#directories","title":"Directories","text":"Type Name dir src <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/</code></p>"},{"location":"References/dir_ba4e964bcd857e995c2b25f3961c5cf7/","title":"Dir TheAtlasEngine/src","text":"<p>FileList &gt; src</p>"},{"location":"References/dir_ba4e964bcd857e995c2b25f3961c5cf7/#directories","title":"Directories","text":"Type Name dir atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/</code></p>"},{"location":"References/dir_846b40a516a2a471658ccbe09e530d2e/","title":"Dir TheAtlasEngine/src/atlas","text":"<p>FileList &gt; atlas</p>"},{"location":"References/dir_846b40a516a2a471658ccbe09e530d2e/#directories","title":"Directories","text":"Type Name dir core dir drivers dir physics dir renderer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/</code></p>"},{"location":"References/dir_72c8e49e70df5a84858ab1265443dbf9/","title":"Dir TheAtlasEngine/src/atlas/core","text":"<p>FileList &gt; atlas &gt; core</p>"},{"location":"References/dir_72c8e49e70df5a84858ab1265443dbf9/#files","title":"Files","text":"Type Name file application.cpp file engine_logger.cpp file timer.cpp file window.cpp"},{"location":"References/dir_72c8e49e70df5a84858ab1265443dbf9/#directories","title":"Directories","text":"Type Name dir editor dir event dir filesystem dir image dir math dir platforms dir scene dir serialize dir system dir ui dir utilities <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/</code></p>"},{"location":"References/dir_8370a929e1c81109a1f99ac5eede01cd/","title":"Dir TheAtlasEngine/src/atlas/core/editor","text":"<p>FileList &gt; atlas &gt; core &gt; editor</p>"},{"location":"References/dir_8370a929e1c81109a1f99ac5eede01cd/#files","title":"Files","text":"Type Name file dockspace.cpp file menu_item.cpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/editor/</code></p>"},{"location":"References/dockspace_8cpp/","title":"File dockspace.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; editor &gt; dockspace.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/editor/dockspace.hpp&gt;</code></li> <li><code>#include &lt;core/ui/widgets.hpp&gt;</code></li> </ul>"},{"location":"References/dockspace_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace ui <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/editor/dockspace.cpp</code></p>"},{"location":"References/dockspace_8cpp_source/","title":"File dockspace.cpp","text":"<p>File List &gt; atlas &gt; core &gt; editor &gt; dockspace.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/editor/dockspace.hpp&gt;\n#include &lt;core/ui/widgets.hpp&gt;\n\nnamespace atlas::ui {\n\n    void dockspace::begin() {\n\n        ImGuiDockNodeFlags dockspace_flags = ImGuiDockNodeFlags_None;\n        ImGuiWindowFlags window_flags =\n          ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_NoDocking;\n\n        if (m_fullscreen_enabled) {\n            ImGuiViewport* viewport = ImGui::GetMainViewport();\n            ImGui::SetNextWindowPos(viewport-&gt;Pos);\n            ImGui::SetNextWindowSize(viewport-&gt;Size);\n            ImGui::SetNextWindowViewport(viewport-&gt;ID);\n            window_flags |= ImGuiWindowFlags_NoTitleBar |\n                            ImGuiWindowFlags_NoCollapse |\n                            ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove;\n            window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus |\n                            ImGuiWindowFlags_NoNavFocus;\n        }\n\n        if (dockspace_flags &amp; ImGuiDockNodeFlags_PassthruCentralNode) {\n            window_flags |= ImGuiWindowFlags_NoBackground;\n        }\n        ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));\n        ImGui::Begin(\"Dockspace Demo\", &amp;m_is_dockspace_open, window_flags);\n        ImGui::PopStyleVar();\n\n        // Dockspace\n        ImGuiIO&amp; io = ImGui::GetIO();\n        if (io.ConfigFlags &amp; ImGuiConfigFlags_DockingEnable) {\n            ImGuiID dockspace_id = ImGui::GetID(\"MyDockspace\");\n            ImGui::DockSpace(dockspace_id, ImVec2(0.f, 0.f), dockspace_flags);\n        }\n    }\n\n    void dockspace::end() {\n        ImGui::End();\n    }\n};\n</code></pre>"},{"location":"References/menu__item_8cpp/","title":"File menu_item.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; editor &gt; menu_item.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/editor/menu_item.hpp&gt;</code></li> <li><code>#include &lt;imgui.h&gt;</code></li> </ul>"},{"location":"References/menu__item_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace ui <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/editor/menu_item.cpp</code></p>"},{"location":"References/menu__item_8cpp_source/","title":"File menu_item.cpp","text":"<p>File List &gt; atlas &gt; core &gt; editor &gt; menu_item.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/editor/menu_item.hpp&gt;\n#include &lt;imgui.h&gt;\n\nnamespace atlas::ui {\n\n    void menu_item::begin() {\n        if (!ImGui::BeginMenuBar()) {\n            throw menu_bar_exception(\"ImGui::BeginMenuBar failed!\");\n        }\n    }\n\n    void menu_item::end() {\n        ImGui::EndMenuBar();\n    }\n\n    void menu_item::add_child(const std::string&amp; p_name,\n                              const std::function&lt;void()&gt;&amp; p_callback) {\n        if (ImGui::MenuItem(p_name.c_str())) {\n            p_callback();\n        }\n        ImGui::Separator();\n    }\n};\n</code></pre>"},{"location":"References/dir_b8e6e82d89ee66e9ca545e81d513e939/","title":"Dir TheAtlasEngine/src/atlas/core/event","text":"<p>FileList &gt; atlas &gt; core &gt; event</p>"},{"location":"References/dir_b8e6e82d89ee66e9ca545e81d513e939/#files","title":"Files","text":"Type Name file event.cpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/event/</code></p>"},{"location":"References/event_8cpp/","title":"File event.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; event &gt; event.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include &lt;core/application.hpp&gt;</code></li> <li><code>#include &lt;core/event/event.hpp&gt;</code></li> </ul>"},{"location":"References/event_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace event <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/event/event.cpp</code></p>"},{"location":"References/event_8cpp_source/","title":"File event.cpp","text":"<p>File List &gt; atlas &gt; core &gt; event &gt; event.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;GLFW/glfw3.h&gt;\n#include &lt;core/application.hpp&gt;\n#include &lt;core/event/event.hpp&gt;\n\nnamespace atlas::event {\n    static std::map&lt;uint32_t, joystick_info&gt; s_controllers;\n\n    using button_id = int;\n    using controller_id = int;\n\n    bool is_key_pressed(int p_key) {\n        GLFWwindow* window = application::get_window();\n\n        auto state = glfwGetKey(window, static_cast&lt;int32_t&gt;(p_key));\n        return (state == GLFW_PRESS);\n    }\n\n    bool is_key_released(int p_key) {\n        GLFWwindow* window = application::get_window();\n\n        auto state = glfwGetKey(window, static_cast&lt;int32_t&gt;(p_key));\n        return (state == GLFW_RELEASE);\n    }\n\n    bool is_mouse_pressed(int p_mouse_code) {\n        GLFWwindow* window = application::get_window();\n\n        auto state =\n          glfwGetMouseButton(window, static_cast&lt;int32_t&gt;(p_mouse_code));\n        return (state == GLFW_PRESS);\n    }\n\n    bool is_mouse_released(int p_mouse_code) {\n        GLFWwindow* window = application::get_window();\n\n        auto state =\n          glfwGetMouseButton(window, static_cast&lt;int32_t&gt;(p_mouse_code));\n        return (state == GLFW_RELEASE);\n    }\n\n    glm::vec2 cursor_position() {\n        GLFWwindow* window = application::get_window();\n\n        double x_pos, y_pos;\n        glfwGetCursorPos(window, &amp;x_pos, &amp;y_pos);\n\n        return { x_pos, y_pos };\n    }\n\n    // joystic-specific functions\n\n    bool is_joystic_present(int p_controller_id) {\n        return s_controllers.contains(p_controller_id);\n    }\n\n    const char* is_joystick_guid(int p_controller_id) {\n        return glfwGetJoystickGUID(p_controller_id);\n    }\n\n    float get_joystic_axis(int p_controller_id, int p_button) {\n        int count;\n        const float axes =\n          glfwGetJoystickAxes(p_controller_id, &amp;count)[p_button];\n\n        if (count &lt; p_button) {\n            return 0.0f;\n        }\n        else {\n            return axes;\n        }\n    }\n\n    // bool is_button_released(button_id p_button, controller_id p_controller) {\n    //     auto selected_controller = s_controllers[p_controller];\n    //     return (selected_controller.Buttons[p_button].ButtonState ==\n    //             input_state::Pressed);\n    // }\n\n    // bool is_button_pressed(int p_button_id, int p_controller_id) {\n    //     auto controller = s_controllers[p_controller_id];\n    //     return (controller.Buttons[p_button_id].ButtonState == GLFW_RELEASE);\n    // }\n\n    bool is_joystick_button_pressed(int p_button) {\n        return p_button == GLFW_PRESS;\n    }\n\n    bool is_joystick_button_released(int p_button) {\n        return p_button == GLFW_RELEASE;\n    }\n\n    // specific for listening events\n    void update_events() {\n        glfwPollEvents();\n\n        // updating joysticks here\n        // ....\n        // 1 is the first joystick.\n        // 16 is the last joystick\n        for (int joystick_id = 0; joystick_id &lt; 16; joystick_id++) {\n            if (glfwJoystickPresent(joystick_id) == GLFW_TRUE) {\n                auto&amp; joystick = s_controllers[joystick_id];\n                joystick.ID = joystick_id;\n                joystick.JoystickName = glfwGetJoystickName(joystick_id);\n\n                int amount_of_buttons = -1;\n                const unsigned char* buttons =\n                  glfwGetJoystickButtons(joystick_id, &amp;amount_of_buttons);\n\n                // ConsoleLogWarn(\"Button Size = {}\", amount_of_buttons);\n\n                for (int i = 0; i &lt; amount_of_buttons; i++) {\n                    // ConsoleLogFatal(\"Button {} is ===&gt; {}\", i, buttons[i]);\n                    // if(buttons[i] == GLFW_PRESS &amp;&amp; !joystick.ButtonsDown[i]){\n                    if (is_joystick_button_pressed(buttons[i]) &amp;&amp;\n                        !joystick.ButtonsDown[i]) {\n                        joystick.Buttons[i].ButtonState = input_state::Pressed;\n                    }\n                    // else if(buttons[i] == GLFW_RELEASE and\n                    // joystick.ButtonsDown[i]){\n                    else if (is_joystick_button_released(buttons[i]) and\n                             joystick.ButtonsDown[i]) {\n                        joystick.Buttons[i].ButtonState = input_state::Released;\n                    }\n\n                    // joystick.ButtonsDown[i] = (buttons[i] == GLFW_PRESS);\n                    joystick.ButtonsDown[i] =\n                      is_joystick_button_pressed(buttons[i]);\n                }\n\n                int amount_of_axes = -1;\n                const float* axes =\n                  glfwGetJoystickAxes(joystick_id, &amp;amount_of_axes);\n                joystick.AxesOfController[joystick_id] = axes;\n                // ConsoleLogFatal(\"Axes at for-loop i = {} and Axes value =\n                // {:.3f}\", 0, axes[0]); ConsoleLogFatal(\"Axes at for-loop i =\n                // {} and Axes value = {:.3f}\", 1, axes[1]); for(int i = 0; i &lt;\n                // amount_of_axes; i++){\n                //     ConsoleLogFatal(\"Axes at for-loop i = {} and Axes value =\n                //     {:.3f}\", i, axes[i]);\n                // }\n            }\n            else {\n                if (is_joystic_present(joystick_id)) {\n                    s_controllers.erase(joystick_id);\n                }\n            }\n        }\n    }\n\n    void wait_for_events() {}\n};\n</code></pre>"},{"location":"References/dir_f130aa4281de8b0a0ce4fe6bb2f3ff76/","title":"Dir TheAtlasEngine/src/atlas/core/filesystem","text":"<p>FileList &gt; atlas &gt; core &gt; filesystem</p>"},{"location":"References/dir_f130aa4281de8b0a0ce4fe6bb2f3ff76/#files","title":"Files","text":"Type Name file file_dialog.cpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/filesystem/</code></p>"},{"location":"References/file__dialog_8cpp/","title":"File file_dialog.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; filesystem &gt; file_dialog.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;core/filesystem/file_dialog.hpp&gt;</code></li> <li><code>#include &lt;nfd/nfd.h&gt;</code></li> </ul>"},{"location":"References/file__dialog_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace filesystem <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/filesystem/file_dialog.cpp</code></p>"},{"location":"References/file__dialog_8cpp_source/","title":"File file_dialog.cpp","text":"<p>File List &gt; atlas &gt; core &gt; filesystem &gt; file_dialog.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/engine_logger.hpp&gt;\n#include &lt;core/filesystem/file_dialog.hpp&gt;\n#include &lt;nfd/nfd.h&gt;\n\nnamespace atlas::filesystem {\n    std::string load_from_file_dialog(\n      const std::string&amp; p_filter,\n      const std::filesystem::path&amp; p_default_path) {\n        char* output_path = nullptr;\n\n        nfdresult_t result = NFD_OpenDialog(\n          p_filter.c_str(), p_default_path.string().c_str(), &amp;output_path);\n\n        // if (result == NFD_OKAY) {\n        //     return std::string(output_path);\n        // }\n\n        // console_log_fatal(\"Error Loading File!\");\n        // return \"\";\n        return (result == NFD_OKAY) ? std::string(output_path) : \"\";\n    }\n\n    std::string save_to_file(const std::string&amp; p_filter,\n                             const std::filesystem::path&amp; p_default) {\n        char* output_path = nullptr;\n        nfdresult_t result = NFD_SaveDialog(\n          p_filter.c_str(), p_default.string().c_str(), &amp;output_path);\n\n        // if(result == NFD_ERROR){\n        //  return std::string();\n        // }\n\n        // return std::string(output_path);\n\n        return (result == NFD_OKAY) ? std::string(output_path) : std::string();\n    }\n};\n</code></pre>"},{"location":"References/dir_b50d2704714c2c2d879ccbd8a82452ca/","title":"Dir TheAtlasEngine/src/atlas/core/image","text":"<p>FileList &gt; atlas &gt; core &gt; image</p>"},{"location":"References/dir_b50d2704714c2c2d879ccbd8a82452ca/#files","title":"Files","text":"Type Name file stb_image.cpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/image/</code></p>"},{"location":"References/stb__image_8cpp/","title":"File stb_image.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; image &gt; stb_image.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/image/stb_image.hpp&gt;</code></li> </ul>"},{"location":"References/stb__image_8cpp/#macros","title":"Macros","text":"Type Name define STB_IMAGE_IMPLEMENTATION"},{"location":"References/stb__image_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"References/stb__image_8cpp/#define-stb_image_implementation","title":"define STB_IMAGE_IMPLEMENTATION","text":"<pre><code>#define STB_IMAGE_IMPLEMENTATION \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/image/stb_image.cpp</code></p>"},{"location":"References/stb__image_8cpp_source/","title":"File stb_image.cpp","text":"<p>File List &gt; atlas &gt; core &gt; image &gt; stb_image.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef STB_IMAGE_IMPLEMENTATION\n#define STB_IMAGE_IMPLEMENTATION\n#include &lt;core/image/stb_image.hpp&gt;\n#endif\n</code></pre>"},{"location":"References/dir_fc6e8c66c05c843f66c0bec401a38de9/","title":"Dir TheAtlasEngine/src/atlas/core/math","text":"<p>FileList &gt; atlas &gt; core &gt; math</p>"},{"location":"References/dir_fc6e8c66c05c843f66c0bec401a38de9/#files","title":"Files","text":"Type Name file utilities.cpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/math/</code></p>"},{"location":"References/core_2math_2utilities_8cpp/","title":"File utilities.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; math &gt; utilities.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/math/utilities.hpp&gt;</code></li> <li><code>#include &lt;core/common.hpp&gt;</code></li> <li><code>#include &lt;glm/gtx/quaternion.hpp&gt;</code></li> </ul>"},{"location":"References/core_2math_2utilities_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace math <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/math/utilities.cpp</code></p>"},{"location":"References/core_2math_2utilities_8cpp_source/","title":"File utilities.cpp","text":"<p>File List &gt; atlas &gt; core &gt; math &gt; utilities.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/math/utilities.hpp&gt;\n#include &lt;core/common.hpp&gt;\n#include &lt;glm/gtx/quaternion.hpp&gt;\n\nnamespace atlas {\n\n    glm::quat to_quat(const glm::vec4&amp; p_values) {\n        return glm::quat({\n          p_values.w,\n          p_values.x,\n          p_values.y,\n          p_values.z,\n        });\n    }\n\n    glm::highp_vec4 from_quat(const glm::vec3&amp; p_values) {\n        // converts glm::vec3 rotation to a quaternion returning the\n        // quaternion-converted values to glm::highp_vec4\n        auto quaternion = glm::quat(p_values);\n        return glm::vec4(\n          { quaternion.x, quaternion.y, quaternion.z, quaternion.w });\n    }\n\n    glm::quat to_quat(const glm::vec3&amp; p_values) {\n        return glm::quat(p_values);\n    }\n\n    glm::quat to_quathp(const glm::highp_vec4&amp; p_values) {\n        return glm::quat({\n          p_values.w,\n          p_values.x,\n          p_values.y,\n          p_values.z,\n        });\n    }\n\n    namespace math {\n\n        glm::vec3 zeroes() {\n            return glm::vec3(0.f);\n        }\n\n        glm::vec3 ones() {\n            return glm::vec3(1.f);\n        }\n\n        glm::quat identity() {\n            return glm::quat_identity&lt;float, glm::defaultp&gt;();\n        }\n\n        glm::vec3 forward() {\n            return glm::vec3(0.f, 0.f, 1.f);\n        }\n\n        glm::vec3 right() {\n            return glm::vec3(1.f, 0.f, 0.f);\n        }\n\n        glm::vec3 left() {\n            return glm::vec3(-1.f, 0.f, 0.f);\n        }\n\n        glm::vec3 backward() {\n            return glm::vec3(0.f, 0.f, -1.f);\n        }\n\n        glm::vec3 up() {\n            return glm::vec3(0.f, 1.f, 0.f);\n        }\n\n        glm::vec3 down() {\n            return glm::vec3(0.f, -1.f, 0.f);\n        }\n    };\n\n};\n</code></pre>"},{"location":"References/dir_8d4914c5e7dfa41cebb35065bb0be3d0/","title":"Dir TheAtlasEngine/src/atlas/core/platforms","text":"<p>FileList &gt; atlas &gt; core &gt; platforms</p>"},{"location":"References/dir_8d4914c5e7dfa41cebb35065bb0be3d0/#files","title":"Files","text":"Type Name file main.cpp file win32.cpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/platforms/</code></p>"},{"location":"References/main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; platforms &gt; main.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> </ul>"},{"location":"References/main_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main ()  int win_main ()"},{"location":"References/main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/main_8cpp/#function-main","title":"function main","text":"<pre><code>int main () \n</code></pre>"},{"location":"References/main_8cpp/#function-win_main","title":"function win_main","text":"<pre><code>int win_main () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/platforms/main.cpp</code></p>"},{"location":"References/main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; atlas &gt; core &gt; platforms &gt; main.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/engine_logger.hpp&gt;\n#include &lt;GLFW/glfw3.h&gt;\nextern int win_main();\n\nint\nmain() {\n    atlas::console_log_manager::initialize_logger_manager();\n    if (!glfwInit()) {\n        console_log_warn(\"GLFW: Failed to initialize\");\n        return -1;\n    }\n\n    return win_main();\n}\n</code></pre>"},{"location":"References/win32_8cpp/","title":"File win32.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; platforms &gt; win32.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/application.hpp&gt;</code></li> <li><code>#include &lt;core/system/registry.hpp&gt;</code></li> <li><code>#include &lt;drivers/graphics_context.hpp&gt;</code></li> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> </ul>"},{"location":"References/win32_8cpp/#public-functions","title":"Public Functions","text":"Type Name int win_main ()"},{"location":"References/win32_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/win32_8cpp/#function-win_main","title":"function win_main","text":"<pre><code>int win_main () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/platforms/win32.cpp</code></p>"},{"location":"References/win32_8cpp_source/","title":"File win32.cpp","text":"<p>File List &gt; atlas &gt; core &gt; platforms &gt; win32.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/application.hpp&gt;\n#include &lt;core/system/registry.hpp&gt;\n#include &lt;drivers/graphics_context.hpp&gt;\n#include &lt;core/engine_logger.hpp&gt;\nextern atlas::ref&lt;atlas::application&gt; atlas::initialize_application();\n\nint\nwin_main() {\n    // atlas::system_registry::initialize();\n    atlas::ref&lt;atlas::graphics_context&gt; graphic_context =\n      atlas::initialize_context(\"vulkan_context\");\n\n    atlas::ref&lt;atlas::system_registry&gt; system =\n      atlas::create_ref&lt;atlas::system_registry&gt;(\"system\");\n    atlas::ref&lt;atlas::application&gt; app = atlas::initialize_application();\n    app-&gt;execute();\n    graphic_context-&gt;destroy();\n    app-&gt;post_destroy();\n    return 0;\n}\n</code></pre>"},{"location":"References/dir_909c0b2c0140e856eaa37e8f470b8792/","title":"Dir TheAtlasEngine/src/atlas/core/scene","text":"<p>FileList &gt; atlas &gt; core &gt; scene</p>"},{"location":"References/dir_909c0b2c0140e856eaa37e8f470b8792/#files","title":"Files","text":"Type Name file game_object.cpp file scene.cpp file world.cpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/scene/</code></p>"},{"location":"References/game__object_8cpp/","title":"File game_object.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; scene &gt; game_object.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/common.hpp&gt;</code></li> <li><code>#include &lt;core/scene/game_object.hpp&gt;</code></li> <li><code>#include &lt;core/scene/components.hpp&gt;</code></li> <li><code>#include &lt;core/scene/exceptions.hpp&gt;</code></li> </ul>"},{"location":"References/game__object_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/scene/game_object.cpp</code></p>"},{"location":"References/game__object_8cpp_source/","title":"File game_object.cpp","text":"<p>File List &gt; atlas &gt; core &gt; scene &gt; game_object.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/common.hpp&gt;\n#include &lt;core/scene/game_object.hpp&gt;\n#include &lt;core/scene/components.hpp&gt;\n#include &lt;core/scene/exceptions.hpp&gt;\n\nnamespace atlas {\n    game_object::game_object(flecs::world_t* p_registry, flecs::entity_t p_id)\n      : flecs::entity(p_registry, p_id) {\n        add&lt;transform&gt;();\n    }\n\n    game_object::game_object(const flecs::entity&amp; p_base)\n      : flecs::entity(p_base) {\n        add&lt;transform&gt;();\n    }\n\n    game_object::game_object(flecs::entity&amp; p_base)\n      : flecs::entity(p_base) {\n        add&lt;transform&gt;();\n    }\n\n    void game_object::child_of(const std::optional&lt;game_object&gt;&amp; p_parent) {\n        add(flecs::ChildOf, p_parent.value());\n    }\n};\n</code></pre>"},{"location":"References/scene_8cpp/","title":"File scene.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; scene &gt; scene.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/scene/scene.hpp&gt;</code></li> </ul>"},{"location":"References/scene_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/scene/scene.cpp</code></p>"},{"location":"References/scene_8cpp_source/","title":"File scene.cpp","text":"<p>File List &gt; atlas &gt; core &gt; scene &gt; scene.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/scene/scene.hpp&gt;\n\nnamespace atlas {\n    scene::scene(const std::string&amp; p_name, event::event_bus&amp; p_bus)\n      : m_name(p_name)\n      , m_bus(&amp;p_bus) {}\n\n    game_object scene::entity(std::string_view p_name) {\n        return game_object(m_registry.entity(p_name.data()));\n    }\n\n    game_object scene::entity(uint64_t p_id) {\n        return game_object(m_registry.entity(p_id));\n    }\n\n    uint32_t scene::children_count(const game_object&amp; p_parent) {\n        return query_builder().with(flecs::ChildOf, p_parent).build().count();\n    }\n\n};\n</code></pre>"},{"location":"References/world_8cpp/","title":"File world.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; scene &gt; world.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/scene/scene.hpp&gt;</code></li> <li><code>#include &lt;core/scene/world.hpp&gt;</code></li> <li><code>#include &lt;core/system/registry.hpp&gt;</code></li> </ul>"},{"location":"References/world_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/scene/world.cpp</code></p>"},{"location":"References/world_8cpp_source/","title":"File world.cpp","text":"<p>File List &gt; atlas &gt; core &gt; scene &gt; world.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/scene/scene.hpp&gt;\n#include &lt;core/scene/world.hpp&gt;\n#include &lt;core/system/registry.hpp&gt;\n\nnamespace atlas {\n\n    world::world(const std::string&amp; p_name)\n      : m_name(p_name) {}\n\n    void world::add_scene(const ref&lt;scene&gt;&amp; p_scene_context) {\n        m_scene_container.emplace(p_scene_context-&gt;name(), p_scene_context);\n    }\n};\n</code></pre>"},{"location":"References/dir_b056caa509fb4971186501a08c712a21/","title":"Dir TheAtlasEngine/src/atlas/core/serialize","text":"<p>FileList &gt; atlas &gt; core &gt; serialize</p>"},{"location":"References/dir_b056caa509fb4971186501a08c712a21/#files","title":"Files","text":"Type Name file serializer.cpp file types.cpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/serialize/</code></p>"},{"location":"References/serializer_8cpp/","title":"File serializer.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; serialize &gt; serializer.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/serialize/serializer.hpp&gt;</code></li> <li><code>#include &lt;core/scene/components.hpp&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;yaml-cpp/emitter.h&gt;</code></li> <li><code>#include &lt;core/system/registry.hpp&gt;</code></li> <li><code>#include &lt;core/serialize/types.hpp&gt;</code></li> <li><code>#include &lt;physics/components.hpp&gt;</code></li> </ul>"},{"location":"References/serializer_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/serialize/serializer.cpp</code></p>"},{"location":"References/serializer_8cpp_source/","title":"File serializer.cpp","text":"<p>File List &gt; atlas &gt; core &gt; serialize &gt; serializer.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/serialize/serializer.hpp&gt;\n#include &lt;core/scene/components.hpp&gt;\n#include &lt;fstream&gt;\n#include &lt;yaml-cpp/emitter.h&gt;\n#include &lt;core/system/registry.hpp&gt;\n#include &lt;core/serialize/types.hpp&gt;\n#include &lt;physics/components.hpp&gt;\n\nnamespace atlas {\n\n    // used to serialize entities\n    // TODO -- expand on this to stream_reader and stream_writer\n    static void serialize_entity(YAML::Emitter&amp; output,\n                                 const flecs::entity&amp; p_entity) {\n        output &lt;&lt; YAML::BeginMap;\n\n        output &lt;&lt; YAML::Key &lt;&lt; \"Entity\" &lt;&lt; YAML::Value &lt;&lt; p_entity.name();\n\n        if (p_entity.has&lt;transform&gt;()) {\n            output &lt;&lt; p_entity.get&lt;transform&gt;();\n        }\n\n        if (p_entity.has&lt;perspective_camera&gt;()) {\n            output &lt;&lt; p_entity.get&lt;perspective_camera&gt;();\n        }\n\n        if (p_entity.has&lt;mesh_source&gt;()) {\n            output &lt;&lt; p_entity.get&lt;mesh_source&gt;();\n        }\n\n        if (p_entity.has&lt;point_light&gt;()) {\n            output &lt;&lt; p_entity.get&lt;point_light&gt;();\n        }\n\n        if (p_entity.has&lt;physics_body&gt;()) {\n            output &lt;&lt; p_entity.get&lt;physics_body&gt;();\n        }\n\n        if (p_entity.has&lt;box_collider&gt;()) {\n            output &lt;&lt; p_entity.get&lt;box_collider&gt;();\n        }\n\n        if (p_entity.has&lt;sphere_collider&gt;()) {\n            output &lt;&lt; p_entity.get&lt;sphere_collider&gt;();\n        }\n\n        if (p_entity.has&lt;capsule_collider&gt;()) {\n            output &lt;&lt; p_entity.get&lt;capsule_collider&gt;();\n        }\n\n        // serialize entity childrens -- TODO\n        // output &lt;&lt; YAML::Key &lt;&lt; \"Children\" &lt;&lt; YAML::Value &lt;&lt; YAML::BeginSeq;\n        // p_entity.children([&amp;](flecs::entity p_child_entity){\n        //  serialize_entity(output, p_child_entity);\n        // });\n\n        output &lt;&lt; YAML::EndMap;\n    }\n\n    static void deserialize_entity(YAML::iterator::value_type p_entity_value,\n                                   flecs::entity&amp; p_deserialize_to_object) {\n        if (p_entity_value[\"Transform\"]) {\n            auto transform_data = p_entity_value[\"Transform\"];\n            p_deserialize_to_object.set&lt;transform&gt;({\n              .position = transform_data[\"Position\"].as&lt;glm::vec3&gt;(),\n              .quaternion = transform_data[\"Quaternion\"].as&lt;glm::highp_vec4&gt;(),\n              .rotation = transform_data[\"Rotation\"].as&lt;glm::vec3&gt;(),\n              .scale = transform_data[\"Scale\"].as&lt;glm::vec3&gt;(),\n            });\n        }\n\n        // Deserialize atlas::perspective_camera component\n        if (p_entity_value[\"PerspectiveCamera\"]) {\n            auto perspective_camera_data = p_entity_value[\"PerspectiveCamera\"];\n            p_deserialize_to_object.set&lt;perspective_camera&gt;({\n              .plane = perspective_camera_data[\"Plane\"].as&lt;glm::vec2&gt;(),\n              .is_active = perspective_camera_data[\"Active\"].as&lt;bool&gt;(),\n              .field_of_view =\n                perspective_camera_data[\"Field of View\"].as&lt;float&gt;(),\n            });\n        }\n\n        // Deserialize atlas::material component\n        if (p_entity_value[\"Mesh Source\"]) {\n            auto perspective_camera_data = p_entity_value[\"Mesh Source\"];\n            p_deserialize_to_object.set&lt;mesh_source&gt;({\n              .model_path =\n                perspective_camera_data[\"Model Path\"].as&lt;std::string&gt;(),\n              .diffuse = perspective_camera_data[\"Diffuse\"].as&lt;std::string&gt;(),\n              .specular = perspective_camera_data[\"Specular\"].as&lt;std::string&gt;(),\n            });\n        }\n\n        if (p_entity_value[\"Point Light\"]) {\n            auto point_light = p_entity_value[\"Point Light\"];\n            p_deserialize_to_object.set&lt;atlas::point_light&gt;({\n              .color = point_light[\"Color\"].as&lt;glm::vec4&gt;(),\n              .attenuation = point_light[\"Attenuation\"].as&lt;float&gt;(),\n              .constant = 1.f,\n              .linear = 1.f,\n              .quadratic = 1.f,\n              .ambient = point_light[\"Ambient\"].as&lt;glm::vec4&gt;(),\n              .diffuse = point_light[\"Diffuse\"].as&lt;glm::vec4&gt;(),\n              .specular = point_light[\"Specular\"].as&lt;glm::vec4&gt;(),\n            });\n        }\n\n        // deserialize physics body\n        if (p_entity_value[\"Physics Body\"]) {\n            auto body = p_entity_value[\"Physics Body\"];\n            p_deserialize_to_object.set&lt;physics_body&gt;(\n              { .linear_velocity = body[\"Linear Velocity\"].as&lt;glm::vec3&gt;(),\n                .angular_velocity = body[\"Angular Velocity\"].as&lt;glm::vec3&gt;(),\n                .force = body[\"Force\"].as&lt;glm::vec3&gt;(),\n                .impulse = body[\"Impulse\"].as&lt;glm::vec3&gt;(),\n                .torque = body[\"Torque\"].as&lt;glm::vec3&gt;(),\n                .center_mass_position =\n                  body[\"Center Mass Position\"].as&lt;glm::vec3&gt;(),\n                .friction = body[\"Friction\"].as&lt;float&gt;(),\n                .restitution = body[\"Restitution\"].as&lt;float&gt;(),\n                .body_movement_type =\n                  static_cast&lt;body_type&gt;(body[\"Body Movement Type\"].as&lt;int&gt;()),\n                .body_layer_type =\n                  static_cast&lt;body_layer&gt;(body[\"Body Layer Type\"].as&lt;int&gt;()) });\n        }\n\n        if (p_entity_value[\"Box Collider\"]) {\n            auto collider = p_entity_value[\"Box Collider\"];\n            p_deserialize_to_object.set&lt;box_collider&gt;({\n              .half_extent = collider[\"Half Extent\"].as&lt;glm::vec3&gt;(),\n            });\n        }\n\n        if (p_entity_value[\"Sphere Collider\"]) {\n            auto collider = p_entity_value[\"Sphere Collider\"];\n            p_deserialize_to_object.set&lt;sphere_collider&gt;({\n              .radius = collider[\"Radius\"].as&lt;float&gt;(),\n            });\n        }\n\n        if (p_entity_value[\"Capsule Collider\"]) {\n            auto collider = p_entity_value[\"Capsule Collider\"];\n            p_deserialize_to_object.set&lt;capsule_collider&gt;({\n              .radius = collider[\"Half Height\"].as&lt;float&gt;(),\n              .half_height = collider[\"Half Height\"].as&lt;float&gt;(),\n            });\n        }\n    }\n\n    serializer::serializer(const ref&lt;scene&gt;&amp; p_scene_ctx)\n      : m_current_scene_ctx(p_scene_ctx) {}\n\n    void serializer::save(const std::filesystem::path&amp; p_filepath) {\n        YAML::Emitter output;\n        output &lt;&lt; YAML::BeginMap;\n        output &lt;&lt; YAML::Key &lt;&lt; \"Scene\" &lt;&lt; YAML::Value\n               &lt;&lt; m_current_scene_ctx-&gt;name();\n        output &lt;&lt; YAML::Key &lt;&lt; \"Entities\" &lt;&lt; YAML::Value &lt;&lt; YAML::BeginSeq;\n\n        // ref&lt;world_scope&gt; world_object =\n        //   system_registry::get_world(\"Editor World\");\n        // ref&lt;scene&gt; current_scene =\n        // world_object-&gt;get_scene(\"LevelScene\");\n\n        // flecs::query&lt;&gt; q =\n        //   current_scene-&gt;query_builder().with&lt;atlas::transform&gt;().build();\n\n        // query all entities with a serialized tag specified\n        // while specifying to not query entities that also have the tag::editor\n        // specified\n        flecs::query&lt;&gt; q = m_current_scene_ctx-&gt;query_builder()\n                             .with&lt;tag::serialize&gt;()\n                             .without&lt;tag::editor&gt;()\n                             .build();\n\n        q.each([&amp;output](flecs::entity p_entity_id) {\n            serialize_entity(output, p_entity_id);\n        });\n\n        std::ofstream output_file(p_filepath.string());\n        output_file &lt;&lt; output.c_str();\n    }\n\n    bool serializer::load(const std::filesystem::path&amp; p_filepath,\n                          const flecs::world&amp; p_registry) {\n        std::ifstream ins(p_filepath.string());\n        std::stringstream ss;\n        ss &lt;&lt; ins.rdbuf();\n\n        YAML::Node data = YAML::Load(ss.str());\n\n        if (!data[\"Scene\"]) {\n            return false;\n        }\n\n        YAML::Node entity_objects = data[\"Entities\"];\n\n        if (entity_objects) {\n            for (YAML::iterator::value_type entity : entity_objects) {\n                std::string name = entity[\"Entity\"].as&lt;std::string&gt;();\n                flecs::entity deserialize_to_object =\n                  p_registry.entity(name.c_str());\n\n                // Deserialize atlas::transform component\n                deserialize_entity(entity, deserialize_to_object);\n            }\n        }\n\n        return true;\n    }\n};\n</code></pre>"},{"location":"References/core_2serialize_2types_8cpp/","title":"File types.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; serialize &gt; types.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/serialize/types.hpp&gt;</code></li> </ul>"},{"location":"References/core_2serialize_2types_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/serialize/types.cpp</code></p>"},{"location":"References/core_2serialize_2types_8cpp_source/","title":"File types.cpp","text":"<p>File List &gt; atlas &gt; core &gt; serialize &gt; types.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/serialize/types.hpp&gt;\n\nnamespace atlas {\n\n    YAML::Emitter&amp; operator&lt;&lt;(YAML::Emitter&amp; p_out,\n                              const glm::highp_vec2&amp; p_values) {\n        p_out &lt;&lt; YAML::Flow;\n        p_out &lt;&lt; YAML::BeginSeq &lt;&lt; p_values.x &lt;&lt; p_values.y &lt;&lt; YAML::EndSeq;\n        return p_out;\n    }\n\n    YAML::Emitter&amp; operator&lt;&lt;(YAML::Emitter&amp; p_out,\n                              const glm::highp_vec3&amp; p_values) {\n        p_out &lt;&lt; YAML::Flow;\n        p_out &lt;&lt; YAML::BeginSeq &lt;&lt; p_values.x &lt;&lt; p_values.y &lt;&lt; p_values.z\n              &lt;&lt; YAML::EndSeq;\n        return p_out;\n    }\n\n    YAML::Emitter&amp; operator&lt;&lt;(YAML::Emitter&amp; p_out,\n                              const glm::highp_vec4&amp; p_values) {\n        p_out &lt;&lt; YAML::Flow;\n        p_out &lt;&lt; YAML::BeginSeq &lt;&lt; p_values.x &lt;&lt; p_values.y &lt;&lt; p_values.z\n              &lt;&lt; p_values.w &lt;&lt; YAML::EndSeq;\n        return p_out;\n    }\n\n    // Serializing atlas::transform component to yaml format\n    YAML::Emitter&amp; operator&lt;&lt;(YAML::Emitter&amp; p_output,\n                              const transform* p_transform) {\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Transform\";\n\n        p_output &lt;&lt; YAML::BeginMap;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Position\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_transform-&gt;position;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Scale\" &lt;&lt; YAML::Value &lt;&lt; p_transform-&gt;scale;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Rotation\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_transform-&gt;rotation;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Quaternion\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_transform-&gt;quaternion;\n        p_output &lt;&lt; YAML::EndMap;\n        return p_output;\n    }\n\n    // Serialize perspective camera component into yaml format\n    YAML::Emitter&amp; operator&lt;&lt;(YAML::Emitter&amp; p_output,\n                              const perspective_camera* p_camera) {\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"PerspectiveCamera\";\n\n        p_output &lt;&lt; YAML::BeginMap;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Plane\" &lt;&lt; YAML::Value &lt;&lt; p_camera-&gt;plane;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Active\" &lt;&lt; YAML::Value &lt;&lt; p_camera-&gt;is_active;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Field of View\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_camera-&gt;field_of_view;\n        p_output &lt;&lt; YAML::EndMap;\n        return p_output;\n    }\n\n    YAML::Emitter&amp; operator&lt;&lt;(YAML::Emitter&amp; p_output,\n                              const mesh_source* p_material) {\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Mesh Source\";\n\n        p_output &lt;&lt; YAML::BeginMap;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Model Path\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_material-&gt;model_path;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Diffuse\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_material-&gt;diffuse;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Specular\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_material-&gt;specular;\n        p_output &lt;&lt; YAML::EndMap;\n        return p_output;\n    }\n\n    YAML::Emitter&amp; operator&lt;&lt;(YAML::Emitter&amp; p_output,\n                              const point_light* p_material) {\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Point Light\";\n\n        p_output &lt;&lt; YAML::BeginMap;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Color\" &lt;&lt; YAML::Value &lt;&lt; p_material-&gt;color;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Attenuation\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_material-&gt;attenuation;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Ambient\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_material-&gt;ambient;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Diffuse\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_material-&gt;diffuse;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Specular\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_material-&gt;specular;\n        p_output &lt;&lt; YAML::EndMap;\n        return p_output;\n    }\n\n    YAML::Emitter&amp; operator&lt;&lt;(YAML::Emitter&amp; p_output,\n                              const physics_body* p_body) {\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Physics Body\";\n\n        p_output &lt;&lt; YAML::BeginMap;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Linear Velocity\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_body-&gt;linear_velocity;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Angular Velocity\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_body-&gt;angular_velocity;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Force\" &lt;&lt; YAML::Value &lt;&lt; p_body-&gt;force;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Impulse\" &lt;&lt; YAML::Value &lt;&lt; p_body-&gt;impulse;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Torque\" &lt;&lt; YAML::Value &lt;&lt; p_body-&gt;torque;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Mass Factor\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_body-&gt;mass_factor;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Center Mass Position\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_body-&gt;center_mass_position;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Friction\" &lt;&lt; YAML::Value &lt;&lt; p_body-&gt;friction;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Restitution\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_body-&gt;restitution;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Body Movement Type\" &lt;&lt; YAML::Value\n                 &lt;&lt; static_cast&lt;int&gt;(p_body-&gt;body_movement_type);\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Body Layer Type\" &lt;&lt; YAML::Value\n                 &lt;&lt; static_cast&lt;int&gt;(p_body-&gt;body_layer_type);\n        p_output &lt;&lt; YAML::EndMap;\n        return p_output;\n    }\n\n    YAML::Emitter&amp; operator&lt;&lt;(YAML::Emitter&amp; p_output,\n                              const box_collider* p_body) {\n        // Tag this specific serialization values to the box collider\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Box Collider\";\n\n        p_output &lt;&lt; YAML::BeginMap;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Half Extent\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_body-&gt;half_extent;\n        p_output &lt;&lt; YAML::EndMap;\n\n        return p_output;\n    }\n\n    YAML::Emitter&amp; operator&lt;&lt;(YAML::Emitter&amp; p_output,\n                              const sphere_collider* p_body) {\n        //\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Sphere Collider\";\n\n        p_output &lt;&lt; YAML::BeginMap;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Radius\" &lt;&lt; YAML::Value &lt;&lt; p_body-&gt;radius;\n\n        p_output &lt;&lt; YAML::EndMap;\n\n        return p_output;\n    }\n\n    YAML::Emitter&amp; operator&lt;&lt;(YAML::Emitter&amp; p_output,\n                              const capsule_collider* p_body) {\n        //\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Capsule Collider\";\n        p_output &lt;&lt; YAML::BeginMap;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Radius\" &lt;&lt; YAML::Value &lt;&lt; p_body-&gt;radius;\n        p_output &lt;&lt; YAML::Key &lt;&lt; \"Half Height\" &lt;&lt; YAML::Value\n                 &lt;&lt; p_body-&gt;half_height;\n        p_output &lt;&lt; YAML::EndMap;\n\n        return p_output;\n    }\n};\n</code></pre>"},{"location":"References/dir_53c06e91a2ea408e8b37a84b8b632614/","title":"Dir TheAtlasEngine/src/atlas/core/system","text":"<p>FileList &gt; atlas &gt; core &gt; system</p>"},{"location":"References/dir_53c06e91a2ea408e8b37a84b8b632614/#files","title":"Files","text":"Type Name file registry.cpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/system/</code></p>"},{"location":"References/registry_8cpp/","title":"File registry.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; system &gt; registry.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;core/scene/world.hpp&gt;</code></li> <li><code>#include &lt;core/system/registry.hpp&gt;</code></li> </ul>"},{"location":"References/registry_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/system/registry.cpp</code></p>"},{"location":"References/registry_8cpp_source/","title":"File registry.cpp","text":"<p>File List &gt; atlas &gt; core &gt; system &gt; registry.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/engine_logger.hpp&gt;\n#include &lt;core/scene/world.hpp&gt;\n#include &lt;core/system/registry.hpp&gt;\n\nnamespace atlas {\n    system_registry* system_registry::s_instance = nullptr;\n\n    system_registry::system_registry(const std::string&amp; p_tag)\n      : m_tag(p_tag) {\n        s_instance = this;\n    }\n\n    system_registry::~system_registry() = default;\n\n    ref&lt;world&gt; system_registry::create_world(const std::string&amp; p_tag) {\n        return s_instance-&gt;append_world_and_get(create_ref&lt;world&gt;(p_tag));\n    }\n\n    ref&lt;world&gt; system_registry::get_world(const std::string&amp; p_tag) {\n        return s_instance-&gt;search_world(p_tag);\n    }\n\n    ref&lt;world&gt; system_registry::search_world(const std::string&amp; p_tag) {\n        return m_world_registered[p_tag];\n    }\n\n    ref&lt;world&gt; system_registry::append_world_and_get(\n      const ref&lt;world&gt;&amp; p_world) {\n        m_world_registered.emplace(p_world-&gt;name(), p_world);\n        return m_world_registered[p_world-&gt;name()];\n    }\n};\n</code></pre>"},{"location":"References/dir_820a1cd67b5638ff1fcd3240ccaeff22/","title":"Dir TheAtlasEngine/src/atlas/core/ui","text":"<p>FileList &gt; atlas &gt; core &gt; ui</p>"},{"location":"References/dir_820a1cd67b5638ff1fcd3240ccaeff22/#files","title":"Files","text":"Type Name file widgets.cpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/ui/</code></p>"},{"location":"References/widgets_8cpp/","title":"File widgets.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; ui &gt; widgets.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/ui/widgets.hpp&gt;</code></li> <li><code>#include &lt;imgui_internal.h&gt;</code></li> </ul>"},{"location":"References/widgets_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace ui <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/ui/widgets.cpp</code></p>"},{"location":"References/widgets_8cpp_source/","title":"File widgets.cpp","text":"<p>File List &gt; atlas &gt; core &gt; ui &gt; widgets.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/ui/widgets.hpp&gt;\n#include &lt;imgui_internal.h&gt; // Used to include \"PushMultiItemsWidths\"\n\nnamespace atlas::ui {\n    using ::ImGui::InputText;\n\n    bool begin_popup_context_window(const char* str_id,\n                                    ImGuiMouseButton mb,\n                                    bool over_items) {\n        return ImGui::BeginPopupContextWindow(\n          str_id, mb | (over_items ? 0 : ImGuiPopupFlags_NoOpenOverItems));\n    }\n\n    void draw_vec3(const std::string&amp; p_tag,\n                   glm::vec3&amp; p_position,\n                   float p_reset_value) {\n        // ImGuiIO&amp; io = ImGui::GetIO();\n        ImGui::PushID(p_tag.c_str());\n\n        float column_width = 125.0f;\n\n        ImGui::Columns(2);\n        ImGui::SetColumnWidth(0, column_width);\n        ImGui::Text(\"%s\", p_tag.c_str());\n        ImGui::NextColumn();\n\n        ImGui::PushMultiItemsWidths(3, ImGui::CalcItemWidth());\n        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2{ 0, 0 });\n\n        float line_height =\n          ImGui::GetFontSize() + ImGui::GetStyle().FramePadding.y * 2.0f;\n        ImVec2 button_size = { line_height + 3.0f, line_height };\n\n        ImGui::PushStyleColor(ImGuiCol_Button,\n                              ImVec4{ 0.8, 0.1f, 0.15f, 1.0f });\n        ImGui::PushStyleColor(ImGuiCol_ButtonHovered,\n                              ImVec4{ 0.3f, 0.8f, 0.3f, 1.0f });\n        ImGui::PushStyleColor(ImGuiCol_ButtonActive,\n                              ImVec4{ 0.2, 0.1f, 0.2f, 1.0f });\n\n        if (ImGui::Button(\"X\", button_size)) {\n            p_position.x = p_reset_value;\n            // ImGui::End();\n        }\n\n        // ImGui::PopFont();\n        ImGui::PopStyleColor(3);\n\n        ImGui::SameLine();\n        ImGui::DragFloat(\"##X\", &amp;p_position.x, 0.1f, 0.0f, 0.0f, \"%.2f\");\n        ImGui::PopItemWidth();\n        ImGui::SameLine();\n\n        // Setting up for the Y button\n        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4{ 0.2, 0.7f, 0.2f, 1.0f });\n        ImGui::PushStyleColor(ImGuiCol_ButtonHovered,\n                              ImVec4{ 0.3f, 0.8f, 0.3f, 1.0f });\n        ImGui::PushStyleColor(ImGuiCol_ButtonActive,\n                              ImVec4{ 0.2, 0.1f, 0.2f, 1.0f });\n\n        if (ImGui::Button(\"Y\", button_size)) {\n            p_position.y = p_reset_value;\n            // ImGui::End();\n        }\n\n        // ImGui::PopFont();\n        ImGui::PopStyleColor(3);\n        ImGui::SameLine();\n        ImGui::DragFloat(\"##Y\", &amp;p_position.y, 0.1f, 0.0f, 0.0f, \"%.2f\");\n        ImGui::PopItemWidth();\n        ImGui::SameLine();\n\n        // Setting up for the Z button\n        ImGui::PushStyleColor(ImGuiCol_Button,\n                              ImVec4{ 0.1, 0.25f, 0.8f, 1.0f });\n        ImGui::PushStyleColor(ImGuiCol_ButtonHovered,\n                              ImVec4{ 0.2f, 0.35f, 0.9f, 1.0f });\n        ImGui::PushStyleColor(ImGuiCol_ButtonActive,\n                              ImVec4{ 0.8, 0.1f, 0.15f, 1.0f });\n        if (ImGui::Button(\"Z\", button_size)) {\n            p_position.z = p_reset_value;\n            // ImGui::End();\n        }\n\n        // ImGui::PopFont();\n        ImGui::PopStyleColor(3);\n        ImGui::SameLine();\n        ImGui::DragFloat(\"##Z\", &amp;p_position.z, 0.1f, 0.0f, 0.0f, \"%.2f\");\n        ImGui::PopItemWidth();\n\n        ImGui::PopStyleVar();\n\n        ImGui::Columns(1);\n\n        ImGui::PopID();\n    }\n\n    void draw_vec4(const std::string&amp; p_tag,\n                   glm::vec4&amp; p_value,\n                   float p_reset_value) {\n        // ImGuiIO&amp; io = ImGui::GetIO();\n        ImGui::PushID(p_tag.c_str());\n\n        float column_width = 100.0f;\n\n        ImGui::Columns(2);\n        ImGui::SetColumnWidth(0, column_width);\n        ImGui::Text(\"%s\", p_tag.c_str());\n        ImGui::NextColumn();\n\n        ImGui::PushMultiItemsWidths(3, ImGui::CalcItemWidth());\n        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2{ 0, 0 });\n\n        float line_height =\n          ImGui::GetFontSize() + ImGui::GetStyle().FramePadding.y * 2.0f;\n        ImVec2 button_size = { line_height + 3.0f, line_height };\n\n        ImGui::PushStyleColor(ImGuiCol_Button,\n                              ImVec4{ 0.8, 0.1f, 0.15f, 1.0f });\n        ImGui::PushStyleColor(ImGuiCol_ButtonHovered,\n                              ImVec4{ 0.3f, 0.8f, 0.3f, 1.0f });\n        ImGui::PushStyleColor(ImGuiCol_ButtonActive,\n                              ImVec4{ 0.2, 0.1f, 0.2f, 1.0f });\n\n        if (ImGui::Button(\"X\", button_size)) {\n            p_value.x = p_reset_value;\n            // ImGui::End();\n        }\n\n        // ImGui::PopFont();\n        ImGui::PopStyleColor(3);\n\n        ImGui::SameLine();\n        ImGui::DragFloat(\"##X\", &amp;p_value.x, 0.1f, 0.0f, 0.0f, \"%.2f\");\n        ImGui::PopItemWidth();\n        ImGui::SameLine();\n\n        // Setting up for the Y button\n        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4{ 0.2, 0.7f, 0.2f, 1.0f });\n        ImGui::PushStyleColor(ImGuiCol_ButtonHovered,\n                              ImVec4{ 0.3f, 0.8f, 0.3f, 1.0f });\n        ImGui::PushStyleColor(ImGuiCol_ButtonActive,\n                              ImVec4{ 0.2, 0.1f, 0.2f, 1.0f });\n\n        if (ImGui::Button(\"Y\", button_size)) {\n            p_value.y = p_reset_value;\n            // ImGui::End();\n        }\n\n        // ImGui::PopFont();\n        ImGui::PopStyleColor(3);\n        ImGui::SameLine();\n        ImGui::DragFloat(\"##Y\", &amp;p_value.y, 0.1f, 0.0f, 0.0f, \"%.2f\");\n        ImGui::PopItemWidth();\n        ImGui::SameLine();\n\n        // Setting up for the Z button\n        ImGui::PushStyleColor(ImGuiCol_Button,\n                              ImVec4{ 0.1, 0.25f, 0.8f, 1.0f });\n        ImGui::PushStyleColor(ImGuiCol_ButtonHovered,\n                              ImVec4{ 0.2f, 0.35f, 0.9f, 1.0f });\n        ImGui::PushStyleColor(ImGuiCol_ButtonActive,\n                              ImVec4{ 0.8, 0.1f, 0.15f, 1.0f });\n        if (ImGui::Button(\"Z\", button_size)) {\n            p_value.z = p_reset_value;\n            // ImGui::End();\n        }\n\n        // ImGui::PopFont();\n        ImGui::PopStyleColor(3);\n        ImGui::SameLine();\n        ImGui::DragFloat(\"##Z\", &amp;p_value.z, 0.1f, 0.0f, 0.0f, \"%.2f\");\n        ImGui::PopItemWidth();\n\n        ImGui::PopStyleVar();\n\n        ImGui::Columns(1);\n\n        ImGui::PopID();\n    }\n\n    void draw_float(const std::string&amp; p_tag,\n                    float&amp; p_value,\n                    float reset_value) {\n        ImGui::PushID(p_tag.c_str());\n\n        float column_width = 100.0f;\n\n        ImGui::Columns(2);\n\n        ImGui::SetColumnWidth(0, column_width);\n        ImGui::Text(\"%s\", p_tag.c_str());\n        ImGui::NextColumn();\n\n        ImGui::PushItemWidth(ImGui::CalcItemWidth());\n        // ImGui::PushMultiItemsWidths(3, ImGui::CalcItemWidth());\n        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2{ 0, 0 });\n        ImGui::PushStyleColor(ImGuiCol_Button,\n                              ImVec4{ 0.8, 0.1f, 0.15f, 1.0f });\n        ImGui::PushStyleColor(ImGuiCol_ButtonHovered,\n                              ImVec4{ 0.3f, 0.8f, 0.3f, 1.0f });\n        ImGui::PushStyleColor(ImGuiCol_ButtonActive,\n                              ImVec4{ 0.2, 0.1f, 0.2f, 1.0f });\n\n        if (ImGui::Button(p_tag.c_str())) {\n            p_value = reset_value;\n            // ImGui::End();\n        }\n\n        // ImGui::PopFont();\n        ImGui::PopStyleColor(3);\n\n        ImGui::SameLine();\n        ImGui::DragFloat(\"##X\", &amp;p_value, 0.1f, 0.0f, 0.0f, \"%.2f\");\n        ImGui::PopItemWidth();\n        ImGui::SameLine();\n\n        ImGui::PopStyleVar();\n\n        ImGui::Columns(1);\n\n        ImGui::PopID();\n    }\n\n    void draw_input_text(std::string&amp; p_dst, std::string&amp; p_src) {\n        std::string input_buffer = p_src;\n\n        ImGuiInputTextFlags flags = ImGuiInputTextFlags_EnterReturnsTrue;\n        input_buffer.resize(255); // resize to allocate for 255 in the char\n                                  // array since this should be long enough\n\n        if (ImGui::InputText(\"##Name\",\n                             (char*)input_buffer.c_str(),\n                             input_buffer.size() + 1,\n                             flags)) {\n            p_dst = input_buffer;\n        }\n\n        if (p_dst.empty()) {\n            p_dst = p_src;\n            return;\n        }\n\n        if (p_dst == p_src) {\n            p_dst = p_src;\n            return;\n        }\n    }\n\n    void draw_text(const std::string&amp; p_value) {\n        ImGui::Text(\"%s\", p_value.data());\n    }\n\n    void dockspace_window(GLFWwindow* p_window) {\n\n        bool dockspace_open = true;\n        static bool opt_fullscreen_persistant = true;\n        bool opt_fullscreen = opt_fullscreen_persistant;\n        static ImGuiDockNodeFlags dockspace_flags = ImGuiDockNodeFlags_None;\n\n        ImGuiWindowFlags window_flags =\n          ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_NoDocking;\n\n        if (opt_fullscreen) {\n            ImGuiViewport* viewport = ImGui::GetMainViewport();\n            ImGui::SetNextWindowPos(viewport-&gt;Pos);\n            ImGui::SetNextWindowSize(viewport-&gt;Size);\n            ImGui::SetNextWindowViewport(viewport-&gt;ID);\n            window_flags |= ImGuiWindowFlags_NoTitleBar |\n                            ImGuiWindowFlags_NoCollapse |\n                            ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove;\n            window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus |\n                            ImGuiWindowFlags_NoNavFocus;\n        }\n\n        if (dockspace_flags &amp; ImGuiDockNodeFlags_PassthruCentralNode) {\n            window_flags |= ImGuiWindowFlags_NoBackground;\n        }\n\n        ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));\n        ImGui::Begin(\"Dockspace Demo\", &amp;dockspace_open, window_flags);\n        ImGui::PopStyleVar();\n\n        if (opt_fullscreen) {\n            ImGui::PopStyleVar(2);\n        }\n\n        // Dockspace\n        ImGuiIO&amp; io = ImGui::GetIO();\n        if (io.ConfigFlags &amp; ImGuiConfigFlags_DockingEnable) {\n            ImGuiID dockspace_id = ImGui::GetID(\"MyDockspace\");\n            ImGui::DockSpace(dockspace_id, ImVec2(0.f, 0.f), dockspace_flags);\n        }\n\n        if (ImGui::BeginMenuBar()) {\n            if (ImGui::MenuItem(\"Exit\")) {\n                glfwSetWindowShouldClose(p_window, true);\n            }\n\n            ImGui::EndMenuBar();\n        }\n\n        ImGui::End();\n    }\n\n    void button_open_file_dialog(const std::string&amp; p_tag,\n                                 std::string&amp; p_filename,\n                                 const std::string&amp; p_filter) {\n        if (ImGui::Button(p_tag.c_str())) {\n            p_filename = filesystem::load_from_file_dialog(p_filter);\n        }\n    }\n};\n</code></pre>"},{"location":"References/dir_4112b34ff4c6cd2019ee1a1b55bd7baf/","title":"Dir TheAtlasEngine/src/atlas/core/utilities","text":"<p>FileList &gt; atlas &gt; core &gt; utilities</p>"},{"location":"References/dir_4112b34ff4c6cd2019ee1a1b55bd7baf/#files","title":"Files","text":"Type Name file state.cpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/utilities/</code></p>"},{"location":"References/state_8cpp/","title":"File state.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; utilities &gt; state.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/utilities/state.hpp&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> </ul>"},{"location":"References/state_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace detail <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/utilities/state.cpp</code></p>"},{"location":"References/state_8cpp_source/","title":"File state.cpp","text":"<p>File List &gt; atlas &gt; core &gt; utilities &gt; state.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/utilities/state.hpp&gt;\n#include &lt;unordered_map&gt;\n\nnamespace atlas {\n    namespace detail {\n        // inline std::deque&lt;std::function&lt;void()&gt;&gt; s_update{};\n        // inline std::deque&lt;std::function&lt;void()&gt;&gt; s_defer_update{};\n        // inline std::deque&lt;std::function&lt;void()&gt;&gt; s_ui_update{};\n        // inline std::deque&lt;std::function&lt;void()&gt;&gt; s_physica_update{};\n        // inline std::deque&lt;std::function&lt;void()&gt;&gt; s_start{};\n\n        // TODO: This should be done in a better way\n        // Potential replace this approach with using std::hive from C++26\n        inline std::unordered_map&lt;void*, std::function&lt;void()&gt;&gt; s_update{};\n        inline std::unordered_map&lt;void*, std::function&lt;void()&gt;&gt;\n          s_defer_update{};\n        inline std::unordered_map&lt;void*, std::function&lt;void()&gt;&gt; s_ui_update{};\n        inline std::unordered_map&lt;void*, std::function&lt;void()&gt;&gt;\n          s_physica_update{};\n        inline std::unordered_map&lt;void*, std::function&lt;void()&gt;&gt; s_start{};\n\n        void poll_update(void* p_address,\n                         const std::function&lt;void()&gt;&amp; p_callable) {\n            // s_update.emplace_back(p_callback);\n            s_update.emplace(p_address, p_callable);\n        }\n\n        void poll_defer_update(void* p_address,\n                               const std::function&lt;void()&gt;&amp; p_callback) {\n            s_defer_update.emplace(p_address, p_callback);\n        }\n\n        void poll_physics_update(void* p_address,\n                                 const std::function&lt;void()&gt;&amp; p_callback) {\n            s_physica_update.emplace(p_address, p_callback);\n        }\n\n        void poll_ui_update(void* p_address,\n                            const std::function&lt;void()&gt;&amp; p_callback) {\n            s_ui_update.emplace(p_address, p_callback);\n        }\n\n        void poll_start(void* p_address,\n                        const std::function&lt;void()&gt;&amp; p_callback) {\n            s_start.emplace(p_address, p_callback);\n        }\n\n        void remove_update(void* p_address) {\n            s_update.erase(p_address);\n        }\n\n        void remove_defer_update(void* p_address) {\n            s_defer_update.erase(p_address);\n        }\n\n        void remove_physics_update(void* p_address) {\n            s_physica_update.erase(p_address);\n        }\n\n        void remove_ui_update(void* p_address) {\n            s_ui_update.erase(p_address);\n        }\n\n        void remove_start(void* p_address) {\n            s_start.erase(p_address);\n        }\n\n        void invoke_on_update() {\n            for (auto&amp; [address, on_update] : s_update) {\n                on_update();\n            }\n        }\n\n        void invoke_defer_update() {\n            for (auto&amp; [address, on_update] : s_defer_update) {\n                on_update();\n            }\n        }\n\n        void invoke_physics_update() {\n            for (auto&amp; [address, on_update] : s_physica_update) {\n                on_update();\n            }\n        }\n\n        void invoke_ui_update() {\n            for (auto&amp; [address, on_update] : s_ui_update) {\n                on_update();\n            }\n        }\n\n        void invoke_start() {\n            for (auto&amp; [address, on_update] : s_start) {\n                on_update();\n            }\n        }\n    };\n};\n</code></pre>"},{"location":"References/application_8cpp/","title":"File application.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; application.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/application.hpp&gt;</code></li> <li><code>#include &lt;core/common.hpp&gt;</code></li> <li><code>#include &lt;core/utilities/state.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_swapchain.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;</code></li> </ul>"},{"location":"References/application_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/application.cpp</code></p>"},{"location":"References/application_8cpp_source/","title":"File application.cpp","text":"<p>File List &gt; atlas &gt; core &gt; application.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/application.hpp&gt;\n#include &lt;core/common.hpp&gt;\n#include &lt;core/utilities/state.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_swapchain.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;\n\nnamespace atlas {\n    application* application::s_instance = nullptr;\n\n    // For now we set this globally readable to other graphics-api agnostic\n    // API's Not able to be modified, rather only read.\n    static api g_graphics_backend_api = api::vulkan;\n\n    application::application(const application_settings&amp; p_settings) {\n        console_log_manager::set_current_logger(p_settings.name);\n        set_current_api(api::vulkan);\n        window_settings settings = {\n            .width = p_settings.width,\n            .height = p_settings.height,\n            .name = p_settings.name,\n        };\n        m_window = create_window(settings);\n\n        m_renderer = create_ref&lt;renderer&gt;(\n          settings, m_window-&gt;current_swapchain().image_size(), \"Renderer\");\n        m_renderer-&gt;set_background_color({\n          p_settings.background_color.x,\n          p_settings.background_color.y,\n          p_settings.background_color.z,\n          p_settings.background_color.w,\n        });\n\n        // vulkan-specific imgui context that allows us to control our backend\n        // through vulkan\n        m_ui_context = vk::imgui_context(m_window);\n\n        vk::vk_context::submit_resource_free(\n          [this]() { m_ui_context.destroy(); });\n        s_instance = this;\n    }\n\n    uint32_t application::current_frame() {\n        return s_instance-&gt;m_current_frame_index;\n    }\n\n    application::~application() {\n        destroy();\n    }\n\n    void application::set_current_api(api api) {\n        g_graphics_backend_api = api;\n    }\n\n    // NOTE: only good for immediate usage,\n    //  this will not work for long-term storage due to the likelyhood\n    //  of the handle being invalidated\n    VkSwapchainKHR application::get_current_swapchain() {\n        return m_window-&gt;current_swapchain();\n    }\n\n    api application::current_api() {\n        return g_graphics_backend_api;\n    }\n\n    void application::destroy() {\n        s_instance-&gt;get_window().close();\n    }\n\n    float application::delta_time() {\n        return s_instance-&gt;m_delta_time;\n    }\n\n    float application::physics_step() {\n        return 0.f;\n    }\n\n    void application::execute() {\n        auto start_time = std::chrono::high_resolution_clock::now();\n\n        detail::invoke_start();\n\n        m_renderer-&gt;preload(\n          m_window-&gt;current_swapchain().swapchain_renderpass());\n\n        ref&lt;world&gt; current_world = system_registry::get_world(\"Editor World\");\n        ref&lt;scene&gt; current_scene = current_world-&gt;get_scene(\"LevelScene\");\n\n        flecs::world current_world_scope = *current_scene;\n\n        /*\n            - flecs::system is how your able to schedule changes for given\n            portions of data in this case the projection/view matrices are only\n            being changed when flecs::world::progress(g_delta_time) is being\n            invoked within the mainloop\n            current_world_scope.system&lt;projection_view, transform,\n            perspective_camera&gt;()\n\n            - When users do object-&gt;add&lt;flecs::pair&lt;tag::editor,\n            projection_view&gt;&gt;(), this automatically gets invoked by the\n           .system&lt;...&gt; that gets invoked by the mainloop.\n        */\n        current_world_scope\n          .system&lt;flecs::pair&lt;tag::editor, projection_view&gt;,\n                  transform,\n                  perspective_camera&gt;()\n          .each([&amp;](flecs::pair&lt;tag::editor, projection_view&gt; p_pair,\n                    transform&amp; p_transform,\n                    perspective_camera&amp; p_camera) {\n              float aspect_ratio = m_window-&gt;aspect_ratio();\n              if (!p_camera.is_active) {\n                  return;\n              }\n\n              p_pair-&gt;projection = glm::mat4(1.f);\n\n              p_pair-&gt;projection =\n                glm::perspective(glm::radians(p_camera.field_of_view),\n                                 aspect_ratio,\n                                 p_camera.plane.x,\n                                 p_camera.plane.y);\n              p_pair-&gt;projection[1][1] *= -1;\n              p_pair-&gt;view = glm::mat4(1.f);\n\n              // This is converting a glm::highp_vec4 to a glm::quat\n              glm::quat quaternion = to_quat(p_transform.quaternion);\n\n              p_pair-&gt;view =\n                glm::translate(p_pair-&gt;view, p_transform.position) *\n                glm::mat4_cast(quaternion);\n\n              p_pair-&gt;view = glm::inverse(p_pair-&gt;view);\n          });\n\n        /*\n            - Currently how this works is we query with anything that has a\n           flecs::pair&lt;tag::editor, projection_view&gt;\n            - This tells the ecs flecs what to do query for in regards to\n           specific objects that are a camera\n            - in the tag:: namespace, this is to imply components that are empty\n           and just represent tags, to specify their uses.\n        */\n        auto query_camera_objects =\n          current_scene\n            -&gt;query_builder&lt;flecs::pair&lt;tag::editor, projection_view&gt;,\n                            perspective_camera&gt;()\n            .build();\n\n        while (m_window-&gt;available()) {\n            auto current_time = std::chrono::high_resolution_clock::now();\n            m_delta_time =\n              std::chrono::duration&lt;float, std::chrono::seconds::period&gt;(\n                current_time - start_time)\n                .count();\n            start_time = current_time;\n            event::update_events();\n\n            // Progresses the flecs::world by one tick (or replaced with using\n            // the delta time)\n            // This also invokes the following system&lt;T...&gt; call  before the\n            // mainloop\n            current_world_scope.progress(m_delta_time);\n\n            m_current_frame_index = m_window-&gt;acquired_next_frame();\n\n            // Current commands that are going to be iterated through\n            // Prevents things like stalling so the CPU doesnt have to wait for\n            // the GPU to fully complete before starting on the next frame\n            // Command buffer uses this to track the frames to process its\n            // commands currently_active_frame = (m_current_frame_index + 1) %\n            // m_window-&gt;current_swapchain().settings().frames_in_flight;\n            // TODO: Going to need to figure out where to put this\n            // Added this here because to ensure the handlers being used by the\n            // renderer is in sync when swapchain is resized\n            ::vk::command_buffer currently_active =\n              m_window-&gt;active_command(m_current_frame_index);\n\n            detail::invoke_physics_update();\n\n            detail::invoke_on_update();\n\n            detail::invoke_defer_update();\n\n            // We want this to be called after late update\n            // This queries all camera objects within the camera system\n            // Update -- going to be removing camera system in replacement of\n            // just simply using flecs::system to keep it simple for the time\n            query_camera_objects.each(\n              [&amp;](flecs::entity,\n                  flecs::pair&lt;tag::editor, projection_view&gt; p_pair,\n                  perspective_camera&amp; p_camera) {\n                  if (!p_camera.is_active) {\n                      return;\n                  }\n\n                  m_proj_view = p_pair-&gt;projection * p_pair-&gt;view;\n              });\n\n            // TODO: Introduce scene renderer that will make use of the\n            // begin/end semantics for setting up tasks during pre-frame\n            // operations\n            // renderer begin to indicate when a start of the frame to start\n            // processing specific tasks that either need to be computed or\n            // pre-defined before the renderer does something with it.\n            // TODO: Add scene_manager to coordinate what to process\n            // before frame preparation\n            auto current_framebuffer =\n              m_window-&gt;current_swapchain().active_framebuffer(\n                m_current_frame_index);\n            m_renderer-&gt;begin(\n              currently_active,\n              m_window-&gt;current_swapchain().settings(),\n              m_window-&gt;current_swapchain().swapchain_renderpass(),\n              current_framebuffer,\n              m_proj_view);\n\n            // TODO: vk:imgui_context will have its own renderpass, command\n            // buffers, and framebuffers specifically for UI-widgets + viewport\n            m_ui_context.begin(currently_active, m_current_frame_index);\n\n            detail::invoke_ui_update();\n\n            m_ui_context.end();\n\n            m_renderer-&gt;end();\n\n            /*\n                TODO -- have m_window present this to the screen, eventually\n               m_renderer should just fetch the images in the order to offload\n               to the swapchain for rendering.\n\n                Where each image has gone through different phases of the\n               renderpass onto the final image\n            */\n\n            std::array&lt;const VkCommandBuffer, 1&gt; commands = {\n                currently_active,\n            };\n            m_window-&gt;current_swapchain().submit(commands);\n            // Presents to the swapchain to display to screen\n            // m_renderer-&gt;present(m_current_frame_index);\n            m_window-&gt;present(m_current_frame_index);\n        }\n    }\n\n    void application::post_destroy() {\n        m_window-&gt;close();\n    }\n\n    float application::aspect_ratio() {\n        return s_instance-&gt;m_window-&gt;aspect_ratio();\n    }\n\n    uint32_t application::image_size() {\n        return s_instance-&gt;m_window-&gt;current_swapchain().image_size();\n    }\n};\n</code></pre>"},{"location":"References/engine__logger_8cpp/","title":"File engine_logger.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; engine_logger.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;spdlog/common.h&gt;</code></li> <li><code>#include &lt;spdlog/sinks/stdout_color_sinks.h&gt;</code></li> </ul>"},{"location":"References/engine__logger_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/engine_logger.cpp</code></p>"},{"location":"References/engine__logger_8cpp_source/","title":"File engine_logger.cpp","text":"<p>File List &gt; atlas &gt; core &gt; engine_logger.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/engine_logger.hpp&gt;\n#include &lt;spdlog/common.h&gt;\n#include &lt;spdlog/sinks/stdout_color_sinks.h&gt;\n\nnamespace atlas {\n\n    std::string g_current_pattern_for_logs = \"Undefined Pattern Specified\";\n    std::unordered_map&lt;std::string, ref&lt;spdlog::logger&gt;&gt;\n      console_log_manager::s_loggers;\n\n    void console_log_manager::initialize_logger_manager(\n      const std::string&amp; pattern) {\n        g_current_pattern_for_logs = pattern;\n\n        s_loggers.insert({ \"engine3d\", spdlog::stdout_color_mt(\"engine3d\") });\n        s_loggers.insert({ \"physics\", spdlog::stdout_color_mt(\"physics\") });\n        s_loggers.insert({ \"vulkan\", spdlog::stdout_color_mt(\"vulkan\") });\n        s_loggers.insert(\n          { \"assert\", spdlog::stdout_color_mt(\"core assertion\") });\n\n        s_loggers[\"engine3d\"]-&gt;set_pattern(pattern);\n        s_loggers[\"engine3d\"]-&gt;set_level(spdlog::level::trace);\n\n        s_loggers[\"physics\"]-&gt;set_level(spdlog::level::trace);\n        s_loggers[\"physics\"]-&gt;set_pattern(pattern);\n\n        s_loggers[\"vulkan\"]-&gt;set_level(spdlog::level::trace);\n        s_loggers[\"vulkan\"]-&gt;set_pattern(pattern);\n\n        s_loggers[\"assert\"]-&gt;set_level(spdlog::level::trace);\n        s_loggers[\"assert\"]-&gt;set_pattern(pattern);\n    }\n\n    void console_log_manager::create_new_logger(\n      [[maybe_unused]] const std::string&amp; p_tag) {\n#ifndef ENABLE_TESTS_ONLY\n        s_loggers[p_tag] = spdlog::stdout_color_mt(p_tag);\n        s_loggers[p_tag]-&gt;set_level(spdlog::level::trace);\n        s_loggers[p_tag]-&gt;set_pattern(g_current_pattern_for_logs);\n#endif\n    }\n\n    void console_log_manager::set_current_logger(\n      [[maybe_unused]] const std::string&amp; p_tag) {\n#ifndef ENABLE_TESTS_ONLY\n        s_loggers[p_tag] = spdlog::stdout_color_mt(p_tag);\n        s_loggers[p_tag]-&gt;set_level(spdlog::level::trace);\n        s_loggers[p_tag]-&gt;set_pattern(g_current_pattern_for_logs);\n#endif\n    }\n\n    ref&lt;spdlog::logger&gt; console_log_manager::get(const std::string&amp; p_tag) {\n        return s_loggers[p_tag];\n    }\n};\n</code></pre>"},{"location":"References/timer_8cpp/","title":"File timer.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; timer.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/timer.cpp</code></p>"},{"location":"References/timer_8cpp_source/","title":"File timer.cpp","text":"<p>File List &gt; atlas &gt; core &gt; timer.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n- Delete this file along with core/timer.hpp if not done so\n- Only exists to prevent merge conflicts in CMakeLists.txt\n*/\n</code></pre>"},{"location":"References/window_8cpp/","title":"File window.cpp","text":"<p>FileList &gt; atlas &gt; core &gt; window.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include &lt;core/application.hpp&gt;</code></li> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;core/window.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_window.hpp&gt;</code></li> </ul>"},{"location":"References/window_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/core/window.cpp</code></p>"},{"location":"References/window_8cpp_source/","title":"File window.cpp","text":"<p>File List &gt; atlas &gt; core &gt; window.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;GLFW/glfw3.h&gt;\n#include &lt;core/application.hpp&gt;\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;core/window.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_window.hpp&gt;\n\nnamespace atlas {\n    ref&lt;window&gt; create_window(const window_settings&amp; p_settings) {\n        switch (application::current_api()) {\n            case api::vulkan:\n                return create_ref&lt;vk::vk_window&gt;(p_settings);\n            default:\n                console_log_error(\n                  \"API that was input was not specifiying valid backend!\");\n                return nullptr;\n        }\n\n        return nullptr;\n    }\n\n    uint32_t window::width() const {\n        return settings().width;\n    }\n\n    uint32_t window::height() const {\n        return settings().height;\n    }\n\n    bool window::available() const {\n        return !glfwWindowShouldClose(native_window());\n    }\n\n    void window::close() {\n        glfwSetWindowShouldClose(native_window(), true);\n    }\n\n    void window::present(const uint32_t&amp; p_current_frame_idx) {\n        return presentation_process(p_current_frame_idx);\n    }\n\n    float window::aspect_ratio() const {\n        return (float)width() / (float)height();\n    }\n};\n</code></pre>"},{"location":"References/dir_608dc5b7aaba5a488a1cee762bfade26/","title":"Dir TheAtlasEngine/src/atlas/drivers","text":"<p>FileList &gt; atlas &gt; drivers</p>"},{"location":"References/dir_608dc5b7aaba5a488a1cee762bfade26/#files","title":"Files","text":"Type Name file graphics_context.cpp file render_context.cpp"},{"location":"References/dir_608dc5b7aaba5a488a1cee762bfade26/#directories","title":"Directories","text":"Type Name dir jolt-cpp dir vulkan-cpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/</code></p>"},{"location":"References/dir_91f3b6bbd0150e83e6271f2b896a7a0e/","title":"Dir TheAtlasEngine/src/atlas/drivers/jolt-cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; jolt-cpp</p>"},{"location":"References/dir_91f3b6bbd0150e83e6271f2b896a7a0e/#files","title":"Files","text":"Type Name file jolt_contact_listener.cpp file jolt_context.cpp file types.cpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/jolt-cpp/</code></p>"},{"location":"References/jolt__contact__listener_8cpp/","title":"File jolt_contact_listener.cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; jolt-cpp &gt; jolt_contact_listener.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/jolt-cpp/jolt-imports.hpp&gt;</code></li> <li><code>#include &lt;drivers/jolt-cpp/jolt_contact_listener.hpp&gt;</code></li> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;drivers/jolt-cpp/jolt_components.hpp&gt;</code></li> <li><code>#include &lt;core/event/types.hpp&gt;</code></li> </ul>"},{"location":"References/jolt__contact__listener_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/jolt-cpp/jolt_contact_listener.cpp</code></p>"},{"location":"References/jolt__contact__listener_8cpp_source/","title":"File jolt_contact_listener.cpp","text":"<p>File List &gt; atlas &gt; drivers &gt; jolt-cpp &gt; jolt_contact_listener.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;drivers/jolt-cpp/jolt-imports.hpp&gt;\n#include &lt;drivers/jolt-cpp/jolt_contact_listener.hpp&gt;\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;drivers/jolt-cpp/jolt_components.hpp&gt;\n#include &lt;core/event/types.hpp&gt;\n\nnamespace atlas::physics {\n\n    contact_listener::contact_listener(event::event_bus&amp; p_bus)\n      : m_bus(&amp;p_bus) {}\n\n    JPH::ValidateResult contact_listener::OnContactValidate(\n      const JPH::Body&amp;,\n      const JPH::Body&amp;,\n      JPH::RVec3Arg,\n      const JPH::CollideShapeResult&amp;) {\n        return JPH::ValidateResult::AcceptAllContactsForThisBodyPair;\n    }\n\n    void contact_listener::OnContactAdded(const JPH::Body&amp; p_body1,\n                                          const JPH::Body&amp; p_body2,\n                                          const JPH::ContactManifold&amp;,\n                                          JPH::ContactSettings&amp;) {\n        event::collision_enter begin_event = {\n            .entity1 = static_cast&lt;uint64_t&gt;(p_body1.GetUserData()),\n            .entity2 = static_cast&lt;uint64_t&gt;(p_body2.GetUserData())\n        };\n\n        // Publishes to all subscribers that this collision_enter event has\n        // occurred\n        m_bus-&gt;publish(begin_event);\n    }\n\n    void contact_listener::OnContactPersisted(const JPH::Body&amp; p_body1,\n                                              const JPH::Body&amp; p_body2,\n                                              const JPH::ContactManifold&amp;,\n                                              JPH::ContactSettings&amp;) {\n        event::collision_persisted persisted_event = {\n            .entity1 = static_cast&lt;uint64_t&gt;(p_body1.GetUserData()),\n            .entity2 = static_cast&lt;uint64_t&gt;(p_body2.GetUserData())\n        };\n\n        m_bus-&gt;publish(persisted_event);\n    }\n\n    void contact_listener::OnContactRemoved(const JPH::SubShapeIDPair&amp;) {\n        console_log_info(\"Collisions Removed!\");\n        // For Event system to handle when collision ends\n    }\n\n}\n</code></pre>"},{"location":"References/jolt__context_8cpp/","title":"File jolt_context.cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; jolt-cpp &gt; jolt_context.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/jolt-cpp/jolt_context.hpp&gt;</code></li> <li><code>#include &lt;drivers/jolt-cpp/jolt-imports.hpp&gt;</code></li> <li><code>#include &lt;physics/math_types.hpp&gt;</code></li> <li><code>#include &lt;drivers/jolt-cpp/types.hpp&gt;</code></li> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> </ul>"},{"location":"References/jolt__context_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/jolt-cpp/jolt_context.cpp</code></p>"},{"location":"References/jolt__context_8cpp_source/","title":"File jolt_context.cpp","text":"<p>File List &gt; atlas &gt; drivers &gt; jolt-cpp &gt; jolt_context.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;drivers/jolt-cpp/jolt_context.hpp&gt;\n#include &lt;drivers/jolt-cpp/jolt-imports.hpp&gt;\n#include &lt;physics/math_types.hpp&gt;\n#include &lt;drivers/jolt-cpp/types.hpp&gt;\n#include &lt;core/engine_logger.hpp&gt;\n\nnamespace atlas::physics {\n    static void trace_impl(const char* p_in_fmt, ...) {\n        va_list list;\n        va_start(list, p_in_fmt);\n        char buffer[1024];\n        vsnprintf(buffer, sizeof(buffer), p_in_fmt, list);\n        va_end(list);\n        console_log_error(\"{}\", buffer);\n    }\n\n    [[maybe_unused]] static bool assert_failed_impl(const char* p_in_expression,\n                                                    const char* p_in_message,\n                                                    const char* p_in_file,\n                                                    unsigned int p_in_line) {\n\n        console_log_error(\"{}:{}: ({}) {}\",\n                          p_in_file,\n                          p_in_line,\n                          p_in_expression,\n                          (p_in_message != nullptr ? p_in_message : \"\"));\n\n        return true;\n    };\n\n    jolt_context::jolt_context(const jolt_settings&amp; p_settings,\n                               event::event_bus&amp; p_bus)\n      : m_contact_listener(p_bus) {\n        JPH::RegisterDefaultAllocator();\n\n        JPH::Trace = trace_impl;\n        JPH_IF_ENABLE_ASSERTS(JPH::AssertFailed = assert_failed_impl;)\n\n        JPH::Factory::sInstance = new JPH::Factory();\n        JPH::RegisterTypes();\n\n        m_temp_allocator =\n          create_ref&lt;JPH::TempAllocatorImpl&gt;(p_settings.allocation_amount);\n\n        // This just sets up the JoltPhysics system and any listeners\n        m_physics_system = create_ref&lt;JPH::PhysicsSystem&gt;();\n        m_broad_phase_layer_interface =\n          create_ref&lt;broad_phase_layer_interface&gt;();\n        m_object_vs_broadphase_filter =\n          create_ref&lt;object_vs_broadphase_layer&gt;();\n        m_object_layer_pair_filter = create_ref&lt;object_layer_pair_filter&gt;();\n\n        if (p_settings.thread_type == thread_type::default_system) {\n\n            m_thread_system = create_scope&lt;JPH::JobSystemThreadPool&gt;(\n              // Max jobs must be a power of 2, otherwise jph crashes.\n              // Bianary tree must be fully balanced\n              std::pow(2, p_settings.max_jobs_power),\n              p_settings.max_barriers,\n              p_settings.physics_threads);\n        }\n        else {\n            console_log_error(\"Unsupported custom job system\");\n            assert(false);\n        }\n\n        m_physics_system-&gt;Init(p_settings.max_bodies,\n                               0,\n                               p_settings.max_body_pairs,\n                               p_settings.max_contact_constraints,\n                               *m_broad_phase_layer_interface,\n                               *m_object_vs_broadphase_filter,\n                               *m_object_layer_pair_filter);\n\n        // Default contact listener impl and can change during runtime\n        m_physics_system-&gt;SetContactListener(&amp;m_contact_listener);\n    }\n\n    void jolt_context::emplace_box_collider(uint32_t p_entity_id,\n                                            const transform* p_transform,\n                                            const physics_body* p_body,\n                                            const box_collider* p_collider) {\n        using namespace JPH;\n        auto&amp; body_interface = m_physics_system-&gt;GetBodyInterface();\n\n        // Creating our box shape and specifying half_extent that is a glm::vec3\n        // conversion to JPH::Vec3 half_extents must be 0.5f or else it can get\n        // an invalid convex radius\n        BoxShapeSettings shape_settings(jolt::to_vec3(p_collider-&gt;half_extent));\n        auto result = shape_settings.Create();\n\n        if (result.HasError()) {\n            console_log_error(\"Box shape creation error: {}\",\n                              result.GetError());\n            return;\n        }\n        EMotionType motion_type = EMotionType::Static;\n        switch (p_body-&gt;body_movement_type) {\n            case body_type::fixed:\n                motion_type = EMotionType::Static;\n                break;\n            case body_type::dynamic:\n                motion_type = EMotionType::Dynamic;\n                break;\n            case body_type::kinematic:\n                motion_type = EMotionType::Kinematic;\n                break;\n        }\n\n        auto&amp; box = result.Get();\n        BodyCreationSettings body_settings(\n          box,\n          jolt::to_vec3(p_transform-&gt;position),\n          jolt::to_quat(p_transform-&gt;quaternion),\n          motion_type,\n          p_body-&gt;body_layer_type);\n\n        // NOTE TO  SELF ------ This is setting some pointer to the entity ID\n        // WE CAN USE THIS TO TELL THE EVENT SYSTEM WHICH FLECS ENTITY COLLIDED\n        // WITH EACH OTHER!!!!!!!! Because each contact listener allows you to\n        // take a pointer from the physics bodies that are just blocks of\n        // data!!!\n        body_settings.mUserData = static_cast&lt;uint64_t&gt;(p_entity_id);\n        body_settings.mFriction = p_body-&gt;friction;\n        body_settings.mRestitution = p_body-&gt;restitution;\n        body_settings.mLinearVelocity = jolt::to_vec3(p_body-&gt;linear_velocity);\n        body_settings.mAngularVelocity =\n          jolt::to_vec3(p_body-&gt;angular_velocity);\n\n        Body* body = body_interface.CreateBody(body_settings);\n        m_cached_body_ids.emplace(p_entity_id, body-&gt;GetID());\n    }\n\n    void jolt_context::emplace_sphere_collider(\n      uint32_t p_entity_id,\n      const transform* p_transform,\n      const physics_body* p_body,\n      const sphere_collider* p_collider) {\n        using namespace JPH;\n        auto&amp; body_interface = m_physics_system-&gt;GetBodyInterface();\n        // ensure that the half_extent of the box shape always matches the\n        // object and reference that information through the transform\n        SphereShapeSettings shape_settings(p_collider-&gt;radius);\n        auto result = shape_settings.Create();\n\n        if (result.HasError()) {\n            console_log_error(\"Sphere shape creation error: {}\",\n                              result.GetError());\n            return;\n        }\n        EMotionType motion_type = EMotionType::Static;\n        switch (p_body-&gt;body_movement_type) {\n            case body_type::fixed: {\n                motion_type = EMotionType::Static;\n            } break;\n            case body_type::dynamic: {\n                motion_type = EMotionType::Dynamic;\n            } break;\n            case body_type::kinematic: {\n                motion_type = EMotionType::Kinematic;\n            } break;\n        }\n\n        auto&amp; box = result.Get();\n        BodyCreationSettings body_settings(\n          box,\n          jolt::to_vec3(p_transform-&gt;position),\n          jolt::to_quat(p_transform-&gt;quaternion),\n          motion_type,\n          p_body-&gt;body_layer_type);\n\n        // Assigning the entity ID as the user data\n        // Fetched when collision happens\n        body_settings.mUserData = static_cast&lt;uint64_t&gt;(p_entity_id);\n        body_settings.mFriction = p_body-&gt;friction;\n        body_settings.mRestitution = p_body-&gt;restitution;\n        body_settings.mLinearVelocity = jolt::to_vec3(p_body-&gt;linear_velocity);\n        body_settings.mAngularVelocity =\n          jolt::to_vec3(p_body-&gt;angular_velocity);\n        Body* body = body_interface.CreateBody(body_settings);\n\n        // body_interface.AddForce(body-&gt;GetID(),\n        // jolt::to_vec3(p_body-&gt;cumulative_force));\n        m_cached_body_ids.emplace(p_entity_id, body-&gt;GetID());\n    }\n\n    void jolt_context::emplace_capsule_collider(\n      uint32_t p_entity_id,\n      const transform* p_transform,\n      const physics_body* p_body,\n      const capsule_collider* p_collider) {\n        using namespace JPH;\n        auto&amp; body_interface = m_physics_system-&gt;GetBodyInterface();\n        // ensure that the half_extent of the box shape always matches the\n        // object and reference that information through the transform\n        CapsuleShapeSettings shape_settings(p_collider-&gt;half_height,\n                                            p_collider-&gt;radius);\n        auto result = shape_settings.Create();\n\n        if (result.HasError()) {\n            console_log_error(\"Capsule shape creation error: {}\",\n                              result.GetError());\n            return;\n        }\n        EMotionType motion_type = EMotionType::Static;\n        switch (p_body-&gt;body_movement_type) {\n            case body_type::fixed: {\n                motion_type = EMotionType::Static;\n            } break;\n            case body_type::dynamic: {\n                motion_type = EMotionType::Dynamic;\n            } break;\n            case body_type::kinematic: {\n                motion_type = EMotionType::Kinematic;\n            } break;\n        }\n\n        auto&amp; box = result.Get();\n        BodyCreationSettings body_settings(\n          box,\n          jolt::to_vec3(p_transform-&gt;position),\n          jolt::to_quat(p_transform-&gt;quaternion),\n          motion_type,\n          p_body-&gt;body_layer_type);\n        body_settings.mFriction = p_body-&gt;friction;\n        body_settings.mRestitution = p_body-&gt;restitution;\n        body_settings.mLinearVelocity = jolt::to_vec3(p_body-&gt;linear_velocity);\n        body_settings.mAngularVelocity =\n          jolt::to_vec3(p_body-&gt;angular_velocity);\n        body_settings.mUserData = static_cast&lt;uint64_t&gt;(p_entity_id);\n\n        Body* body = body_interface.CreateBody(body_settings);\n        m_cached_body_ids.emplace(p_entity_id, body-&gt;GetID());\n    }\n\n    transform jolt_context::context_read_transform(uint32_t p_id) {\n        using namespace JPH;\n        transform new_transform{};\n        auto&amp; body_interface = m_physics_system-&gt;GetBodyInterface();\n\n        BodyID body_id = m_cached_body_ids[p_id];\n        JPH::Vec3 pos = body_interface.GetPosition(body_id);\n        JPH::Quat rot = body_interface.GetRotation(body_id);\n        JPH::Vec3 rot_euler = rot.GetEulerAngles();\n\n        new_transform.position = to_vec3(pos);\n        new_transform.quaternion = to_vec4(rot);\n        new_transform.rotation = to_vec3(rot_euler);\n\n        return new_transform;\n    }\n\n    physics_body jolt_context::context_read_physics_body(uint32_t p_id) {\n        using namespace JPH;\n        auto&amp; body_interface = m_physics_system-&gt;GetBodyInterface();\n\n        // TODO: Will need to change this because if this entity doesn't exist\n        // then it will be set to zeroes, gotta be careful about this\n        if (!m_cached_body_ids.contains(p_id)) {\n            return {};\n        }\n\n        auto body_id = m_cached_body_ids.at(p_id);\n\n        physics_body body = {\n            .linear_velocity =\n              to_vec3(body_interface.GetLinearVelocity(body_id)),\n            .angular_velocity =\n              to_vec3(body_interface.GetAngularVelocity(body_id)),\n            .center_mass_position =\n              to_vec3(body_interface.GetCenterOfMassPosition(body_id)),\n            .gravity_factor = body_interface.GetGravityFactor(body_id),\n            .friction = body_interface.GetFriction(body_id),\n            .restitution = body_interface.GetRestitution(body_id),\n        };\n\n        return body;\n    }\n\n    void jolt_context::destroy_bodies() {\n        auto&amp; body_interface = m_physics_system-&gt;GetBodyInterface();\n\n        // Retrieve all body ID's to ensure that we do proper deactivation and\n        // post cleanup for the physics simulation\n        JPH::BodyIDVector all_body_ids;\n        m_physics_system-&gt;GetBodies(all_body_ids);\n\n        if (!all_body_ids.empty()) {\n\n            body_interface.DeactivateBodies(\n              all_body_ids.data(), static_cast&lt;int&gt;(all_body_ids.size()));\n\n            body_interface.RemoveBodies(all_body_ids.data(),\n                                        static_cast&lt;int&gt;(all_body_ids.size()));\n\n            body_interface.DestroyBodies(all_body_ids.data(),\n                                         static_cast&lt;int&gt;(all_body_ids.size()));\n\n            m_cached_body_ids.clear();\n        }\n    }\n\n    void jolt_context::linear_velocity(uint64_t p_id,\n                                       const glm::vec3&amp; p_linear_velocity) {\n        using namespace JPH;\n        auto&amp; body_interface = m_physics_system-&gt;GetBodyInterface();\n\n        body_interface.SetLinearVelocity(m_cached_body_ids.at(p_id),\n                                         jolt::to_vec3(p_linear_velocity));\n    }\n\n    void jolt_context::angular_velocity(uint64_t p_id,\n                                        const glm::vec3&amp; p_angular_velocity) {\n        using namespace JPH;\n        auto&amp; body_interface = m_physics_system-&gt;GetBodyInterface();\n        BodyID body_id(p_id);\n\n        body_interface.SetAngularVelocity(m_cached_body_ids.at(p_id),\n                                          jolt::to_vec3(p_angular_velocity));\n    }\n\n    void jolt_context::force(uint64_t p_id, const glm::vec3&amp; p_force) {\n        using namespace JPH;\n        auto&amp; body_interface = m_physics_system-&gt;GetBodyInterface();\n        BodyID body_id(p_id);\n\n        body_interface.AddForce(m_cached_body_ids.at(p_id),\n                                jolt::to_vec3(p_force));\n    }\n\n    void jolt_context::add_force_and_torque(uint64_t p_id,\n                                            const glm::vec3&amp; p_force,\n                                            const glm::vec3&amp; p_torque) {\n        using namespace JPH;\n        auto&amp; body_interface = m_physics_system-&gt;GetBodyInterface();\n\n        body_interface.AddForceAndTorque(m_cached_body_ids.at(p_id),\n                                         jolt::to_vec3(p_force),\n                                         jolt::to_vec3(p_torque));\n    }\n\n    void jolt_context::add_impulse(uint64_t p_id, const glm::vec3&amp; p_impulse) {\n        using namespace JPH;\n        auto&amp; body_interface = m_physics_system-&gt;GetBodyInterface();\n\n        body_interface.AddImpulse(m_cached_body_ids.at(p_id),\n                                  jolt::to_vec3(p_impulse));\n    }\n\n    void jolt_context::prepare_and_finalize() {\n        using namespace JPH;\n\n        JPH::BodyIDVector all_body_ids;\n        m_physics_system-&gt;GetBodies(all_body_ids);\n\n        auto&amp; body_interface = m_physics_system-&gt;GetBodyInterface();\n        auto state = body_interface.AddBodiesPrepare(\n          all_body_ids.data(), static_cast&lt;int&gt;(all_body_ids.size()));\n        body_interface.AddBodiesFinalize(all_body_ids.data(),\n                                         static_cast&lt;int&gt;(all_body_ids.size()),\n                                         state,\n                                         JPH::EActivation::Activate);\n    }\n\n    void jolt_context::update_simulation(float p_delta_time) {\n        float fixed_time_step = 1.0f / 60.0f;\n        int time_step = 1 + (int)(60 * fixed_time_step);\n        m_physics_system-&gt;Update(p_delta_time,\n                                 time_step,\n                                 m_temp_allocator.get(),\n                                 m_thread_system.get());\n    }\n}\n</code></pre>"},{"location":"References/drivers_2jolt-cpp_2types_8cpp/","title":"File types.cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; jolt-cpp &gt; types.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/jolt-cpp/jolt-imports.hpp&gt;</code></li> <li><code>#include &lt;drivers/jolt-cpp/types.hpp&gt;</code></li> </ul>"},{"location":"References/drivers_2jolt-cpp_2types_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace jolt <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/jolt-cpp/types.cpp</code></p>"},{"location":"References/drivers_2jolt-cpp_2types_8cpp_source/","title":"File types.cpp","text":"<p>File List &gt; atlas &gt; drivers &gt; jolt-cpp &gt; types.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;drivers/jolt-cpp/jolt-imports.hpp&gt;\n#include &lt;drivers/jolt-cpp/types.hpp&gt;\n\nnamespace atlas {\n    namespace jolt {\n        JPH::RVec3 to_rvec3(const glm::vec3&amp; p_value) {\n            return { p_value.x, p_value.y, p_value.z };\n        }\n\n        JPH::Vec3 to_vec3(const glm::vec3&amp; p_value) {\n            return { p_value.x, p_value.y, p_value.z };\n        }\n\n        JPH::Quat to_quat(const glm::vec4&amp; q) {\n            return { q.x, q.y, q.z, q.w };\n        }\n\n        JPH::Quat to_quat(glm::quat&amp; p_value) {\n            return JPH::Quat(p_value.w, p_value.x, p_value.y, p_value.z);\n        }\n    }\n\n    glm::quat to_quat(const JPH::Quat&amp; p_value) {\n        return glm::quat(\n          p_value.GetW(), p_value.GetX(), p_value.GetY(), p_value.GetZ());\n    }\n\n    glm::vec3 to_vec3(const JPH::Vec3&amp; p_value) {\n        return vector3&lt;JPH::Vec3&gt;(p_value);\n    }\n\n    glm::vec4 to_vec4(const JPH::Quat&amp; p_value) {\n        return glm::vec4(\n          p_value.GetX(), p_value.GetY(), p_value.GetZ(), p_value.GetW());\n    }\n};\n</code></pre>"},{"location":"References/dir_328caf802809d01e7397181570d57cd0/","title":"Dir TheAtlasEngine/src/atlas/drivers/vulkan-cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp</p>"},{"location":"References/dir_328caf802809d01e7397181570d57cd0/#files","title":"Files","text":"Type Name file mesh.cpp file shader_resource_group.cpp file utilities.cpp file vk_context.cpp file vk_driver.cpp file vk_imgui.cpp file vk_physical_driver.cpp file vk_renderer.cpp file vk_swapchain.cpp file vk_window.cpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/vulkan-cpp/</code></p>"},{"location":"References/mesh_8cpp/","title":"File mesh.cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; mesh.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/mesh.hpp&gt;</code></li> <li><code>#include &lt;tiny_obj_loader.h&gt;</code></li> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/hash.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;</code></li> </ul>"},{"location":"References/mesh_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/mesh_8cpp/#macros","title":"Macros","text":"Type Name define STB_IMAGE_IMPLEMENTATION define STB_IMAGE_WRITE_IMPLEMENTATION"},{"location":"References/mesh_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"References/mesh_8cpp/#define-stb_image_implementation","title":"define STB_IMAGE_IMPLEMENTATION","text":"<pre><code>#define STB_IMAGE_IMPLEMENTATION \n</code></pre>"},{"location":"References/mesh_8cpp/#define-stb_image_write_implementation","title":"define STB_IMAGE_WRITE_IMPLEMENTATION","text":"<pre><code>#define STB_IMAGE_WRITE_IMPLEMENTATION \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/vulkan-cpp/mesh.cpp</code></p>"},{"location":"References/mesh_8cpp_source/","title":"File mesh.cpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; mesh.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;cstddef&gt;\n#include &lt;drivers/vulkan-cpp/mesh.hpp&gt;\n#include &lt;tiny_obj_loader.h&gt;\n#define STB_IMAGE_IMPLEMENTATION\n#define STB_IMAGE_WRITE_IMPLEMENTATION\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;drivers/vulkan-cpp/hash.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;\n\nnamespace atlas::vk {\n    mesh::mesh(std::span&lt;::vk::vertex_input&gt; p_vertices,\n               std::span&lt;uint32_t&gt; p_indices) {\n        m_physical = vk_context::physical_driver();\n        m_device = vk_context::driver_context();\n        ::vk::vertex_params vbo_settings = { .phsyical_memory_properties =\n                                               m_physical.memory_properties(),\n                                             .vertices = p_vertices };\n        ::vk::index_params ibo_settings = { .phsyical_memory_properties =\n                                              m_physical.memory_properties(),\n                                            .indices = p_indices };\n        m_vbo = ::vk::vertex_buffer(m_device, vbo_settings);\n        m_ibo = ::vk::index_buffer(m_device, ibo_settings);\n    }\n\n    mesh::mesh(const std::filesystem::path&amp; p_filename, bool p_flip)\n      : m_flip(p_flip) {\n        m_physical = vk_context::physical_driver();\n        m_device = vk_context::driver_context();\n        reload_mesh(p_filename);\n    }\n\n    void mesh::reload_mesh(const std::filesystem::path&amp; p_filename) {\n        console_log_info(\"Loading .obj file!!!\");\n        load_obj(p_filename);\n    }\n\n    void mesh::load_obj(const std::filesystem::path&amp; p_filename) {\n        tinyobj::attrib_t attrib;\n        std::vector&lt;tinyobj::shape_t&gt; shapes;\n        std::vector&lt;tinyobj::material_t&gt; materials;\n        std::string warn, err;\n\n        if (!tinyobj::LoadObj(&amp;attrib,\n                              &amp;shapes,\n                              &amp;materials,\n                              &amp;warn,\n                              &amp;err,\n                              p_filename.string().c_str())) {\n            console_log_warn(\"Could not load model from path {}\",\n                             p_filename.string());\n            m_model_loaded = false;\n            return;\n        }\n\n        std::vector&lt;::vk::vertex_input&gt; vertices;\n        std::vector&lt;uint32_t&gt; indices;\n        std::unordered_map&lt;::vk::vertex_input, uint32_t&gt; unique_vertices{};\n\n        // for (const auto&amp; shape : shapes) {\n        for (size_t i = 0; i &lt; shapes.size(); i++) {\n            auto shape = shapes[i];\n            // for (const auto&amp; index : shape.mesh.indices) {\n            for (size_t j = 0; j &lt; shape.mesh.indices.size(); j++) {\n                auto index = shape.mesh.indices[j];\n                ::vk::vertex_input vertex{};\n\n                if (!unique_vertices.contains(vertex)) {\n                    unique_vertices[vertex] =\n                      static_cast&lt;uint32_t&gt;(vertices.size());\n                    vertices.push_back(vertex);\n                }\n\n                if (index.vertex_index &gt;= 0) {\n                    vertex.position = {\n                        attrib.vertices[3 * index.vertex_index + 0],\n                        attrib.vertices[3 * index.vertex_index + 1],\n                        attrib.vertices[3 * index.vertex_index + 2]\n                    };\n\n                    vertex.color = {\n                        attrib.colors[3 * index.vertex_index + 0],\n                        attrib.colors[3 * index.vertex_index + 1],\n                        attrib.colors[3 * index.vertex_index + 2]\n                    };\n                }\n\n                if (!attrib.normals.empty()) {\n                    vertex.normals = {\n                        attrib.normals[3 * index.normal_index + 0],\n                        attrib.normals[3 * index.normal_index + 1],\n                        attrib.normals[3 * index.normal_index + 2]\n                    };\n                }\n                if (!attrib.texcoords.empty()) {\n                    glm::vec2 flipped_uv = {\n                        attrib.texcoords\n                          [static_cast&lt;long long&gt;(index.texcoord_index) * 2],\n                        1.0f - attrib.texcoords[static_cast&lt;long long&gt;(\n                                                  index.texcoord_index) *\n                                                  2 +\n                                                1],\n                    };\n\n                    glm::vec2 original_uv = {\n                        attrib.texcoords\n                          [static_cast&lt;long long&gt;(index.texcoord_index) * 2],\n                        attrib.texcoords\n                          [static_cast&lt;long long&gt;(index.texcoord_index) * 2 +\n                           1],\n                    };\n\n                    vertex.uv = m_flip ? flipped_uv : original_uv;\n                }\n                else {\n                    vertex.uv = glm::vec2(0.f, 0.f);\n                }\n\n                if (!unique_vertices.contains(vertex)) {\n                    unique_vertices[vertex] =\n                      static_cast&lt;uint32_t&gt;(vertices.size());\n                    vertices.push_back(vertex);\n                }\n\n                indices.push_back(unique_vertices[vertex]);\n            }\n        }\n\n        ::vk::vertex_params vbo_settings = { .phsyical_memory_properties =\n                                               m_physical.memory_properties(),\n                                             .vertices = vertices };\n        ::vk::index_params ibo_settings = { .phsyical_memory_properties =\n                                              m_physical.memory_properties(),\n                                            .indices = indices };\n        m_vbo = ::vk::vertex_buffer(m_device, vbo_settings);\n        m_ibo = ::vk::index_buffer(m_device, ibo_settings);\n        m_model_loaded = true;\n    }\n\n    void mesh::add_diffuse(const std::filesystem::path&amp; p_path) {\n        ::vk::texture_info config_texture = {\n            .phsyical_memory_properties = m_physical.memory_properties(),\n            .filepath = p_path,\n        };\n        m_diffuse = ::vk::texture(m_device, config_texture);\n\n        if (!m_diffuse.loaded()) {\n            console_log_info(\"Diffuse Texture {} is NOT loaded!!!\",\n                             p_path.string());\n            return;\n        }\n    }\n\n    void mesh::add_specular(const std::filesystem::path&amp; p_path) {\n        ::vk::texture_info config_texture = { .phsyical_memory_properties =\n                                                m_physical.memory_properties(),\n                                              .filepath = p_path };\n        m_specular = ::vk::texture(m_device, config_texture);\n\n        if (!m_specular.loaded()) {\n            console_log_error(\"Specular Texture {} is NOT loaded!!!\",\n                              p_path.string());\n            return;\n        }\n    }\n\n    void mesh::draw(const VkCommandBuffer&amp; p_current) {\n        m_vbo.bind(p_current);\n        if (m_ibo.size() &gt; 0) {\n            m_ibo.bind(p_current);\n            vkCmdDrawIndexed(p_current, m_ibo.size(), 1, 0, 0, 0);\n        }\n        else {\n            vkCmdDraw(p_current, m_vbo.size(), 1, 0, 0);\n        }\n    }\n\n    void mesh::destroy() {\n        m_vbo.destroy();\n        m_ibo.destroy();\n\n        m_diffuse.destroy();\n        m_specular.destroy();\n        m_geoemtry_ubo.destroy();\n        m_material_ubo.destroy();\n    }\n};\n</code></pre>"},{"location":"References/shader__resource__group_8cpp/","title":"File shader_resource_group.cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; shader_resource_group.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/vulkan-cpp/shader_resource_group.hpp&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;vulkan-cpp/utilities.hpp&gt;</code></li> <li><code>#include &lt;ranges&gt;</code></li> <li><code>#include &lt;shaderc/shaderc.hpp&gt;</code></li> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> </ul>"},{"location":"References/shader__resource__group_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/vulkan-cpp/shader_resource_group.cpp</code></p>"},{"location":"References/shader__resource__group_8cpp_source/","title":"File shader_resource_group.cpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; shader_resource_group.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;drivers/vulkan-cpp/shader_resource_group.hpp&gt;\n#include &lt;fstream&gt;\n#include &lt;filesystem&gt;\n#include &lt;vulkan-cpp/utilities.hpp&gt;\n#include &lt;ranges&gt;\n#include &lt;shaderc/shaderc.hpp&gt;\n#include &lt;core/engine_logger.hpp&gt;\n\nnamespace atlas::vk {\n\n    // Reading the raw .spv binaries\n    static std::vector&lt;char&gt; read_raw_spirv(const std::string&amp; p_file) {\n        std::vector&lt;char&gt; out_buffer;\n        std::ifstream ins(p_file, std::ios::ate | std::ios::binary);\n\n        if (!ins) {\n            throw std::runtime_error(\"Cannot load in .spv files!!\");\n        }\n\n        uint32_t file_size = (uint32_t)ins.tellg();\n        out_buffer.resize(file_size);\n        ins.seekg(0);\n        ins.read(out_buffer.data(), file_size);\n        return out_buffer;\n    }\n\n    static std::vector&lt;char&gt; compile_binary_shader_source(\n      const ::vk::shader_source&amp; p_shader_source) {\n\n        if (!std::filesystem::is_regular_file(p_shader_source.filename)) {\n            throw std::runtime_error(\"Cannot load .spv file\");\n        }\n\n        return read_raw_spirv(p_shader_source.filename);\n    }\n\n    static std::string read_shader_source_code(const std::string&amp; p_filename) {\n        std::ifstream ins(p_filename, std::ios::ate | std::ios::binary);\n\n        if (!ins.is_open()) {\n            console_log_warn(\"Could not open filename = {}\", p_filename);\n            return { 'a' };\n        }\n\n        size_t file_size = (size_t)ins.tellg();\n        std::string output;\n        output.resize(file_size);\n        ins.seekg(0);\n        ins.read(output.data(), static_cast&lt;uint32_t&gt;(file_size));\n\n        return output;\n    }\n\n    static std::vector&lt;uint32_t&gt; compile_source_from_file(\n      const ::vk::shader_source&amp; p_shader_source) {\n        shaderc::CompileOptions options;\n        options.SetTargetEnvironment(shaderc_target_env_vulkan,\n                                     shaderc_env_version_vulkan_1_3);\n        options.SetWarningsAsErrors();\n\n        shaderc_shader_kind type;\n\n        switch (p_shader_source.stage) {\n            case ::vk::shader_stage::vertex:\n                type = shaderc_glsl_vertex_shader;\n                break;\n            case ::vk::shader_stage::fragment:\n                type = shaderc_glsl_fragment_shader;\n                break;\n            default:\n                throw std::runtime_error(\"shader_stage unspecified!~!!\");\n        }\n\n        shaderc::Compiler compiler;\n        std::string text_source_code =\n          read_shader_source_code(p_shader_source.filename);\n\n        // Prints out the text of the shader source code\n        // console_log_warn(\"Source Text Code!!!\");\n        // console_log_info(\"{}\", text_source_code);\n        shaderc::CompilationResult result =\n          compiler.CompileGlslToSpv(text_source_code,\n                                    type,\n                                    p_shader_source.filename.c_str(),\n                                    \"main\",\n                                    options);\n\n        std::vector&lt;uint32_t&gt; blob;\n\n        if (result.GetCompilationStatus() !=\n            shaderc_compilation_status_success) {\n            throw std::runtime_error(\n              std::format(\"Shader Compilation Error! Failed with reason {}\\n{}\",\n                          p_shader_source.filename,\n                          result.GetErrorMessage())\n                .c_str());\n        }\n\n        for (auto blob_chunk : result) {\n            blob.push_back(blob_chunk);\n        }\n\n        return blob;\n    }\n\n    shader_resource_group::shader_resource_group(\n      const VkDevice&amp; p_device,\n      const ::vk::shader_resource_info&amp; p_info)\n      : m_device(p_device) {\n\n        // We go through all of the specified shader source and their specific\n        // stage Compile them through shader compiler or if provided a .spv,\n        // then we compile and read in the stream of bytes directly\n        for (size_t i = 0; i &lt; p_info.sources.size(); i++) {\n            const ::vk::shader_source shader_src = p_info.sources[i];\n            std::filesystem::path filepath =\n              std::filesystem::path(shader_src.filename);\n\n            if (filepath.extension().string() == \".spv\") {\n                std::vector&lt;char&gt; blob =\n                  compile_binary_shader_source(shader_src);\n\n                if (blob.empty()) {\n                    m_resource_valid = false;\n                    throw std::runtime_error(\"Cannot load in vector&lt;uint32_t&gt; \"\n                                             \"blob of compiled down data!!!\");\n                }\n\n                create_module(blob, shader_src);\n            }\n            else {\n                std::string text_source_code =\n                  read_shader_source_code(filepath.string());\n                std::vector&lt;uint32_t&gt; blob =\n                  compile_source_from_file(shader_src);\n                create_module(blob, shader_src);\n            }\n        }\n\n        // This is a testing example for getting shaders hot-reloading\n        // m_watcher = create_ref&lt;wtr::watch&gt;(\"./experimental-shaders\",\n        // [this](const wtr::event&amp; e){\n        //     console_log_info(\"File {} Reload!!!\",\n        //     e.path_name.filename().string()); if (e.effect_type ==\n        //     wtr::event::effect_type::modify and e.path_type ==\n        //     wtr::event::path_type::file) {\n        //         console_log_info(\"File has been modified!!\");\n        //         // std::string fmt = std::format(\"experimental-shaders/{}\",\n        //         e.path_name.filename().string());\n        //         console_log_info(\"({}).contains = {}\",\n        //         e.path_name.filename().string(),\n        //         m_modules.contains(e.path_name.filename().string()));\n        //         if(m_modules.contains(e.path_name.filename().string())) {\n        //             console_log_info(\"Reload has been requested!!!\");\n        //             m_reload_requested = true;\n        //             // reload\n        //             ::vk::shader_source reload_src = {\n        //                 .filename = e.path_name.filename().string(),\n        //                 .stage =\n        //                 m_modules.at(e.path_name.filename().string()).stage\n        //             };\n        //             reload_shader(reload_src);\n\n        //         }\n        //     }\n        //     else {\n        //         console_log_info(\"File {} Could Not Be Reloaded!!!\",\n        //         e.path_name.filename().string());\n        //     }\n        // });\n\n        m_resource_valid = true;\n    }\n\n    void shader_resource_group::reload_shader(\n      const ::vk::shader_source&amp; p_source) {\n        console_log_info(\"p_source.filename = {}\", p_source.filename);\n        if (m_modules[p_source.filename].module != nullptr) {\n            vkDestroyShaderModule(\n              m_device, m_modules[p_source.filename].module, nullptr);\n        }\n\n        auto&amp; handle = m_modules[p_source.filename];\n\n        std::filesystem::path filepath(p_source.filename);\n        std::string text_source_code =\n          read_shader_source_code(filepath.string());\n        std::vector&lt;uint32_t&gt; blob = compile_source_from_file(p_source);\n        std::span&lt;uint32_t&gt; view_blob(blob.data(), blob.size());\n        // create_module(blob, p_source);\n        VkShaderModuleCreateInfo shader_module_ci = {\n            .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,\n            .pNext = nullptr,\n            .codeSize = view_blob.size_bytes(),\n            .pCode = view_blob.data()\n        };\n\n        ::vk::vk_check(vkCreateShaderModule(\n                         m_device, &amp;shader_module_ci, nullptr, &amp;handle.module),\n                       \"vkCreateShaderModule\");\n    }\n\n    void shader_resource_group::create_module(\n      std::span&lt;char&gt; p_blob,\n      const ::vk::shader_source&amp; p_source) {\n        VkShaderModuleCreateInfo shader_module_ci = {\n            .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,\n            .pNext = nullptr,\n            .codeSize = p_blob.size(),\n            .pCode = reinterpret_cast&lt;const uint32_t*&gt;(p_blob.data())\n        };\n\n        std::filesystem::path filepath(p_source.filename);\n        std::string filename = filepath.filename().string();\n\n        // Setting m_shader_module_handlers[i]'s stage and the VkShaderModule\n        // handle altogether construct this beforehand and then we are going set\n        // that shader module\n        m_modules.emplace(filename, ::vk::shader_handle{});\n        ::vk::vk_check(\n          vkCreateShaderModule(\n            m_device, &amp;shader_module_ci, nullptr, &amp;m_modules[filename].module),\n          \"vkCreateShaderModule\");\n        m_modules[filename].stage = p_source.stage;\n    }\n\n    void shader_resource_group::create_module(\n      std::span&lt;uint32_t&gt; p_blob,\n      const ::vk::shader_source&amp; p_source) {\n        VkShaderModuleCreateInfo shader_module_ci = {\n            .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,\n            .pNext = nullptr,\n            .codeSize = p_blob.size_bytes(),\n            .pCode = p_blob.data()\n        };\n\n        // console_log_info(\"map key = {}\", p_source.filename);\n        std::filesystem::path filepath(p_source.filename);\n\n        std::string filename = filepath.filename().string();\n\n        console_log_info(\"Key = {}\", filename);\n\n        // Setting m_shader_module_handlers[i]'s stage and the VkShaderModule\n        // handle altogether construct this beforehand and then we are going set\n        // that shader module\n        m_modules.emplace(filename, ::vk::shader_handle{});\n        ::vk::vk_check(\n          vkCreateShaderModule(\n            m_device, &amp;shader_module_ci, nullptr, &amp;m_modules[filename].module),\n          \"vkCreateShaderModule\");\n        m_modules[filename].stage = p_source.stage;\n    }\n\n    std::vector&lt;::vk::shader_handle&gt; shader_resource_group::map_to_vector()\n      const {\n        // Using C++'s std::views to extract all of the values in\n        // unordered_map&lt;string, vk::shader_handle&gt; to a vector&lt;shader_handle&gt;\n        // that gets passed to graphics pipeline\n        return (m_modules | std::views::values |\n                std::ranges::to&lt;std::vector&gt;());\n    }\n\n    void shader_resource_group::vertex_attributes(\n      std::span&lt;const ::vk::vertex_attribute&gt; p_attributes) {\n        /*\n            -- These comments are a reminder to myself --\n            - this function simplifies the need to separately define vertex\n           attributes and the vertex binding attributes as shown below:\n\n            - vertex attributes specify the types of data within the vertex\n\n            - vertex binding attribute specifies the rate of reading that data\n           layout specified by the vertex attributes\n\n            - Interpret the following vertex attributes below with this shader\n           code with `layout(location = n)` specified where by default these are\n           set to binding zero by the shader\n\n            layout(location = 0) in vec3 inPosition;\n            layout(location = 1) in vec3 inColor;\n            layout(location = 2) in vec3 inNormals;\n            layout(location = 3) in vec2 inTexCoords;\n\n            m_shader_group.set_vertex_attributes(VkVertexInputAttributeDescription{\n                { .location = 0, .binding = 0, .format =\n           VK_FORMAT_R32G32B32_SFLOAT, .offset = offsetof(vk::vertex, position),\n           }, { .location = 1, .binding = 0, .format =\n           VK_FORMAT_R32G32B32_SFLOAT, .offset = offsetof(vk::vertex, color), },\n                { .location = 2, .binding = 0, .format =\n           VK_FORMAT_R32G32B32_SFLOAT, .offset = offsetof(vk::vertex, normals),\n           }, { .location = 3, .binding = 0, .format = VK_FORMAT_R32G32_SFLOAT,\n           .offset = offsetof(vk::vertex, uv), },\n            });\n\n            m_shader_group.set_vertex_bind_attributes(VkVertexInputBindingDescription{\n                {.binding = 0, .stride = sizeof(vk::vertex), .inputRate =\n           VK_VERTEX_INPUT_RATE_VERTEX,},\n            });\n\n            Which gets handled in specifying the following below\n        */\n\n        m_vertex_binding_attributes.resize(p_attributes.size());\n\n        for (size_t i = 0; i &lt; m_vertex_binding_attributes.size(); i++) {\n            // setting up vertex binding\n            const ::vk::vertex_attribute attribute = p_attributes[i];\n            m_vertex_attributes.resize(attribute.entries.size());\n            m_vertex_binding_attributes[i] = { .binding = attribute.binding,\n                                               .stride = attribute.stride,\n                                               .inputRate = to_input_rate(\n                                                 attribute.input_rate) };\n\n            // then setting up the vertex attributes for the vertex data layouts\n            for (size_t j = 0; j &lt; attribute.entries.size(); j++) {\n                const ::vk::vertex_attribute_entry entry = attribute.entries[j];\n                m_vertex_attributes[j] = { .location = entry.location,\n                                           .binding = attribute.binding,\n                                           .format = static_cast&lt;VkFormat&gt;(\n                                             entry.format),\n                                           .offset = entry.stride };\n            }\n        }\n    }\n\n    void shader_resource_group::destroy() {\n\n        for (auto&amp; [filename, shader_handle] : m_modules) {\n            if (shader_handle.module != nullptr) {\n                vkDestroyShaderModule(m_device, shader_handle.module, nullptr);\n            }\n        }\n    }\n};\n</code></pre>"},{"location":"References/drivers_2vulkan-cpp_2utilities_8cpp/","title":"File utilities.cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; utilities.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/vulkan-cpp/utilities.hpp&gt;</code></li> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;</code></li> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> </ul>"},{"location":"References/drivers_2vulkan-cpp_2utilities_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/vulkan-cpp/utilities.cpp</code></p>"},{"location":"References/drivers_2vulkan-cpp_2utilities_8cpp_source/","title":"File utilities.cpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; utilities.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;drivers/vulkan-cpp/utilities.hpp&gt;\n#include &lt;vulkan/vulkan_core.h&gt;\n#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;filesystem&gt;\n\nnamespace atlas::vk {\n\n    void vk_check(const VkResult&amp; p_result,\n                  const std::string&amp; p_name,\n                  const std::source_location&amp; p_source) {\n        if (p_result != VK_SUCCESS) {\n            console_log_error_tagged(\n              \"vulkan\",\n              \"File {} on line {} failed VkResult check\",\n              std::filesystem::relative(p_source.file_name()).string(),\n              p_source.line());\n            console_log_error_tagged(\"vulkan\",\n                                     \"Current Function Location = {}\",\n                                     p_source.function_name());\n            console_log_error_tagged(\n              \"vulkan\", \"{} VkResult returned: {}\", p_name, (int)p_result);\n        }\n    }\n};\n</code></pre>"},{"location":"References/vk__context_8cpp/","title":"File vk_context.cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_context.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/vulkan-cpp/vulkan-imports.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;</code></li> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/utilities.hpp&gt;</code></li> </ul>"},{"location":"References/vk__context_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/vulkan-cpp/vk_context.cpp</code></p>"},{"location":"References/vk__context_8cpp_source/","title":"File vk_context.cpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_context.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;drivers/vulkan-cpp/vulkan-imports.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;drivers/vulkan-cpp/utilities.hpp&gt;\n\nnamespace atlas::vk {\n    std::vector&lt;const char*&gt; initialize_instance_extensions() {\n        std::vector&lt;const char*&gt; extension_names;\n\n        extension_names.emplace_back(VK_KHR_SURFACE_EXTENSION_NAME);\n        extension_names.emplace_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);\n\n        // An additional surface extension needs to be loaded. This extension is\n        // platform-specific so needs to be selected based on the platform the\n        // example is going to be deployed to. Preprocessor directives are used\n        // here to select the correct platform.\n#ifdef VK_USE_PLATFORM_WIN32_KHR\n        extension_names.emplace_back(VK_KHR_WIN32_SURFACE_EXTENSION_NAME);\n#endif\n#ifdef VK_USE_PLATFORM_XLIB_KHR\n        extensionNames.emplace_back(VK_KHR_XLIB_SURFACE_EXTENSION_NAME);\n#endif\n#ifdef VK_USE_PLATFORM_XCB_KHR\n        extensionNames.emplace_back(VK_KHR_XCB_SURFACE_EXTENSION_NAME);\n#endif\n#ifdef VK_USE_PLATFORM_ANDROID_KHR\n        extensionNames.emplace_back(VK_KHR_ANDROID_SURFACE_EXTENSION_NAME);\n#endif\n#ifdef VK_USE_PLATFORM_WAYLAND_KHR\n        extensionNames.emplace_back(VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME);\n#endif\n#ifdef VK_USE_PLATFORM_MACOS_MVK\n        extensionNames.emplace_back(VK_MVK_MACOS_SURFACE_EXTENSION_NAME);\n#endif\n#ifdef USE_PLATFORM_NULLWS\n        extensionNames.emplace_back(VK_KHR_DISPLAY_EXTENSION_NAME);\n#endif\n\n        return extension_names;\n    }\n\n#ifdef _DEBUG\n    const std::vector&lt;const char*&gt; validation_layers = {\n        \"VK_LAYER_KHRONOS_validation\",\n        \"VK_LAYER_KHRONOS_synchronization2\"\n    };\n\n    static VKAPI_ATTR VkBool32 VKAPI_CALL debug_callback(\n      [[maybe_unused]] VkDebugUtilsMessageSeverityFlagBitsEXT\n        p_message_severity,\n      [[maybe_unused]] VkDebugUtilsMessageTypeFlagsEXT p_message_type,\n      const VkDebugUtilsMessengerCallbackDataEXT* p_callback_data,\n      [[maybe_unused]] void* p_user_data) {\n        console_log_trace(\"validation layer:\\t\\t{}\", p_callback_data-&gt;pMessage);\n        return false;\n    }\n#endif\n\n    vk_context* vk_context::s_instance = nullptr;\n\n    vk_context::vk_context(const std::string&amp; p_tag) {\n        console_log_manager::create_new_logger(p_tag);\n\n        VkApplicationInfo app_info = {\n            .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,\n            .pNext = nullptr,\n            .applicationVersion = 1,\n            .pEngineName = \"TheAtlasEngine\",\n            .engineVersion = 1,\n            .apiVersion = VK_API_VERSION_1_3,\n        };\n\n        VkInstanceCreateInfo create_info = {\n            .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,\n            .pNext = nullptr,\n            .flags = 0,\n            .pApplicationInfo = &amp;app_info\n        };\n\n        std::vector&lt;const char*&gt; extensions = initialize_instance_extensions();\n#if _DEBUG\n        extensions.push_back(\"VK_EXT_debug_utils\");\n#endif\n        create_info.enabledExtensionCount =\n          static_cast&lt;uint32_t&gt;(extensions.size());\n        create_info.ppEnabledExtensionNames = extensions.data();\n#ifdef _DEBUG\n        // by default we enable validation layers used for debugging!\n        create_info.enabledLayerCount =\n          static_cast&lt;uint32_t&gt;(validation_layers.size());\n        create_info.ppEnabledLayerNames = validation_layers.data();\n\n        // printing out available validation layers\n        uint32_t layer_count;\n        std::vector&lt;VkLayerProperties&gt; available_validation_layers;\n        vkEnumerateInstanceLayerProperties(&amp;layer_count, nullptr);\n\n        available_validation_layers.resize(layer_count);\n        vkEnumerateInstanceLayerProperties(&amp;layer_count,\n                                           available_validation_layers.data());\n\n        console_log_trace(\"================================================\");\n        console_log_trace(\"\\tValidation Layers Available\");\n        console_log_trace(\"================================================\");\n        for (VkLayerProperties properties : available_validation_layers) {\n            console_log_trace(\"Validation Layer:\\t\\t{}\", properties.layerName);\n            console_log_trace(\"Description\\t\\t{}\", properties.description);\n            console_log_trace(\"Version\\t\\t\\t{}\", (int)properties.specVersion);\n        }\n\n        console_log_trace(\"\\n\");\n        console_log_trace(\"================================================\\n\");\n\n        VkDebugUtilsMessengerCreateInfoEXT debug_create_info = {\n            .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,\n            .messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |\n                               VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |\n                               VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT,\n            .messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |\n                           VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |\n                           VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT,\n            .pfnUserCallback = debug_callback,\n        };\n\n        create_info.pNext =\n          (VkDebugUtilsMessengerCreateInfoEXT*)&amp;debug_create_info;\n#else\n        create_info.enabledLayerCount = 0;\n        create_info.ppEnabledLayerNames = nullptr;\n        create_info.pNext = nullptr;\n#endif\n        vk_check(vkCreateInstance(&amp;create_info, nullptr, &amp;m_instance_handler),\n                 \"vkCreateInstance\");\n\n#if _DEBUG\n        // This needs to be created after the VkInstance is or else it wont be\n        // applied the debug information during validation layer error message\n        // execution\n        m_vk_set_debug_utils_object_name_ext =\n          reinterpret_cast&lt;PFN_vkSetDebugUtilsObjectNameEXT&gt;(\n            vkGetInstanceProcAddr(m_instance_handler,\n                                  \"vkSetDebugUtilsObjectNameEXT\"));\n#endif\n        s_instance = this;\n\n        m_physical = vk_physical_driver(m_instance_handler);\n        m_driver = vk_driver(m_physical);\n    }\n\n    VkInstance vk_context::handler() {\n        return s_instance-&gt;m_instance_handler;\n    }\n\n    void vk_context::resource_free(std::function&lt;void()&gt;&amp;&amp; p_resource) {\n        m_resources_free.push_back(p_resource);\n    }\n\n    void vk_context::submit_resource_free(std::function&lt;void()&gt;&amp;&amp; p_resource) {\n        s_instance-&gt;m_resources_free.push_back(p_resource);\n    }\n\n    void vk_context::destroy_context() {\n        for (auto&amp; callback : m_resources_free) {\n            callback();\n        }\n\n        m_driver.destroy();\n    }\n};\n</code></pre>"},{"location":"References/vk__driver_8cpp/","title":"File vk_driver.cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_driver.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/vulkan-cpp/vk_driver.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/utilities.hpp&gt;</code></li> </ul>"},{"location":"References/vk__driver_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/vulkan-cpp/vk_driver.cpp</code></p>"},{"location":"References/vk__driver_8cpp_source/","title":"File vk_driver.cpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_driver.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;drivers/vulkan-cpp/vk_driver.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;\n#include &lt;span&gt;\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;drivers/vulkan-cpp/utilities.hpp&gt;\n\nnamespace atlas::vk {\n    static VkFormat search_supported_depth_format(\n      const VkPhysicalDevice&amp; p_physical,\n      std::span&lt;VkFormat&gt; p_formats,\n      VkImageTiling p_tiling,\n      VkFormatFeatureFlags p_feature_flag) {\n        VkFormat format = VK_FORMAT_UNDEFINED;\n\n        for (size_t i = 0; i &lt; p_formats.size(); i++) {\n            VkFormat current_format = p_formats[i];\n            VkFormatProperties format_properties;\n            vkGetPhysicalDeviceFormatProperties(\n              p_physical, current_format, &amp;format_properties);\n\n            if (p_tiling == VK_IMAGE_TILING_LINEAR) {\n                if (format_properties.linearTilingFeatures &amp; p_feature_flag) {\n                    format = current_format;\n                }\n            }\n            else if (p_tiling == VK_IMAGE_TILING_OPTIMAL and\n                     format_properties.optimalTilingFeatures &amp; p_feature_flag) {\n                format = current_format;\n            }\n        }\n\n        return format;\n    }\n\n    static VkFormat search_depth_format(const VkPhysicalDevice&amp; p_physical) {\n        std::vector&lt;VkFormat&gt; candidate_formats = {\n            VK_FORMAT_D32_SFLOAT,\n            VK_FORMAT_D32_SFLOAT_S8_UINT,\n            VK_FORMAT_D24_UNORM_S8_UINT\n        };\n\n        VkFormat format = search_supported_depth_format(\n          p_physical,\n          candidate_formats,\n          VK_IMAGE_TILING_OPTIMAL,\n          VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT);\n        return format;\n    }\n\n    vk_driver::vk_driver(const vk_physical_driver&amp; p_physical)\n      : m_physical(p_physical) {\n        m_depth_format_selected = search_depth_format(m_physical);\n\n        float queue_priority[1] = { 0.0f };\n\n        std::vector&lt;const char*&gt; device_extension = {\n            VK_KHR_SWAPCHAIN_EXTENSION_NAME\n        };\n\n        uint32_t graphics_index =\n          m_physical.read_queue_family_indices().graphics;\n\n        VkDeviceQueueCreateInfo queue_create_info = {\n            .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,\n            .pNext = nullptr,\n            .flags = 0,\n            .queueFamilyIndex = graphics_index,\n            .queueCount = 1,\n            .pQueuePriorities = queue_priority,\n        };\n\n        VkDeviceCreateInfo create_info = {\n            .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,\n            .pNext = nullptr,\n            .flags = 0,\n            .queueCreateInfoCount = 1,\n            .pQueueCreateInfos = &amp;queue_create_info,\n            .enabledLayerCount = 0,\n            .ppEnabledLayerNames = nullptr,\n            .enabledExtensionCount =\n              static_cast&lt;uint32_t&gt;(device_extension.size()),\n            .ppEnabledExtensionNames = device_extension.data(),\n        };\n\n        VkPhysicalDeviceFeatures features;\n        vkGetPhysicalDeviceFeatures(m_physical, &amp;features);\n        features.robustBufferAccess = false;\n        create_info.pEnabledFeatures = &amp;features;\n\n        vk_check(vkCreateDevice(m_physical, &amp;create_info, nullptr, &amp;m_driver),\n                 \"vkCreateDevice\");\n\n        vkGetDeviceQueue(\n          m_driver, graphics_index, 0, &amp;m_device_queues.graphics_queue);\n    }\n\n    uint32_t vk_driver::select_memory_type(\n      uint32_t p_type_filter,\n      VkMemoryPropertyFlags p_property_flag) {\n        VkPhysicalDeviceMemoryProperties mem_props;\n        vkGetPhysicalDeviceMemoryProperties(m_physical, &amp;mem_props);\n\n        for (uint32_t i = 0; i &lt; mem_props.memoryTypeCount; i++) {\n            if ((p_type_filter &amp; (1 &lt;&lt; i)) and\n                (mem_props.memoryTypes[i].propertyFlags &amp; p_property_flag) ==\n                  p_property_flag) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    VkFormat vk_driver::depth_format() const {\n        return m_depth_format_selected;\n    }\n\n    void vk_driver::destroy() {\n        vkDeviceWaitIdle(m_driver);\n        vkDestroyDevice(m_driver, nullptr);\n    }\n};\n</code></pre>"},{"location":"References/vk__imgui_8cpp/","title":"File vk_imgui.cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_imgui.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/vulkan-cpp/vk_imgui.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/utilities.hpp&gt;</code></li> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;imgui.h&gt;</code></li> <li><code>#include &lt;imgui/backends/imgui_impl_glfw.h&gt;</code></li> <li><code>#include &lt;imgui/backends/imgui_impl_vulkan.h&gt;</code></li> </ul>"},{"location":"References/vk__imgui_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/vulkan-cpp/vk_imgui.cpp</code></p>"},{"location":"References/vk__imgui_8cpp_source/","title":"File vk_imgui.cpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_imgui.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;drivers/vulkan-cpp/vk_imgui.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;\n#include &lt;drivers/vulkan-cpp/utilities.hpp&gt;\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;imgui.h&gt;\n#include &lt;imgui/backends/imgui_impl_glfw.h&gt;\n#include &lt;imgui/backends/imgui_impl_vulkan.h&gt;\n\nnamespace atlas::vk {\n\n    static void im_gui_layout_color_modification() {\n        auto&amp; colors = ImGui::GetStyle().Colors; // @note Colors is ImVec4\n\n        colors[ImGuiCol_WindowBg] = ImVec4{ 0.1f, 0.105f, 0.11f, 1.0f };\n\n        // Headers\n        colors[ImGuiCol_Header] = ImVec4{ 0.2f, 0.205f, 0.21f, 1.0f };\n        colors[ImGuiCol_HeaderHovered] = ImVec4{ 0.3f, 0.305f, 0.31f, 1.0f };\n        colors[ImGuiCol_HeaderActive] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };\n\n        // Buttons\n        colors[ImGuiCol_Button] = ImVec4{ 0.2f, 0.205f, 0.21f, 1.0f };\n        colors[ImGuiCol_ButtonHovered] = ImVec4{ 0.3f, 0.305f, 0.31f, 1.0f };\n        colors[ImGuiCol_ButtonActive] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };\n\n        // Frame BG\n        colors[ImGuiCol_FrameBg] = ImVec4{ 0.2f, 0.205f, 0.21f, 1.0f };\n        colors[ImGuiCol_FrameBgHovered] = ImVec4{ 0.3f, 0.305f, 0.31f, 1.0f };\n        colors[ImGuiCol_FrameBgActive] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };\n\n        // Tabs\n        colors[ImGuiCol_Tab] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };\n        colors[ImGuiCol_TabHovered] = ImVec4{ 0.38f, 0.3805f, 0.381f, 1.0f };\n        colors[ImGuiCol_TabActive] = ImVec4{ 0.28f, 0.2805f, 0.281f, 1.0f };\n        colors[ImGuiCol_TabUnfocused] = ImVec4{ 0.15f, 0.1505f, 0.15f, 1.0f };\n        colors[ImGuiCol_TabUnfocusedActive] =\n          ImVec4{ 0.2f, 0.205f, 0.21f, 1.0f };\n\n        // Titles\n        colors[ImGuiCol_TitleBg] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };\n        colors[ImGuiCol_TitleBgActive] = ImVec4{ 0.15f, 0.1505f, 0.15f, 1.0f };\n        colors[ImGuiCol_TitleBgCollapsed] =\n          ImVec4{ 0.1f, 0.150f, 0.951f, 1.0f };\n    }\n\n    imgui_context::imgui_context(const ref&lt;window&gt;&amp; p_window_ctx) {\n        m_instance = vk_context::handler();\n        m_physical = vk_context::physical_driver();\n        m_driver = vk_context::driver_context();\n\n        m_current_swapchain_handler = p_window_ctx-&gt;current_swapchain();\n\n        // Setting up imgui\n        IMGUI_CHECKVERSION();\n        ImGui::CreateContext();\n        ImGuiIO&amp; io = ImGui::GetIO();\n\n        io.ConfigFlags |=\n          ImGuiConfigFlags_NavEnableKeyboard; // Enable Keyboard Controls\n        // io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable\n        // Gamepad Controls\n        io.ConfigFlags |= ImGuiConfigFlags_DockingEnable; // Enable Docking\n        io.ConfigFlags |=\n          ImGuiConfigFlags_ViewportsEnable; // Enable Multi-Viewport / Platform\n                                            // Windows\n\n        // io.ConfigViewportsNoAutoMerge = true;\n        // io.ConfigViewportsNoAutoMerge = true;\n        // io.ConfigViewportsNoTaskBarIcon = true;\n\n        // Setup Dear ImGui style\n        // ImGui::StyleColorsDark();\n        // ImGui::StyleColorsClassic();\n        im_gui_layout_color_modification();\n\n        ImGuiStyle&amp; style = ImGui::GetStyle();\n        if (io.ConfigFlags &amp; ImGuiConfigFlags_ViewportsEnable) {\n            style.WindowRounding = 0.0f;\n            style.Colors[ImGuiCol_WindowBg].w = 1.0f;\n        }\n\n        m_viewport_command_buffers.resize(\n          p_window_ctx-&gt;current_swapchain().image_size());\n\n        for (size_t i = 0; i &lt; m_viewport_command_buffers.size(); i++) {\n            ::vk::command_params settings = {\n                .levels = ::vk::command_levels::primary,\n                // .queue_index = enumerate_swapchain_settings.present_index,\n                .queue_index = 0,\n                .flags = ::vk::command_pool_flags::reset,\n            };\n            m_viewport_command_buffers[i] =\n              ::vk::command_buffer(m_driver, settings);\n        }\n\n        // ::vk::descriptor_res\n        // m_imgui_descriptor = ::vk::descriptor_resource(m_driver, {});\n        // 1: create descriptor pool for IMGUI\n        //  the size of the pool is very oversize, but it's copied from imgui\n        //  demo itself.\n        std::array&lt;VkDescriptorPoolSize, 11&gt; pool_sizes = {\n            VkDescriptorPoolSize{ VK_DESCRIPTOR_TYPE_SAMPLER, 100 },\n            VkDescriptorPoolSize{ VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,\n                                  100 },\n            VkDescriptorPoolSize{ VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, 100 },\n            VkDescriptorPoolSize{ VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 100 },\n            VkDescriptorPoolSize{ VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,\n                                  100 },\n            VkDescriptorPoolSize{ VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,\n                                  100 },\n            VkDescriptorPoolSize{ VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 100 },\n            VkDescriptorPoolSize{ VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 100 },\n            VkDescriptorPoolSize{ VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,\n                                  100 },\n            VkDescriptorPoolSize{ VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,\n                                  100 },\n            VkDescriptorPoolSize{ VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, 100 }\n        };\n\n        VkDescriptorPoolCreateInfo desc_pool_create_info = {\n            .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,\n            .pNext = nullptr,\n            .flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,\n            .maxSets = static_cast&lt;uint32_t&gt;(1000 * pool_sizes.size()),\n            // .poolSizeCount = (uint32_t)std::size(pool_sizes),\n            .poolSizeCount = static_cast&lt;uint32_t&gt;(pool_sizes.size()),\n            .pPoolSizes = pool_sizes.data()\n        };\n\n        // VkDescriptorPool imgui_pool;\n        vk::vk_check(vkCreateDescriptorPool(\n                       m_driver, &amp;desc_pool_create_info, nullptr, &amp;m_desc_pool),\n                     \"vkCreateDescriptorPool\");\n\n        create(*p_window_ctx,\n               p_window_ctx-&gt;current_swapchain().image_size(),\n               p_window_ctx-&gt;current_swapchain().swapchain_renderpass());\n    }\n\n    void imgui_context::create(GLFWwindow* p_window_handler,\n                               const uint32_t&amp; p_image_size,\n                               const VkRenderPass&amp; p_current_renderpass) {\n        ImGui_ImplGlfw_InitForVulkan(p_window_handler, true);\n        ImGui_ImplVulkan_InitInfo init_info = {};\n        init_info.Instance = m_instance;\n        init_info.PhysicalDevice = m_physical;\n        init_info.Device = m_driver;\n        init_info.Queue = m_driver.graphics_queue();\n        init_info.RenderPass = p_current_renderpass;\n        init_info.PipelineCache = nullptr;\n        init_info.DescriptorPool = m_desc_pool;\n        init_info.MinImageCount = 2;\n        init_info.ImageCount = p_image_size;\n        init_info.UseDynamicRendering = false;\n        init_info.MSAASamples = VK_SAMPLE_COUNT_1_BIT;\n        ImGui_ImplVulkan_Init(&amp;init_info);\n    }\n\n    void imgui_context::begin(const VkCommandBuffer&amp; p_current,\n                              const uint32_t&amp; p_frame_index) {\n        ImGui_ImplVulkan_NewFrame();\n        ImGui_ImplGlfw_NewFrame();\n        ImGui::NewFrame();\n\n        m_current_frame_index = p_frame_index;\n        m_current = p_current;\n    }\n\n    void imgui_context::end() {\n        ImGui::Render();\n\n        ImDrawData* draw_data = ImGui::GetDrawData();\n        ImGui_ImplVulkan_RenderDrawData(draw_data, m_current);\n\n        ImGuiIO&amp; io = ImGui::GetIO();\n        if (io.ConfigFlags &amp; ImGuiConfigFlags_ViewportsEnable) {\n            ImGui::UpdatePlatformWindows();\n            ImGui::RenderPlatformWindowsDefault();\n        }\n    }\n\n    void imgui_context::draw_hud(const hud_data&amp; p_hud_data,\n                                 const window_settings&amp; p_settings) {\n        ImGuiIO&amp; io = ImGui::GetIO();\n\n        // --- Top-Left HUD (FPS and Weapon) ---\n        ImGui::SetNextWindowPos(ImVec2(10, 10),\n                                ImGuiCond_Always); // Fixed position\n        ImGui::SetNextWindowBgAlpha(0.0f);         // Transparent background\n\n        ImGuiWindowFlags hud_flags =\n          ImGuiWindowFlags_NoDecoration |    // No title bar, borders, etc.\n          ImGuiWindowFlags_NoMove |          // Cannot be moved by user\n          ImGuiWindowFlags_NoResize |        // Cannot be resized by user\n          ImGuiWindowFlags_NoSavedSettings | // Don't save position/size to .ini\n          ImGuiWindowFlags_NoInputs; // Does not block mouse/keyboard input\n\n        if (ImGui::Begin(\"TopLeftHUD\", nullptr, hud_flags)) {\n            ImGui::Text(\"FPS: %.1f\", p_hud_data.fps);\n            ImGui::Text(\"Weapon: %s\", p_hud_data.currentWeapon.c_str());\n            // ImGui::Text(\"Health:\");\n            // Use a progress bar for health\n            // ImGui::ProgressBar(p_hud_data.playerHealth / 100.0f, ImVec2(-1,\n            // 0), \"#Health\"); // -1 width fills available space\n            ImGui::Text(\"Health: %.1f\", p_hud_data.playerHealth);\n            ImGui::ProgressBar(p_hud_data.playerHealth / 100.0f,\n                               ImVec2(-1, 0)); // No overlay text here\n        }\n        ImGui::End();\n\n        // --- Health Bar (Bottom-Left) ---\n        ImGui::SetNextWindowPos(ImVec2(10, (float)p_settings.width - 50),\n                                ImGuiCond_Always);\n        ImGui::SetNextWindowSize(ImVec2(200, 40),\n                                 ImGuiCond_Always); // Fixed size\n        ImGui::SetNextWindowBgAlpha(0.0f);\n\n        // if (ImGui::Begin(\"HealthBar\", nullptr, hud_flags)) {\n        //     ImGui::Text(\"Health:\");\n        //     // Use a progress bar for health\n        //     ImGui::ProgressBar(p_hud_data.playerHealth / 100.0f, ImVec2(-1,\n        //     0), \"HP\"); // -1 width fills available space\n        // }\n        // ImGui::End();\n\n        // --- Score (Top-Right) ---\n        // Position it relative to the right edge\n        ImGui::SetNextWindowPos(ImVec2((float)p_settings.width - 150, 10),\n                                ImGuiCond_Always);\n        ImGui::SetNextWindowSize(\n          ImVec2(140, 0),\n          ImGuiCond_Always); // 0 height means auto-size vertically\n        ImGui::SetNextWindowBgAlpha(0.0f);\n\n        if (ImGui::Begin(\"ScoreDisplay\", nullptr, hud_flags)) {\n            ImGui::SetCursorPosX(\n              ImGui::GetWindowSize().x -\n              ImGui::CalcTextSize(\n                std::to_string(p_hud_data.playerScore).c_str())\n                .x -\n              ImGui::GetStyle().WindowPadding.x);\n            ImGui::Text(\"Score: %d\", p_hud_data.playerScore);\n        }\n        ImGui::End();\n\n        // --- Crosshair (Custom Drawing - Optional) ---\n        // If you want a more custom crosshair, you might use ImDrawList.\n        // This is more advanced and often handled by your game's rendering\n        // pipeline directly, but ImGui can draw simple shapes. To draw on the\n        // main viewport, you can get the foreground draw list of the main\n        // viewport.\n        ImDrawList* draw_list =\n          ImGui::GetBackgroundDrawList(); // Or ImGui::GetForegroundDrawList()\n        if (draw_list) {\n            ImVec2 center =\n              ImVec2(io.DisplaySize.x * 0.5f, io.DisplaySize.y * 0.5f);\n            float crosshair_size = 10.0f;\n            float gap = 2.0f;\n            ImU32 crosshair_color = IM_COL32(255, 255, 255, 255); // White\n\n            // Horizontal lines\n            draw_list-&gt;AddLine(\n              ImVec2(center.x - crosshair_size - gap, center.y),\n              ImVec2(center.x - gap, center.y),\n              crosshair_color);\n            draw_list-&gt;AddLine(\n              ImVec2(center.x + gap, center.y),\n              ImVec2(center.x + crosshair_size + gap, center.y),\n              crosshair_color);\n\n            // Vertical lines\n            draw_list-&gt;AddLine(\n              ImVec2(center.x, center.y - crosshair_size - gap),\n              ImVec2(center.x, center.y - gap),\n              crosshair_color);\n            draw_list-&gt;AddLine(\n              ImVec2(center.x, center.y + gap),\n              ImVec2(center.x, center.y + crosshair_size + gap),\n              crosshair_color);\n        }\n    }\n\n    void imgui_context::destroy() {\n        ImGui_ImplVulkan_Shutdown();\n        vkDestroyDescriptorPool(m_driver, m_desc_pool, nullptr);\n\n        for (auto&amp; command_buffer : m_viewport_command_buffers) {\n            command_buffer.destroy();\n        }\n\n        ImGui_ImplGlfw_Shutdown();\n        ImGui::DestroyContext();\n    }\n};\n</code></pre>"},{"location":"References/vk__physical__driver_8cpp/","title":"File vk_physical_driver.cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_physical_driver.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/vulkan-cpp/vk_physical_driver.hpp&gt;</code></li> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/utilities.hpp&gt;</code></li> </ul>"},{"location":"References/vk__physical__driver_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/vulkan-cpp/vk_physical_driver.cpp</code></p>"},{"location":"References/vk__physical__driver_8cpp_source/","title":"File vk_physical_driver.cpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_physical_driver.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;drivers/vulkan-cpp/vk_physical_driver.hpp&gt;\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;drivers/vulkan-cpp/utilities.hpp&gt;\n\nnamespace atlas::vk {\n\n    vk_physical_driver::vk_physical_driver(const VkInstance&amp; p_instance) {\n\n        uint32_t device_count = 0;\n        vkEnumeratePhysicalDevices(p_instance, &amp;device_count, nullptr);\n\n        if (device_count == 0) {\n            console_log_fatal(\"Device Count is {} and no devices found!!!\",\n                              device_count);\n            return;\n        }\n\n        std::vector&lt;VkPhysicalDevice&gt; physical_drivers(device_count);\n        vkEnumeratePhysicalDevices(\n          p_instance, &amp;device_count, physical_drivers.data());\n\n        for (const auto&amp; device : physical_drivers) {\n            VkPhysicalDeviceProperties device_properties;\n            VkPhysicalDeviceFeatures device_features;\n            vkGetPhysicalDeviceProperties(device, &amp;device_properties);\n            vkGetPhysicalDeviceFeatures(device, &amp;device_features);\n            if (device_properties.deviceType ==\n                VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {\n                m_physical_driver = device;\n                break;\n            }\n        }\n\n        uint32_t queue_family_count = 0;\n        vkGetPhysicalDeviceQueueFamilyProperties(\n          m_physical_driver, &amp;queue_family_count, nullptr);\n        m_queue_family_properties.resize(queue_family_count);\n\n        vkGetPhysicalDeviceQueueFamilyProperties(\n          m_physical_driver,\n          &amp;queue_family_count,\n          m_queue_family_properties.data());\n\n        m_queue_indices = select_queue_family_indices();\n    }\n\n    vk_physical_driver::~vk_physical_driver() = default;\n\n    surface_properties vk_physical_driver::get_surface_properties(\n      const VkSurfaceKHR&amp; p_surface) {\n        vk_check(vkGetPhysicalDeviceSurfaceCapabilitiesKHR(\n                   m_physical_driver,\n                   p_surface,\n                   &amp;m_surface_properties.surface_capabilities),\n                 \"vkGetPhysicalDeviceSurfaceCapabilitiesKHR\");\n\n        uint32_t format_count = 0;\n        std::vector&lt;VkSurfaceFormatKHR&gt; formats;\n        vk_check(vkGetPhysicalDeviceSurfaceFormatsKHR(\n                   m_physical_driver, p_surface, &amp;format_count, nullptr),\n                 \"vkGetPhysicalDeviceSurfaceFormatsKHR\");\n\n        formats.resize(format_count);\n\n        vk_check(vkGetPhysicalDeviceSurfaceFormatsKHR(\n                   m_physical_driver, p_surface, &amp;format_count, formats.data()),\n                 \"vkGetPhysicalDeviceSurfaceFormatsKHR\");\n\n        for (const auto&amp; format : formats) {\n            if (format.format == VK_FORMAT_B8G8R8A8_SRGB &amp;&amp;\n                format.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {\n                m_surface_properties.surface_format = format;\n            }\n        }\n\n        m_surface_properties.surface_format = formats[0];\n\n        return m_surface_properties;\n    }\n\n    vk_physical_driver::queue_family_indices\n    vk_physical_driver::select_queue_family_indices() {\n        VkPhysicalDeviceMemoryProperties physical_device_memory_properties;\n        vkGetPhysicalDeviceMemoryProperties(m_physical_driver,\n                                            &amp;physical_device_memory_properties);\n        vk_physical_driver::queue_family_indices indices;\n        int i = 0;\n\n        for (const auto&amp; queue_family : m_queue_family_properties) {\n            if (queue_family.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) {\n                indices.graphics = i;\n                break;\n            }\n            i++;\n        }\n\n        return indices;\n    }\n\n    uint32_t vk_physical_driver::read_presentation_index(\n      const VkSurfaceKHR&amp; p_surface) {\n        uint32_t presentation_index = -1;\n        VkBool32 compatible = VK_FALSE;\n        uint32_t i = 0;\n        for (const auto&amp; queue_family : m_queue_family_properties) {\n            if (queue_family.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) {\n                vk_check(vkGetPhysicalDeviceSurfaceSupportKHR(\n                           m_physical_driver, i, p_surface, &amp;compatible),\n                         \"vkGetPhysicalDeviceSurfaceSupportKHR\");\n\n                if (compatible) {\n                    presentation_index = i;\n                }\n            }\n            i++;\n        }\n\n        return presentation_index;\n    }\n\n    VkPhysicalDeviceMemoryProperties vk_physical_driver::memory_properties()\n      const {\n        VkPhysicalDeviceMemoryProperties physical_memory_properties;\n        vkGetPhysicalDeviceMemoryProperties(m_physical_driver,\n                                            &amp;physical_memory_properties);\n        return physical_memory_properties;\n    }\n};\n</code></pre>"},{"location":"References/vk__renderer_8cpp/","title":"File vk_renderer.cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_renderer.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/common.hpp&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_renderer.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/utilities.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;</code></li> <li><code>#include &lt;renderer/uniforms.hpp&gt;</code></li> </ul>"},{"location":"References/vk__renderer_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/vulkan-cpp/vk_renderer.cpp</code></p>"},{"location":"References/vk__renderer_8cpp_source/","title":"File vk_renderer.cpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_renderer.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/common.hpp&gt;\n#include &lt;array&gt;\n#include &lt;drivers/vulkan-cpp/vk_renderer.hpp&gt;\n#include &lt;drivers/vulkan-cpp/utilities.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;\n#include &lt;renderer/uniforms.hpp&gt;\n\nnamespace atlas::vk {\n\n    vk_renderer::vk_renderer(const window_settings&amp; p_settings,\n                             uint32_t p_image_size,\n                             const std::string&amp; p_tag) {\n        console_log_manager::create_new_logger(p_tag);\n        m_device = vk_context::driver_context();\n        m_physical = vk_context::physical_driver();\n        m_window_extent = p_settings;\n\n        m_image_count = p_image_size;\n#ifdef USE_SHADERC\n        std::array&lt;::vk::shader_source, 2&gt; shader_sources = {\n            ::vk::shader_source{\n              \"experimental-shaders/test.vert\",\n              ::vk::shader_stage::vertex,\n            },\n            ::vk::shader_source{\n              \"experimental-shaders/test.frag\",\n              ::vk::shader_stage::fragment,\n            }\n        };\n#else\n        std::array&lt;::vk::shader_source, 2&gt; shader_sources = {\n            ::vk::shader_source{\n              \"experimental-shaders/test.vert.spv\",\n              ::vk::shader_stage::vertex,\n            },\n            ::vk::shader_source{\n              \"experimental-shaders/test.frag.spv\",\n              ::vk::shader_stage::fragment,\n            }\n        };\n#endif\n\n        std::array&lt;::vk::vertex_attribute_entry, 4&gt; attribute_entries = {\n            ::vk::vertex_attribute_entry{\n              .location = 0,\n              .format = ::vk::format::rgb32_sfloat,\n              .stride = offsetof(vk::vertex_input, position),\n            },\n            ::vk::vertex_attribute_entry{\n              .location = 1,\n              .format = ::vk::format::rgb32_sfloat,\n              .stride = offsetof(vk::vertex_input, color),\n            },\n            ::vk::vertex_attribute_entry{\n              .location = 2,\n              .format = ::vk::format::rgb32_sfloat,\n              .stride = offsetof(vertex_input, normals),\n            },\n            ::vk::vertex_attribute_entry{\n              .location = 3,\n              .format = ::vk::format::rg32_sfloat,\n              .stride = offsetof(vertex_input, uv),\n            }\n        };\n\n        std::array&lt;::vk::vertex_attribute, 1&gt; attribute = {\n            ::vk::vertex_attribute{\n              // layout (set = 0, binding = 0)\n              .binding = 0,\n              .entries = attribute_entries,\n              .stride = sizeof(vk::vertex_input),\n              .input_rate = ::vk::input_rate::vertex,\n            },\n        };\n\n        ::vk::shader_resource_info shader_info = {\n            .sources = shader_sources,\n        };\n\n        try {\n            m_shader_group = shader_resource_group(m_device, shader_info);\n            m_shader_group.vertex_attributes(attribute);\n        }\n        catch (std::runtime_error&amp; e) {\n            console_log_error(\"Compilation Error!!\");\n            console_log_error(\"{}\", e.what());\n        }\n        // Setting global descriptor set 0\n        std::vector&lt;::vk::descriptor_entry&gt; set0_entries = {\n            ::vk::descriptor_entry{\n                // specifies \"layout (set = 0, binding = 0) uniform GlobalUbo\"\n                .type = ::vk::buffer::uniform,\n                .binding_point = {\n                    .binding = 0,\n                    .stage = ::vk::shader_stage::vertex,\n                },\n                .descriptor_count = 1,\n            },\n            ::vk::descriptor_entry{\n                // specifies \"layout (set = 0, binding = 1) uniform light_ubo\"\n                .type = ::vk::buffer::uniform,\n                .binding_point = {\n                    .binding = 1,\n                    .stage = ::vk::shader_stage::fragment,\n                },\n                .descriptor_count = 1,\n            },\n        };\n\n        // uint32_t image_count = image_count;\n        ::vk::descriptor_layout set0_layout = {\n            .slot = 0,\n            .max_sets = m_image_count,\n            .entries = set0_entries,\n        };\n        m_global_descriptors = ::vk::descriptor_resource(m_device, set0_layout);\n\n        ::vk::uniform_params global_info = {\n            .phsyical_memory_properties = m_physical.memory_properties(),\n            .size_bytes = sizeof(global_ubo),\n            .debug_name = \"\\nm_global_uniforms\\n\",\n            .vkSetDebugUtilsObjectNameEXT = vk_context::get_debug_object_name()\n        };\n        m_global_uniforms = ::vk::uniform_buffer(m_device, global_info);\n\n        // setting up our light uniforms as the global uniforms rather then\n        // per-object basis\n        ::vk::uniform_params light_ubo_params = {\n            .phsyical_memory_properties = m_physical.memory_properties(),\n            .size_bytes = sizeof(light_scene_ubo),\n        };\n        m_point_light_uniforms =\n          ::vk::uniform_buffer(m_device, light_ubo_params);\n\n        std::array&lt;::vk::write_buffer, 1&gt; binding0_uniforms = {\n            ::vk::write_buffer{\n              .buffer = m_global_uniforms,\n              .offset = 0,\n              .range = m_global_uniforms.size_bytes(),\n            },\n        };\n\n        std::array&lt;::vk::write_buffer, 1&gt; binding1_uniforms = {\n            ::vk::write_buffer{\n              .buffer = m_point_light_uniforms,\n              .offset = 0,\n              .range = m_point_light_uniforms.size_bytes(),\n            },\n        };\n\n        std::array&lt;::vk::write_buffer_descriptor, 2&gt; set0_write_buffers = {\n            ::vk::write_buffer_descriptor{\n              .dst_binding = 0,\n              .uniforms = binding0_uniforms,\n            },\n            ::vk::write_buffer_descriptor{\n              .dst_binding = 1,\n              .uniforms = binding1_uniforms,\n            }\n        };\n        m_global_descriptors.update(set0_write_buffers);\n\n        m_sets_layouts = {\n            m_global_descriptors.layout(),\n        };\n\n        ::vk::image_extent extent = {\n            .width = 1,\n            .height = 1,\n        };\n        m_white_texture =\n          ::vk::texture(m_device, extent, m_physical.memory_properties());\n\n        vk_context::submit_resource_free([this]() {\n            m_white_texture.destroy();\n            m_shader_group.destroy();\n            m_global_descriptors.destroy();\n            m_global_uniforms.destroy();\n            m_point_light_uniforms.destroy();\n            for (auto&amp; [id, mesh] : m_cached_meshes) {\n                console_log_trace(\"Entity \\\"{}\\\" Destroyed in vk_renderer!!!\",\n                                  id);\n                mesh.destroy();\n            }\n\n            for (auto&amp; [id, uniform] : m_mesh_geometry_set) {\n                uniform.destroy();\n            }\n\n            for (auto&amp; [id, material_uniform] : m_mesh_material_set) {\n                material_uniform.destroy();\n            }\n\n            for (auto&amp; [key, descriptor_map] : m_mesh_descriptors) {\n                for (auto&amp; [descriptor_type, descriptor] : descriptor_map) {\n                    descriptor.destroy();\n                }\n            }\n            m_main_pipeline.destroy();\n        });\n    }\n\n    void vk_renderer::current_scene(ref&lt;scene&gt; p_scene) {\n        m_current_scene = p_scene;\n    }\n\n    void vk_renderer::background_color(const std::array&lt;float, 4&gt;&amp; p_color) {\n        m_color = {\n            { p_color.at(0), p_color.at(1), p_color.at(2), p_color.at(3) }\n        };\n    }\n\n    void vk_renderer::preload_assets(const VkRenderPass&amp; p_renderpass) {\n        m_final_renderpass = p_renderpass;\n        // set 1 -- material uniforms\n        // ref&lt;world&gt; current_world = system_registry::get_world(\"Editor\n        // World\"); ref&lt;scene&gt; current_scene =\n        // current_world-&gt;get_scene(\"LevelScene\");\n\n        flecs::query&lt;&gt; caching =\n          m_current_scene-&gt;query_builder&lt;mesh_source&gt;().build();\n\n        caching.each([this](flecs::entity p_entity) {\n            const mesh_source* target = p_entity.get&lt;mesh_source&gt;();\n            mesh new_mesh(std::filesystem::path(target-&gt;model_path),\n                          target-&gt;flip);\n\n            // we do a check if the geometry uniform associated with this game\n            // object is valid\n            if (!m_mesh_geometry_set.contains(p_entity.id())) {\n                ::vk::uniform_params geo_info = {\n                    .phsyical_memory_properties =\n                      m_physical.memory_properties(),\n                    .size_bytes = sizeof(material_uniform),\n                };\n                m_mesh_geometry_set[p_entity.id()] =\n                  ::vk::uniform_buffer(m_device, geo_info);\n            }\n\n            // check if material is already associated with this particular game\n            // object\n            if (!m_mesh_material_set.contains(p_entity.id())) {\n                ::vk::uniform_params mat_info = {\n                    .phsyical_memory_properties =\n                      m_physical.memory_properties(),\n                    .size_bytes = sizeof(material_metadata),\n                };\n                m_mesh_material_set[p_entity.id()] =\n                  ::vk::uniform_buffer(m_device, mat_info);\n            }\n\n            new_mesh.add_diffuse(std::filesystem::path(target-&gt;diffuse));\n            new_mesh.add_specular(std::filesystem::path(target-&gt;specular));\n\n            if (new_mesh.loaded()) {\n                m_cached_meshes.emplace(p_entity.id(), new_mesh);\n\n                std::vector&lt;::vk::descriptor_entry&gt; set1_entries = {\n                    ::vk::descriptor_entry{\n                        // specifies \"layout (set = 1, binding = 0) uniform geometry_uniform\"\n                        .type = ::vk::buffer::uniform,\n                        .binding_point = {\n                            .binding = 0,\n                            .stage = ::vk::shader_stage::vertex,\n                        },\n                        .descriptor_count = 1,\n                    },\n                    ::vk::descriptor_entry{\n                        // specifies \"layout (set = 1, binding = 1) uniform sampler2D diffuse_texture\"\n                        .type = ::vk::buffer::combined_image_sampler,\n                        .binding_point = {\n                            .binding = 1,\n                            .stage = ::vk::shader_stage::fragment,\n                        },\n                        .descriptor_count = 1,\n                    },\n                    ::vk::descriptor_entry{\n                        // specifies \"layout (set = 1, binding = 2) uniform sampler2D specular_texture\"\n                        .type = ::vk::buffer::combined_image_sampler,\n                        .binding_point = {\n                            .binding = 2,\n                            .stage = ::vk::shader_stage::fragment,\n                        },\n                        .descriptor_count = 1,\n                    },\n                    ::vk::descriptor_entry{\n                        // specifies \"layout (set = 1, binding = 3) uniform sampler2D material_ubo\"\n                        .type = ::vk::buffer::uniform,\n                        .binding_point = {\n                            .binding = 3,\n                            .stage = ::vk::shader_stage::fragment,\n                        },\n                        .descriptor_count = 1,\n                    },\n                };\n\n                ::vk::descriptor_layout set1_layout = {\n                    .slot = 1,\n                    .max_sets = m_image_count,\n                    .entries = set1_entries,\n                };\n\n                m_mesh_descriptors[p_entity.id()].emplace(\n                  \"materials\",\n                  ::vk::descriptor_resource(m_device, set1_layout));\n\n                // specify to the vk::write_descriptor_buffer\n                std::array&lt;::vk::write_buffer, 1&gt; binding0_buffers = {\n                    ::vk::write_buffer{\n                      .buffer = m_mesh_geometry_set[p_entity.id()],\n                      .offset = 0,\n                      .range = m_mesh_geometry_set[p_entity.id()].size_bytes(),\n                    }\n                };\n\n                std::array&lt;::vk::write_buffer, 1&gt; binding3_buffers = {\n                    ::vk::write_buffer{\n                      .buffer = m_mesh_material_set[p_entity.id()],\n                      .offset = 0,\n                      .range = m_mesh_material_set[p_entity.id()].size_bytes(),\n                    }\n                };\n\n                std::vector&lt;::vk::write_buffer_descriptor&gt; material_uniforms = {\n                    // layout(set=  1, binding = 0) geometry_ubo\n                    ::vk::write_buffer_descriptor{\n                      .dst_binding = 0,\n                      .uniforms = binding0_buffers,\n                    },\n                    // layout(set=  1, binding = 3) material_ubo\n                    ::vk::write_buffer_descriptor{\n                      .dst_binding = 3,\n                      .uniforms = binding3_buffers,\n                    },\n                };\n\n                // layout(set = 1, binding = 1)\n                // If the texture loaded successfully then we use that texture,\n                // otherwise utilize the default white texture\n                ::vk::sample_image diffuse =\n                  m_cached_meshes[p_entity.id()].diffuse_loaded()\n                    ? m_cached_meshes[p_entity.id()].diffuse()\n                    : m_white_texture.image();\n\n                // layout(set = 1, binding = 2)\n                ::vk::sample_image specular =\n                  m_cached_meshes[p_entity.id()].specular_loaded()\n                    ? m_cached_meshes[p_entity.id()].specular()\n                    : m_white_texture.image();\n\n                // writes to texture at layout(set = 1, binding = 1)\n                std::array&lt;::vk::write_image, 1&gt;\n                  binding1_images = { ::vk::write_image{\n                    .sampler = diffuse.sampler(),\n                    .view = diffuse.image_view(),\n                    // .image_layout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,\n                    .layout = ::vk::image_layout::shader_read_only_optimal,\n                  } };\n\n                // writes to texture at layout(set = 1, binding = 2)\n                std::array&lt;::vk::write_image, 1&gt;\n                  binding2_images = { ::vk::write_image{\n                    .sampler = specular.sampler(),\n                    .view = specular.image_view(),\n                    // .image_layout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,\n                    .layout = ::vk::image_layout::shader_read_only_optimal,\n                  } };\n\n                // vulkan image descriptors are for writing textures\n                std::vector&lt;::vk::write_image_descriptor&gt; material_textures = {\n                    // layout(set = 1, binding = 1) uniform sampler2D\n                    ::vk::write_image_descriptor{\n                      .dst_binding = 1,\n                      .sample_images = binding1_images,\n                    },\n                    // layout(set = 1, binding = 2) uniform sampler2D\n                    ::vk::write_image_descriptor{\n                      .dst_binding = 2,\n                      .sample_images = binding2_images,\n                    },\n                };\n\n                m_mesh_descriptors[p_entity.id()][\"materials\"].update(\n                  material_uniforms, material_textures);\n\n                m_sets_layouts.push_back(\n                  m_mesh_descriptors[p_entity.id()][\"materials\"].layout());\n            }\n        });\n\n        std::vector&lt;::vk::shader_handle&gt; modules = m_shader_group.handles();\n\n        ::vk::pipeline_settings pipeline_configuration = {\n            .renderpass = m_final_renderpass,\n            .shader_modules = modules,\n            .vertex_attributes = m_shader_group.vertex_attributes(),\n            .vertex_bind_attributes = m_shader_group.vertex_bind_attributes(),\n            .descriptor_layouts = m_sets_layouts\n        };\n        m_main_pipeline = ::vk::pipeline(m_device, pipeline_configuration);\n    }\n\n    void vk_renderer::start_frame(const ::vk::command_buffer&amp; p_current,\n                                  const window_settings&amp; p_settings,\n                                  const VkRenderPass&amp; p_renderpass,\n                                  const VkFramebuffer&amp; p_framebuffer,\n                                  const glm::mat4&amp; p_proj_view) {\n        m_proj_view = p_proj_view;\n        m_current_frame = application::current_frame();\n        m_final_renderpass = p_renderpass;\n\n        std::array&lt;VkClearValue, 2&gt; clear_values = {};\n\n        clear_values[0].color = m_color;\n        clear_values[1].depthStencil = { 1.f, 0 };\n        m_window_extent = p_settings;\n\n        VkRenderPassBeginInfo renderpass_begin_info = {\n            .sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,\n            .pNext = nullptr,\n            .renderPass = p_renderpass,\n            .renderArea = {\n                .offset = {\n                    .x = 0,\n                    .y = 0\n                },\n                .extent = {\n                    .width = p_settings.width,\n                    .height = p_settings.height\n                },\n            },\n            .clearValueCount = static_cast&lt;uint32_t&gt;(clear_values.size()),\n            .pClearValues = clear_values.data()\n        };\n\n        m_current_command_buffer = p_current;\n        m_current_command_buffer.begin(\n          ::vk::command_usage::simulatneous_use_bit);\n\n        VkViewport viewport = {\n            .x = 0.0f,\n            .y = 0.0f,\n            .width = static_cast&lt;float&gt;(m_window_extent.width),\n            .height = static_cast&lt;float&gt;(m_window_extent.height),\n            .minDepth = 0.0f,\n            .maxDepth = 1.0f,\n        };\n\n        vkCmdSetViewport(m_current_command_buffer, 0, 1, &amp;viewport);\n\n        VkRect2D scissor = {\n            .offset = { 0, 0 },\n            .extent = { m_window_extent.width, m_window_extent.height },\n        };\n\n        vkCmdSetScissor(m_current_command_buffer, 0, 1, &amp;scissor);\n\n        renderpass_begin_info.framebuffer = p_framebuffer;\n\n        vkCmdBeginRenderPass(m_current_command_buffer,\n                             &amp;renderpass_begin_info,\n                             VK_SUBPASS_CONTENTS_INLINE);\n    }\n\n    // This just returns the arbitrary amount of bytes of the object\n    // TODO: Move this into core/utilities.hpp\n    template&lt;typename T&gt;\n    std::span&lt;uint8_t&gt; to_bytes(T p_data) {\n        return std::span&lt;uint8_t&gt;(reinterpret_cast&lt;uint8_t*&gt;(&amp;p_data),\n                                  sizeof(p_data));\n    }\n\n    void vk_renderer::post_frame() {\n\n        // For now, using this. Will need to remove this before vulkan\n        // integration merging into dev This is for testing and to hopefully\n        // have a global_ubo for globalized uniforms\n        global_ubo global_frame_ubo = { .mvp = m_proj_view };\n\n        // TODO: Make to_bytes be part of utilities. This can be useful in\n        // sending the amount of bytes in batches for batch-rendering\n        // std::span&lt;uint8_t&gt; bytes_data = to_bytes(global_frame_ubo);\n        // m_global_uniforms.update(bytes_data.data());\n        m_global_uniforms.update(&amp;global_frame_ubo);\n\n        ref&lt;world&gt; current_world = system_registry::get_world(\"Editor World\");\n        ref&lt;scene&gt; current_scene = current_world-&gt;get_scene(\"LevelScene\");\n\n        // query all entities that have a point light\n        flecs::query&lt;point_light&gt; query_point_lights =\n          current_scene-&gt;query_builder&lt;point_light&gt;().build();\n\n        light_scene_ubo test_light = {};\n        uint32_t index = 0;\n        query_point_lights.each(\n          [&amp;index, &amp;test_light](flecs::entity p_entity, point_light&amp; p_light) {\n              const transform* t = p_entity.get&lt;transform&gt;();\n              p_light.position = t-&gt;position;\n\n              test_light.light_sources[index] = {\n                  .position = glm::vec4(p_light.position, 1.f),\n                  .color = p_light.color,\n                  .attenuation = p_light.attenuation,\n                  .constant = p_light.constant,\n                  .linear = p_light.linear,\n                  .quadratic = p_light.quadratic,\n                  .ambient = p_light.ambient,\n                  .diffuse = p_light.diffuse,\n                  .specular = p_light.specular,\n              };\n              index += 1;\n          });\n        test_light.num_lights = index;\n\n        m_point_light_uniforms.update(&amp;test_light);\n\n        // query all objects with a specified 3d mesh source\n        flecs::query&lt;&gt; query_targets =\n          current_scene-&gt;query_builder&lt;mesh_source&gt;().build();\n\n        m_main_pipeline.bind(m_current_command_buffer);\n\n        // Bind global camera data here\n        m_global_descriptors.bind(m_current_command_buffer,\n                                  m_main_pipeline.layout());\n        query_targets.each([this](flecs::entity p_entity) {\n            const transform* transform_component = p_entity.get&lt;transform&gt;();\n            const mesh_source* material_component = p_entity.get&lt;mesh_source&gt;();\n            m_model = glm::mat4(1.f);\n            m_model = glm::translate(m_model, transform_component-&gt;position);\n            m_model = glm::scale(m_model, transform_component-&gt;scale);\n            glm::mat4 rotation_mat4 =\n              glm::mat4(glm::quat(transform_component-&gt;rotation));\n\n            m_model *= rotation_mat4;\n\n            // Mesh used for viking_room - replaced with std::map equivalent\n            geometry_uniform mesh_ubo = { .model = m_model,\n                                          .color = material_component-&gt;color };\n\n            if (m_cached_meshes[p_entity.id()].loaded()) {\n                m_mesh_geometry_set[p_entity.id()].update(&amp;mesh_ubo);\n\n                material_metadata data = {};\n\n                if (p_entity.has&lt;material_metadata&gt;()) {\n                    data = *p_entity.get&lt;material_metadata&gt;();\n                }\n                m_mesh_material_set[p_entity.id()].update(&amp;data);\n\n                m_mesh_descriptors[p_entity.id()][\"materials\"].bind(\n                  m_current_command_buffer, m_main_pipeline.layout());\n\n                m_cached_meshes[p_entity.id()].draw(m_current_command_buffer);\n            }\n        });\n\n        vkCmdEndRenderPass(m_current_command_buffer);\n        m_current_command_buffer.end();\n    }\n};\n</code></pre>"},{"location":"References/vk__swapchain_8cpp/","title":"File vk_swapchain.cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_swapchain.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/vulkan-cpp/vk_swapchain.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;</code></li> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/utilities.hpp&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;vulkan-cpp/types.hpp&gt;</code></li> </ul>"},{"location":"References/vk__swapchain_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/vulkan-cpp/vk_swapchain.cpp</code></p>"},{"location":"References/vk__swapchain_8cpp_source/","title":"File vk_swapchain.cpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_swapchain.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;drivers/vulkan-cpp/vk_swapchain.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;drivers/vulkan-cpp/utilities.hpp&gt;\n#include &lt;array&gt;\n#include &lt;vulkan-cpp/types.hpp&gt;\n\nnamespace atlas::vk {\n\n    vk_swapchain::vk_swapchain(const VkSurfaceKHR&amp; p_surface,\n                               const window_settings&amp; p_settings)\n      : m_current_surface_handler(p_surface)\n      , m_window_settings(p_settings)\n      , m_current_surface(p_surface) {\n        m_physical = vk_context::physical_driver();\n        m_driver = vk_context::driver_context();\n\n        create();\n    }\n\n    void vk_swapchain::create() {\n\n        // surface properties are always updated from the physical device\n        // so they are valid should the swapchain be recreated\n        m_surface_properties =\n          m_physical.get_surface_properties(m_current_surface);\n        m_window_settings.width =\n          m_surface_properties.surface_capabilities.currentExtent.width;\n        m_window_settings.height =\n          m_surface_properties.surface_capabilities.currentExtent.height;\n\n        // request what our minimum image count is\n        uint32_t request_min_image_count =\n          select_images_size(m_surface_properties.surface_capabilities);\n\n        m_swapchain_extent =\n          m_surface_properties.surface_capabilities.currentExtent;\n\n        // setting our presentation properties\n        uint32_t present_index =\n          m_physical.read_presentation_index(m_current_surface_handler);\n\n        VkSwapchainCreateInfoKHR swapchain_ci = {\n            .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,\n            .surface = m_current_surface_handler,\n            .minImageCount = request_min_image_count,\n            .imageFormat = m_surface_properties.surface_format.format,\n            .imageColorSpace = m_surface_properties.surface_format.colorSpace,\n            // use physical device surface formats to getting the right formats\n            // in vulkan\n            .imageExtent = m_swapchain_extent,\n            .imageArrayLayers = 1,\n            .imageUsage = (VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT |\n                           VK_IMAGE_USAGE_TRANSFER_DST_BIT),\n            .queueFamilyIndexCount = 1,\n            .pQueueFamilyIndices = &amp;present_index,\n            .preTransform =\n              m_surface_properties.surface_capabilities.currentTransform,\n            .compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,\n            .presentMode = VK_PRESENT_MODE_IMMEDIATE_KHR,\n            .clipped = true\n        };\n\n        vk_check(vkCreateSwapchainKHR(\n                   m_driver, &amp;swapchain_ci, nullptr, &amp;m_swapchain_handler),\n                 \"vkCreateSwapchainKHR\");\n\n        uint32_t image_count = 0;\n        vkGetSwapchainImagesKHR(m_driver,\n                                m_swapchain_handler,\n                                &amp;image_count,\n                                nullptr); // used to get the amount of images\n        std::vector&lt;VkImage&gt; images(image_count);\n        vkGetSwapchainImagesKHR(m_driver,\n                                m_swapchain_handler,\n                                &amp;image_count,\n                                images.data()); // used to store in the images\n\n        // Creating Images\n        m_swapchain_images.resize(image_count);\n        m_image_size = image_count;\n        m_swapchain_depth_images.resize(image_count);\n\n        VkFormat depth_format = m_driver.depth_format();\n\n        for (uint32_t i = 0; i &lt; m_swapchain_images.size(); i++) {\n            ::vk::image_params color_image_config = {\n                .extent = { m_swapchain_extent.width,\n                            m_swapchain_extent.height, },\n                .format = m_surface_properties.surface_format.format,\n                .aspect = ::vk::image_aspect_flags::color_bit,\n                .usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,\n                .mip_levels = 1,\n                .layer_count = 1,\n                .phsyical_memory_properties = m_physical.memory_properties(),\n\n            };\n\n            m_swapchain_images[i] =\n              ::vk::sample_image(m_driver, images[i], color_image_config);\n\n            ::vk::image_params depth_image_config = {\n                .extent = { m_swapchain_extent.width,\n                            m_swapchain_extent.height, },\n                .format = depth_format,\n                .aspect = ::vk::image_aspect_flags::depth_bit,\n                .usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,\n                .mip_levels = 1,\n                .layer_count = 1,\n                .phsyical_memory_properties = m_physical.memory_properties(),\n            };\n\n            m_swapchain_depth_images[i] =\n              ::vk::sample_image(m_driver, depth_image_config);\n        }\n\n        // command buffers\n\n        m_swapchain_command_buffers.resize(image_count);\n\n        for (size_t i = 0; i &lt; m_swapchain_command_buffers.size(); i++) {\n            ::vk::command_params settings = {\n                .levels = ::vk::command_levels::primary,\n                // .queue_index = enumerate_swapchain_settings.present_index,\n                .queue_index = 0,\n                .flags = ::vk::command_pool_flags::reset,\n            };\n\n            m_swapchain_command_buffers[i] =\n              ::vk::command_buffer(m_driver, settings);\n        }\n\n        std::array&lt;::vk::attachment, 2&gt; renderpass_attachments = {\n            ::vk::attachment{\n              .format = m_surface_properties.surface_format.format,\n              .layout = ::vk::image_layout::color_optimal,\n              .samples = ::vk::sample_bit::count_1,\n              .load = ::vk::attachment_load::clear,\n              .store = ::vk::attachment_store::store,\n              .stencil_load = ::vk::attachment_load::clear,\n              .stencil_store = ::vk::attachment_store::dont_care,\n              .initial_layout = ::vk::image_layout::undefined,\n              .final_layout = ::vk::image_layout::present_src_khr,\n            },\n            ::vk::attachment{\n              .format = depth_format,\n              .layout = ::vk::image_layout::depth_stencil_optimal,\n              .samples = ::vk::sample_bit::count_1,\n              .load = ::vk::attachment_load::clear,\n              .store = ::vk::attachment_store::dont_care,\n              .stencil_load = ::vk::attachment_load::dont_care,\n              .stencil_store = ::vk::attachment_store::dont_care,\n              .initial_layout = ::vk::image_layout::undefined,\n              .final_layout = ::vk::image_layout::depth_stencil_optimal,\n            },\n        };\n        m_final_renderpass = ::vk::renderpass(m_driver, renderpass_attachments);\n\n        // creating framebuffers\n        m_swapchain_framebuffers.resize(m_swapchain_images.size());\n\n        for (uint32_t i = 0; i &lt; m_swapchain_images.size(); i++) {\n\n            std::array&lt;VkImageView, renderpass_attachments.size()&gt;\n              image_attachments = { m_swapchain_images[i].image_view(),\n                                    m_swapchain_depth_images[i].image_view() };\n\n            ::vk::framebuffer_params framebuffer_info = {\n                .renderpass = m_final_renderpass,\n                .views = image_attachments,\n                .extent = m_swapchain_extent\n            };\n            m_swapchain_framebuffers[i] =\n              ::vk::framebuffer(m_driver, framebuffer_info);\n        }\n\n        ::vk::queue_params present_queue_params{\n            .family = 0,\n            .index = 0,\n        };\n        m_present_to_queue = ::vk::device_present_queue(\n          m_driver, m_swapchain_handler, present_queue_params);\n    }\n\n    void vk_swapchain::invalidate() {\n        destroy();\n        create();\n    }\n\n    uint32_t vk_swapchain::select_images_size(\n      const VkSurfaceCapabilitiesKHR&amp; p_surface_capabilities) {\n        uint32_t requested_images = p_surface_capabilities.minImageCount + 1;\n\n        uint32_t final_image_count = 0;\n\n        if ((p_surface_capabilities.maxImageCount &gt; 0) and\n            (requested_images &gt; p_surface_capabilities.maxImageCount)) {\n            final_image_count = p_surface_capabilities.maxImageCount;\n        }\n        else {\n            final_image_count = requested_images;\n        }\n\n        return final_image_count;\n    }\n\n    uint32_t vk_swapchain::read_acquired_image() {\n        m_present_to_queue.wait_idle();\n\n        // uint32_t frame_idx = m_present_to_queue.acquired_frame();\n        uint32_t frame_idx = m_present_to_queue.acquire_next_image();\n        if (m_present_to_queue.out_of_date()) {\n            invalidate();\n            m_present_to_queue.out_of_date(false);\n            frame_idx = m_present_to_queue.acquire_next_image();\n        }\n\n        return frame_idx;\n    }\n\n    void vk_swapchain::present(const uint32_t&amp; p_current_frame) {\n        m_present_to_queue.present_frame(p_current_frame);\n        if (m_present_to_queue.out_of_date()) {\n            invalidate();\n            m_present_to_queue.out_of_date(false);\n        }\n    }\n\n    void vk_swapchain::submit(std::span&lt;const VkCommandBuffer&gt; p_commands) {\n        // m_present_to_queue.submit_immediate_async(p_command);\n        m_present_to_queue.submit_async(p_commands);\n    }\n\n    void vk_swapchain::destroy() {\n        vkDeviceWaitIdle(m_driver);\n\n        for (size_t i = 0; i &lt; m_swapchain_framebuffers.size(); i++) {\n            m_swapchain_framebuffers[i].destroy();\n        }\n\n        m_final_renderpass.destroy();\n\n        m_present_to_queue.destroy();\n\n        for (size_t i = 0; i &lt; m_swapchain_command_buffers.size(); i++) {\n            m_swapchain_command_buffers[i].destroy();\n        }\n\n        for (uint32_t i = 0; i &lt; m_swapchain_depth_images.size(); i++) {\n            m_swapchain_depth_images[i].destroy();\n        }\n\n        for (uint32_t i = 0; i &lt; m_swapchain_images.size(); i++) {\n            m_swapchain_images[i].destroy();\n        }\n\n        vkDestroySwapchainKHR(m_driver, m_swapchain_handler, nullptr);\n    }\n};\n</code></pre>"},{"location":"References/vk__window_8cpp/","title":"File vk_window.cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_window.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/vulkan-cpp/vulkan-imports.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_window.hpp&gt;</code></li> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/utilities.hpp&gt;</code></li> </ul>"},{"location":"References/vk__window_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/vulkan-cpp/vk_window.cpp</code></p>"},{"location":"References/vk__window_8cpp_source/","title":"File vk_window.cpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan-cpp &gt; vk_window.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;drivers/vulkan-cpp/vulkan-imports.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_window.hpp&gt;\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;\n#include &lt;drivers/vulkan-cpp/utilities.hpp&gt;\n\nnamespace atlas::vk {\n    vk_window* vk_window::s_instance = nullptr;\n    vk_window::vk_window(const window_settings&amp; p_settings)\n      : m_settings(p_settings) {\n\n        if (!glfwVulkanSupported()) {\n            console_log_warn(\"GLFW: Vulkan is not supported!\");\n            return;\n        }\n\n        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);\n        glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);\n\n        m_instance_handler = vk_context::handler();\n\n        m_window_handler = glfwCreateWindow((int)p_settings.width,\n                                            (int)p_settings.height,\n                                            p_settings.name.c_str(),\n                                            nullptr,\n                                            nullptr);\n\n        glfwMakeContextCurrent(m_window_handler);\n\n        vk_check(\n          glfwCreateWindowSurface(\n            m_instance_handler, m_window_handler, nullptr, &amp;m_window_surface),\n          \"glfwCreateWindowSurface\");\n\n        center_window();\n\n        m_swapchain = vk_swapchain(m_window_surface, m_settings);\n\n        vk_context::submit_resource_free([this]() {\n            console_log_fatal(\"vk_window submit freed resources!!!\");\n            m_swapchain.destroy();\n        });\n\n        glfwSetWindowUserPointer(m_window_handler, this);\n\n        s_instance = this;\n    }\n\n    vk_window::~vk_window() {\n        vkDestroySurfaceKHR(m_instance_handler, m_window_surface, nullptr);\n        vkDestroyInstance(m_instance_handler, nullptr);\n        glfwDestroyWindow(m_window_handler);\n    }\n\n    void vk_window::center_window() {\n        GLFWmonitor* monitor = glfwGetPrimaryMonitor();\n        const GLFWvidmode* mode = glfwGetVideoMode(monitor);\n        uint32_t width = (mode-&gt;width / 2) - (m_settings.width / 2);\n        uint32_t height = (mode-&gt;height / 2) - (m_settings.height / 2);\n        glfwSetWindowPos(m_window_handler, (int)width, (int)height);\n    }\n\n    void vk_window::presentation_process(const uint32_t&amp; p_current_frame) {\n        m_swapchain.present(p_current_frame);\n    }\n\n    window_settings vk_window::settings() const {\n        return m_swapchain.settings();\n    }\n\n    uint32_t vk_window::read_acquired_next_frame() {\n        return m_swapchain.read_acquired_image();\n    }\n\n    GLFWwindow* vk_window::native_window() const {\n        return m_window_handler;\n    }\n};\n</code></pre>"},{"location":"References/graphics__context_8cpp/","title":"File graphics_context.cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; graphics_context.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/graphics_context.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;</code></li> <li><code>#include &lt;core/application.hpp&gt;</code></li> </ul>"},{"location":"References/graphics__context_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/graphics_context.cpp</code></p>"},{"location":"References/graphics__context_8cpp_source/","title":"File graphics_context.cpp","text":"<p>File List &gt; atlas &gt; drivers &gt; graphics_context.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;drivers/graphics_context.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_context.hpp&gt;\n#include &lt;core/application.hpp&gt;\n\nnamespace atlas {\n    ref&lt;graphics_context&gt; initialize_context(const std::string&amp; p_tag) {\n        switch (application::current_api()) {\n            case api::vulkan:\n                return create_ref&lt;vk::vk_context&gt;(p_tag);\n            default:\n                return nullptr;\n        }\n    }\n};\n</code></pre>"},{"location":"References/render__context_8cpp/","title":"File render_context.cpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; render_context.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/renderer_context.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan-cpp/vk_renderer.hpp&gt;</code></li> <li><code>#include &lt;core/application.hpp&gt;</code></li> </ul>"},{"location":"References/render__context_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/drivers/render_context.cpp</code></p>"},{"location":"References/render__context_8cpp_source/","title":"File render_context.cpp","text":"<p>File List &gt; atlas &gt; drivers &gt; render_context.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;drivers/renderer_context.hpp&gt;\n#include &lt;drivers/vulkan-cpp/vk_renderer.hpp&gt;\n#include &lt;core/application.hpp&gt;\n\nnamespace atlas {\n\n    ref&lt;render_context&gt; initialize_renderer(\n      const window_settings&amp; p_window_extent,\n      uint32_t p_image_size,\n      const std::string&amp; p_tag) {\n        switch (application::current_api()) {\n            case api::vulkan:\n                return create_ref&lt;vk::vk_renderer&gt;(\n                  p_window_extent, p_image_size, p_tag);\n            default:\n                return nullptr;\n        }\n    }\n};\n</code></pre>"},{"location":"References/dir_9a62c5ba85569e7099ed16d4b534a85a/","title":"Dir TheAtlasEngine/src/atlas/physics","text":"<p>FileList &gt; atlas &gt; physics</p>"},{"location":"References/dir_9a62c5ba85569e7099ed16d4b534a85a/#files","title":"Files","text":"Type Name file physics_context.cpp file physics_engine.cpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/physics/</code></p>"},{"location":"References/physics__context_8cpp/","title":"File physics_context.cpp","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_context.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;Jolt/Jolt.h&gt;</code></li> <li><code>#include &lt;physics/physics_context.hpp&gt;</code></li> <li><code>#include &lt;drivers/jolt-cpp/jolt_context.hpp&gt;</code></li> <li><code>#include &lt;core/event/event_bus.hpp&gt;</code></li> </ul>"},{"location":"References/physics__context_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/physics/physics_context.cpp</code></p>"},{"location":"References/physics__context_8cpp_source/","title":"File physics_context.cpp","text":"<p>File List &gt; atlas &gt; physics &gt; physics_context.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;type_traits&gt;\n#include &lt;Jolt/Jolt.h&gt;\n#include &lt;physics/physics_context.hpp&gt;\n#include &lt;drivers/jolt-cpp/jolt_context.hpp&gt;\n#include &lt;core/event/event_bus.hpp&gt;\n\nnamespace atlas::physics {\n\n    ref&lt;physics_context&gt; initialize_physics_context(\n      const jolt_settings&amp; p_settings,\n      event::event_bus&amp; p_bus) {\n        return create_ref&lt;jolt_context&gt;(p_settings, p_bus);\n    }\n\n}\n</code></pre>"},{"location":"References/physics__engine_8cpp/","title":"File physics_engine.cpp","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_engine.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;physics/physics_engine.hpp&gt;</code></li> <li><code>#include &lt;drivers/jolt-cpp/types.hpp&gt;</code></li> <li><code>#include &lt;drivers/jolt-cpp/jolt-imports.hpp&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Body/BodyLockMulti.h&gt;</code></li> <li><code>#include &lt;core/application.hpp&gt;</code></li> <li><code>#include &lt;flecs.h&gt;</code></li> </ul>"},{"location":"References/physics__engine_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/physics/physics_engine.cpp</code></p>"},{"location":"References/physics__engine_8cpp_source/","title":"File physics_engine.cpp","text":"<p>File List &gt; atlas &gt; physics &gt; physics_engine.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;physics/physics_engine.hpp&gt;\n#include &lt;drivers/jolt-cpp/types.hpp&gt;\n#include &lt;drivers/jolt-cpp/jolt-imports.hpp&gt;\n#include &lt;Jolt/Physics/Body/BodyLockMulti.h&gt;\n#include &lt;core/application.hpp&gt;\n#include &lt;flecs.h&gt;\n\nnamespace atlas::physics {\n\n    physics_engine::physics_engine(const jolt_settings&amp; p_settings,\n                                   flecs::world&amp; p_registry,\n                                   event::event_bus&amp; p_bus)\n      : m_registry(&amp;p_registry)\n      , m_bus(&amp;p_bus) {\n        m_physics_context = initialize_physics_context(p_settings, *m_bus);\n        // This may change, but for now we want to ensure that we only want to\n        // create a single physics body with a specific collider Rather then\n        // having multiple colliders be associated to a single physics body\n        // itself.\n        m_query_box_collider =\n          m_registry-&gt;query_builder&lt;transform, physics_body, box_collider&gt;()\n            .without&lt;sphere_collider, capsule_collider&gt;()\n            .build();\n        m_query_sphere_collider =\n          m_registry-&gt;query_builder&lt;transform, physics_body, sphere_collider&gt;()\n            .without&lt;box_collider, capsule_collider&gt;()\n            .build();\n        m_query_capsule_collider =\n          m_registry-&gt;query_builder&lt;transform, physics_body, capsule_collider&gt;()\n            .without&lt;sphere_collider, box_collider&gt;()\n            .build();\n\n        m_physics_bodies = m_registry-&gt;query_builder&lt;physics_body&gt;().build();\n    };\n\n    void physics_engine::start() {\n        // At the start of every simulation we create physics bodies to run\n        // simulation on those physics bodies with the specific colliders\n        // associated with them\n        m_query_box_collider.each([this](flecs::entity p_entity,\n                                         transform&amp; p_transform,\n                                         physics_body&amp; p_body,\n                                         box_collider&amp; p_collider) {\n            m_physics_context-&gt;add_box_collider(\n              p_entity.id(), &amp;p_transform, &amp;p_body, &amp;p_collider);\n        });\n\n        m_query_sphere_collider.each([this](flecs::entity p_entity,\n                                            transform&amp; p_transform,\n                                            physics_body&amp; p_body,\n                                            sphere_collider&amp; p_collider) {\n            m_physics_context-&gt;add_sphere_collider(\n              p_entity.id(), &amp;p_transform, &amp;p_body, &amp;p_collider);\n        });\n\n        m_query_capsule_collider.each([this](flecs::entity p_entity,\n                                             transform&amp; p_transform,\n                                             physics_body&amp; p_body,\n                                             capsule_collider&amp; p_collider) {\n            m_physics_context-&gt;add_capsule_collider(\n              p_entity.id(), &amp;p_transform, &amp;p_body, &amp;p_collider);\n        });\n        m_physics_context-&gt;prepare();\n    }\n\n    void physics_engine::update(float p_delta_time) {\n        using namespace JPH;\n\n        m_physics_bodies.each(\n          [this](flecs::entity p_entity, physics_body&amp; p_body) {\n              m_physics_context-&gt;set_force_and_torque(\n                p_entity.id(), p_body.force, p_body.torque);\n              m_physics_context-&gt;set_linear_velocity(p_entity.id(),\n                                                     p_body.linear_velocity);\n              m_physics_context-&gt;set_angular_velocity(p_entity.id(),\n                                                      p_body.angular_velocity);\n              m_physics_context-&gt;set_impulse(p_entity.id(), p_body.impulse);\n          });\n        // This will ensure all physics bodies with which colliders they are\n        // associated with are update with the simulation, and their parameters\n        // are modified\n        m_physics_context-&gt;update(p_delta_time);\n\n        m_query_box_collider.each([&amp;](flecs::entity p_entity,\n                                      transform&amp; p_transform,\n                                      physics_body&amp; p_body,\n                                      box_collider&amp;) {\n            // updating transform\n            transform t = m_physics_context-&gt;read_transform(p_entity.id());\n            p_transform.position = t.position;\n            p_transform.rotation = t.rotation;\n            p_transform.quaternion = t.quaternion;\n\n            // physics bodies parameters\n            auto body = m_physics_context-&gt;read_physics_body(p_entity.id());\n            p_body.linear_damping = body.linear_damping;\n            p_body.linear_velocity = body.linear_velocity;\n            p_body.angular_velocity = body.angular_velocity;\n            p_body.gravity_factor = body.gravity_factor;\n            p_body.center_mass_position = body.center_mass_position;\n            p_body.friction = body.friction;\n            p_body.restitution = body.restitution;\n            p_body.angular_velocity = body.angular_velocity;\n            p_body.linear_velocity = body.linear_velocity;\n        });\n\n        // updating sphere collider\n        m_query_sphere_collider.each([this](flecs::entity p_entity,\n                                            transform&amp; p_transform,\n                                            physics_body&amp; p_body,\n                                            sphere_collider&amp;) {\n            // updating transform\n            transform t = m_physics_context-&gt;read_transform(p_entity.id());\n            p_transform.position = t.position;\n            p_transform.rotation = t.rotation;\n            p_transform.quaternion = t.quaternion;\n\n            // updating physics body\n            auto body = m_physics_context-&gt;read_physics_body(p_entity.id());\n            p_body.linear_damping = body.linear_damping;\n            p_body.linear_velocity = body.linear_velocity;\n            p_body.angular_velocity = body.angular_velocity;\n            p_body.gravity_factor = body.gravity_factor;\n            p_body.center_mass_position = body.center_mass_position;\n            p_body.friction = body.friction;\n            p_body.restitution = body.restitution;\n        });\n\n        // updating capsule collider\n        m_query_capsule_collider.each([this](flecs::entity p_entity,\n                                             transform&amp; p_transform,\n                                             physics_body&amp; p_body,\n                                             capsule_collider&amp;) {\n            transform t = m_physics_context-&gt;read_transform(p_entity.id());\n            p_transform.position = t.position;\n            p_transform.rotation = t.rotation;\n            p_transform.quaternion = t.quaternion;\n\n            auto body = m_physics_context-&gt;read_physics_body(p_entity.id());\n            p_body.linear_damping = body.linear_damping;\n            p_body.linear_velocity = body.linear_velocity;\n            p_body.angular_velocity = body.angular_velocity;\n            p_body.gravity_factor = body.gravity_factor;\n            p_body.center_mass_position = body.center_mass_position;\n            p_body.friction = body.friction;\n            p_body.restitution = body.restitution;\n        });\n    }\n\n    void physics_engine::stop() {\n        m_physics_context-&gt;destroy();\n    }\n\n}\n</code></pre>"},{"location":"References/dir_fa8a80cc4ed6793f178a8a05028bb97a/","title":"Dir TheAtlasEngine/src/atlas/renderer","text":"<p>FileList &gt; atlas &gt; renderer</p>"},{"location":"References/dir_fa8a80cc4ed6793f178a8a05028bb97a/#files","title":"Files","text":"Type Name file renderer.cpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/renderer/</code></p>"},{"location":"References/renderer_8cpp/","title":"File renderer.cpp","text":"<p>FileList &gt; atlas &gt; renderer &gt; renderer.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;renderer/renderer.hpp&gt;</code></li> <li><code>#include &lt;drivers/renderer_context.hpp&gt;</code></li> </ul>"},{"location":"References/renderer_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/src/atlas/renderer/renderer.cpp</code></p>"},{"location":"References/renderer_8cpp_source/","title":"File renderer.cpp","text":"<p>File List &gt; atlas &gt; renderer &gt; renderer.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;renderer/renderer.hpp&gt;\n#include &lt;drivers/renderer_context.hpp&gt;\n\nnamespace atlas {\n\n    renderer::renderer(const window_settings&amp; p_window_extent,\n                       uint32_t p_image_size,\n                       const std::string&amp; p_tag) {\n        m_render_context =\n          initialize_renderer(p_window_extent, p_image_size, p_tag);\n    }\n\n    void renderer::preload(const VkRenderPass&amp; p_renderpass) {\n        m_render_context-&gt;preload(p_renderpass);\n    }\n\n    void renderer::begin(const ::vk::command_buffer&amp; p_current,\n                         const window_settings&amp; p_settings,\n                         const VkRenderPass&amp; p_renderpass,\n                         const VkFramebuffer&amp; p_framebuffer,\n                         const glm::mat4&amp; p_proj_view) {\n        return m_render_context-&gt;begin_frame(\n          p_current, p_settings, p_renderpass, p_framebuffer, p_proj_view);\n    }\n\n    void renderer::end() {\n        return m_render_context-&gt;end_frame();\n    }\n\n    void renderer::set_background_color(const std::array&lt;float, 4&gt;&amp; p_color) {\n        m_render_context-&gt;set_background_color(p_color);\n    }\n\n    void renderer::current_scene(ref&lt;scene&gt; p_scene) {\n        m_render_context-&gt;current_scene_context(std::move(p_scene));\n    }\n};\n</code></pre>"},{"location":"References/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace atlas <ul> <li>namespace detail </li> <li>namespace event </li> <li>namespace filesystem </li> <li>namespace jolt </li> <li>namespace math </li> <li>namespace physics </li> <li>namespace ui </li> <li>namespace vk </li> </ul> </li> </ul>"},{"location":"References/classes/","title":"Class Index","text":""},{"location":"References/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p>"},{"location":"References/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"References/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"References/class_members/","title":"Class Members","text":"<p>Nothing related to Class Members found.</p>"},{"location":"References/class_member_functions/","title":"Class Member Functions","text":"<p>Nothing related to Class Member Functions found.</p>"},{"location":"References/class_member_variables/","title":"Class Member Variables","text":"<p>Nothing related to Class Member Variables found.</p>"},{"location":"References/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"References/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"References/namespace_members/","title":"Namespace Members","text":""},{"location":"References/namespace_members/#a","title":"a","text":"<ul> <li>assert_failed_impl (atlas::physics)</li> </ul>"},{"location":"References/namespace_members/#b","title":"b","text":"<ul> <li>button_id (atlas::event)</li> <li>backward (atlas::math)</li> <li>begin_popup_context_window (atlas::ui)</li> <li>button_open_file_dialog (atlas::ui)</li> </ul>"},{"location":"References/namespace_members/#c","title":"c","text":"<ul> <li>controller_id (atlas::event)</li> <li>cursor_position (atlas::event)</li> <li>compile_binary_shader_source (atlas::vk)</li> <li>compile_source_from_file (atlas::vk)</li> <li>create_window (atlas)</li> </ul>"},{"location":"References/namespace_members/#d","title":"d","text":"<ul> <li>down (atlas::math)</li> <li>dockspace_window (atlas::ui)</li> <li>draw_float (atlas::ui)</li> <li>draw_input_text (atlas::ui)</li> <li>draw_text (atlas::ui)</li> <li>draw_vec3 (atlas::ui)</li> <li>draw_vec4 (atlas::ui)</li> <li>deserialize_entity (atlas)</li> </ul>"},{"location":"References/namespace_members/#f","title":"f","text":"<ul> <li>forward (atlas::math)</li> <li>from_quat (atlas)</li> </ul>"},{"location":"References/namespace_members/#g","title":"g","text":"<ul> <li>get_joystic_axis (atlas::event)</li> <li>g_current_pattern_for_logs (atlas)</li> <li>g_graphics_backend_api (atlas)</li> </ul>"},{"location":"References/namespace_members/#i","title":"i","text":"<ul> <li>invoke_defer_update (atlas::detail)</li> <li>invoke_on_update (atlas::detail)</li> <li>invoke_physics_update (atlas::detail)</li> <li>invoke_start (atlas::detail)</li> <li>invoke_ui_update (atlas::detail)</li> <li>is_joystic_present (atlas::event)</li> <li>is_joystick_button_pressed (atlas::event)</li> <li>is_joystick_button_released (atlas::event)</li> <li>is_joystick_guid (atlas::event)</li> <li>is_key_pressed (atlas::event)</li> <li>is_key_released (atlas::event)</li> <li>is_mouse_pressed (atlas::event)</li> <li>is_mouse_released (atlas::event)</li> <li>identity (atlas::math)</li> <li>initialize_physics_context (atlas::physics)</li> <li>im_gui_layout_color_modification (atlas::vk)</li> <li>initialize_instance_extensions (atlas::vk)</li> <li>initialize_context (atlas)</li> <li>initialize_renderer (atlas)</li> </ul>"},{"location":"References/namespace_members/#l","title":"l","text":"<ul> <li>load_from_file_dialog (atlas::filesystem)</li> <li>left (atlas::math)</li> </ul>"},{"location":"References/namespace_members/#o","title":"o","text":"<ul> <li>ones (atlas::math)</li> <li>operator&lt;&lt; (atlas)</li> </ul>"},{"location":"References/namespace_members/#p","title":"p","text":"<ul> <li>poll_defer_update (atlas::detail)</li> <li>poll_physics_update (atlas::detail)</li> <li>poll_start (atlas::detail)</li> <li>poll_ui_update (atlas::detail)</li> <li>poll_update (atlas::detail)</li> </ul>"},{"location":"References/namespace_members/#r","title":"r","text":"<ul> <li>remove_defer_update (atlas::detail)</li> <li>remove_physics_update (atlas::detail)</li> <li>remove_start (atlas::detail)</li> <li>remove_ui_update (atlas::detail)</li> <li>remove_update (atlas::detail)</li> <li>right (atlas::math)</li> <li>read_raw_spirv (atlas::vk)</li> <li>read_shader_source_code (atlas::vk)</li> </ul>"},{"location":"References/namespace_members/#s","title":"s","text":"<ul> <li>s_defer_update (atlas::detail)</li> <li>s_physica_update (atlas::detail)</li> <li>s_start (atlas::detail)</li> <li>s_ui_update (atlas::detail)</li> <li>s_update (atlas::detail)</li> <li>s_controllers (atlas::event)</li> <li>save_to_file (atlas::filesystem)</li> <li>search_depth_format (atlas::vk)</li> <li>search_supported_depth_format (atlas::vk)</li> <li>serialize_entity (atlas)</li> </ul>"},{"location":"References/namespace_members/#t","title":"t","text":"<ul> <li>to_quat (atlas::jolt, atlas)</li> <li>to_rvec3 (atlas::jolt)</li> <li>to_vec3 (atlas::jolt, atlas)</li> <li>trace_impl (atlas::physics)</li> <li>to_bytes (atlas::vk)</li> <li>to_quathp (atlas)</li> <li>to_vec4 (atlas)</li> </ul>"},{"location":"References/namespace_members/#u","title":"u","text":"<ul> <li>update_events (atlas::event)</li> <li>up (atlas::math)</li> </ul>"},{"location":"References/namespace_members/#v","title":"v","text":"<ul> <li>vk_check (atlas::vk)</li> </ul>"},{"location":"References/namespace_members/#w","title":"w","text":"<ul> <li>wait_for_events (atlas::event)</li> </ul>"},{"location":"References/namespace_members/#z","title":"z","text":"<ul> <li>zeroes (atlas::math)</li> </ul>"},{"location":"References/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"References/namespace_member_functions/#a","title":"a","text":"<ul> <li>assert_failed_impl (atlas::physics)</li> </ul>"},{"location":"References/namespace_member_functions/#b","title":"b","text":"<ul> <li>backward (atlas::math)</li> <li>begin_popup_context_window (atlas::ui)</li> <li>button_open_file_dialog (atlas::ui)</li> </ul>"},{"location":"References/namespace_member_functions/#c","title":"c","text":"<ul> <li>cursor_position (atlas::event)</li> <li>compile_binary_shader_source (atlas::vk)</li> <li>compile_source_from_file (atlas::vk)</li> <li>create_window (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#d","title":"d","text":"<ul> <li>down (atlas::math)</li> <li>dockspace_window (atlas::ui)</li> <li>draw_float (atlas::ui)</li> <li>draw_input_text (atlas::ui)</li> <li>draw_text (atlas::ui)</li> <li>draw_vec3 (atlas::ui)</li> <li>draw_vec4 (atlas::ui)</li> <li>deserialize_entity (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#f","title":"f","text":"<ul> <li>forward (atlas::math)</li> <li>from_quat (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#g","title":"g","text":"<ul> <li>get_joystic_axis (atlas::event)</li> </ul>"},{"location":"References/namespace_member_functions/#i","title":"i","text":"<ul> <li>invoke_defer_update (atlas::detail)</li> <li>invoke_on_update (atlas::detail)</li> <li>invoke_physics_update (atlas::detail)</li> <li>invoke_start (atlas::detail)</li> <li>invoke_ui_update (atlas::detail)</li> <li>is_joystic_present (atlas::event)</li> <li>is_joystick_button_pressed (atlas::event)</li> <li>is_joystick_button_released (atlas::event)</li> <li>is_joystick_guid (atlas::event)</li> <li>is_key_pressed (atlas::event)</li> <li>is_key_released (atlas::event)</li> <li>is_mouse_pressed (atlas::event)</li> <li>is_mouse_released (atlas::event)</li> <li>identity (atlas::math)</li> <li>initialize_physics_context (atlas::physics)</li> <li>im_gui_layout_color_modification (atlas::vk)</li> <li>initialize_instance_extensions (atlas::vk)</li> <li>initialize_context (atlas)</li> <li>initialize_renderer (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#l","title":"l","text":"<ul> <li>load_from_file_dialog (atlas::filesystem)</li> <li>left (atlas::math)</li> </ul>"},{"location":"References/namespace_member_functions/#o","title":"o","text":"<ul> <li>ones (atlas::math)</li> <li>operator&lt;&lt; (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#p","title":"p","text":"<ul> <li>poll_defer_update (atlas::detail)</li> <li>poll_physics_update (atlas::detail)</li> <li>poll_start (atlas::detail)</li> <li>poll_ui_update (atlas::detail)</li> <li>poll_update (atlas::detail)</li> </ul>"},{"location":"References/namespace_member_functions/#r","title":"r","text":"<ul> <li>remove_defer_update (atlas::detail)</li> <li>remove_physics_update (atlas::detail)</li> <li>remove_start (atlas::detail)</li> <li>remove_ui_update (atlas::detail)</li> <li>remove_update (atlas::detail)</li> <li>right (atlas::math)</li> <li>read_raw_spirv (atlas::vk)</li> <li>read_shader_source_code (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_functions/#s","title":"s","text":"<ul> <li>save_to_file (atlas::filesystem)</li> <li>search_depth_format (atlas::vk)</li> <li>search_supported_depth_format (atlas::vk)</li> <li>serialize_entity (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#t","title":"t","text":"<ul> <li>to_quat (atlas::jolt, atlas)</li> <li>to_rvec3 (atlas::jolt)</li> <li>to_vec3 (atlas::jolt, atlas)</li> <li>trace_impl (atlas::physics)</li> <li>to_bytes (atlas::vk)</li> <li>to_quathp (atlas)</li> <li>to_vec4 (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#u","title":"u","text":"<ul> <li>update_events (atlas::event)</li> <li>up (atlas::math)</li> </ul>"},{"location":"References/namespace_member_functions/#v","title":"v","text":"<ul> <li>vk_check (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_functions/#w","title":"w","text":"<ul> <li>wait_for_events (atlas::event)</li> </ul>"},{"location":"References/namespace_member_functions/#z","title":"z","text":"<ul> <li>zeroes (atlas::math)</li> </ul>"},{"location":"References/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"References/namespace_member_variables/#g","title":"g","text":"<ul> <li>g_current_pattern_for_logs (atlas)</li> <li>g_graphics_backend_api (atlas)</li> </ul>"},{"location":"References/namespace_member_variables/#s","title":"s","text":"<ul> <li>s_defer_update (atlas::detail)</li> <li>s_physica_update (atlas::detail)</li> <li>s_start (atlas::detail)</li> <li>s_ui_update (atlas::detail)</li> <li>s_update (atlas::detail)</li> <li>s_controllers (atlas::event)</li> </ul>"},{"location":"References/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"References/namespace_member_typedefs/#b","title":"b","text":"<ul> <li>button_id (atlas::event)</li> </ul>"},{"location":"References/namespace_member_typedefs/#c","title":"c","text":"<ul> <li>controller_id (atlas::event)</li> </ul>"},{"location":"References/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"References/functions/","title":"Functions","text":""},{"location":"References/functions/#m","title":"m","text":"<ul> <li>main (main.cpp)</li> </ul>"},{"location":"References/functions/#w","title":"w","text":"<ul> <li>win_main (main.cpp, win32.cpp)</li> </ul>"},{"location":"References/macros/","title":"Macros","text":""},{"location":"References/macros/#s","title":"s","text":"<ul> <li>STB_IMAGE_IMPLEMENTATION (stb_image.cpp, mesh.cpp)</li> <li>STB_IMAGE_WRITE_IMPLEMENTATION (mesh.cpp)</li> </ul>"},{"location":"References/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"References/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}