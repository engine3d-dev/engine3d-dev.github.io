{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udfe0 Home","text":"Welcome to Atlas's Home Page"},{"location":"#overview","title":"Overview","text":"<p>TheAtlasEngine is a cross-platform 3D game engine. That strives to be powerful with no restrictions to the user. Allowing to be used for educational, creative, and commerical purpose games.</p>"},{"location":"#the-basics","title":"The Basics","text":"<p>TheAtlasEngine is a 3D game engine that is comprised of variety of different systems. The engine aims to have the ability to make games and build cool projects with. The engine is built fully in C++. With an inetractive application that enables users to think of a different and creative way to making games.</p>"},{"location":"about/","title":"About TheAtlasEngine","text":"<p>Still in progress \ud83d\udea7</p> <p>Atlas started as a 2D interactive game engine that was built just for fun and to have a fun way of seeing how game engines are made. Using them to build fun games.</p> <p>Then Aaron (creator) of the project decided to on making this project now focused in 3D. Where it gives students the opportunities to work on a cool project. Then being able to seeing some great results and using them during game jam events.</p> <p>One of the most satisfying factors of building this project is being able to use them during game jams and submitting games developed by this engine. That is the feeling he wants to share with other students.</p>"},{"location":"api/","title":"TheAtlasEngine API Documentation","text":"<p>Welcome to TheAtlasEngine documentaiton</p> <p>This section provides a detailed documentation for classes, files, namespace, and other API's from the atlas project.</p>"},{"location":"api/#contents","title":"Contents","text":"<p>Here are the main entry points to the generated documentation:</p> <ul> <li>Annotated Index: A comprehensive, alphabetically sorted list of all documented entities.</li> <li>Files: Browse documentation by source file.</li> <li>Namespaces: Explore the engine's structure through its namespaces.</li> <li>Classes: A direct list of all documented classes.</li> <li>Hierarchy: View the class inheritance hierarchy.</li> <li>Modules: Organized groups of related entities (if defined in Doxygen).</li> <li>Related Pages: Additional informational pages (if defined in Doxygen).</li> </ul>"},{"location":"api/#detailed-references","title":"Detailed References","text":"<p>Below is a detailed breakdown of individual components within the engine, organized by type.</p>"},{"location":"api/#classes-and-structs","title":"Classes and Structs","text":"<ul> <li>DescriptorSet</li> <li>DescriptorSetLayout</li> <li>DirectionalLightUbo</li> <li>Framebuffer</li> <li>Image</li> <li>ImageSampler</li> <li>ParallelUpdateManager</li> <li>Pipeline</li> <li>PointLightUbo</li> <li>SpotLightUbo</li> <li>UniformBuffer</li> <li>VulkanImGui</li> <li>application</li> <li>application_settings</li> <li>box_collider3d</li> <li>camera</li> <li>camera_ubo</li> <li>console_log_manager</li> <li>entity_t</li> <li>joystick_button</li> <li>joystick_info</li> <li>imgui_backend</li> <li>index_buffer</li> <li>interpolation</li> <li>light</li> <li>math_generic</li> <li>matrix2</li> <li>matrix3</li> <li>matrix4</li> <li>mesh</li> <li>JoltPhysicBody</li> <li>jolt_config</li> <li>jolt_settings</li> <li>physics_engine</li> <li>render_context</li> <li>renderer</li> <li>renderpass</li> <li>renderpass_properties</li> <li>rendertarget3d</li> <li>rigidbody3d</li> <li>scene_object</li> <li>scene_scope</li> <li>serializer</li> <li>shader</li> <li>swapchain</li> <li>system_registry</li> <li>tag</li> <li>thread</li> <li>timer</li> <li>transform</li> <li>vector2</li> <li>vector3</li> <li>vector3&lt; JPH::Vec3 &gt;</li> <li>vector4</li> <li>vertex</li> <li>vertex_buffer</li> <li>BufferTutorial</li> <li>VulkanDescriptorSets</li> <li>VulkanPipeline</li> <li>VulkanRenderPass</li> <li>VulkanUniformBuffer</li> <li>descriptor_pool</li> <li>descriptor_pool::builder</li> <li>descriptor_set_layout</li> <li>descriptor_set_layout::builder</li> <li>descriptor_writer</li> <li>shader_pipeline_config</li> <li>vk_context</li> <li>vk_driver</li> <li>vk_index_buffer</li> <li>vk_physical_driver</li> <li>vk_physical_driver::queue_family_indices</li> <li>vk_renderer</li> <li>vk_shader</li> <li>vk_swapchain</li> <li>vk_vertex_buffer</li> <li>vk_window</li> <li>window</li> <li>world_scope</li> <li>vk_swapchain::swapchain_depth_image</li> <li>vk_swapchain::swapchain_image</li> </ul>"},{"location":"api/#namespaces","title":"Namespaces","text":"<ul> <li>atlas::event</li> <li>atlas::filesystem</li> <li>atlas::physics</li> <li>atlas::sync_update</li> <li>atlas::ui</li> <li>atlas::vk</li> <li>std</li> </ul>"},{"location":"api/#files","title":"Files","text":"<ul> <li>event.hpp</li> <li>event.hpp Source</li> <li>joystick_codes.hpp</li> <li>joystick_codes.hpp Source</li> <li>key_codes.hpp</li> <li>key_codes.hpp Source</li> <li>mouse_codes.hpp</li> <li>mouse_codes.hpp Source</li> <li>file_dialog.hpp</li> <li>file_dialog.hpp Source</li> <li>mesh.hpp</li> <li>mesh.hpp Source</li> <li>stb_image.hpp</li> <li>stb_image.hpp Source</li> <li>math.hpp</li> <li>math.hpp Source</li> <li>core/math/types.hpp</li> <li>core/math/types.hpp Source</li> <li>components.hpp</li> <li>components.hpp Source</li> <li>entity.hpp</li> <li>entity.hpp Source</li> <li>scene.hpp</li> <li>scene.hpp Source</li> <li>scene_object.hpp</li> <li>scene_object.hpp Source</li> <li>world.hpp</li> <li>world.hpp Source</li> <li>serializer.hpp</li> <li>serializer.hpp Source</li> <li>system_registry.hpp</li> <li>system_registry.hpp Source</li> <li>core/threads/thread.hpp</li> <li>core/threads/thread.hpp Source</li> <li>widgets.hpp</li> <li>widgets.hpp Source</li> <li>global_update.hpp</li> <li>global_update.hpp Source</li> <li>parallel_update_manager.hpp</li> <li>parallel_update_manager.hpp Source</li> <li>sync_update.hpp</li> <li>sync_update.hpp Source</li> <li>thread_manager.hpp</li> <li>thread_manager.hpp Source</li> <li>update_handlers/timer.hpp</li> <li>update_handlers/timer.hpp Source</li> <li>hash.hpp</li> <li>hash.hpp Source</li> <li>api.hpp</li> <li>api.hpp Source</li> <li>application.hpp</li> <li>application.hpp Source</li> <li>core.hpp</li> <li>core.hpp Source</li> <li>engine_logger.hpp</li> <li>engine_logger.hpp Source</li> <li>timer.hpp</li> <li>timer.hpp Source</li> <li>window.hpp</li> <li>window.hpp Source</li> <li>imgui_backend.hpp</li> <li>imgui_backend.hpp Source</li> <li>vulkan_shader.hpp</li> <li>vulkan_shader.hpp Source</li> <li>vulkan_shader_pipeline_config.hpp</li> <li>vulkan_shader_pipeline_config.hpp Source</li> <li>buffer_tutorial.hpp</li> <li>buffer_tutorial.hpp Source</li> <li>descriptor_tutorial.hpp</li> <li>descriptor_tutorial.hpp Source</li> <li>drivers/vulkan/helper_functions.hpp</li> <li>drivers/vulkan/helper_functions.hpp Source</li> <li>drivers/vulkan/types.hpp</li> <li>drivers/vulkan/types.hpp Source</li> <li>utility.hpp</li> <li>utility.hpp Source</li> <li>vulkan-imports.hpp</li> <li>vulkan-imports.hpp Source</li> <li>vulkan_context.hpp</li> <li>vulkan_context.hpp Source</li> <li>vulkan_core.hpp</li> <li>vulkan_core.hpp Source</li> <li>vulkan_descriptors.hpp</li> <li>vulkan_descriptors.hpp Source</li> <li>vulkan_driver.hpp</li> <li>vulkan_driver.hpp Source</li> <li>vulkan_gpu.hpp</li> <li>vulkan_gpu.hpp Source</li> <li>vulkan_imgui.hpp</li> <li>vulkan_imgui.hpp Source</li> <li>vulkan_index_buffer.hpp</li> <li>vulkan_index_buffer.hpp Source</li> <li>vulkan_physical_driver.hpp</li> <li>vulkan_physical_driver.hpp Source</li> <li>vulkan_pipeline.hpp</li> <li>vulkan_pipeline.hpp Source</li> <li>vulkan_renderer.hpp</li> <li>vulkan_renderer.hpp Source</li> <li>vulkan_renderpass.hpp</li> <li>vulkan_renderpass.hpp Source</li> <li>vulkan_swapchain.hpp</li> <li>vulkan_swapchain.hpp Source</li> <li>vulkan_uniform_buffer.hpp</li> <li>vulkan_uniform_buffer.hpp Source</li> <li>vulkan_vertex_buffer.hpp</li> <li>vulkan_vertex_buffer.hpp Source</li> <li>vulkan_window.hpp</li> <li>vulkan_window.hpp Source</li> <li>descriptor_sets.hpp</li> <li>descriptor_sets.hpp Source</li> <li>frame_buffer.hpp</li> <li>frame_buffer.hpp Source</li> <li>image.hpp</li> <li>image.hpp Source</li> <li>index_buffer.hpp</li> <li>index_buffer.hpp Source</li> <li>pipeline.hpp</li> <li>pipeline.hpp Source</li> <li>render_pass.hpp</li> <li>render_pass.hpp Source</li> <li>renderer_backend.hpp</li> <li>renderer_backend.hpp Source</li> <li>shader.hpp</li> <li>shader.hpp Source</li> <li>swapchain.hpp</li> <li>swapchain.hpp Source</li> <li>uniform.hpp</li> <li>uniform.hpp Source</li> <li>uniform_buffer.hpp</li> <li>uniform_buffer.hpp Source</li> <li>vertex_buffer.hpp</li> <li>vertex_buffer.hpp Source</li> <li>physics/jolt-cpp/helper_functions.hpp</li> <li>physics/jolt-cpp/helper_functions.hpp Source</li> <li>jolt-imports.hpp</li> <li>jolt-imports.hpp Source</li> <li>jolt-cpp/jolt_api.hpp</li> <li>jolt-cpp/jolt_api.hpp Source</li> <li>jolt_body.hpp</li> <li>jolt_body.hpp Source</li> <li>jolt_config.hpp</li> <li>jolt_config.hpp Source</li> <li>jolt_settings.hpp</li> <li>jolt_settings.hpp Source</li> <li>physics_3d/jolt/jolt_api.hpp</li> <li>physics_3d/jolt/jolt_api.hpp Source</li> <li>jolt_physics_engine.hpp</li> <li>jolt_physics_engine.hpp Source</li> <li>physics_api.hpp</li> <li>physics_api.hpp Source</li> <li>physics_engine.hpp</li> <li>physics_engine.hpp Source</li> <li>physics/types.hpp</li> <li>physics/types.hpp Source</li> <li>renderer.hpp</li> <li>renderer.hpp Source</li> <li>thread_utils/thread.hpp</li> <li>thread_utils/thread.hpp Source</li> <li>thread_utils.hpp</li> <li>thread_utils.hpp Source</li> </ul>"},{"location":"api/#other-appendices","title":"Other Appendices","text":"<ul> <li>Class Members: A combined index of all class members.<ul> <li>Functions</li> <li>Variables</li> <li>Typedefs</li> <li>Enums</li> </ul> </li> <li>Namespace Members: A combined index of all namespace members.<ul> <li>Functions</li> <li>Variables</li> <li>Typedefs</li> <li>Enums</li> </ul> </li> <li>Global Functions</li> <li>Global Macros</li> <li>Global Variables</li> <li>Source Code Links (if generated)</li> </ul>"},{"location":"getting_started/","title":"\ud83d\udcda Getting Started","text":""},{"location":"getting_started/#prerequisites","title":"\ud83d\udca5 Prerequisites","text":"<p>These are needed before working to get TheAtlasEngine building successfully on your platform.</p> <ul> <li><code>python</code>: 3.12 or above</li> <li><code>conan</code>: 2.10.0 or above</li> <li><code>llvm</code>: 17 or above</li> <li><code>CMake</code> Build tool for the project</li> <li><code>git</code>: Version control</li> </ul> WindowsUbuntu 20.0+MacOS X <p>Info</p> <p>Needs to install Visual Studio's installer before using the <code>winget</code> command</p> <p>Visual studio is required only on Windows for getting C++ to work</p> <p>Run this <code>winget</code> command to setup C++ with Visual Studio installer in powershell (in admin mode)</p> <pre><code>winget install Microsoft.VisualStudio.2022.BuildTools --override \"--add Microsoft.VisualStudio.Workload.VCTools --includeRecommended -p --installWhileDownloading\"\n</code></pre> <p>It is recommended to use Choco for an easy installation process on Windows.</p> <p>To install <code>choco</code>, open powershell with admin access and run the following command in your terminal (powershell must be admin):</p> <pre><code>Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n</code></pre> <p>Tip</p> <p>If <code>choco</code> command does not work after running this script try closing and reopening powershell again. When <code>choco</code> prompts you to run install scripts from the commands below, enter <code>all</code> so it can install everything.</p> <p>Install <code>git</code> (powershell must be admin): <pre><code>choco install git\n</code></pre></p> <p>Install <code>python</code> (powershell must be admin): <pre><code>choco install python --version=3.12.0\n</code></pre></p> <p>Install <code>llvm</code> (powershell must be admin):</p> <p>Error</p> <p>If you get this error make sure that your environment variable is set to LLVM's clang.exe and clang++.exe filepath.</p> <p>While also making sure </p> <pre><code>CMake Error at CMakeLists.txt:2 (project):\nThe CMAKE_CXX_COMPILER:\n\n    C:/Program Files/LLVM/bin/clang++.exe\n\nis not a full path to an existing compiler tool.\n</code></pre> <pre><code>choco install llvm\n</code></pre> <p>Install <code>conan</code> (powershell must be admin) <pre><code>pip install \"conan&gt;=2.10.2\"\n</code></pre></p> <p>Install cmake and make</p> <p>Error</p> <p>you can get this error if you DO NOT have 'make' installed via choco</p> <pre><code>CMake Error: CMake was unable to find a build program corresponding to \"Unix Makefiles\".  CMAKE_MAKE_PROGRAM is not set.  You probably need to select a different build tool.\n</code></pre> <p>Error</p> <p>you can get this error if you DO NOT have 'mingw' installed via choco</p> <p>CMake Error: CMake was unable to find a build program corresponding to \"MinGW Makefiles\".  CMAKE_MAKE_PROGRAM is not set.  You probably need to select a different build tool.</p> <pre><code>choco install make cmake\n</code></pre> <p>Info</p> <p>mingw is installed because we need <code>mingw32-make.exe</code> as dependencies will default to using \"MinGW Makefiles\" generator specified. which means that their CMake will look for <code>mingw32-make.exe</code> specific make executables instead of <code>make.exe</code></p> <p>Install mingw <pre><code>choco install mingw\n</code></pre></p> <p>Info</p> <p>Using this <code>winget</code> command will install Vulkan's installer, set it up for you, and set the environment path variable.</p> <p>Installing Vulkan's installer from the terminal in powershell. (in admin mode) <pre><code>winget install --id=KhronosGroup.VulkanSDK -e\n</code></pre></p> <p>Tip</p> <p>Once you have completely finish installing. DONT FORGET to refresh your powershell before building the TheAtlasEngine project.</p> <p>Install wget if it isn't already on your system</p> <p><code>sudo apt-get install wget</code></p> <p>Install the latest version of <code>llvm</code></p> <pre><code>wget https://apt.llvm.org/llvm.sh\nchmod +x llvm.sh\nsudo ./llvm.sh\n</code></pre> <p>Install LLVM's C+ standard library (this will use the llvm apt repos)</p> <pre><code>sudo apt install libc++-17-dev libc++abi-17-dev\n</code></pre> <p>Installing Linux Prerequisites</p> <pre><code>sudo apt install -y lsb-release wget software-properties-common gnupg libgtk2.0-dev libgl1-mesa-dev\nsudo apt-get install -y libx11-dev libx11-xcb-dev libfontenc-dev libice-dev libsm-dev libxau-dev libxaw7-dev libxt-dev libxtst-dev libxrender-dev libxrandr-dev libxi-dev\nsudo apt install -y software-properties-common\nsudo add-apt-repository ppa:deadsnakes/ppa\n</code></pre> <p>Info</p> <p>If your using 20.04, you have to upgrade Python to 3.10</p> <pre><code>sudo apt update\nsudo apt install software-properties-common -y\nsudo add-apt-repository ppa:deadsnakes/ppa\nsudo apt install Python3.10\n</code></pre> <p>Install pipx which is used to install conan</p> <pre><code>sudo apt install pipx\n</code></pre> <p>Installing conan</p> <pre><code>pipx install \"conan&gt;=2.10.1\"\n</code></pre> <p>Tip</p> <p>On linux vulkan is not needed to be installed, conan handles that</p> <p>Install Homebrew:</p> <p><pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> Install latest version of Python &amp;&amp; llvm:</p> <pre><code>brew install python pipx llvm@17\n</code></pre> <p>Install conan:</p> <pre><code>pipx install \"conan&gt;=2.10.2\"\n</code></pre> <p>Make <code>clang-tidy</code> available on the command line:</p> <pre><code>sudo ln -s $(brew --prefix llvm)/bin/clang-tidy /usr/local/bin/\n</code></pre> <p>Install Rosetta (only required for M1 macs):</p> <pre><code>/usr/sbin/softwareupdate --install-rosetta --agree-to-license\n</code></pre> <p>Info</p> <p>metal-cpp does not need to be installed because conan handles this for you</p>"},{"location":"getting_started/#setting-up-conan","title":"\ud83d\udce6 Setting up Conan","text":"<p>Install host profiles for your specific platforms</p> WindowsX86 LinuxM1 Mac <p>If you are on an x86 architecture for Windows.</p> <pre><code>conan config install -sf profiles/x86_64/Windows/ -tf profiles https://github.com/engine3d-dev/conan-config.git\n</code></pre> <p>If you are on a linux platform that uses an x86 architecture.</p> <pre><code>conan config install -sf profiles/x86_64/linux/ -tf profiles https://github.com/engine3d-dev/conan-config.git\n</code></pre> <p>If you are on an M1 Mac OS.</p> <pre><code>conan config install -sf profiles/armv8/mac/ -tf profiles https://github.com/engine3d-dev/conan-config.git\n</code></pre>"},{"location":"getting_started/#getting-project-repositories-from-artifactory","title":"\ud83d\udce5 Getting project repositories from Artifactory","text":"<p>Add the engine3d-conan repository to your system. This repository holds all of the TheAtlasEngine packages.</p> <pre><code>conan remote add engine3d-conan https://libhal.jfrog.io/artifactory/api/conan/engine3d-conan\n</code></pre>"},{"location":"getting_started/#development-environment-completed","title":"\u2705 Development Environment Completed!!","text":"<p>Once the development environment is completed. Then go to the repos to see the list of repositories that you plan to contribute to.</p>"},{"location":"getting_started/#changing-build-type","title":"Changing Build Type","text":"<p>The build type determines level of optimizations for the project you are building for. TheAtlasEngine by default is Release is because performance is one of the most important aspects of the project.</p> <p>You can change <code>build_type</code> to the following types:</p> <ul> <li> <p><code>Debug</code>: Turns on some optimizations to reduce binary size and improve performance while still maintaining the structure to make debugging easier. Recommended for testing and prototyping.</p> </li> <li> <p><code>Release</code>: Turns on optimizations and favors high-performance optimizations over space-saving optimizations.</p> </li> <li> <p><code>MinSizeRel</code>: Turns on optimizations and favor higher space saving optimizations over higher-performance.</p> </li> </ul> <p>Tip</p> <p>-b missing is only used during your first build.</p> <pre><code>conan build . -b missing -s build_type=Debug\n</code></pre> <p>This is how you can specify build types when building with conan:</p> <pre><code>conan build . -s build_type=Debug\n</code></pre>"},{"location":"summary/","title":"Summary","text":"<ul> <li>\ud83c\udfe0 Home</li> <li>\ud83d\udcda Getting Started</li> <li>\ud83d\udd79\ufe0f User Guide</li> <li>\ud83d\ude80 Contributor Guides</li> <li>\ud83c\udfa8 Style Guide</li> <li>\ud83d\udcdd Code Design</li> <li>\ud83d\udcdc Project Information</li> <li>About</li> <li>\ud83d\udcd6 Documentation</li> </ul>"},{"location":"contributor_guide/code_design/","title":"\ud83d\udcdd Core Engine Design","text":""},{"location":"contributor_guide/code_design/#interfaces","title":"Interfaces","text":"<p>Interfaces are the foundation of how the api-agnostic API's may work if they have vary defined backends. They present a generalized ideal of a particular aspect of computing.</p> <p>For example, a graphics API such as vulkan, directX, and metal. They both contain their own varied version of a command buffer. In Vulkan it is referred to as VkCommandBuffer, DirectX referred to as ID3D12GraphicsCommandList, and metal it is referred to as MTLCommandBuffer.</p> <p>Which each of this implementation may be operated differently that is widely dependent on their API's.</p> <p>This following guideline should be kept in mind when creating interfaces.</p> <p>Here is an example of some interfaces in libhal. It is recommended to look at these to get an idea of how the interfaces could be written.</p> <ul> <li>atlas::render_context</li> </ul>"},{"location":"contributor_guide/code_design/#designing-and-making-interfaces","title":"Designing and Making Interfaces","text":"<p>Using vtables are quite small and only require a single pointer lookup. The initial idea that comes to mind with vtables is minimize least number of lookups that needs to be made to virtual functions if possible.</p> <p>why?</p> <p>Each virtual function in an interface will require a v-table entry (a pointer) in the v-table of each implementation of an interface. Specific sections of the binary. More you have to store in space.</p> <p>Consider</p> <p>Having an interface for graphics for supporting multiple graphics API called <code>render_context</code>. This render_context could be an interface that may be used for implement the different graphics-api backends such as Vulkan, Metal, and DirectX3D.</p> <p>These are implementations that will have common API's to do equivalent operations. The interface will have common API's for operations such as writing data to a vertex, index, or uniform buffer.</p> <p>The fundamental idea is interfaces should be used to allow a generalized API that internal state of the engine could interact without touching or using any api-dependent code within the engine. That should be completely handle and communicated via those abstraction layers around those API's.</p>"},{"location":"contributor_guide/code_design/#inheritance-not-used-for-game-objects","title":"Inheritance Not Used for Game Objects","text":"<p>Why are we not using inheritance to express game object state?</p> <p>As game objects grow more complex, especially in modern game engines. Inheritance in game engines have been used to determine a variety of states game objects could be in. Including using virtual functions and inheritance to express relationships between the variety of complex states game objects can go into.</p> <p>What are the issues that comes from this design?</p> <p>To further learn why I went with a data-oriented design approach in atlas. It is because</p>"},{"location":"contributor_guide/code_design/#interfaces-not-used-for-actorsobjects","title":"Interfaces Not Used for Actors/Objects","text":"<p>Typically it is seen natural to have scene objects inherit from some virtual class to define a <code>UActor</code> (like unreal). As other engines will have their own variation of this.</p> <p>In this engine, I wanted to have a different look at building games, using a completely different approach in making games that does not have users by default be binded to a contract having them inherit a base class.</p> <p>These are caveuats I should mention below.</p> <ul> <li> <p>One of the biggest issue isn't just the binded contract devs have to make every time they need to make a new actor. Its also the size each actor now carries. What does this mean?</p> <ul> <li>This means that if you look at Unreal's and other engines they have their own variation of how they handle actors. Usually when creating custom actors that inherit, they carry the size of the objects they not only inherit of even if those functions do not get used.</li> <li>Which means bloated in class size in bytes.</li> </ul> </li> <li> <p>Amount of lookups in the vtable is quite high because lets look at particles for example.</p> <ul> <li>If we have particles that may vary in different aspects of geometry, mesh, assets, etc. The amount of difference in data can actually be widely expansive. What initially would happen is we'd have to lookup the vtable entry to get information about the actor every time we need something</li> <li>When we already know its memory location and where this scene object is located, we could minimize these caveuts and initially minimizing code bloatware of binary sizes because we are not creating actors through inheritance.</li> </ul> </li> </ul> <p>Given this example.</p> <p>In game engines today, you will have some variation following this approach.</p> <pre><code>class MyActor : public AActor {\npublic:\n    /* do other pre-init state initialization needed in implementation */\nprotected:\n    virtual void BeginPlay() override { /* do stuff when begin play ticked */ }\n};\n</code></pre>"},{"location":"contributor_guide/code_design/#different-perspective-creating-game-objects","title":"Different Perspective Creating Game Objects","text":"<p>As game object state grows more complex. TheAtlasEngine strives to allow game object to contain the data associated with. Rather the game objects themselves contain state. It is because game object state can be widely complex and making an attempt to try expressing these state for the objects in the form of inheritance and virtual functions can lead to caveauts that I want to research into.</p> <p>These caveauts involve code bloat, complex and high increase of vtables, complex contracts users are by default signed into when trying to make their own game objects.</p> <p>Approaching with a data-oriented design in mind. This way it could simplify what users need has to do for setting up a game object. Simplifying means of how these objects get created, lifetime managements of these objects, when these objects get updated. As time update frequency matters and giving users that control when their objects state get update is direct.</p> <p>Concerns Removed When Creating Objects <pre><code>// Creating custom scene to contain user-defined game objects in this given scene\nclass level_scene : public scene_scope{\npublic:\n    level_scene(const std::string&amp; p_tag) : scene_scope(p_tag) {\n        // Creating entity \"Camera Entity\" to this scene while setting the lifetime of this object to be managed by scene_scope\n        m_camera = this-&gt;create_new_entity(\"Camera Entity\");\n\n        // Creating entity \"Sphere Entity\" to this scene while setting the lifetime of this object to be managed by scene_scope\n        m_sphere = this-&gt;create_new_entity(\"Sphere Entity\");\n\n\n        // This registers our update callable and associates the address of our current scene\n        // then calling this function\n        atlas::sync(this, &amp;level_scene::update);\n\n        // physics() gets called during the interval of physics steps since the timing\n        // for physics can be different compared to logic during update\n        atlas::sync_physics(this, &amp;level_scene::physics);\n    }\n\n\n    void update() {\n        // Running our update logic for being called\n    }\n\n    void physics() {\n        // Running physics logic at the right time interval physics should run at.\n    }\n\nprivate:\n    atlas::ref&lt;atlas::scene_object&gt; m_camera;\n    atlas::ref&lt;atlas::scene_object&gt; m_sphere;\n};\n</code></pre></p>"},{"location":"contributor_guide/philosophy/","title":"Code Design","text":"<p>The core design tenets of <code>atlas</code> and libraries extending must seek to achieve every design choice, line written, and architecture made.</p> <p>D.0. General</p> <p><code>atlas</code> abstraction API's such as <code>engine-audio</code> should focus on enabling configurational settings that does not have users directly writing backend code. If users decide to use <code>engine-audio</code> they should not be touching any piece of code or API of miniaudio.</p> <p>D.1 Minimalist</p> <p><code>atlas</code> aims to be as simple as possible and no simpler. Libraries, Classes, implementation, and features should be implemented to handle currend edge cases. Then focus on expanding afterwards.</p> <p>D.2 Safe &amp; Reliable</p> <p><code>atlas</code> and its style guide uses patterns, techniques, and documentation to reduce safety issues and improve reliability throught out its codebases.</p> <p>D.3 Tested &amp; Testable</p> <p><code>atlas</code> codebases should be as testable and unit tested.</p> <p>D.4 Portable</p> <p>NOTE: In-progress</p> <p>As of this current moment in the early development of <code>atlas</code>, we only support windows.</p> <p><code>atlas</code> will aim to support multiple OS's backends. Such as for Linux and Mac.</p>"},{"location":"contributor_guide/style/","title":"\ud83c\udfa8 Style Guide","text":""},{"location":"contributor_guide/style/#s0-code-guidelines","title":"S.0 Code Guidelines","text":"<p>All guides follow the C++ Core Guidelines.</p>"},{"location":"contributor_guide/style/#s1-code-guidelines","title":"S.1. Code Guidelines","text":"<ul> <li> <p>Code in the atlas organization will follow the <code>.clang-format</code> file, which uses the Mozilla's</p> </li> <li> <p>Code will follow the atlas organization's <code>.naming.style</code> file, which are similar to the standard library's naming convention.</p> </li> <li> <p>CAP_CASE for MACROs (avoid MACROs in general).</p> </li> <li> <p>CamelCase used for template parameters</p> </li> <li>lowercase snake_case for everything else</li> <li>prefix <code>p_</code> for function parameters</li> <li> <p>prefix <code>m_</code> for private/protected class members</p> </li> <li> <p>Refrain from abbreviated variable name. Don't do <code>m_cnt</code> and just write out <code>m_count</code>.</p> </li> <li>Every file must end with a newline character.</li> <li>Every line in a file must stay within 80 character limit.</li> <li>Include C++ header versions of C headers such as <code>&lt;cstdint&gt;</code> vs <code>&lt;stdint.h&gt;</code></li> </ul>"},{"location":"contributor_guide/style/#s2-refrain-from-using-macros","title":"S.2. Refrain from using MACROS","text":"<p>Usually macros are replaced with <code>constexpr</code> or const variables or function calls.</p> <p>Only use preprocessors <code>#if</code> and the like if it is impossible to use <code>if constexpr</code> to achieve the same behavior.</p>"},{"location":"contributor_guide/style/#s3-interfaces-should-follow-the-public-private-api-scheme","title":"S.3. Interfaces should follow the public private API scheme.","text":"<p>See private virtual methods for more details. Rationale can be found with that link as well.</p>"},{"location":"contributor_guide/style/#s4-avoid-using-bool-as","title":"S.4. Avoid using <code>bool</code> as","text":"<p>NOTE: This is still in-progress</p>"},{"location":"contributor_guide/style/#s5-include-guards","title":"S.5. Include guards","text":"<p>For ease of usage, use <code>#pragma once</code> as your include guard. Usage of classic include guards like:</p> <pre><code>#ifndef FOO\n#define FOO\n\n#endif // FOO\n</code></pre> <p>Are annoying and error prone. Do not use these!</p> <p>S.6. Include Ordering</p> <p>Headers should be included in your header and source files in the following order:</p> <ul> <li> <p>C standard library headers. Include using chevrons: <code>&lt;&gt;</code></p> </li> <li> <p>C++ 3rd party library packages. Include using chevrons: <code>&lt;&gt;</code></p> </li> <li> <p>C++ Standard library headers. Include using chevrons: <code>&lt;&gt;</code></p> </li> <li> <p>Local Header/Project Headers. Include using quotes <code>\"\"</code></p> </li> </ul> <p>For standard C headers use C++ <code>&lt;cstdio&gt;</code> style over the C <code>&lt;stdio.h&gt;</code> style.</p> <p>Example of how this should look:</p> <pre><code>#pragma once\n\n// C header first\n#include &lt;cstdio&gt;\n#include &lt;cstdint&gt;\n\n// C++ headers\n#include &lt;string_view&gt;\n#include &lt;span&gt;\n\n// C++ library header s\n#include &lt;atlas/application.hpp&gt;\n#include &lt;atlas/core/event/event.hpp&gt;\n\n// Local project\n#include \"game-template/content/custom_scene.hpp\"\n#include \"game-template/content/custom_actor.hpp\"\n\n// actual code goes here\n</code></pre> <p>Exception: <code>boost.ut</code> must ALWAYS be the last include in your code in order to allow <code>ostream operator&lt;&lt;</code> overloading to work.</p>"},{"location":"contributor_guide/style/#s6-classes","title":"S.6. Classes","text":""},{"location":"contributor_guide/style/#s61-declaration-order","title":"S.6.1. Declaration Order","text":"<p>Class's visibility specifiers and member sections should appear in the following order.</p> <ol> <li> <p>Public.</p> </li> <li> <p>Protected.</p> </li> <li> <p>Private.</p> </li> </ol> <p>Omit any sections that would be empty.</p> <p>Within each section, group similar declarations together this order and follow this order:</p> <ol> <li> <p>Types and type aliases</p> <ul> <li> <p>Using directives (<code>using</code>)</p> </li> <li> <p>Enum Classes</p> </li> <li> <p>Nested structs and classes</p> </li> <li> <p>Friend classes and structs</p> </li> </ul> </li> <li> <p>Static constants</p> </li> <li>Factory functions (if applicable)</li> <li>Constructors and assignment operators</li> <li>Destructor</li> <li>All other member functions (static and non static member functions, as well as friend functions)</li> <li>All other data members (static and non-static)</li> </ol> <p>Do not put large method definitions inline within the class definition. Typically only trivial or performance critical methods \\ that are very short may be defined inline. If the class as a template, then all functions must be defined inline in the\\ header file.</p> <p>Note</p> <p>if a friend is a class or class function, then the friend should appear under the same visibility \\ specifier as a friend. For example, if you are friending a private class function, then the friend \\ function delcaration should also appear in the private section of the friending class.</p>"},{"location":"contributor_guide/style/#s62-storing-references","title":"S.6.2. Storing References","text":"<p>Class within the project should not have reference member variables like so:</p> <pre><code>class my_scene {\npublic:\n    my_scene(flecs::registry&amp; p_registry) : m_registry(p_registry) {}\n\nprivate:\n    flecs::registry&amp; m_registry;\n};\n</code></pre> <p>Reference members implicitly delete copy constructors of a class they are within because they are themselves are not copyable. You cannot reassign a reference after it's made.</p> <p>Instead take the parameter as a reference but save its address as a pointer.</p> <pre><code>class my_scene {\npublic:\n    my_scene(flecs::registry&amp; p_registry) : m_registry(&amp;p_registry) {}\n\nprivate:\n    flecs::registry* m_registry;\n};\n</code></pre>"},{"location":"user_guide/setup_vscode/","title":"\ud83d\udd79\ufe0f Setting VSCode w/ <code>clangd</code>","text":"<p>The majority of the contributors and users uses Visual Studio Code. These guidelines should also help with non-vscoders as well.</p>"},{"location":"user_guide/setup_vscode/#setup-vscode-configuration","title":"Setup VSCode Configuration","text":"<p>Make sure you already install clang via getting started.</p> <ol> <li>Install VSCode if you haven't already done so.</li> <li>Go to the \"Extensions\" section on left-side of the bar. It looks like 4 blocks with the upper right-hand block disconnected from the other 3. Hover over the icons to get their name.</li> <li>Search for \"C/C++\" and disable the Windows intellisense extension if it is already installed and enabled.</li> <li>Search for the extension <code>clangd</code> and install the extension.</li> <li>Go to the <code>clangd</code> extension settings page. Find <code>clangd</code> extension and press the GEAR \u2699\ufe0f icon to open in settings.</li> <li>Find the settings <code>clangd: Arguments</code> and add:<ol> <li>In <code>Clangd: Arguments</code> input <code>--header-insertion=never</code></li> </ol> </li> </ol>"},{"location":"user_guide/setup_vscode/#disable-vscode-default-intellisense","title":"Disable VSCode Default Intellisense","text":"<p>When using <code>clangd</code> it will conflict with Visual Studio Code's default intellisense. This is how you can disable it.</p> <p>Follow the same setups above. In the intellisense sections in the extensions for \"C/C++\".</p> <p>Check the disable checkbox as shown below</p> <p></p>"},{"location":"user_guide/setup_vscode/#disable-auto-include-headers","title":"Disable auto-include headers","text":"<p>If you do not want auto-imported headers and are already including them if you have precompiled headers setup. This is how you can disable them.</p> <p>Clangd arguments should look like this:</p> <p></p>"},{"location":"user_guide/setup_vscode/#used-in-your-own-project","title":"Used in your own project","text":"<p>You can either add a <code>self.requires(\"engine3d-cmake-utils/3.0\")</code> to your project or add the following lines to your <code>CMakeLists.txt</code></p> <pre><code># Generate compile commands for anyone using our libraries.\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n\n# Always run this custom target by making it depend on ALL\nadd_custom_target(copy_compile_commands ALL\n    COMMAND ${CMAKE_COMMAND} -E copy_if_different\n    ${CMAKE_BINARY_DIR}/compile_commands.json\n    ${CMAKE_SOURCE_DIR}/compile_commands.json\n    DEPENDS ${CMAKE_BINARY_DIR}/compile_commands.json)\n</code></pre> <p>Run <code>conan build .</code> (where <code>.</code> is the path to your project/library) and it should generate the <code>compile_commands.json</code> file.</p> <p>To ensure that the dependencies in your <code>conanfile.py</code> file that uses <code>self.requires</code>.</p> <p>You can also run with <code>-b missing</code> (where <code>-b missing</code> indicates that to install any missing binary into the conan cache)</p> <pre><code>conan build . -b missing\n</code></pre>"},{"location":"user_guide/setup_vscode/#how-clangd-works","title":"How <code>clangd</code> works","text":"<p>Once you get <code>clangd</code> setup. Let me tell you how clangd works. Your workspace needs <code>compile_commands.json</code> file to be present or using <code>.clangd</code> in the root of your project's directory to be configured to know where to look for the location the <code>compile_commands.json</code> is located.</p> <p><code>compile_commands.json</code> tells <code>clangd</code> what commands you are using in order to determine exactly how your files are build and whjat commands are used to build them. Which provides the following benefits:</p> <ol> <li>More accurate warnings and error messages within your IDE.</li> <li>Faster response time because only the necessary includes for the specific version you are targeted will be used when evaluated.</li> </ol>"},{"location":"References/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace atlas <ul> <li>struct DescriptorSet </li> <li>struct DescriptorSetLayout </li> <li>struct DirectionalLightUbo </li> <li>class Framebuffer </li> <li>class Image </li> <li>struct ImageSampler </li> <li>class ParallelUpdateManager </li> <li>class Pipeline </li> <li>struct PointLightUbo </li> <li>struct SpotLightUbo </li> <li>class UniformBuffer </li> <li>class VulkanImGui </li> <li>class application </li> <li>struct application_settings </li> <li>struct box_collider3d </li> <li>class camera </li> <li>struct camera_ubo </li> <li>class console_log_manager </li> <li>class entity_t </li> <li>namespace event <ul> <li>struct joystick_button </li> <li>struct joystick_info </li> </ul> </li> <li>namespace filesystem </li> <li>class imgui_backend </li> <li>class index_buffer </li> <li>class interpolation </li> <li>struct light TODO: Make this better (when we do lighting) </li> <li>struct math_generic </li> <li>struct matrix2 </li> <li>struct matrix3 </li> <li>struct matrix4 </li> <li>class mesh </li> <li>namespace physics <ul> <li>class JoltPhysicBody </li> <li>struct jolt_config Used to keep global data for player access and use. Tells how physics bodies should act within a given scene by default. </li> <li>struct jolt_settings A data structure to give to flecs and get the physics. </li> <li>class physics_engine </li> </ul> </li> <li>class render_context </li> <li>class renderer </li> <li>class renderpass </li> <li>struct renderpass_properties </li> <li>struct rendertarget3d </li> <li>struct rigidbody3d </li> <li>class scene_object </li> <li>class scene_scope </li> <li>class serializer </li> <li>class shader </li> <li>class swapchain </li> <li>namespace sync_update </li> <li>class system_registry </li> <li>struct tag </li> <li>class thread </li> <li>class timer </li> <li>struct transform </li> <li>namespace ui </li> <li>struct vector2 </li> <li>struct vector2&lt; glm::highp_vec2 &gt; </li> <li>struct vector3 </li> <li>struct vector3&lt; JPH::Vec3 &gt; </li> <li>struct vector3&lt; glm::highp_vec3 &gt; </li> <li>struct vector4 </li> <li>struct vector4&lt; glm::highp_vec4 &gt; </li> <li>struct vertex </li> <li>class vertex_buffer </li> <li>namespace vk <ul> <li>class BufferTutorial </li> <li>class VulkanDescriptorSets </li> <li>class VulkanPipeline </li> <li>class VulkanRenderPass </li> <li>class VulkanUniformBuffer </li> <li>class descriptor_pool <ul> <li>class builder </li> </ul> </li> <li>class descriptor_set_layout <ul> <li>class builder </li> </ul> </li> <li>class descriptor_writer </li> <li>struct shader_pipeline_config </li> <li>class vk_context </li> <li>class vk_driver </li> <li>class vk_index_buffer </li> <li>class vk_physical_driver <ul> <li>struct queue_family_indices </li> </ul> </li> <li>class vk_renderer </li> <li>class vk_shader </li> <li>class vk_swapchain </li> <li>class vk_vertex_buffer </li> <li>class vk_window </li> </ul> </li> <li>class window </li> <li>class world_scope Lets rethink how world_scope gets created. </li> </ul> </li> <li>struct swapchain_depth_image </li> <li>struct swapchain_image </li> <li>namespace std </li> </ul>"},{"location":"References/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir TheAtlasEngine <ul> <li>dir atlas <ul> <li>dir core <ul> <li>dir event <ul> <li>file event.hpp </li> <li>file joystick_codes.hpp </li> <li>file key_codes.hpp </li> <li>file mouse_codes.hpp </li> </ul> </li> <li>dir filesystem <ul> <li>file file_dialog.hpp </li> </ul> </li> <li>dir geometry <ul> <li>file mesh.hpp </li> </ul> </li> <li>dir image <ul> <li>file stb_image.hpp </li> </ul> </li> <li>dir math <ul> <li>file math.hpp </li> <li>file types.hpp </li> </ul> </li> <li>dir scene <ul> <li>file components.hpp </li> <li>file entity.hpp </li> <li>file scene.hpp </li> <li>file scene_object.hpp </li> <li>file world.hpp </li> </ul> </li> <li>dir serialize <ul> <li>file serializer.hpp </li> </ul> </li> <li>dir system_framework <ul> <li>file system_registry.hpp </li> </ul> </li> <li>dir threads <ul> <li>file thread.hpp </li> </ul> </li> <li>dir ui <ul> <li>file widgets.hpp </li> </ul> </li> <li>dir update_handlers <ul> <li>file global_update.hpp </li> <li>file parallel_update_manager.hpp </li> <li>file sync_update.hpp </li> <li>file thread_manager.hpp </li> <li>file timer.hpp </li> </ul> </li> <li>dir utilities <ul> <li>file hash.hpp </li> </ul> </li> <li>file api.hpp </li> <li>file application.hpp </li> <li>file core.hpp </li> <li>file engine_logger.hpp </li> <li>file timer.hpp </li> <li>file window.hpp </li> </ul> </li> <li>dir drivers <ul> <li>dir ui <ul> <li>file imgui_backend.hpp </li> </ul> </li> <li>dir vulkan <ul> <li>dir shaders <ul> <li>file vulkan_shader.hpp </li> <li>file vulkan_shader_pipeline_config.hpp </li> </ul> </li> <li>file buffer_tutorial.hpp </li> <li>file descriptor_tutorial.hpp </li> <li>file helper_functions.hpp </li> <li>file types.hpp </li> <li>file utility.hpp </li> <li>file vulkan-imports.hpp </li> <li>file vulkan_context.hpp </li> <li>file vulkan_core.hpp </li> <li>file vulkan_descriptors.hpp </li> <li>file vulkan_driver.hpp </li> <li>file vulkan_gpu.hpp </li> <li>file vulkan_imgui.hpp </li> <li>file vulkan_index_buffer.hpp </li> <li>file vulkan_physical_driver.hpp </li> <li>file vulkan_pipeline.hpp </li> <li>file vulkan_renderer.hpp </li> <li>file vulkan_renderpass.hpp </li> <li>file vulkan_swapchain.hpp </li> <li>file vulkan_uniform_buffer.hpp </li> <li>file vulkan_vertex_buffer.hpp </li> <li>file vulkan_window.hpp </li> </ul> </li> <li>file descriptor_sets.hpp </li> <li>file frame_buffer.hpp </li> <li>file image.hpp </li> <li>file index_buffer.hpp </li> <li>file pipeline.hpp </li> <li>file render_pass.hpp </li> <li>file renderer_backend.hpp </li> <li>file shader.hpp </li> <li>file swapchain.hpp </li> <li>file uniform.hpp </li> <li>file uniform_buffer.hpp </li> <li>file vertex_buffer.hpp </li> </ul> </li> <li>dir physics <ul> <li>dir jolt-cpp <ul> <li>file helper_functions.hpp </li> <li>file jolt-imports.hpp </li> <li>file jolt_api.hpp </li> <li>file jolt_body.hpp </li> </ul> </li> <li>dir physics_3d <ul> <li>dir data <ul> <li>file jolt_config.hpp </li> <li>file jolt_settings.hpp </li> </ul> </li> <li>dir jolt <ul> <li>file jolt_api.hpp </li> <li>file jolt_physics_engine.hpp </li> </ul> </li> <li>file physics_api.hpp </li> <li>file physics_engine.hpp </li> </ul> </li> <li>file types.hpp </li> </ul> </li> <li>dir renderer <ul> <li>file renderer.hpp </li> </ul> </li> <li>dir thread_utils <ul> <li>file thread.hpp </li> <li>file thread_utils.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"References/namespaceatlas/","title":"Namespace atlas","text":"<p>Namespace List &gt; atlas</p>"},{"location":"References/namespaceatlas/#namespaces","title":"Namespaces","text":"Type Name namespace event namespace filesystem namespace physics namespace sync_update namespace ui namespace vk"},{"location":"References/namespaceatlas/#classes","title":"Classes","text":"Type Name struct DescriptorSet struct DescriptorSetLayout struct DirectionalLightUbo class Framebuffer class Image struct ImageSampler class ParallelUpdateManager class Pipeline struct PointLightUbo struct SpotLightUbo class UniformBuffer class VulkanImGui class application struct application_settings struct box_collider3d class camera struct camera_ubo class console_log_manager class entity_t class imgui_backend class index_buffer class interpolation struct light TODO: Make this better (when we do lighting) struct math_generic &lt;typename T&gt; struct matrix2 &lt;typename T&gt; struct matrix3 &lt;typename T&gt; struct matrix4 &lt;typename T&gt; class mesh class render_context class renderer class renderpass struct renderpass_properties struct rendertarget3d struct rigidbody3d class scene_object class scene_scope class serializer class shader class swapchain class system_registry struct tag class thread class timer struct transform struct vector2 &lt;typename T&gt; struct vector2&lt; glm::highp_vec2 &gt; &lt;&gt; struct vector3 &lt;typename T&gt; struct vector3&lt; JPH::Vec3 &gt; &lt;&gt; struct vector3&lt; glm::highp_vec3 &gt; &lt;&gt; struct vector4 &lt;typename T&gt; struct vector4&lt; glm::highp_vec4 &gt; &lt;&gt; struct vertex class vertex_buffer class window class world_scope Lets rethink how world_scope gets created."},{"location":"References/namespaceatlas/#public-types","title":"Public Types","text":"Type Name enum API enum CameraMovement enum ImageFormat enum ImageLayout enum PipelineStageFlags enum ShaderAccessOperation enum int SubpassContents typedef vector2&lt; glm::highp_vec2 &gt; highp_vec2 typedef vector3&lt; glm::highp_vec3 &gt; highp_vec3 typedef vector4&lt; glm::highp_vec4 &gt; highp_vec4 typedef math_generic&lt; glm::mat&lt; C, R, T &gt; &gt; mat typedef matrix2&lt; glm::mat2 &gt; mat2 typedef matrix3&lt; glm::mat3 &gt; mat3 typedef matrix4&lt; glm::mat4 &gt; mat4 typedef std::shared_ptr&lt; T &gt; ref typedef std::unique_ptr&lt; T &gt; scope typedef math_generic&lt; glm::vec&lt; Size, T &gt; &gt; vec typedef vector2&lt; glm::vec2 &gt; vec2 typedef vector3&lt; glm::vec3 &gt; vec3 typedef vector4&lt; glm::vec4 &gt; vec4 typedef std::weak_ptr&lt; T &gt; weak_ptr"},{"location":"References/namespaceatlas/#public-functions","title":"Public Functions","text":"Type Name void attach (UObject * p_instance, const UCallable &amp; p_callable)  constexpr ref&lt; T &gt; create_ref (Args &amp;&amp;... args)  constexpr scope&lt; T &gt; create_scope (Args &amp;&amp;... args)  constexpr weak_ptr&lt; T &gt; create_weak_ptr (Args &amp;&amp;... args)  uint32_t get_thread_count ()  void hash_combine (size_t &amp; seed, const T &amp; v, const Rest &amp;... rest)  ref&lt; application &gt; initialize_application ()  void post (UObject * p_instance, const UCallable &amp; p_callable)  void sync (UObject * p_instance, const UCallable &amp; p_callable)  void sync_physics (UObject * p_instance, const UCallable &amp; p_callable)  weak_ptr&lt; T &gt; to_weak_ptr (const U &amp; p_value)"},{"location":"References/namespaceatlas/#public-static-functions","title":"Public Static Functions","text":"Type Name void core_assert (bool x, T &amp;&amp;... args)"},{"location":"References/namespaceatlas/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"References/namespaceatlas/#enum-api","title":"enum API","text":"<pre><code>enum atlas::API {\n    VULKAN,\n    DIRECTX11,\n    DIRECTX12,\n    UNSPECIFIED\n};\n</code></pre>"},{"location":"References/namespaceatlas/#enum-cameramovement","title":"enum CameraMovement","text":"<pre><code>enum atlas::CameraMovement {\n    Forward,\n    Backward,\n    Left,\n    Right,\n    Up,\n    Down\n};\n</code></pre>"},{"location":"References/namespaceatlas/#enum-imageformat","title":"enum ImageFormat","text":"<pre><code>enum atlas::ImageFormat {\n    RED,\n    RGBA8,\n    RGBA16,\n    DEPTH24_STENCIL8,\n    DEFAULT = DEPTH24_STENCIL8\n};\n</code></pre> <p>Note:</p> <p>Used to specify what attachment type for per render pass </p> <p>Note:</p> <p>Usage: Format that is defaulted to throughout the vulkan abstraction </p> <p>Note:</p> <p>Meaning not just used for attachment formats, also image formats </p>"},{"location":"References/namespaceatlas/#enum-imagelayout","title":"enum ImageLayout","text":"<pre><code>enum atlas::ImageLayout {\n    UNDEFINED,\n    IMAGE_OPTIMAL,\n    COLOR_ATTACHMENT,\n    DEPTH_STENCIL_ATTACHMENT_READ_WRITE,\n    DEPTH_STENCIL_READ,\n    TRANSFER_SRC,\n    TRANSFER_DST,\n    PREINITIALIZED,\n    STENCIL_READ_WRITE_DEPTH_READ_ONLY,\n    DEPTH_READ_WRITE_STENCIL_READ_ONLY\n};\n</code></pre> <p>Note:</p> <p>Used for specifying the type of image layout for getting accessed </p>"},{"location":"References/namespaceatlas/#enum-pipelinestageflags","title":"enum PipelineStageFlags","text":"<pre><code>enum atlas::PipelineStageFlags {\n    COLOR_ATTACHMENT\n};\n</code></pre>"},{"location":"References/namespaceatlas/#enum-shaderaccessoperation","title":"enum ShaderAccessOperation","text":"<pre><code>enum atlas::ShaderAccessOperation {\n    DONT_CARE,\n    LOAD,\n    STORE,\n    DEFAULT = DONT_CARE\n};\n</code></pre> <p>Note:</p> <p>Enum for indicating state of what access shaders have </p> <p>Note:</p> <p>Usage: as a bitfield </p>"},{"location":"References/namespaceatlas/#enum-subpasscontents","title":"enum SubpassContents","text":"<pre><code>enum atlas::SubpassContents {\n    INLINE = 0,\n    SECONDARY_COMMAND_BUFFERS = 1,\n    INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR = 2,\n    INLINE_AND_COMMAND_BUFFERS_EXT = 3\n};\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-highp_vec2","title":"typedef highp_vec2","text":"<pre><code>using atlas::highp_vec2 = typedef vector2&lt;glm::highp_vec2&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-highp_vec3","title":"typedef highp_vec3","text":"<pre><code>using atlas::highp_vec3 = typedef vector3&lt;glm::highp_vec3&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-highp_vec4","title":"typedef highp_vec4","text":"<pre><code>using atlas::highp_vec4 = typedef vector4&lt;glm::highp_vec4&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-mat","title":"typedef mat","text":"<pre><code>using atlas::mat = typedef math_generic&lt;glm::mat&lt;C, R, T&gt; &gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-mat2","title":"typedef mat2","text":"<pre><code>using atlas::mat2 = typedef matrix2&lt;glm::mat2&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-mat3","title":"typedef mat3","text":"<pre><code>using atlas::mat3 = typedef matrix3&lt;glm::mat3&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-mat4","title":"typedef mat4","text":"<pre><code>using atlas::mat4 = typedef matrix4&lt;glm::mat4&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-ref","title":"typedef ref","text":"<pre><code>using atlas::ref = typedef std::shared_ptr&lt;T&gt;;\n</code></pre> <p>Note:</p> <p>Some aliases for the smart pointers </p>"},{"location":"References/namespaceatlas/#typedef-scope","title":"typedef scope","text":"<pre><code>using atlas::scope = typedef std::unique_ptr&lt;T&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-vec","title":"typedef vec","text":"<pre><code>using atlas::vec = typedef math_generic&lt;glm::vec&lt;Size, T&gt; &gt;;\n</code></pre> <p>Note:</p> <p>By default we use glm </p>"},{"location":"References/namespaceatlas/#typedef-vec2","title":"typedef vec2","text":"<pre><code>using atlas::vec2 = typedef vector2&lt;glm::vec2&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-vec3","title":"typedef vec3","text":"<pre><code>using atlas::vec3 = typedef vector3&lt;glm::vec3&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-vec4","title":"typedef vec4","text":"<pre><code>using atlas::vec4 = typedef vector4&lt;glm::vec4&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#typedef-weak_ptr","title":"typedef weak_ptr","text":"<pre><code>using atlas::weak_ptr = typedef std::weak_ptr&lt;T&gt;;\n</code></pre>"},{"location":"References/namespaceatlas/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas/#function-attach","title":"function attach","text":"<pre><code>template&lt;typename UObject, typename UCallable&gt;\nvoid atlas::attach (\n    UObject * p_instance,\n    const UCallable &amp; p_callable\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-create_ref","title":"function create_ref","text":"<pre><code>template&lt;typename T, typename... Args&gt;\nconstexpr ref&lt; T &gt; atlas::create_ref (\n    Args &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-create_scope","title":"function create_scope","text":"<pre><code>template&lt;typename T, typename... Args&gt;\nconstexpr scope&lt; T &gt; atlas::create_scope (\n    Args &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-create_weak_ptr","title":"function create_weak_ptr","text":"<pre><code>template&lt;typename T, typename... Args&gt;\nconstexpr weak_ptr&lt; T &gt; atlas::create_weak_ptr (\n    Args &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-get_thread_count","title":"function get_thread_count","text":"<pre><code>uint32_t atlas::get_thread_count () \n</code></pre>"},{"location":"References/namespaceatlas/#function-hash_combine","title":"function hash_combine","text":"<pre><code>template&lt;typename T, typename... Rest&gt;\nvoid atlas::hash_combine (\n    size_t &amp; seed,\n    const T &amp; v,\n    const Rest &amp;... rest\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-initialize_application","title":"function initialize_application","text":"<pre><code>ref&lt; application &gt; atlas::initialize_application () \n</code></pre>"},{"location":"References/namespaceatlas/#function-post","title":"function post","text":"<pre><code>template&lt;typename UObject, typename UCallable&gt;\nvoid atlas::post (\n    UObject * p_instance,\n    const UCallable &amp; p_callable\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-sync","title":"function sync","text":"<pre><code>template&lt;typename UObject, typename UCallable&gt;\nvoid atlas::sync (\n    UObject * p_instance,\n    const UCallable &amp; p_callable\n) \n</code></pre> <p>Note:</p> <p>These are public functions that users can utilize </p> <p>Note:</p> <p>If users are using anything within the sync_update namespace. They shouldn't </p>"},{"location":"References/namespaceatlas/#function-sync_physics","title":"function sync_physics","text":"<pre><code>template&lt;typename UObject, typename UCallable&gt;\nvoid atlas::sync_physics (\n    UObject * p_instance,\n    const UCallable &amp; p_callable\n) \n</code></pre>"},{"location":"References/namespaceatlas/#function-to_weak_ptr","title":"function to_weak_ptr","text":"<pre><code>template&lt;typename T, typename U&gt;\nweak_ptr&lt; T &gt; atlas::to_weak_ptr (\n    const U &amp; p_value\n) \n</code></pre>"},{"location":"References/namespaceatlas/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/namespaceatlas/#function-core_assert","title":"function core_assert","text":"<pre><code>template&lt;typename... T&gt;\nstatic void atlas::core_assert (\n    bool x,\n    T &amp;&amp;... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/api.hpp</code></p>"},{"location":"References/classatlas_1_1DescriptorSet/","title":"Struct atlas::DescriptorSet","text":"<p>ClassList &gt; atlas &gt; DescriptorSet</p>"},{"location":"References/classatlas_1_1DescriptorSet/#public-attributes","title":"Public Attributes","text":"Type Name VkDescriptorSetLayoutBinding Binding VkDescriptorSet Set"},{"location":"References/classatlas_1_1DescriptorSet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/classatlas_1_1DescriptorSet/#variable-binding","title":"variable Binding","text":"<pre><code>VkDescriptorSetLayoutBinding atlas::DescriptorSet::Binding;\n</code></pre>"},{"location":"References/classatlas_1_1DescriptorSet/#variable-set","title":"variable Set","text":"<pre><code>VkDescriptorSet atlas::DescriptorSet::Set;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/descriptor_sets.hpp</code></p>"},{"location":"References/structatlas_1_1DescriptorSetLayout/","title":"Struct atlas::DescriptorSetLayout","text":"<p>ClassList &gt; atlas &gt; DescriptorSetLayout</p>"},{"location":"References/structatlas_1_1DescriptorSetLayout/#public-functions","title":"Public Functions","text":"Type Name DescriptorSetLayout ()"},{"location":"References/structatlas_1_1DescriptorSetLayout/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1DescriptorSetLayout/#function-descriptorsetlayout","title":"function DescriptorSetLayout","text":"<pre><code>atlas::DescriptorSetLayout::DescriptorSetLayout () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/descriptor_sets.hpp</code></p>"},{"location":"References/structatlas_1_1DirectionalLightUbo/","title":"Struct atlas::DirectionalLightUbo","text":"<p>ClassList &gt; atlas &gt; DirectionalLightUbo</p>"},{"location":"References/structatlas_1_1DirectionalLightUbo/#public-attributes","title":"Public Attributes","text":"Type Name glm::vec3 Direction   = <code>{ -0.2f, -1.0f, -0.3f }</code> glm::vec3 ambient   = <code>{ 0.05f, 0.05f, 0.05f }</code> glm::vec3 diffuse   = <code>{ 0.4f, 0.4f, 0.4f }</code> glm::vec3 specular   = <code>{ 0.5f, 0.5f, 0.5f }</code>"},{"location":"References/structatlas_1_1DirectionalLightUbo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1DirectionalLightUbo/#variable-direction","title":"variable Direction","text":"<pre><code>glm::vec3 atlas::DirectionalLightUbo::Direction;\n</code></pre>"},{"location":"References/structatlas_1_1DirectionalLightUbo/#variable-ambient","title":"variable ambient","text":"<pre><code>glm::vec3 atlas::DirectionalLightUbo::ambient;\n</code></pre>"},{"location":"References/structatlas_1_1DirectionalLightUbo/#variable-diffuse","title":"variable diffuse","text":"<pre><code>glm::vec3 atlas::DirectionalLightUbo::diffuse;\n</code></pre>"},{"location":"References/structatlas_1_1DirectionalLightUbo/#variable-specular","title":"variable specular","text":"<pre><code>glm::vec3 atlas::DirectionalLightUbo::specular;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/uniform.hpp</code></p>"},{"location":"References/classatlas_1_1Framebuffer/","title":"Class atlas::Framebuffer","text":"<p>ClassList &gt; atlas &gt; Framebuffer</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/frame_buffer.hpp</code></p>"},{"location":"References/classatlas_1_1Image/","title":"Class atlas::Image","text":"<p>ClassList &gt; atlas &gt; Image</p>"},{"location":"References/classatlas_1_1Image/#public-functions","title":"Public Functions","text":"Type Name Image (const std::string &amp; p_filepath)"},{"location":"References/classatlas_1_1Image/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1Image/#function-image","title":"function Image","text":"<pre><code>atlas::Image::Image (\n    const std::string &amp; p_filepath\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/image.hpp</code></p>"},{"location":"References/structatlas_1_1ImageSampler/","title":"Struct atlas::ImageSampler","text":"<p>ClassList &gt; atlas &gt; ImageSampler</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/image.hpp</code></p>"},{"location":"References/classatlas_1_1ParallelUpdateManager/","title":"Class atlas::ParallelUpdateManager","text":"<p>ClassList &gt; atlas &gt; ParallelUpdateManager</p>"},{"location":"References/classatlas_1_1ParallelUpdateManager/#public-functions","title":"Public Functions","text":"Type Name ParallelUpdateManager () = delete"},{"location":"References/classatlas_1_1ParallelUpdateManager/#public-static-functions","title":"Public Static Functions","text":"Type Name void InitializeParallel ()"},{"location":"References/classatlas_1_1ParallelUpdateManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1ParallelUpdateManager/#function-parallelupdatemanager","title":"function ParallelUpdateManager","text":"<pre><code>atlas::ParallelUpdateManager::ParallelUpdateManager () = delete\n</code></pre>"},{"location":"References/classatlas_1_1ParallelUpdateManager/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1ParallelUpdateManager/#function-initializeparallel","title":"function InitializeParallel","text":"<pre><code>static void atlas::ParallelUpdateManager::InitializeParallel () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/update_handlers/parallel_update_manager.hpp</code></p>"},{"location":"References/classatlas_1_1Pipeline/","title":"Class atlas::Pipeline","text":"<p>ClassList &gt; atlas &gt; Pipeline</p>"},{"location":"References/classatlas_1_1Pipeline/#public-functions","title":"Public Functions","text":"Type Name Pipeline () = default"},{"location":"References/classatlas_1_1Pipeline/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1Pipeline/#function-pipeline","title":"function Pipeline","text":"<pre><code>atlas::Pipeline::Pipeline () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/pipeline.hpp</code></p>"},{"location":"References/structatlas_1_1PointLightUbo/","title":"Struct atlas::PointLightUbo","text":"<p>ClassList &gt; atlas &gt; PointLightUbo</p>"},{"location":"References/structatlas_1_1PointLightUbo/#public-attributes","title":"Public Attributes","text":"Type Name float Constant float Linear glm::vec3 Position float Quadratic glm::vec3 ambient glm::vec3 diffuse glm::vec3 specular"},{"location":"References/structatlas_1_1PointLightUbo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1PointLightUbo/#variable-constant","title":"variable Constant","text":"<pre><code>float atlas::PointLightUbo::Constant;\n</code></pre>"},{"location":"References/structatlas_1_1PointLightUbo/#variable-linear","title":"variable Linear","text":"<pre><code>float atlas::PointLightUbo::Linear;\n</code></pre>"},{"location":"References/structatlas_1_1PointLightUbo/#variable-position","title":"variable Position","text":"<pre><code>glm::vec3 atlas::PointLightUbo::Position;\n</code></pre>"},{"location":"References/structatlas_1_1PointLightUbo/#variable-quadratic","title":"variable Quadratic","text":"<pre><code>float atlas::PointLightUbo::Quadratic;\n</code></pre>"},{"location":"References/structatlas_1_1PointLightUbo/#variable-ambient","title":"variable ambient","text":"<pre><code>glm::vec3 atlas::PointLightUbo::ambient;\n</code></pre>"},{"location":"References/structatlas_1_1PointLightUbo/#variable-diffuse","title":"variable diffuse","text":"<pre><code>glm::vec3 atlas::PointLightUbo::diffuse;\n</code></pre>"},{"location":"References/structatlas_1_1PointLightUbo/#variable-specular","title":"variable specular","text":"<pre><code>glm::vec3 atlas::PointLightUbo::specular;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/uniform.hpp</code></p>"},{"location":"References/structatlas_1_1SpotLightUbo/","title":"Struct atlas::SpotLightUbo","text":"<p>ClassList &gt; atlas &gt; SpotLightUbo</p>"},{"location":"References/structatlas_1_1SpotLightUbo/#public-attributes","title":"Public Attributes","text":"Type Name glm::vec3 Direction   = <code>{ 1.f, 0.f, 0.f }</code> glm::vec3 Position glm::vec3 ambient   = <code>{ 0.0f, 0.0f, 0.0f }</code> float constant   = <code>{ 1.f }</code> float cut_off glm::vec3 diffuse   = <code>{ 1.0f, 1.0f, 1.0f }</code> float linear   = <code>{ 0.09f }</code> float outer_cut_off float quadratic   = <code>{ 0.032f }</code> glm::vec3 specular   = <code>{ 1.0f, 1.0f, 1.0f }</code>"},{"location":"References/structatlas_1_1SpotLightUbo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1SpotLightUbo/#variable-direction","title":"variable Direction","text":"<pre><code>glm::vec3 atlas::SpotLightUbo::Direction;\n</code></pre>"},{"location":"References/structatlas_1_1SpotLightUbo/#variable-position","title":"variable Position","text":"<pre><code>glm::vec3 atlas::SpotLightUbo::Position;\n</code></pre>"},{"location":"References/structatlas_1_1SpotLightUbo/#variable-ambient","title":"variable ambient","text":"<pre><code>glm::vec3 atlas::SpotLightUbo::ambient;\n</code></pre>"},{"location":"References/structatlas_1_1SpotLightUbo/#variable-constant","title":"variable constant","text":"<pre><code>float atlas::SpotLightUbo::constant;\n</code></pre>"},{"location":"References/structatlas_1_1SpotLightUbo/#variable-cut_off","title":"variable cut_off","text":"<pre><code>float atlas::SpotLightUbo::cut_off;\n</code></pre>"},{"location":"References/structatlas_1_1SpotLightUbo/#variable-diffuse","title":"variable diffuse","text":"<pre><code>glm::vec3 atlas::SpotLightUbo::diffuse;\n</code></pre>"},{"location":"References/structatlas_1_1SpotLightUbo/#variable-linear","title":"variable linear","text":"<pre><code>float atlas::SpotLightUbo::linear;\n</code></pre>"},{"location":"References/structatlas_1_1SpotLightUbo/#variable-outer_cut_off","title":"variable outer_cut_off","text":"<pre><code>float atlas::SpotLightUbo::outer_cut_off;\n</code></pre>"},{"location":"References/structatlas_1_1SpotLightUbo/#variable-quadratic","title":"variable quadratic","text":"<pre><code>float atlas::SpotLightUbo::quadratic;\n</code></pre>"},{"location":"References/structatlas_1_1SpotLightUbo/#variable-specular","title":"variable specular","text":"<pre><code>glm::vec3 atlas::SpotLightUbo::specular;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/uniform.hpp</code></p>"},{"location":"References/classatlas_1_1UniformBuffer/","title":"Class atlas::UniformBuffer","text":"<p>ClassList &gt; atlas &gt; UniformBuffer</p>"},{"location":"References/classatlas_1_1UniformBuffer/#public-functions","title":"Public Functions","text":"Type Name UniformBuffer (uint32_t p_BindingIndex)"},{"location":"References/classatlas_1_1UniformBuffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1UniformBuffer/#function-uniformbuffer","title":"function UniformBuffer","text":"<pre><code>atlas::UniformBuffer::UniformBuffer (\n    uint32_t p_BindingIndex\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/uniform_buffer.hpp</code></p>"},{"location":"References/classatlas_1_1VulkanImGui/","title":"Class atlas::VulkanImGui","text":"<p>ClassList &gt; atlas &gt; VulkanImGui</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_imgui.hpp</code></p>"},{"location":"References/classatlas_1_1application/","title":"Class atlas::application","text":"<p>ClassList &gt; atlas &gt; application</p>"},{"location":"References/classatlas_1_1application/#public-functions","title":"Public Functions","text":"Type Name application (const application_settings &amp; p_settings)  void execute ()  ref&lt; swapchain &gt; get_current_swapchain ()  ~application ()"},{"location":"References/classatlas_1_1application/#public-static-functions","title":"Public Static Functions","text":"Type Name API current_api ()  float delta_time ()  void destroy ()  uint32_t get_aspect_ratio ()  window &amp; get_window ()  float physics_step ()"},{"location":"References/classatlas_1_1application/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1application/#function-application","title":"function application","text":"<pre><code>atlas::application::application (\n    const application_settings &amp; p_settings\n) \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-execute","title":"function execute","text":"<pre><code>void atlas::application::execute () \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-get_current_swapchain","title":"function get_current_swapchain","text":"<pre><code>ref&lt; swapchain &gt; atlas::application::get_current_swapchain () \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-application_1","title":"function ~application","text":"<pre><code>atlas::application::~application () \n</code></pre>"},{"location":"References/classatlas_1_1application/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1application/#function-current_api","title":"function current_api","text":"<pre><code>static API atlas::application::current_api () \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-delta_time","title":"function delta_time","text":"<pre><code>static float atlas::application::delta_time () \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-destroy","title":"function destroy","text":"<pre><code>static void atlas::application::destroy () \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-get_aspect_ratio","title":"function get_aspect_ratio","text":"<pre><code>static uint32_t atlas::application::get_aspect_ratio () \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-get_window","title":"function get_window","text":"<pre><code>static inline window &amp; atlas::application::get_window () \n</code></pre>"},{"location":"References/classatlas_1_1application/#function-physics_step","title":"function physics_step","text":"<pre><code>static float atlas::application::physics_step () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/application.hpp</code></p>"},{"location":"References/structatlas_1_1application__settings/","title":"Struct atlas::application_settings","text":"<p>ClassList &gt; atlas &gt; application_settings</p>"},{"location":"References/structatlas_1_1application__settings/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t Height   = <code>0</code> std::string Name   = <code>\"Undefined\"</code> uint32_t Width   = <code>0</code>"},{"location":"References/structatlas_1_1application__settings/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1application__settings/#variable-height","title":"variable Height","text":"<pre><code>uint32_t atlas::application_settings::Height;\n</code></pre>"},{"location":"References/structatlas_1_1application__settings/#variable-name","title":"variable Name","text":"<pre><code>std::string atlas::application_settings::Name;\n</code></pre>"},{"location":"References/structatlas_1_1application__settings/#variable-width","title":"variable Width","text":"<pre><code>uint32_t atlas::application_settings::Width;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/application.hpp</code></p>"},{"location":"References/structatlas_1_1box__collider3d/","title":"Struct atlas::box_collider3d","text":"<p>ClassList &gt; atlas &gt; box_collider3d</p> <p>More...</p> <ul> <li><code>#include &lt;components.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1box__collider3d/#public-attributes","title":"Public Attributes","text":"Type Name float density   = <code>1.0f</code> float friction   = <code>0.5f</code> glm::vec3 offset   = <code>{ 0.f, 0.f, 0.f }</code> float restitution   = <code>0.0f</code> float restitutionThreshold   = <code>0.5f</code> glm::vec3 size   = <code>{ 0.5f, 0.5f, 0.5f }</code>"},{"location":"References/structatlas_1_1box__collider3d/#public-functions","title":"Public Functions","text":"Type Name box_collider3d () = default box_collider3d (const box_collider3d &amp;) = default"},{"location":"References/structatlas_1_1box__collider3d/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Our interpretation of the BoxCollider that will get interpreted based on physics API's enabled </p>"},{"location":"References/structatlas_1_1box__collider3d/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1box__collider3d/#variable-density","title":"variable density","text":"<pre><code>float atlas::box_collider3d::density;\n</code></pre>"},{"location":"References/structatlas_1_1box__collider3d/#variable-friction","title":"variable friction","text":"<pre><code>float atlas::box_collider3d::friction;\n</code></pre>"},{"location":"References/structatlas_1_1box__collider3d/#variable-offset","title":"variable offset","text":"<pre><code>glm::vec3 atlas::box_collider3d::offset;\n</code></pre>"},{"location":"References/structatlas_1_1box__collider3d/#variable-restitution","title":"variable restitution","text":"<pre><code>float atlas::box_collider3d::restitution;\n</code></pre>"},{"location":"References/structatlas_1_1box__collider3d/#variable-restitutionthreshold","title":"variable restitutionThreshold","text":"<pre><code>float atlas::box_collider3d::restitutionThreshold;\n</code></pre>"},{"location":"References/structatlas_1_1box__collider3d/#variable-size","title":"variable size","text":"<pre><code>glm::vec3 atlas::box_collider3d::size;\n</code></pre>"},{"location":"References/structatlas_1_1box__collider3d/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1box__collider3d/#function-box_collider3d-12","title":"function box_collider3d [1/2]","text":"<pre><code>atlas::box_collider3d::box_collider3d () = default\n</code></pre>"},{"location":"References/structatlas_1_1box__collider3d/#function-box_collider3d-22","title":"function box_collider3d [2/2]","text":"<pre><code>atlas::box_collider3d::box_collider3d (\n    const box_collider3d &amp;\n) = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/components.hpp</code></p>"},{"location":"References/classatlas_1_1camera/","title":"Class atlas::camera","text":"<p>ClassList &gt; atlas &gt; camera</p> <p>More...</p> <ul> <li><code>#include &lt;components.hpp&gt;</code></li> </ul>"},{"location":"References/classatlas_1_1camera/#public-attributes","title":"Public Attributes","text":"Type Name float AspectRatio   = <code>0.f</code> glm::vec3 Down glm::vec3 EulerRotation bool IsMainCamera   = <code>false</code> glm::vec3 Left float MouseSensitivity   = <code>{}</code> float MovementSpeed   = <code>{}</code> glm::vec3 Position glm::mat4 Projection glm::vec3 Right glm::vec3 Up glm::mat4 View glm::vec3 WorldUp float Zoom   = <code>{}</code> float camera_mouse_sensitivity   = <code>2.5f</code> float camera_movement_sensitivity   = <code>2.5f</code>"},{"location":"References/classatlas_1_1camera/#public-functions","title":"Public Functions","text":"Type Name camera (glm::vec3 position=glm::vec3(0.0f, 1.50f, 0.0f), glm::vec3 up=glm::vec3(0.0f, -1.0f, 0.0f), float yaw=-90.0f, float pitch=0.0f)  float camera_sensitivity () const glm::vec3 get_front () const glm::mat4 get_projection () const glm::mat4 get_view () const void process_keyboard (CameraMovement p_direction, float p_delta_time)  void process_mouse_movement (float p_x, float p_y, bool p_constraint_pitch=true)  void process_mouse_scroll (float yoffset)  void set_mouse_speed (float p_sensitivity)  void set_movement_speed (float p_sensitivity) TODO: REMOVE THESE these should be user-defined. void update_proj_view ()"},{"location":"References/classatlas_1_1camera/#detailed-description","title":"Detailed Description","text":"<p>TODO: Camera class needs to strip out the following properties</p> <ul> <li>Zoom</li> </ul> <p>TODO: Camera should contain</p> <ul> <li>Position </li> </ul>"},{"location":"References/classatlas_1_1camera/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/classatlas_1_1camera/#variable-aspectratio","title":"variable AspectRatio","text":"<pre><code>float atlas::camera::AspectRatio;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-down","title":"variable Down","text":"<pre><code>glm::vec3 atlas::camera::Down;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-eulerrotation","title":"variable EulerRotation","text":"<pre><code>glm::vec3 atlas::camera::EulerRotation;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-ismaincamera","title":"variable IsMainCamera","text":"<pre><code>bool atlas::camera::IsMainCamera;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-left","title":"variable Left","text":"<pre><code>glm::vec3 atlas::camera::Left;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-mousesensitivity","title":"variable MouseSensitivity","text":"<pre><code>float atlas::camera::MouseSensitivity;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-movementspeed","title":"variable MovementSpeed","text":"<pre><code>float atlas::camera::MovementSpeed;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-position","title":"variable Position","text":"<pre><code>glm::vec3 atlas::camera::Position;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-projection","title":"variable Projection","text":"<pre><code>glm::mat4 atlas::camera::Projection;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-right","title":"variable Right","text":"<pre><code>glm::vec3 atlas::camera::Right;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-up","title":"variable Up","text":"<pre><code>glm::vec3 atlas::camera::Up;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-view","title":"variable View","text":"<pre><code>glm::mat4 atlas::camera::View;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-worldup","title":"variable WorldUp","text":"<pre><code>glm::vec3 atlas::camera::WorldUp;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-zoom","title":"variable Zoom","text":"<pre><code>float atlas::camera::Zoom;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-camera_mouse_sensitivity","title":"variable camera_mouse_sensitivity","text":"<pre><code>float atlas::camera::camera_mouse_sensitivity;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#variable-camera_movement_sensitivity","title":"variable camera_movement_sensitivity","text":"<pre><code>float atlas::camera::camera_movement_sensitivity;\n</code></pre>"},{"location":"References/classatlas_1_1camera/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1camera/#function-camera","title":"function camera","text":"<pre><code>inline atlas::camera::camera (\n    glm::vec3 position=glm::vec3(0.0f, 1.50f, 0.0f),\n    glm::vec3 up=glm::vec3(0.0f, -1.0f, 0.0f),\n    float yaw=-90.0f,\n    float pitch=0.0f\n) \n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-camera_sensitivity","title":"function camera_sensitivity","text":"<pre><code>inline float atlas::camera::camera_sensitivity () const\n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-get_front","title":"function get_front","text":"<pre><code>inline glm::vec3 atlas::camera::get_front () const\n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-get_projection","title":"function get_projection","text":"<pre><code>inline glm::mat4 atlas::camera::get_projection () const\n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-get_view","title":"function get_view","text":"<pre><code>inline glm::mat4 atlas::camera::get_view () const\n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-process_keyboard","title":"function process_keyboard","text":"<pre><code>inline void atlas::camera::process_keyboard (\n    CameraMovement p_direction,\n    float p_delta_time\n) \n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-process_mouse_movement","title":"function process_mouse_movement","text":"<pre><code>inline void atlas::camera::process_mouse_movement (\n    float p_x,\n    float p_y,\n    bool p_constraint_pitch=true\n) \n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-process_mouse_scroll","title":"function process_mouse_scroll","text":"<pre><code>inline void atlas::camera::process_mouse_scroll (\n    float yoffset\n) \n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-set_mouse_speed","title":"function set_mouse_speed","text":"<pre><code>inline void atlas::camera::set_mouse_speed (\n    float p_sensitivity\n) \n</code></pre>"},{"location":"References/classatlas_1_1camera/#function-set_movement_speed","title":"function set_movement_speed","text":"<p>TODO: REMOVE THESE these should be user-defined. <pre><code>inline void atlas::camera::set_movement_speed (\n    float p_sensitivity\n) \n</code></pre></p>"},{"location":"References/classatlas_1_1camera/#function-update_proj_view","title":"function update_proj_view","text":"<pre><code>inline void atlas::camera::update_proj_view () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/components.hpp</code></p>"},{"location":"References/structatlas_1_1camera__ubo/","title":"Struct atlas::camera_ubo","text":"<p>ClassList &gt; atlas &gt; camera_ubo</p>"},{"location":"References/structatlas_1_1camera__ubo/#public-attributes","title":"Public Attributes","text":"Type Name glm::mat4 Projection glm::mat4 View"},{"location":"References/structatlas_1_1camera__ubo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1camera__ubo/#variable-projection","title":"variable Projection","text":"<pre><code>glm::mat4 atlas::camera_ubo::Projection;\n</code></pre>"},{"location":"References/structatlas_1_1camera__ubo/#variable-view","title":"variable View","text":"<pre><code>glm::mat4 atlas::camera_ubo::View;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/uniform.hpp</code></p>"},{"location":"References/classatlas_1_1console__log__manager/","title":"Class atlas::console_log_manager","text":"<p>ClassList &gt; atlas &gt; console_log_manager</p>"},{"location":"References/classatlas_1_1console__log__manager/#public-static-functions","title":"Public Static Functions","text":"Type Name void create_new_logger (const std::string &amp; p_tag=\"Undefined Tag\")  ref&lt; spdlog::logger &gt; get (const std::string &amp; p_tag)  void initialize_logger_manager (const std::string &amp; pattern=\"%^[%T] %n: %v%$\")  void set_current_logger (const std::string &amp; p_tag=\"Undefined g_Tag in console_logger\")"},{"location":"References/classatlas_1_1console__log__manager/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1console__log__manager/#function-create_new_logger","title":"function create_new_logger","text":"<pre><code>static void atlas::console_log_manager::create_new_logger (\n    const std::string &amp; p_tag=\"Undefined Tag\"\n) \n</code></pre>"},{"location":"References/classatlas_1_1console__log__manager/#function-get","title":"function get","text":"<pre><code>static ref&lt; spdlog::logger &gt; atlas::console_log_manager::get (\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1console__log__manager/#function-initialize_logger_manager","title":"function initialize_logger_manager","text":"<pre><code>static void atlas::console_log_manager::initialize_logger_manager (\n    const std::string &amp; pattern=\"%^[%T] %n: %v%$\"\n) \n</code></pre> <p>Note:</p> <p>Used for initiating this console logger across engine3d supplying the pattern and application to dedicate log messages to </p>"},{"location":"References/classatlas_1_1console__log__manager/#function-set_current_logger","title":"function set_current_logger","text":"<pre><code>static void atlas::console_log_manager::set_current_logger (\n    const std::string &amp; p_tag=\"Undefined g_Tag in console_logger\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/engine_logger.hpp</code></p>"},{"location":"References/classatlas_1_1entity__t/","title":"Class atlas::entity_t","text":"<p>ClassList &gt; atlas &gt; entity_t</p>"},{"location":"References/classatlas_1_1entity__t/#public-functions","title":"Public Functions","text":"Type Name void add ()  entity_t () = default entity_t (flecs::world * p_registry, const std::string &amp; p_tag)  entity_t (const flecs::entity &amp; p_entity)  const UComponent * get () const UComponent * get_mut () const bool has () const bool is_alive () const void on_destruction ()  entity () const entity ()  void remove ()  void set (const UComponent &amp; p_component)  void set (const UComponent1 &amp; p_component1, const UComponent2 &amp; p_component2)  ~entity_t ()"},{"location":"References/classatlas_1_1entity__t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1entity__t/#function-add","title":"function add","text":"<pre><code>template&lt;typename UComponent&gt;\ninline void atlas::entity_t::add () \n</code></pre> <p>Note:</p> <p>Creates component in the ECS storage but does not assign it with a value. </p>"},{"location":"References/classatlas_1_1entity__t/#function-entity_t-13","title":"function entity_t [1/3]","text":"<pre><code>atlas::entity_t::entity_t () = default\n</code></pre>"},{"location":"References/classatlas_1_1entity__t/#function-entity_t-23","title":"function entity_t [2/3]","text":"<pre><code>atlas::entity_t::entity_t (\n    flecs::world * p_registry,\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1entity__t/#function-entity_t-33","title":"function entity_t [3/3]","text":"<pre><code>inline atlas::entity_t::entity_t (\n    const flecs::entity &amp; p_entity\n) \n</code></pre>"},{"location":"References/classatlas_1_1entity__t/#function-get","title":"function get","text":"<pre><code>template&lt;typename UComponent&gt;\ninline const UComponent * atlas::entity_t::get () const\n</code></pre> <p>Note:</p> <p>Returns the component from the entity </p> <p>Note:</p> <p>Flecs has you return a pointer for checking if the component is found </p> <p>Note:</p> <p>If not found will return nullptr </p>"},{"location":"References/classatlas_1_1entity__t/#function-get_mut","title":"function get_mut","text":"<pre><code>template&lt;typename UComponent&gt;\ninline UComponent * atlas::entity_t::get_mut () const\n</code></pre>"},{"location":"References/classatlas_1_1entity__t/#function-has","title":"function has","text":"<pre><code>template&lt;typename UComponent&gt;\ninline bool atlas::entity_t::has () const\n</code></pre> <p>Note:</p> <p>Checks if specific component of type UComponent is provided to this entity </p>"},{"location":"References/classatlas_1_1entity__t/#function-is_alive","title":"function is_alive","text":"<pre><code>inline bool atlas::entity_t::is_alive () const\n</code></pre> <p>Note:</p> <p>Flecs allows to check when an entity has been created </p> <p>Note:</p> <p>Knowing when this entity lifecyle's ended </p>"},{"location":"References/classatlas_1_1entity__t/#function-on_destruction","title":"function on_destruction","text":"<pre><code>inline void atlas::entity_t::on_destruction () \n</code></pre>"},{"location":"References/classatlas_1_1entity__t/#function-entity-12","title":"function entity [1/2]","text":"<pre><code>inline atlas::entity_t::entity () const\n</code></pre>"},{"location":"References/classatlas_1_1entity__t/#function-entity-22","title":"function entity [2/2]","text":"<pre><code>inline atlas::entity_t::entity () \n</code></pre>"},{"location":"References/classatlas_1_1entity__t/#function-remove","title":"function remove","text":"<pre><code>template&lt;typename UComponent&gt;\ninline void atlas::entity_t::remove () \n</code></pre>"},{"location":"References/classatlas_1_1entity__t/#function-set-12","title":"function set [1/2]","text":"<pre><code>template&lt;typename UComponent&gt;\ninline void atlas::entity_t::set (\n    const UComponent &amp; p_component\n) \n</code></pre> <p>Note:</p> <p>Setting a component TODO: Try to allow the set component to be set to its initial value Initial value should be set when the component that is set is empty </p>"},{"location":"References/classatlas_1_1entity__t/#function-set-22","title":"function set [2/2]","text":"<pre><code>template&lt;typename UComponent1, typename UComponent2&gt;\ninline void atlas::entity_t::set (\n    const UComponent1 &amp; p_component1,\n    const UComponent2 &amp; p_component2\n) \n</code></pre> <p>Note:</p> <p>Set value for position and velocity component </p> <p>Note:</p> <p>Flecs set component will be added if entity doesn't the component </p> <p>Note:</p> <p>This is for setting multiple different components to be stored into the entity </p>"},{"location":"References/classatlas_1_1entity__t/#function-entity_t","title":"function ~entity_t","text":"<pre><code>atlas::entity_t::~entity_t () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/entity.hpp</code></p>"},{"location":"References/namespaceatlas_1_1event/","title":"Namespace atlas::event","text":"<p>Namespace List &gt; atlas &gt; event</p>"},{"location":"References/namespaceatlas_1_1event/#classes","title":"Classes","text":"Type Name struct joystick_button struct joystick_info"},{"location":"References/namespaceatlas_1_1event/#public-types","title":"Public Types","text":"Type Name enum int JoystickCodes enum uint32_t Key enum uint32_t Mouse enum input_state"},{"location":"References/namespaceatlas_1_1event/#public-functions","title":"Public Functions","text":"Type Name glm::vec2 cursor_position ()  float get_joystic_axis (int p_controller_id, int p_button)  bool is_joystic_present (int p_controller_id)  bool is_joystick_button_pressed (int p_button)  bool is_joystick_button_released (int p_button)  const char * is_joystick_guid (int p_controller_id)  bool is_key_pressed (int p_key)  bool is_key_released (int p_key)  bool is_mouse_pressed (int p_mouse_code)  bool is_mouse_released (int p_mouse_code)  void update_events ()  void wait_for_events ()"},{"location":"References/namespaceatlas_1_1event/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"References/namespaceatlas_1_1event/#enum-joystickcodes","title":"enum JoystickCodes","text":"<pre><code>enum atlas::event::JoystickCodes {\n    Joystick1 = 0,\n    Joystick2 = 1,\n    Joystick3 = 2,\n    Joystick4 = 3,\n    Joystick5 = 4,\n    Joystick6 = 5,\n    Joystick7 = 6,\n    Joystick8 = 7,\n    Joystick9 = 8,\n    Joystick10 = 9,\n    Joystick11 = 10,\n    Joystick12 = 11,\n    Joystick13 = 12,\n    Joystick14 = 13,\n    Joystick15 = 14,\n    Joystick16 = 15,\n    JoystickLAST = Joystick16\n};\n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#enum-key","title":"enum Key","text":"<pre><code>enum atlas::event::Key {\n    Space = 32,\n    Apostrophe = 39,\n    Comma = 44,\n    Minus = 45,\n    Period = 46,\n    Slash = 47,\n    D0 = 48,\n    D1 = 49,\n    D2 = 50,\n    D3 = 51,\n    D4 = 52,\n    D5 = 53,\n    D6 = 54,\n    D7 = 55,\n    D8 = 56,\n    D9 = 57,\n    Semicolon = 59,\n    Equal = 61,\n    A = 65,\n    B = 66,\n    C = 67,\n    D = 68,\n    E = 69,\n    F = 70,\n    G = 71,\n    H = 72,\n    I = 73,\n    J = 74,\n    K = 75,\n    L = 76,\n    M = 77,\n    N = 78,\n    O = 79,\n    P = 80,\n    Q = 81,\n    R = 82,\n    S = 83,\n    T = 84,\n    U = 85,\n    V = 86,\n    W = 87,\n    X = 88,\n    Y = 89,\n    Z = 90,\n    LeftBracket = 91,\n    Backslash = 92,\n    RightBracket = 93,\n    GraveAccent = 96,\n    World1 = 161,\n    World2 = 162,\n    Escape = 256,\n    Enter = 257,\n    Tab = 258,\n    Backspace = 259,\n    Insert = 260,\n    Delete = 261,\n    Right = 262,\n    Left = 263,\n    Down = 264,\n    Up = 265,\n    PageUp = 266,\n    PageDown = 267,\n    Home = 268,\n    End = 269,\n    CapsLock = 280,\n    ScrollLock = 281,\n    NumLock = 282,\n    PrintScreen = 283,\n    Pause = 284,\n    F1 = 290,\n    F2 = 291,\n    F3 = 292,\n    F4 = 293,\n    F5 = 294,\n    F6 = 295,\n    F7 = 296,\n    F8 = 297,\n    F9 = 298,\n    F10 = 299,\n    F11 = 300,\n    F12 = 301,\n    F13 = 302,\n    F14 = 303,\n    F15 = 304,\n    F16 = 305,\n    F17 = 306,\n    F18 = 307,\n    F19 = 308,\n    F20 = 309,\n    F21 = 310,\n    F22 = 311,\n    F23 = 312,\n    F24 = 313,\n    F25 = 314,\n    KP0 = 320,\n    KP1 = 321,\n    KP2 = 322,\n    KP3 = 323,\n    KP4 = 324,\n    KP5 = 325,\n    KP6 = 326,\n    KP7 = 327,\n    KP8 = 328,\n    KP9 = 329,\n    KPDecimal = 330,\n    KPDivide = 331,\n    KPMultiply = 332,\n    KPSubtract = 333,\n    KPAdd = 334,\n    KPEnter = 335,\n    KPEqual = 336,\n    LeftShift = 340,\n    LeftControl = 341,\n    LeftAlt = 342,\n    Leftsuper = 343,\n    RightShift = 344,\n    RightControl = 345,\n    RightAlt = 346,\n    Rightsuper = 347,\n    Menu = 348\n};\n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#enum-mouse","title":"enum Mouse","text":"<pre><code>enum atlas::event::Mouse {\n    Button0 = 0,\n    Button1 = 1,\n    Button2 = 2,\n    Button3 = 3,\n    Button4 = 4,\n    Button5 = 5,\n    Button6 = 6,\n    Button7 = 7,\n    ButtonLast = Button7,\n    ButtonLeft = Button0,\n    ButtonRight = Button1,\n    ButtonMiddle = Button2\n};\n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#enum-input_state","title":"enum input_state","text":"<pre><code>enum atlas::event::input_state {\n    None,\n    Idle,\n    Pressed,\n    Released\n};\n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1event/#function-cursor_position","title":"function cursor_position","text":"<pre><code>glm::vec2 atlas::event::cursor_position () \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-get_joystic_axis","title":"function get_joystic_axis","text":"<pre><code>float atlas::event::get_joystic_axis (\n    int p_controller_id,\n    int p_button\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_joystic_present","title":"function is_joystic_present","text":"<pre><code>bool atlas::event::is_joystic_present (\n    int p_controller_id\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_joystick_button_pressed","title":"function is_joystick_button_pressed","text":"<pre><code>bool atlas::event::is_joystick_button_pressed (\n    int p_button\n) \n</code></pre> <p>Note:</p> <p>FIXME: Make button later </p>"},{"location":"References/namespaceatlas_1_1event/#function-is_joystick_button_released","title":"function is_joystick_button_released","text":"<pre><code>bool atlas::event::is_joystick_button_released (\n    int p_button\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_joystick_guid","title":"function is_joystick_guid","text":"<pre><code>const char * atlas::event::is_joystick_guid (\n    int p_controller_id\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_key_pressed","title":"function is_key_pressed","text":"<pre><code>bool atlas::event::is_key_pressed (\n    int p_key\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_key_released","title":"function is_key_released","text":"<pre><code>bool atlas::event::is_key_released (\n    int p_key\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_mouse_pressed","title":"function is_mouse_pressed","text":"<pre><code>bool atlas::event::is_mouse_pressed (\n    int p_mouse_code\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-is_mouse_released","title":"function is_mouse_released","text":"<pre><code>bool atlas::event::is_mouse_released (\n    int p_mouse_code\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-update_events","title":"function update_events","text":"<pre><code>void atlas::event::update_events () \n</code></pre>"},{"location":"References/namespaceatlas_1_1event/#function-wait_for_events","title":"function wait_for_events","text":"<pre><code>void atlas::event::wait_for_events () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/event/event.hpp</code></p>"},{"location":"References/structatlas_1_1event_1_1joystick__button/","title":"Struct atlas::event::joystick_button","text":"<p>ClassList &gt; atlas &gt; event &gt; joystick_button</p>"},{"location":"References/structatlas_1_1event_1_1joystick__button/#public-attributes","title":"Public Attributes","text":"Type Name input_state ButtonState   = <code>input\\_state::None</code> int ID   = <code>-1</code> std::string Name   = <code>\"\"</code> input_state PreviousButtonState   = <code>input\\_state::None</code>"},{"location":"References/structatlas_1_1event_1_1joystick__button/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1event_1_1joystick__button/#variable-buttonstate","title":"variable ButtonState","text":"<pre><code>input_state atlas::event::joystick_button::ButtonState;\n</code></pre>"},{"location":"References/structatlas_1_1event_1_1joystick__button/#variable-id","title":"variable ID","text":"<pre><code>int atlas::event::joystick_button::ID;\n</code></pre>"},{"location":"References/structatlas_1_1event_1_1joystick__button/#variable-name","title":"variable Name","text":"<pre><code>std::string atlas::event::joystick_button::Name;\n</code></pre>"},{"location":"References/structatlas_1_1event_1_1joystick__button/#variable-previousbuttonstate","title":"variable PreviousButtonState","text":"<pre><code>input_state atlas::event::joystick_button::PreviousButtonState;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/event/event.hpp</code></p>"},{"location":"References/structatlas_1_1event_1_1joystick__info/","title":"Struct atlas::event::joystick_info","text":"<p>ClassList &gt; atlas &gt; event &gt; joystick_info</p>"},{"location":"References/structatlas_1_1event_1_1joystick__info/#public-attributes","title":"Public Attributes","text":"Type Name std::map&lt; int, const float * &gt; AxesOfController std::map&lt; int, joystick_button &gt; Buttons std::map&lt; int, bool &gt; ButtonsDown int ID   = <code>-1</code> std::string JoystickName   = <code>\"Default\"</code>"},{"location":"References/structatlas_1_1event_1_1joystick__info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1event_1_1joystick__info/#variable-axesofcontroller","title":"variable AxesOfController","text":"<pre><code>std::map&lt;int, const float*&gt; atlas::event::joystick_info::AxesOfController;\n</code></pre>"},{"location":"References/structatlas_1_1event_1_1joystick__info/#variable-buttons","title":"variable Buttons","text":"<pre><code>std::map&lt;int, joystick_button&gt; atlas::event::joystick_info::Buttons;\n</code></pre>"},{"location":"References/structatlas_1_1event_1_1joystick__info/#variable-buttonsdown","title":"variable ButtonsDown","text":"<pre><code>std::map&lt;int, bool&gt; atlas::event::joystick_info::ButtonsDown;\n</code></pre>"},{"location":"References/structatlas_1_1event_1_1joystick__info/#variable-id","title":"variable ID","text":"<pre><code>int atlas::event::joystick_info::ID;\n</code></pre>"},{"location":"References/structatlas_1_1event_1_1joystick__info/#variable-joystickname","title":"variable JoystickName","text":"<pre><code>std::string atlas::event::joystick_info::JoystickName;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/event/event.hpp</code></p>"},{"location":"References/namespaceatlas_1_1filesystem/","title":"Namespace atlas::filesystem","text":"<p>Namespace List &gt; atlas &gt; filesystem</p>"},{"location":"References/namespaceatlas_1_1filesystem/#public-functions","title":"Public Functions","text":"Type Name std::string load_from_file_dialog (const std::string &amp; p_filter)  std::string save_to_file (const std::string &amp; p_filter)"},{"location":"References/namespaceatlas_1_1filesystem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1filesystem/#function-load_from_file_dialog","title":"function load_from_file_dialog","text":"<pre><code>std::string atlas::filesystem::load_from_file_dialog (\n    const std::string &amp; p_filter\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1filesystem/#function-save_to_file","title":"function save_to_file","text":"<pre><code>std::string atlas::filesystem::save_to_file (\n    const std::string &amp; p_filter\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/filesystem/file_dialog.hpp</code></p>"},{"location":"References/classatlas_1_1imgui__backend/","title":"Class atlas::imgui_backend","text":"<p>ClassList &gt; atlas &gt; imgui_backend</p>"},{"location":"References/classatlas_1_1imgui__backend/#public-static-functions","title":"Public Static Functions","text":"Type Name void begin ()  void end ()  void initialize ()"},{"location":"References/classatlas_1_1imgui__backend/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1imgui__backend/#function-begin","title":"function begin","text":"<pre><code>static void atlas::imgui_backend::begin () \n</code></pre>"},{"location":"References/classatlas_1_1imgui__backend/#function-end","title":"function end","text":"<pre><code>static void atlas::imgui_backend::end () \n</code></pre>"},{"location":"References/classatlas_1_1imgui__backend/#function-initialize","title":"function initialize","text":"<pre><code>static void atlas::imgui_backend::initialize () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/ui/imgui_backend.hpp</code></p>"},{"location":"References/classatlas_1_1index__buffer/","title":"Class atlas::index_buffer","text":"<p>ClassList &gt; atlas &gt; index_buffer</p> <p>Inherited by the following classes: atlas::vk::vk_index_buffer</p>"},{"location":"References/classatlas_1_1index__buffer/#public-functions","title":"Public Functions","text":"Type Name void bind (const VkCommandBuffer &amp; p_command_buffer)  void draw (const VkCommandBuffer &amp; p_command_buffer)  bool has_indices () const virtual ~index_buffer () = default"},{"location":"References/classatlas_1_1index__buffer/#public-static-functions","title":"Public Static Functions","text":"Type Name ref&lt; index_buffer &gt; create (const std::vector&lt; uint32_t &gt; &amp; p_indices)"},{"location":"References/classatlas_1_1index__buffer/#protected-functions","title":"Protected Functions","text":"Type Name virtual void bind_to_index_buffer (const VkCommandBuffer &amp; p_command_buffer) = 0 virtual bool contains_indices () const = 0 virtual void render_index_buffer (const VkCommandBuffer &amp; p_command_buffer) = 0"},{"location":"References/classatlas_1_1index__buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1index__buffer/#function-bind","title":"function bind","text":"<pre><code>void atlas::index_buffer::bind (\n    const VkCommandBuffer &amp; p_command_buffer\n) \n</code></pre>"},{"location":"References/classatlas_1_1index__buffer/#function-draw","title":"function draw","text":"<pre><code>void atlas::index_buffer::draw (\n    const VkCommandBuffer &amp; p_command_buffer\n) \n</code></pre>"},{"location":"References/classatlas_1_1index__buffer/#function-has_indices","title":"function has_indices","text":"<pre><code>bool atlas::index_buffer::has_indices () const\n</code></pre>"},{"location":"References/classatlas_1_1index__buffer/#function-index_buffer","title":"function ~index_buffer","text":"<pre><code>virtual atlas::index_buffer::~index_buffer () = default\n</code></pre>"},{"location":"References/classatlas_1_1index__buffer/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1index__buffer/#function-create","title":"function create","text":"<pre><code>static ref&lt; index_buffer &gt; atlas::index_buffer::create (\n    const std::vector&lt; uint32_t &gt; &amp; p_indices\n) \n</code></pre>"},{"location":"References/classatlas_1_1index__buffer/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"References/classatlas_1_1index__buffer/#function-bind_to_index_buffer","title":"function bind_to_index_buffer","text":"<pre><code>virtual void atlas::index_buffer::bind_to_index_buffer (\n    const VkCommandBuffer &amp; p_command_buffer\n) = 0\n</code></pre>"},{"location":"References/classatlas_1_1index__buffer/#function-contains_indices","title":"function contains_indices","text":"<pre><code>virtual bool atlas::index_buffer::contains_indices () const = 0\n</code></pre>"},{"location":"References/classatlas_1_1index__buffer/#function-render_index_buffer","title":"function render_index_buffer","text":"<pre><code>virtual void atlas::index_buffer::render_index_buffer (\n    const VkCommandBuffer &amp; p_command_buffer\n) = 0\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/index_buffer.hpp</code></p>"},{"location":"References/classatlas_1_1interpolation/","title":"Class atlas::interpolation","text":"<p>ClassList &gt; atlas &gt; interpolation</p>"},{"location":"References/classatlas_1_1interpolation/#public-static-functions","title":"Public Static Functions","text":"Type Name T linear_interpolate (T start, T end, const std::function&lt; float(float)&gt; &amp; function, float t)"},{"location":"References/classatlas_1_1interpolation/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1interpolation/#function-linear_interpolate","title":"function linear_interpolate","text":"<pre><code>template&lt;typename T&gt;\nstatic inline T atlas::interpolation::linear_interpolate (\n    T start,\n    T end,\n    const std::function&lt; float(float)&gt; &amp; function,\n    float t\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/math.hpp</code></p>"},{"location":"References/structatlas_1_1light/","title":"Struct atlas::light","text":"<p>ClassList &gt; atlas &gt; light</p> <p>TODO: Make this better (when we do lighting) </p> <ul> <li><code>#include &lt;components.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1light/#public-attributes","title":"Public Attributes","text":"Type Name glm::vec3 Position   = <code>{ 1.f }</code>"},{"location":"References/structatlas_1_1light/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1light/#variable-position","title":"variable Position","text":"<pre><code>glm::vec3 atlas::light::Position;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/components.hpp</code></p>"},{"location":"References/structatlas_1_1math__generic/","title":"Struct atlas::math_generic","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; math_generic</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/structatlas_1_1matrix2/","title":"Struct atlas::matrix2","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; matrix2</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/structatlas_1_1matrix3/","title":"Struct atlas::matrix3","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; matrix3</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/structatlas_1_1matrix4/","title":"Struct atlas::matrix4","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; matrix4</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/classatlas_1_1mesh/","title":"Class atlas::mesh","text":"<p>ClassList &gt; atlas &gt; mesh</p>"},{"location":"References/classatlas_1_1mesh/#public-functions","title":"Public Functions","text":"Type Name ref&lt; index_buffer &gt; &amp; get_index_buffer ()  ref&lt; vertex_buffer &gt; &amp; get_vertex_buffer ()  bool is_loaded () const mesh () = default mesh (const std::string &amp; p_filepath)  mesh (const ref&lt; vertex_buffer &gt; &amp; p_vertex_buffer, const ref&lt; index_buffer &gt; &amp; p_index_buffer)"},{"location":"References/classatlas_1_1mesh/#public-static-functions","title":"Public Static Functions","text":"Type Name mesh load (const std::string &amp; p_filepath)"},{"location":"References/classatlas_1_1mesh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1mesh/#function-get_index_buffer","title":"function get_index_buffer","text":"<pre><code>inline ref&lt; index_buffer &gt; &amp; atlas::mesh::get_index_buffer () \n</code></pre>"},{"location":"References/classatlas_1_1mesh/#function-get_vertex_buffer","title":"function get_vertex_buffer","text":"<pre><code>inline ref&lt; vertex_buffer &gt; &amp; atlas::mesh::get_vertex_buffer () \n</code></pre>"},{"location":"References/classatlas_1_1mesh/#function-is_loaded","title":"function is_loaded","text":"<pre><code>bool atlas::mesh::is_loaded () const\n</code></pre>"},{"location":"References/classatlas_1_1mesh/#function-mesh-13","title":"function mesh [1/3]","text":"<pre><code>atlas::mesh::mesh () = default\n</code></pre>"},{"location":"References/classatlas_1_1mesh/#function-mesh-23","title":"function mesh [2/3]","text":"<pre><code>atlas::mesh::mesh (\n    const std::string &amp; p_filepath\n) \n</code></pre>"},{"location":"References/classatlas_1_1mesh/#function-mesh-33","title":"function mesh [3/3]","text":"<pre><code>atlas::mesh::mesh (\n    const ref&lt; vertex_buffer &gt; &amp; p_vertex_buffer,\n    const ref&lt; index_buffer &gt; &amp; p_index_buffer\n) \n</code></pre>"},{"location":"References/classatlas_1_1mesh/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1mesh/#function-load","title":"function load","text":"<pre><code>static mesh atlas::mesh::load (\n    const std::string &amp; p_filepath\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/geometry/mesh.hpp</code></p>"},{"location":"References/namespaceatlas_1_1physics/","title":"Namespace atlas::physics","text":"<p>Namespace List &gt; atlas &gt; physics</p>"},{"location":"References/namespaceatlas_1_1physics/#classes","title":"Classes","text":"Type Name class JoltPhysicBody struct jolt_config Used to keep global data for player access and use. Tells how physics bodies should act within a given scene by default. struct jolt_settings A data structure to give to flecs and get the physics. class physics_engine"},{"location":"References/namespaceatlas_1_1physics/#public-functions","title":"Public Functions","text":"Type Name void create (ref&lt; atlas::scene_object &gt; physics_object) Initializes physics global data for a particular scene. void create_engine (const jolt_settings &amp; settings) Initializes physics global data for a particular scene."},{"location":"References/namespaceatlas_1_1physics/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1physics/#function-create","title":"function create","text":"<p>Initializes physics global data for a particular scene. <pre><code>void atlas::physics::create (\n    ref&lt; atlas::scene_object &gt; physics_object\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>physics_object</code> An entity to allow the user to control the data from the hierarchy. (within the editor) </li> </ul>"},{"location":"References/namespaceatlas_1_1physics/#function-create_engine","title":"function create_engine","text":"<p>Initializes physics global data for a particular scene. <pre><code>void atlas::physics::create_engine (\n    const jolt_settings &amp; settings\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>physics_object</code> An entity to allow the user to control the data from the hierarchy. (within the editor) </li> </ul> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/helper_functions.hpp</code></p>"},{"location":"References/classatlas_1_1physics_1_1JoltPhysicBody/","title":"Class atlas::physics::JoltPhysicBody","text":"<p>ClassList &gt; atlas &gt; physics &gt; JoltPhysicBody</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_body.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/","title":"Struct atlas::physics::jolt_config","text":"<p>ClassList &gt; atlas &gt; physics &gt; jolt_config</p> <p>Used to keep global data for player access and use. Tells how physics bodies should act within a given scene by default. </p> <ul> <li><code>#include &lt;jolt_config.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#public-attributes","title":"Public Attributes","text":"Type Name float contact_bias_factor   = <code>0.2f</code> bool enable_collision_callbacks   = <code>true</code> bool enable_constraints   = <code>true</code> bool enable_contacts   = <code>true</code> float fixed_time_step   = <code>1.0f / 60.0f</code> glm::vec3 gravity   = <code>glm::vec3(0.0f, -9.80665f, 0.0f)</code> uint32_t position_iterations   = <code>6</code> float restitution_threshold   = <code>1.0f</code> float sleep_angular_velocity_threshold   = <code>0.05f</code> float sleep_velocity_threshold   = <code>0.05f</code> float time_before_sleep   = <code>5.0f</code> bool use_fixed_timestep   = <code>false</code> uint32_t velocity_iterations   = <code>6</code> float world_unit_scale   = <code>1.0f</code>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-contact_bias_factor","title":"variable contact_bias_factor","text":"<pre><code>float atlas::physics::jolt_config::contact_bias_factor;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-enable_collision_callbacks","title":"variable enable_collision_callbacks","text":"<pre><code>bool atlas::physics::jolt_config::enable_collision_callbacks;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-enable_constraints","title":"variable enable_constraints","text":"<pre><code>bool atlas::physics::jolt_config::enable_constraints;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-enable_contacts","title":"variable enable_contacts","text":"<pre><code>bool atlas::physics::jolt_config::enable_contacts;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-fixed_time_step","title":"variable fixed_time_step","text":"<pre><code>float atlas::physics::jolt_config::fixed_time_step;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-gravity","title":"variable gravity","text":"<pre><code>glm::vec3 atlas::physics::jolt_config::gravity;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-position_iterations","title":"variable position_iterations","text":"<pre><code>uint32_t atlas::physics::jolt_config::position_iterations;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-restitution_threshold","title":"variable restitution_threshold","text":"<pre><code>float atlas::physics::jolt_config::restitution_threshold;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-sleep_angular_velocity_threshold","title":"variable sleep_angular_velocity_threshold","text":"<pre><code>float atlas::physics::jolt_config::sleep_angular_velocity_threshold;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-sleep_velocity_threshold","title":"variable sleep_velocity_threshold","text":"<pre><code>float atlas::physics::jolt_config::sleep_velocity_threshold;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-time_before_sleep","title":"variable time_before_sleep","text":"<pre><code>float atlas::physics::jolt_config::time_before_sleep;\n</code></pre> <p>Note:</p> <p>In seconds </p>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-use_fixed_timestep","title":"variable use_fixed_timestep","text":"<pre><code>bool atlas::physics::jolt_config::use_fixed_timestep;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-velocity_iterations","title":"variable velocity_iterations","text":"<pre><code>uint32_t atlas::physics::jolt_config::velocity_iterations;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__config/#variable-world_unit_scale","title":"variable world_unit_scale","text":"<pre><code>float atlas::physics::jolt_config::world_unit_scale;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/data/jolt_config.hpp</code></p>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/","title":"Struct atlas::physics::jolt_settings","text":"<p>ClassList &gt; atlas &gt; physics &gt; jolt_settings</p> <p>A data structure to give to flecs and get the physics. More...</p> <ul> <li><code>#include &lt;jolt_settings.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#public-attributes","title":"Public Attributes","text":"Type Name float broadphase_scale   = <code>1.0f</code> uint32_t collision_filter_layer_count   = <code>32</code> uint32_t default_collision_group   = <code>0</code> uint32_t default_filter_mask   = <code>0xFFFFFFFF</code> bool is_multithreaded   = <code>true</code> uint32_t max_bodies   = <code>16384</code> uint32_t max_body_pairs   = <code>32768</code> uint32_t max_contact_constraints   = <code>8192</code> glm::vec3 physics_scene_position   = <code>glm::vec3(0.0f, 0.0f, 0.0f)</code> uint32_t physics_threads   = <code>std::thread::hardware\\_concurrency()</code> bool use_4_layer_broadphase   = <code>true</code> glm::vec3 world_bounds_max   = <code>glm::vec3(500.0f, 500.0f, 500.0f)</code> glm::vec3 world_bounds_min   = <code>glm::vec3(-500.0f, -500.0f, -500.0f)</code>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#detailed-description","title":"Detailed Description","text":""},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#engine-prepped-for-init-phase","title":"engine prepped for Init() phase.","text":"<p>Note:</p> <p>This includes global configs for each scene and how the </p>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#physics-engine-will-behave-in-a-paticular-scene","title":"physics engine will behave in a paticular scene.","text":"<p>Remark:</p> <p>world_bounds_min &amp;&amp; world_bounds_max: These values are arbitrary until further investigation happens and are more of a reminder that floating point error exsists. True max values should be determined in the near future. </p>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-broadphase_scale","title":"variable broadphase_scale","text":"<pre><code>float atlas::physics::jolt_settings::broadphase_scale;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-collision_filter_layer_count","title":"variable collision_filter_layer_count","text":"<pre><code>uint32_t atlas::physics::jolt_settings::collision_filter_layer_count;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-default_collision_group","title":"variable default_collision_group","text":"<pre><code>uint32_t atlas::physics::jolt_settings::default_collision_group;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-default_filter_mask","title":"variable default_filter_mask","text":"<pre><code>uint32_t atlas::physics::jolt_settings::default_filter_mask;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-is_multithreaded","title":"variable is_multithreaded","text":"<pre><code>bool atlas::physics::jolt_settings::is_multithreaded;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-max_bodies","title":"variable max_bodies","text":"<pre><code>uint32_t atlas::physics::jolt_settings::max_bodies;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-max_body_pairs","title":"variable max_body_pairs","text":"<pre><code>uint32_t atlas::physics::jolt_settings::max_body_pairs;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-max_contact_constraints","title":"variable max_contact_constraints","text":"<pre><code>uint32_t atlas::physics::jolt_settings::max_contact_constraints;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-physics_scene_position","title":"variable physics_scene_position","text":"<pre><code>glm::vec3 atlas::physics::jolt_settings::physics_scene_position;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-physics_threads","title":"variable physics_threads","text":"<pre><code>uint32_t atlas::physics::jolt_settings::physics_threads;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-use_4_layer_broadphase","title":"variable use_4_layer_broadphase","text":"<pre><code>bool atlas::physics::jolt_settings::use_4_layer_broadphase;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-world_bounds_max","title":"variable world_bounds_max","text":"<pre><code>glm::vec3 atlas::physics::jolt_settings::world_bounds_max;\n</code></pre>"},{"location":"References/structatlas_1_1physics_1_1jolt__settings/#variable-world_bounds_min","title":"variable world_bounds_min","text":"<pre><code>glm::vec3 atlas::physics::jolt_settings::world_bounds_min;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/data/jolt_settings.hpp</code></p>"},{"location":"References/classatlas_1_1physics_1_1physics__engine/","title":"Class atlas::physics::physics_engine","text":"<p>ClassList &gt; atlas &gt; physics &gt; physics_engine</p> <p>More...</p> <ul> <li><code>#include &lt;physics_engine.hpp&gt;</code></li> </ul>"},{"location":"References/classatlas_1_1physics_1_1physics__engine/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Used for indicating whether objects in a given scene are static or dynamic (meaning can collide with other objects) </p> <p>Note:</p> <p>Used as a representation for both ObjectLayer(uint16_t) and BroadPhaseLayer(class) </p> <p>Note:</p> <p>ObjectLayer just seems to be defined as a body type within joltphysics </p> <p>Note:</p> <p>BroadPhaseLayer is just joltphysic's representation of a collider pretty much. It is mainly used by the jolt physics collision detection system that uses it. Typically in JoltPhysics you'd have less of these then ObjectLayer's it seems</p> <p>Note:</p> <p>BroadPhaseLayer can be ways to map multiple object layers (BodyType's)</p> <p>Note:</p> <p>Physics settings per physic scene  ! </p> <p>Note:</p> <p>These are notes for myself on triggers. Just so I dont forget. Lets not think about this for the time being.</p> <p>Here is an idea for handling triggering events</p> <p>Utilize Event Dispatcher System</p> <p>Example API's</p> <p>Alternative #1</p> <p>Idea behind this is we get our event dispatcher. Then we go ahead and submit a trigerred event when sphere activates that specific event IDEA: We need to figure out a way to target specific objects and how they are able to submit triggering events so the event system is aware it is happening auto dispatcher = event::get_event(); dispatcher.dispatch&lt;SphereTriggered&gt;(sphere_object); </p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/physics_engine.hpp</code></p>"},{"location":"References/classatlas_1_1render__context/","title":"Class atlas::render_context","text":"<p>ClassList &gt; atlas &gt; render_context</p> <p>Inherited by the following classes: atlas::vk::vk_renderer</p>"},{"location":"References/classatlas_1_1render__context/#public-functions","title":"Public Functions","text":"Type Name void begin ()  void end ()  virtual ~render_context () = default"},{"location":"References/classatlas_1_1render__context/#public-static-functions","title":"Public Static Functions","text":"Type Name uint32_t get_current_frame ()  scope&lt; render_context &gt; initialize (const std::string &amp; p_tag)"},{"location":"References/classatlas_1_1render__context/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1render__context/#function-begin","title":"function begin","text":"<pre><code>void atlas::render_context::begin () \n</code></pre>"},{"location":"References/classatlas_1_1render__context/#function-end","title":"function end","text":"<pre><code>void atlas::render_context::end () \n</code></pre>"},{"location":"References/classatlas_1_1render__context/#function-render_context","title":"function ~render_context","text":"<pre><code>virtual atlas::render_context::~render_context () = default\n</code></pre>"},{"location":"References/classatlas_1_1render__context/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1render__context/#function-get_current_frame","title":"function get_current_frame","text":"<pre><code>static uint32_t atlas::render_context::get_current_frame () \n</code></pre>"},{"location":"References/classatlas_1_1render__context/#function-initialize","title":"function initialize","text":"<pre><code>static scope&lt; render_context &gt; atlas::render_context::initialize (\n    const std::string &amp; p_tag\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/renderer_backend.hpp</code></p>"},{"location":"References/classatlas_1_1renderer/","title":"Class atlas::renderer","text":"<p>ClassList &gt; atlas &gt; renderer</p>"},{"location":"References/classatlas_1_1renderer/#public-static-functions","title":"Public Static Functions","text":"Type Name void begin ()  void end ()  uint32_t get_current_frame ()  void initialize ()"},{"location":"References/classatlas_1_1renderer/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1renderer/#function-begin","title":"function begin","text":"<pre><code>static void atlas::renderer::begin () \n</code></pre> <p>Note:</p> <p>Begin() * Indicates to the renderer the preparation before the next frame's called</p> <p>Note:</p> <p>End() * At the end of frame the renderer will offload the tasks onto the GPU</p> <p>TODO: Implement Batch Rendering (Minimal Optimizaiton) * Batch Rendering is a technique on rendering in batches * Meaning when we call <code>Render*</code> functions, we are not calling draw commands per function call of <code>Render*</code> * Batch Rendering is how we render in batches. Meaning when we call Render*, we submit to via those Render* functions. Then when we reached the end of the frame via End() function. * Then End() is reached before we indicate the scene is rendered, we render all our modified objects </p>"},{"location":"References/classatlas_1_1renderer/#function-end","title":"function end","text":"<pre><code>static void atlas::renderer::end () \n</code></pre>"},{"location":"References/classatlas_1_1renderer/#function-get_current_frame","title":"function get_current_frame","text":"<pre><code>static uint32_t atlas::renderer::get_current_frame () \n</code></pre>"},{"location":"References/classatlas_1_1renderer/#function-initialize","title":"function initialize","text":"<pre><code>static void atlas::renderer::initialize () \n</code></pre> <p>Note:</p> <p>Used to initialize </p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/renderer/renderer.hpp</code></p>"},{"location":"References/classatlas_1_1renderpass/","title":"Class atlas::renderpass","text":"<p>ClassList &gt; atlas &gt; renderpass</p> <p>Inherited by the following classes: atlas::vk::VulkanRenderPass</p>"},{"location":"References/classatlas_1_1renderpass/#public-functions","title":"Public Functions","text":"Type Name void Begin ()  void End ()"},{"location":"References/classatlas_1_1renderpass/#public-static-functions","title":"Public Static Functions","text":"Type Name ref&lt; renderpass &gt; create (const renderpass_properties &amp; properties)"},{"location":"References/classatlas_1_1renderpass/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1renderpass/#function-begin","title":"function Begin","text":"<pre><code>inline void atlas::renderpass::Begin () \n</code></pre> <p>Note:</p> <p>When a render pass should start per frame </p>"},{"location":"References/classatlas_1_1renderpass/#function-end","title":"function End","text":"<pre><code>inline void atlas::renderpass::End () \n</code></pre> <p>Note:</p> <p>When a render pass should end at the end per frame </p>"},{"location":"References/classatlas_1_1renderpass/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1renderpass/#function-create","title":"function create","text":"<pre><code>static ref&lt; renderpass &gt; atlas::renderpass::create (\n    const renderpass_properties &amp; properties\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/render_pass.hpp</code></p>"},{"location":"References/structatlas_1_1renderpass__properties/","title":"Struct atlas::renderpass_properties","text":"<p>ClassList &gt; atlas &gt; renderpass_properties</p> <p>More...</p> <ul> <li><code>#include &lt;render_pass.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1renderpass__properties/#public-attributes","title":"Public Attributes","text":"Type Name std::span&lt; ImageFormat &gt; attachments uint32_t height std::span&lt; ShaderAccessOperation &gt; operations uint32_t width"},{"location":"References/structatlas_1_1renderpass__properties/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>To specify our what attachments our render passes will take </p>"},{"location":"References/structatlas_1_1renderpass__properties/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1renderpass__properties/#variable-attachments","title":"variable attachments","text":"<pre><code>std::span&lt;ImageFormat&gt; atlas::renderpass_properties::attachments;\n</code></pre>"},{"location":"References/structatlas_1_1renderpass__properties/#variable-height","title":"variable height","text":"<pre><code>uint32_t atlas::renderpass_properties::height;\n</code></pre>"},{"location":"References/structatlas_1_1renderpass__properties/#variable-operations","title":"variable operations","text":"<pre><code>std::span&lt;ShaderAccessOperation&gt; atlas::renderpass_properties::operations;\n</code></pre>"},{"location":"References/structatlas_1_1renderpass__properties/#variable-width","title":"variable width","text":"<pre><code>uint32_t atlas::renderpass_properties::width;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/render_pass.hpp</code></p>"},{"location":"References/structatlas_1_1rendertarget3d/","title":"Struct atlas::rendertarget3d","text":"<p>ClassList &gt; atlas &gt; rendertarget3d</p> <p>More...</p> <ul> <li><code>#include &lt;components.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1rendertarget3d/#public-attributes","title":"Public Attributes","text":"Type Name std::string Filepath mesh MeshMetaData   = <code>{}</code> glm::mat4 Model   = <code>{ 1.f }</code>"},{"location":"References/structatlas_1_1rendertarget3d/#public-functions","title":"Public Functions","text":"Type Name rendertarget3d () = default rendertarget3d (const std::string &amp; p_filepath)"},{"location":"References/structatlas_1_1rendertarget3d/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Contains our render target as the mesh TODO: IMPORTANT: NEED TO CHANGE HOW THIS WORKSS!! IMPORTANT: flecs gives you a lifetime issue if it doesnt have a default constructor implictly added to a struct/class </p>"},{"location":"References/structatlas_1_1rendertarget3d/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1rendertarget3d/#variable-filepath","title":"variable Filepath","text":"<pre><code>std::string atlas::rendertarget3d::Filepath;\n</code></pre>"},{"location":"References/structatlas_1_1rendertarget3d/#variable-meshmetadata","title":"variable MeshMetaData","text":"<pre><code>mesh atlas::rendertarget3d::MeshMetaData;\n</code></pre>"},{"location":"References/structatlas_1_1rendertarget3d/#variable-model","title":"variable Model","text":"<pre><code>glm::mat4 atlas::rendertarget3d::Model;\n</code></pre>"},{"location":"References/structatlas_1_1rendertarget3d/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1rendertarget3d/#function-rendertarget3d-12","title":"function rendertarget3d [1/2]","text":"<pre><code>atlas::rendertarget3d::rendertarget3d () = default\n</code></pre>"},{"location":"References/structatlas_1_1rendertarget3d/#function-rendertarget3d-22","title":"function rendertarget3d [2/2]","text":"<pre><code>inline atlas::rendertarget3d::rendertarget3d (\n    const std::string &amp; p_filepath\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/components.hpp</code></p>"},{"location":"References/structatlas_1_1rigidbody3d/","title":"Struct atlas::rigidbody3d","text":"<p>ClassList &gt; atlas &gt; rigidbody3d</p> <p>More...</p> <ul> <li><code>#include &lt;components.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1rigidbody3d/#public-types","title":"Public Types","text":"Type Name enum BodyType"},{"location":"References/structatlas_1_1rigidbody3d/#public-attributes","title":"Public Attributes","text":"Type Name void * BodyAtRuntime   = <code>/* multi line expression */</code> bool HasFixation   = <code>false</code> BodyType Type   = <code>BodyType::STATIC</code>"},{"location":"References/structatlas_1_1rigidbody3d/#public-functions","title":"Public Functions","text":"Type Name rigidbody3d () = default"},{"location":"References/structatlas_1_1rigidbody3d/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Our interpretation of the RigidBody3D </p>"},{"location":"References/structatlas_1_1rigidbody3d/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"References/structatlas_1_1rigidbody3d/#enum-bodytype","title":"enum BodyType","text":"<pre><code>enum atlas::rigidbody3d::BodyType {\n    STATIC = 0,\n    DYNAMIC = 1,\n    KINEMATIC = 2\n};\n</code></pre>"},{"location":"References/structatlas_1_1rigidbody3d/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1rigidbody3d/#variable-bodyatruntime","title":"variable BodyAtRuntime","text":"<pre><code>void* atlas::rigidbody3d::BodyAtRuntime;\n</code></pre>"},{"location":"References/structatlas_1_1rigidbody3d/#variable-hasfixation","title":"variable HasFixation","text":"<pre><code>bool atlas::rigidbody3d::HasFixation;\n</code></pre>"},{"location":"References/structatlas_1_1rigidbody3d/#variable-type","title":"variable Type","text":"<pre><code>BodyType atlas::rigidbody3d::Type;\n</code></pre>"},{"location":"References/structatlas_1_1rigidbody3d/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1rigidbody3d/#function-rigidbody3d","title":"function rigidbody3d","text":"<pre><code>atlas::rigidbody3d::rigidbody3d () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/components.hpp</code></p>"},{"location":"References/classatlas_1_1scene__object/","title":"Class atlas::scene_object","text":"<p>ClassList &gt; atlas &gt; scene_object</p>"},{"location":"References/classatlas_1_1scene__object/#public-functions","title":"Public Functions","text":"Type Name void add ()  void add (UComponent &amp; p_component_value)  void add_query () Specify groups of entity signatures to add to the entity. const UComponent * get () const glm::mat4 get_model ()  UComponent * get_mut ()  bool has ()  entity () const entity ()  void remove ()  scene_object () = default scene_object (flecs::world * p_registry, const std::string &amp; p_tag)  scene_object (const flecs::entity &amp; p_entity)  void set (const UComponent &amp; p_component)  void set (const UComponent &amp; p_component, const UComponent2 &amp; p_component2)  ~scene_object ()"},{"location":"References/classatlas_1_1scene__object/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1scene__object/#function-add-12","title":"function add [1/2]","text":"<pre><code>template&lt;typename UComponent&gt;\ninline void atlas::scene_object::add () \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-add-22","title":"function add [2/2]","text":"<pre><code>template&lt;typename UComponent&gt;\ninline void atlas::scene_object::add (\n    UComponent &amp; p_component_value\n) \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-add_query","title":"function add_query","text":"<p>Specify groups of entity signatures to add to the entity. <pre><code>template&lt;typename... Args&gt;\ninline void atlas::scene_object::add_query () \n</code></pre></p> <p>signatures being the components EXPERIEMENTAL: Function to add multiple components but still in its experiemental stages. </p>"},{"location":"References/classatlas_1_1scene__object/#function-get","title":"function get","text":"<pre><code>template&lt;typename UComponent&gt;\ninline const UComponent * atlas::scene_object::get () const\n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-get_model","title":"function get_model","text":"<pre><code>inline glm::mat4 atlas::scene_object::get_model () \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-get_mut","title":"function get_mut","text":"<pre><code>template&lt;typename UComponent&gt;\ninline UComponent * atlas::scene_object::get_mut () \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-has","title":"function has","text":"<pre><code>template&lt;typename UComponent&gt;\ninline bool atlas::scene_object::has () \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-entity-12","title":"function entity [1/2]","text":"<pre><code>inline atlas::scene_object::entity () const\n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-entity-22","title":"function entity [2/2]","text":"<pre><code>inline atlas::scene_object::entity () \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-remove","title":"function remove","text":"<pre><code>template&lt;typename UComponent&gt;\ninline void atlas::scene_object::remove () \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-scene_object-13","title":"function scene_object [1/3]","text":"<pre><code>atlas::scene_object::scene_object () = default\n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-scene_object-23","title":"function scene_object [2/3]","text":"<pre><code>inline atlas::scene_object::scene_object (\n    flecs::world * p_registry,\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-scene_object-33","title":"function scene_object [3/3]","text":"<pre><code>inline atlas::scene_object::scene_object (\n    const flecs::entity &amp; p_entity\n) \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-set-12","title":"function set [1/2]","text":"<pre><code>template&lt;typename UComponent&gt;\ninline void atlas::scene_object::set (\n    const UComponent &amp; p_component\n) \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-set-22","title":"function set [2/2]","text":"<pre><code>template&lt;typename UComponent, typename UComponent2&gt;\ninline void atlas::scene_object::set (\n    const UComponent &amp; p_component,\n    const UComponent2 &amp; p_component2\n) \n</code></pre>"},{"location":"References/classatlas_1_1scene__object/#function-scene_object","title":"function ~scene_object","text":"<pre><code>inline atlas::scene_object::~scene_object () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/scene_object.hpp</code></p>"},{"location":"References/classatlas_1_1scene__scope/","title":"Class atlas::scene_scope","text":"<p>ClassList &gt; atlas &gt; scene_scope</p>"},{"location":"References/classatlas_1_1scene__scope/#public-functions","title":"Public Functions","text":"Type Name ref&lt; scene_object &gt; create_new_object (const std::string &amp; p_tag)  std::string get_tag ()  world () const world ()  flecs::query_builder&lt; Comps... &gt; query_builder (Args &amp;&amp;... args) const scene_scope ()  scene_scope (const std::string &amp; p_tag)  virtual ~scene_scope () = default"},{"location":"References/classatlas_1_1scene__scope/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1scene__scope/#function-create_new_object","title":"function create_new_object","text":"<pre><code>inline ref&lt; scene_object &gt; atlas::scene_scope::create_new_object (\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1scene__scope/#function-get_tag","title":"function get_tag","text":"<pre><code>inline std::string atlas::scene_scope::get_tag () \n</code></pre>"},{"location":"References/classatlas_1_1scene__scope/#function-world-12","title":"function world [1/2]","text":"<pre><code>inline atlas::scene_scope::world () const\n</code></pre>"},{"location":"References/classatlas_1_1scene__scope/#function-world-22","title":"function world [2/2]","text":"<pre><code>inline atlas::scene_scope::world () \n</code></pre>"},{"location":"References/classatlas_1_1scene__scope/#function-query_builder","title":"function query_builder","text":"<pre><code>template&lt;typename... Comps, typename... Args&gt;\ninline flecs::query_builder&lt; Comps... &gt; atlas::scene_scope::query_builder (\n    Args &amp;&amp;... args\n) const\n</code></pre>"},{"location":"References/classatlas_1_1scene__scope/#function-scene_scope-12","title":"function scene_scope [1/2]","text":"<pre><code>inline atlas::scene_scope::scene_scope () \n</code></pre>"},{"location":"References/classatlas_1_1scene__scope/#function-scene_scope-22","title":"function scene_scope [2/2]","text":"<pre><code>inline atlas::scene_scope::scene_scope (\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1scene__scope/#function-scene_scope","title":"function ~scene_scope","text":"<pre><code>virtual atlas::scene_scope::~scene_scope () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/scene.hpp</code></p>"},{"location":"References/classatlas_1_1serializer/","title":"Class atlas::serializer","text":"<p>ClassList &gt; atlas &gt; serializer</p>"},{"location":"References/classatlas_1_1serializer/#public-functions","title":"Public Functions","text":"Type Name void save_as (const std::string &amp; p_filepath)  serializer (const scene_scope * p_scene_ctx)"},{"location":"References/classatlas_1_1serializer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1serializer/#function-save_as","title":"function save_as","text":"<pre><code>void atlas::serializer::save_as (\n    const std::string &amp; p_filepath\n) \n</code></pre>"},{"location":"References/classatlas_1_1serializer/#function-serializer","title":"function serializer","text":"<pre><code>atlas::serializer::serializer (\n    const scene_scope * p_scene_ctx\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/serialize/serializer.hpp</code></p>"},{"location":"References/classatlas_1_1shader/","title":"Class atlas::shader","text":"<p>ClassList &gt; atlas &gt; shader</p> <p>Inherited by the following classes: atlas::vk::vk_shader</p>"},{"location":"References/classatlas_1_1shader/#public-functions","title":"Public Functions","text":"Type Name VkPipeline get_graphics_pipeline ()  virtual ~shader () = default"},{"location":"References/classatlas_1_1shader/#public-static-functions","title":"Public Static Functions","text":"Type Name ref&lt; shader &gt; create (const std::string &amp; p_vert_shader, const std::string &amp; p_frag_shader, const vk::shader_pipeline_config &amp; p_config)"},{"location":"References/classatlas_1_1shader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1shader/#function-get_graphics_pipeline","title":"function get_graphics_pipeline","text":"<pre><code>VkPipeline atlas::shader::get_graphics_pipeline () \n</code></pre>"},{"location":"References/classatlas_1_1shader/#function-shader","title":"function ~shader","text":"<pre><code>virtual atlas::shader::~shader () = default\n</code></pre>"},{"location":"References/classatlas_1_1shader/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1shader/#function-create","title":"function create","text":"<pre><code>static ref&lt; shader &gt; atlas::shader::create (\n    const std::string &amp; p_vert_shader,\n    const std::string &amp; p_frag_shader,\n    const vk::shader_pipeline_config &amp; p_config\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/shader.hpp</code></p>"},{"location":"References/classatlas_1_1swapchain/","title":"Class atlas::swapchain","text":"<p>ClassList &gt; atlas &gt; swapchain</p> <p>Inherited by the following classes: atlas::vk::vk_swapchain</p>"},{"location":"References/classatlas_1_1swapchain/#public-functions","title":"Public Functions","text":"Type Name uint32_t acquire_next_image ()  uint32_t get_current_per_tick ()  VkExtent2D get_extent ()  VkFramebuffer get_framebuffer (uint32_t p_index)  VkImageView get_image_view (uint32_t p_index)  uint32_t get_images_size () const VkRenderPass get_renderpass ()  VkFormat &amp; get_swapchain_format ()  VkSwapchainKHR get_vk_swapchain ()  bool is_resized ()  void on_resize (uint32_t p_width, uint32_t p_height)  void set_resize_status (bool p_is_resized_signaled)  void submit_command_buffer (VkCommandBuffer * p_command_buffers)  virtual ~swapchain () = default"},{"location":"References/classatlas_1_1swapchain/#public-static-functions","title":"Public Static Functions","text":"Type Name ref&lt; swapchain &gt; initialize (VkSurfaceKHR p_surface)  bool is_rebuild ()  void reset_build ()"},{"location":"References/classatlas_1_1swapchain/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1swapchain/#function-acquire_next_image","title":"function acquire_next_image","text":"<pre><code>uint32_t atlas::swapchain::acquire_next_image () \n</code></pre> <p>Note:</p> <p>Proceeds to getting next frame. </p>"},{"location":"References/classatlas_1_1swapchain/#function-get_current_per_tick","title":"function get_current_per_tick","text":"<pre><code>uint32_t atlas::swapchain::get_current_per_tick () \n</code></pre> <p>Returns:</p> <p>m_CurrentFrameIdx </p>"},{"location":"References/classatlas_1_1swapchain/#function-get_extent","title":"function get_extent","text":"<pre><code>VkExtent2D atlas::swapchain::get_extent () \n</code></pre>"},{"location":"References/classatlas_1_1swapchain/#function-get_framebuffer","title":"function get_framebuffer","text":"<pre><code>VkFramebuffer atlas::swapchain::get_framebuffer (\n    uint32_t p_index\n) \n</code></pre>"},{"location":"References/classatlas_1_1swapchain/#function-get_image_view","title":"function get_image_view","text":"<pre><code>VkImageView atlas::swapchain::get_image_view (\n    uint32_t p_index\n) \n</code></pre>"},{"location":"References/classatlas_1_1swapchain/#function-get_images_size","title":"function get_images_size","text":"<pre><code>uint32_t atlas::swapchain::get_images_size () const\n</code></pre>"},{"location":"References/classatlas_1_1swapchain/#function-get_renderpass","title":"function get_renderpass","text":"<pre><code>VkRenderPass atlas::swapchain::get_renderpass () \n</code></pre>"},{"location":"References/classatlas_1_1swapchain/#function-get_swapchain_format","title":"function get_swapchain_format","text":"<pre><code>VkFormat &amp; atlas::swapchain::get_swapchain_format () \n</code></pre>"},{"location":"References/classatlas_1_1swapchain/#function-get_vk_swapchain","title":"function get_vk_swapchain","text":"<pre><code>VkSwapchainKHR atlas::swapchain::get_vk_swapchain () \n</code></pre>"},{"location":"References/classatlas_1_1swapchain/#function-is_resized","title":"function is_resized","text":"<pre><code>bool atlas::swapchain::is_resized () \n</code></pre>"},{"location":"References/classatlas_1_1swapchain/#function-on_resize","title":"function on_resize","text":"<pre><code>void atlas::swapchain::on_resize (\n    uint32_t p_width,\n    uint32_t p_height\n) \n</code></pre> <p>Note:</p> <p>Public API's </p>"},{"location":"References/classatlas_1_1swapchain/#function-set_resize_status","title":"function set_resize_status","text":"<pre><code>void atlas::swapchain::set_resize_status (\n    bool p_is_resized_signaled\n) \n</code></pre>"},{"location":"References/classatlas_1_1swapchain/#function-submit_command_buffer","title":"function submit_command_buffer","text":"<pre><code>void atlas::swapchain::submit_command_buffer (\n    VkCommandBuffer * p_command_buffers\n) \n</code></pre>"},{"location":"References/classatlas_1_1swapchain/#function-swapchain","title":"function ~swapchain","text":"<pre><code>virtual atlas::swapchain::~swapchain () = default\n</code></pre>"},{"location":"References/classatlas_1_1swapchain/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1swapchain/#function-initialize","title":"function initialize","text":"<pre><code>static ref&lt; swapchain &gt; atlas::swapchain::initialize (\n    VkSurfaceKHR p_surface\n) \n</code></pre> <p>Note:</p> <p>Initialize our swapchain </p>"},{"location":"References/classatlas_1_1swapchain/#function-is_rebuild","title":"function is_rebuild","text":"<pre><code>static bool atlas::swapchain::is_rebuild () \n</code></pre>"},{"location":"References/classatlas_1_1swapchain/#function-reset_build","title":"function reset_build","text":"<pre><code>static void atlas::swapchain::reset_build () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/swapchain.hpp</code></p>"},{"location":"References/namespaceatlas_1_1sync__update/","title":"Namespace atlas::sync_update","text":"<p>Namespace List &gt; atlas &gt; sync_update</p>"},{"location":"References/namespaceatlas_1_1sync__update/#public-attributes","title":"Public Attributes","text":"Type Name std::deque&lt; std::function&lt; void()&gt; &gt; s_late_update std::deque&lt; std::function&lt; void()&gt; &gt; s_physica_update std::deque&lt; std::function&lt; void()&gt; &gt; s_ui_update std::deque&lt; std::function&lt; void()&gt; &gt; s_update"},{"location":"References/namespaceatlas_1_1sync__update/#public-functions","title":"Public Functions","text":"Type Name void attach (UObject * p_instance, const UCallable &amp; p_callable)  float delta_time ()  void initialize ()  void on_late_update ()  void on_physics_update ()  void on_ui_update ()  void on_update ()  void post (UObject * p_instance, const UCallable &amp; p_callable)  void sync (UObject * p_instance, const UFunction &amp; p_callable)  void sync_physics (UObject * p_instance, const UFunction &amp; p_callable)"},{"location":"References/namespaceatlas_1_1sync__update/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/namespaceatlas_1_1sync__update/#variable-s_late_update","title":"variable s_late_update","text":"<pre><code>std::deque&lt;std::function&lt;void()&gt; &gt; atlas::sync_update::s_late_update;\n</code></pre>"},{"location":"References/namespaceatlas_1_1sync__update/#variable-s_physica_update","title":"variable s_physica_update","text":"<pre><code>std::deque&lt;std::function&lt;void()&gt; &gt; atlas::sync_update::s_physica_update;\n</code></pre>"},{"location":"References/namespaceatlas_1_1sync__update/#variable-s_ui_update","title":"variable s_ui_update","text":"<pre><code>std::deque&lt;std::function&lt;void()&gt; &gt; atlas::sync_update::s_ui_update;\n</code></pre>"},{"location":"References/namespaceatlas_1_1sync__update/#variable-s_update","title":"variable s_update","text":"<pre><code>std::deque&lt;std::function&lt;void()&gt; &gt; atlas::sync_update::s_update;\n</code></pre>"},{"location":"References/namespaceatlas_1_1sync__update/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1sync__update/#function-attach","title":"function attach","text":"<pre><code>template&lt;typename UObject, typename UCallable&gt;\nvoid atlas::sync_update::attach (\n    UObject * p_instance,\n    const UCallable &amp; p_callable\n) \n</code></pre> <p>Note:</p> <p>Attach our UI Updates </p>"},{"location":"References/namespaceatlas_1_1sync__update/#function-delta_time","title":"function delta_time","text":"<pre><code>float atlas::sync_update::delta_time () \n</code></pre> <p>Note:</p> <p>Retrieves the local delta time </p>"},{"location":"References/namespaceatlas_1_1sync__update/#function-initialize","title":"function initialize","text":"<pre><code>void atlas::sync_update::initialize () \n</code></pre> <p>Note:</p> <p>Initializes sync update manager to make sure our manager is able to dispatch our update functions. </p>"},{"location":"References/namespaceatlas_1_1sync__update/#function-on_late_update","title":"function on_late_update","text":"<pre><code>void atlas::sync_update::on_late_update () \n</code></pre>"},{"location":"References/namespaceatlas_1_1sync__update/#function-on_physics_update","title":"function on_physics_update","text":"<pre><code>void atlas::sync_update::on_physics_update () \n</code></pre>"},{"location":"References/namespaceatlas_1_1sync__update/#function-on_ui_update","title":"function on_ui_update","text":"<pre><code>void atlas::sync_update::on_ui_update () \n</code></pre>"},{"location":"References/namespaceatlas_1_1sync__update/#function-on_update","title":"function on_update","text":"<pre><code>void atlas::sync_update::on_update () \n</code></pre>"},{"location":"References/namespaceatlas_1_1sync__update/#function-post","title":"function post","text":"<pre><code>template&lt;typename UObject, typename UCallable&gt;\ninline void atlas::sync_update::post (\n    UObject * p_instance,\n    const UCallable &amp; p_callable\n) \n</code></pre> <p>Note:</p> <p>Post update - newly defined late update </p>"},{"location":"References/namespaceatlas_1_1sync__update/#function-sync","title":"function sync","text":"<pre><code>template&lt;typename UObject, typename UFunction&gt;\nvoid atlas::sync_update::sync (\n    UObject * p_instance,\n    const UFunction &amp; p_callable\n) \n</code></pre> <p>Note:</p> <p>Synchronize our update per frame </p>"},{"location":"References/namespaceatlas_1_1sync__update/#function-sync_physics","title":"function sync_physics","text":"<pre><code>template&lt;typename UObject, typename UFunction&gt;\nvoid atlas::sync_update::sync_physics (\n    UObject * p_instance,\n    const UFunction &amp; p_callable\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/update_handlers/sync_update.hpp</code></p>"},{"location":"References/classatlas_1_1system__registry/","title":"Class atlas::system_registry","text":"<p>ClassList &gt; atlas &gt; system_registry</p>"},{"location":"References/classatlas_1_1system__registry/#public-functions","title":"Public Functions","text":"Type Name system_registry (const std::string &amp; p_tag)  ~system_registry ()"},{"location":"References/classatlas_1_1system__registry/#public-static-functions","title":"Public Static Functions","text":"Type Name ref&lt; world_scope &gt; create_world (const std::string &amp; p_tag) Instantiates new world_scope . ref&lt; world_scope &gt; get_world (const std::string &amp; p_tag) Searches and returns world_scope if found."},{"location":"References/classatlas_1_1system__registry/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1system__registry/#function-system_registry","title":"function system_registry","text":"<pre><code>atlas::system_registry::system_registry (\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1system__registry/#function-system_registry_1","title":"function ~system_registry","text":"<pre><code>atlas::system_registry::~system_registry () \n</code></pre>"},{"location":"References/classatlas_1_1system__registry/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1system__registry/#function-create_world","title":"function create_world","text":"<p>Instantiates new world_scope . <pre><code>static ref&lt; world_scope &gt; atlas::system_registry::create_world (\n    const std::string &amp; p_tag\n) \n</code></pre></p> <p>Note:</p> <p>system_registry does the following: * Creates world scopes * Manages Lifetimes of world objects * Keeps tracks of the refcounting of references to these world objects * Provide globalized access to other worlds </p>"},{"location":"References/classatlas_1_1system__registry/#function-get_world","title":"function get_world","text":"<p>Searches and returns world_scope if found. <pre><code>static ref&lt; world_scope &gt; atlas::system_registry::get_world (\n    const std::string &amp; p_tag\n) \n</code></pre></p> <p>Returns nullptr if world_scope not found </p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/system_framework/system_registry.hpp</code></p>"},{"location":"References/structatlas_1_1tag/","title":"Struct atlas::tag","text":"<p>ClassList &gt; atlas &gt; tag</p>"},{"location":"References/structatlas_1_1tag/#public-attributes","title":"Public Attributes","text":"Type Name std::string TagMetadata   = <code>\"\"</code>"},{"location":"References/structatlas_1_1tag/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1tag/#variable-tagmetadata","title":"variable TagMetadata","text":"<pre><code>std::string atlas::tag::TagMetadata;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/components.hpp</code></p>"},{"location":"References/classatlas_1_1thread/","title":"Class atlas::thread","text":"<p>ClassList &gt; atlas &gt; thread</p> <p>More...</p> <ul> <li><code>#include &lt;thread.hpp&gt;</code></li> </ul>"},{"location":"References/classatlas_1_1thread/#public-functions","title":"Public Functions","text":"Type Name void Join ()  bool Joinable ()  void dispatch (const T &amp; p_function)  void dispatch (T &amp;&amp; func, Args &amp;&amp;... args)  thread (const std::string &amp; p_tag)  thread () = delete thread (const std::string &amp; p_tag=\"Undefined\")  ~thread ()"},{"location":"References/classatlas_1_1thread/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Current work to get back to it.</p> <p>Note:</p> <p>The thought we are doing are the following</p> <p>Note:</p> <p>First implement thread.hpp </p> <p>Note:</p> <p>Implementing the thread class to wrap around the &lt;thread&gt; for handling and doing thread stuff like thread statuses, policies, etc</p> <p>Note:</p> <p>Second improve &lt;thread_pool&gt; to first be able to spawn those threads </p> <p>Note:</p> <p>Then once we can spawn those specific threads successfully then we apply what global update does and use a similar logic into the &lt;thread_pool&gt; itself</p> <p>Note:</p> <p>Third, fix up the FPS and timer for udpate frequency </p>"},{"location":"References/classatlas_1_1thread/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1thread/#function-join","title":"function Join","text":"<pre><code>inline void atlas::thread::Join () \n</code></pre>"},{"location":"References/classatlas_1_1thread/#function-joinable","title":"function Joinable","text":"<pre><code>inline bool atlas::thread::Joinable () \n</code></pre>"},{"location":"References/classatlas_1_1thread/#function-dispatch-12","title":"function dispatch [1/2]","text":"<pre><code>template&lt;typename T&gt;\ninline void atlas::thread::dispatch (\n    const T &amp; p_function\n) \n</code></pre>"},{"location":"References/classatlas_1_1thread/#function-dispatch-22","title":"function dispatch [2/2]","text":"<pre><code>template&lt;typename T, typename... Args&gt;\ninline void atlas::thread::dispatch (\n    T &amp;&amp; func,\n    Args &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/classatlas_1_1thread/#function-thread-13","title":"function thread [1/3]","text":"<pre><code>atlas::thread::thread (\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1thread/#function-thread-23","title":"function thread [2/3]","text":"<pre><code>atlas::thread::thread () = delete\n</code></pre>"},{"location":"References/classatlas_1_1thread/#function-thread-33","title":"function thread [3/3]","text":"<pre><code>inline atlas::thread::thread (\n    const std::string &amp; p_tag=\"Undefined\"\n) \n</code></pre>"},{"location":"References/classatlas_1_1thread/#function-thread","title":"function ~thread","text":"<pre><code>inline atlas::thread::~thread () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/threads/thread.hpp</code></p>"},{"location":"References/classatlas_1_1timer/","title":"Class atlas::timer","text":"<p>ClassList &gt; atlas &gt; timer</p>"},{"location":"References/classatlas_1_1timer/#public-functions","title":"Public Functions","text":"Type Name std::chrono::time_point&lt; std::chrono::high_resolution_clock &gt; current_time ()  float elapsed ()  void reset ()  float seconds ()  timer ()"},{"location":"References/classatlas_1_1timer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1timer/#function-current_time","title":"function current_time","text":"<pre><code>std::chrono::time_point&lt; std::chrono::high_resolution_clock &gt; atlas::timer::current_time () \n</code></pre>"},{"location":"References/classatlas_1_1timer/#function-elapsed","title":"function elapsed","text":"<pre><code>float atlas::timer::elapsed () \n</code></pre>"},{"location":"References/classatlas_1_1timer/#function-reset","title":"function reset","text":"<pre><code>void atlas::timer::reset () \n</code></pre>"},{"location":"References/classatlas_1_1timer/#function-seconds","title":"function seconds","text":"<pre><code>float atlas::timer::seconds () \n</code></pre>"},{"location":"References/classatlas_1_1timer/#function-timer","title":"function timer","text":"<pre><code>atlas::timer::timer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/update_handlers/timer.hpp</code></p>"},{"location":"References/structatlas_1_1transform/","title":"Struct atlas::transform","text":"<p>ClassList &gt; atlas &gt; transform</p>"},{"location":"References/structatlas_1_1transform/#public-attributes","title":"Public Attributes","text":"Type Name glm::highp_vec4 Color   = <code>{ 1.f }</code> glm::highp_vec3 Position   = <code>{ 0.f }</code> glm::highp_vec3 QuaternionRotation   = <code>{ 0.f }</code> glm::highp_vec3 Rotation   = <code>{ 0.f }</code> glm::highp_vec3 Scale   = <code>{ 1.f }</code>"},{"location":"References/structatlas_1_1transform/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1transform/#variable-color","title":"variable Color","text":"<pre><code>glm::highp_vec4 atlas::transform::Color;\n</code></pre>"},{"location":"References/structatlas_1_1transform/#variable-position","title":"variable Position","text":"<pre><code>glm::highp_vec3 atlas::transform::Position;\n</code></pre>"},{"location":"References/structatlas_1_1transform/#variable-quaternionrotation","title":"variable QuaternionRotation","text":"<pre><code>glm::highp_vec3 atlas::transform::QuaternionRotation;\n</code></pre>"},{"location":"References/structatlas_1_1transform/#variable-rotation","title":"variable Rotation","text":"<pre><code>glm::highp_vec3 atlas::transform::Rotation;\n</code></pre>"},{"location":"References/structatlas_1_1transform/#variable-scale","title":"variable Scale","text":"<pre><code>glm::highp_vec3 atlas::transform::Scale;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/components.hpp</code></p>"},{"location":"References/namespaceatlas_1_1ui/","title":"Namespace atlas::ui","text":"<p>Namespace List &gt; atlas &gt; ui</p>"},{"location":"References/namespaceatlas_1_1ui/#public-functions","title":"Public Functions","text":"Type Name bool begin_popup_context_window (const char * p_str_id, ImGuiMouseButton p_mb, bool p_over_items)  void button_open_file_dialog (const std::string &amp; p_tag, std::string &amp; p_filepath, const std::string &amp; p_filter=\"obj;glftf;fbx\")  void dockspace_window (GLFWwindow * p_window)  void draw_float (const std::string &amp; p_tag, float &amp; p_value, float p_reset_value=0.f)  void draw_vec3 (const std::string &amp; p_tag, glm::vec3 &amp; p_value, float p_reset_value=0.f)  void draw_vec4 (const std::string &amp; p_tag, glm::vec4 &amp; p_value, float p_reset_value=0.f)"},{"location":"References/namespaceatlas_1_1ui/#public-static-functions","title":"Public Static Functions","text":"Type Name void draw_panel_component (const std::string &amp; p_tag, const UFunction &amp; p_callable)"},{"location":"References/namespaceatlas_1_1ui/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1ui/#function-begin_popup_context_window","title":"function begin_popup_context_window","text":"<pre><code>bool atlas::ui::begin_popup_context_window (\n    const char * p_str_id,\n    ImGuiMouseButton p_mb,\n    bool p_over_items\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1ui/#function-button_open_file_dialog","title":"function button_open_file_dialog","text":"<pre><code>void atlas::ui::button_open_file_dialog (\n    const std::string &amp; p_tag,\n    std::string &amp; p_filepath,\n    const std::string &amp; p_filter=\"obj;glftf;fbx\"\n) \n</code></pre> <p>Note:</p> <p>Sets up UI button for loading files </p>"},{"location":"References/namespaceatlas_1_1ui/#function-dockspace_window","title":"function dockspace_window","text":"<pre><code>void atlas::ui::dockspace_window (\n    GLFWwindow * p_window\n) \n</code></pre> <p>Note:</p> <p>Sets up dockspaces </p>"},{"location":"References/namespaceatlas_1_1ui/#function-draw_float","title":"function draw_float","text":"<pre><code>void atlas::ui::draw_float (\n    const std::string &amp; p_tag,\n    float &amp; p_value,\n    float p_reset_value=0.f\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1ui/#function-draw_vec3","title":"function draw_vec3","text":"<pre><code>void atlas::ui::draw_vec3 (\n    const std::string &amp; p_tag,\n    glm::vec3 &amp; p_value,\n    float p_reset_value=0.f\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1ui/#function-draw_vec4","title":"function draw_vec4","text":"<pre><code>void atlas::ui::draw_vec4 (\n    const std::string &amp; p_tag,\n    glm::vec4 &amp; p_value,\n    float p_reset_value=0.f\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1ui/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1ui/#function-draw_panel_component","title":"function draw_panel_component","text":"<pre><code>template&lt;typename T, typename UFunction&gt;\nstatic void atlas::ui::draw_panel_component (\n    const std::string &amp; p_tag,\n    const UFunction &amp; p_callable\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/ui/widgets.hpp</code></p>"},{"location":"References/structatlas_1_1vector2/","title":"Struct atlas::vector2","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; vector2</p> <p>More...</p>"},{"location":"References/structatlas_1_1vector2/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>The reason why we do this is because if we have an arbitrary type of vec2, vec3, vec4. This allows us to still utilize glm::vec3 as our default vec3 types </p> <p>Note:</p> <p>The computation would still be of how you can do math can be implemented by the math library of your choice, the only thing you just to is make those changes at compile-time to glm::vec2, glm::vec3, or even glm::vec4. </p> <p>Note:</p> <p>Hence why you override these metadata classes for specifically vec2, 3, and 4</p> <p>Note:</p> <p>By doing this we can let the default we define be utilizing glm's mathematical data types. Then letting users define their own customizable types if they choose to utilize a different mathematical type </p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4/","title":"Struct atlas::vector2&lt; glm::highp_vec2 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; atlas &gt; vector2&lt; glm::highp_vec2 &gt;</p>"},{"location":"References/structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4/#public-functions","title":"Public Functions","text":"Type Name highp_vec2 ()  glm::highp_vec2 operator= (const glm::highp_vec2 &amp; p_other)  bool operator== (const glm::vec4 &amp; p_other)  vector2 () = default vector2 (const glm::highp_vec2 &amp; p_other)"},{"location":"References/structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4/#function-highp_vec2","title":"function highp_vec2","text":"<pre><code>inline atlas::vector2&lt; glm::highp_vec2 &gt;::highp_vec2 () \n</code></pre>"},{"location":"References/structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4/#function-operator","title":"function operator=","text":"<pre><code>inline glm::highp_vec2 atlas::vector2&lt; glm::highp_vec2 &gt;::operator= (\n    const glm::highp_vec2 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::vector2&lt; glm::highp_vec2 &gt;::operator== (\n    const glm::vec4 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4/#function-vector2-12","title":"function vector2 [1/2]","text":"<pre><code>atlas::vector2&lt; glm::highp_vec2 &gt;::vector2 () = default\n</code></pre>"},{"location":"References/structatlas_1_1vector2_3_01glm_1_1highp__vec2_01_4/#function-vector2-22","title":"function vector2 [2/2]","text":"<pre><code>inline atlas::vector2&lt; glm::highp_vec2 &gt;::vector2 (\n    const glm::highp_vec2 &amp; p_other\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/structatlas_1_1vector3/","title":"Struct atlas::vector3","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; vector3</p>"},{"location":"References/structatlas_1_1vector3/#public-functions","title":"Public Functions","text":"Type Name vec3 ()  glm::vec3 operator= (const T &amp; p_other)  bool operator== (const glm::vec3 &amp; p_other)  vector3 () = default vector3 (const T &amp; p_other)  vector3 (float x, float y, float z)  vector3 (const std::initializer_list&lt; float &gt; &amp; values)"},{"location":"References/structatlas_1_1vector3/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1vector3/#function-vec3","title":"function vec3","text":"<pre><code>inline atlas::vector3::vec3 () \n</code></pre>"},{"location":"References/structatlas_1_1vector3/#function-operator","title":"function operator=","text":"<pre><code>inline glm::vec3 atlas::vector3::operator= (\n    const T &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector3/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::vector3::operator== (\n    const glm::vec3 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector3/#function-vector3-14","title":"function vector3 [1/4]","text":"<pre><code>atlas::vector3::vector3 () = default\n</code></pre>"},{"location":"References/structatlas_1_1vector3/#function-vector3-24","title":"function vector3 [2/4]","text":"<pre><code>inline atlas::vector3::vector3 (\n    const T &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector3/#function-vector3-34","title":"function vector3 [3/4]","text":"<pre><code>inline atlas::vector3::vector3 (\n    float x,\n    float y,\n    float z\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector3/#function-vector3-44","title":"function vector3 [4/4]","text":"<pre><code>inline atlas::vector3::vector3 (\n    const std::initializer_list&lt; float &gt; &amp; values\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4/","title":"Struct atlas::vector3&lt; JPH::Vec3 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; atlas &gt; vector3&lt; JPH::Vec3 &gt;</p>"},{"location":"References/structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4/#public-functions","title":"Public Functions","text":"Type Name vec3 ()  glm::vec3 operator= (const JPH::Vec3 &amp; p_other)  bool operator== (const glm::vec3 &amp; p_other)  vector3 () = default vector3 (const JPH::Vec3 &amp; p_other)"},{"location":"References/structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4/#function-vec3","title":"function vec3","text":"<pre><code>inline atlas::vector3&lt; JPH::Vec3 &gt;::vec3 () \n</code></pre>"},{"location":"References/structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4/#function-operator","title":"function operator=","text":"<pre><code>inline glm::vec3 atlas::vector3&lt; JPH::Vec3 &gt;::operator= (\n    const JPH::Vec3 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::vector3&lt; JPH::Vec3 &gt;::operator== (\n    const glm::vec3 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4/#function-vector3-12","title":"function vector3 [1/2]","text":"<pre><code>atlas::vector3&lt; JPH::Vec3 &gt;::vector3 () = default\n</code></pre>"},{"location":"References/structatlas_1_1vector3_3_01JPH_1_1Vec3_01_4/#function-vector3-22","title":"function vector3 [2/2]","text":"<pre><code>inline atlas::vector3&lt; JPH::Vec3 &gt;::vector3 (\n    const JPH::Vec3 &amp; p_other\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/helper_functions.hpp</code></p>"},{"location":"References/structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4/","title":"Struct atlas::vector3&lt; glm::highp_vec3 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; atlas &gt; vector3&lt; glm::highp_vec3 &gt;</p>"},{"location":"References/structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4/#public-functions","title":"Public Functions","text":"Type Name highp_vec3 ()  glm::highp_vec3 operator= (const glm::highp_vec3 &amp; p_other)  bool operator== (const glm::highp_vec3 &amp; p_other)  vector3 () = default vector3 (const glm::highp_vec3 &amp; p_other)"},{"location":"References/structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4/#function-highp_vec3","title":"function highp_vec3","text":"<pre><code>inline atlas::vector3&lt; glm::highp_vec3 &gt;::highp_vec3 () \n</code></pre>"},{"location":"References/structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4/#function-operator","title":"function operator=","text":"<pre><code>inline glm::highp_vec3 atlas::vector3&lt; glm::highp_vec3 &gt;::operator= (\n    const glm::highp_vec3 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::vector3&lt; glm::highp_vec3 &gt;::operator== (\n    const glm::highp_vec3 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4/#function-vector3-12","title":"function vector3 [1/2]","text":"<pre><code>atlas::vector3&lt; glm::highp_vec3 &gt;::vector3 () = default\n</code></pre>"},{"location":"References/structatlas_1_1vector3_3_01glm_1_1highp__vec3_01_4/#function-vector3-22","title":"function vector3 [2/2]","text":"<pre><code>inline atlas::vector3&lt; glm::highp_vec3 &gt;::vector3 (\n    const glm::highp_vec3 &amp; p_other\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/structatlas_1_1vector4/","title":"Struct atlas::vector4","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; atlas &gt; vector4</p>"},{"location":"References/structatlas_1_1vector4/#public-functions","title":"Public Functions","text":"Type Name vec4 ()  glm::vec4 operator= (const T &amp; p_other)  bool operator== (const glm::vec4 &amp; p_other)  vector4 () = default vector4 (const T &amp; p_other)  vector4 (float x, float y, float z, float w)"},{"location":"References/structatlas_1_1vector4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1vector4/#function-vec4","title":"function vec4","text":"<pre><code>inline atlas::vector4::vec4 () \n</code></pre>"},{"location":"References/structatlas_1_1vector4/#function-operator","title":"function operator=","text":"<pre><code>inline glm::vec4 atlas::vector4::operator= (\n    const T &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::vector4::operator== (\n    const glm::vec4 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector4/#function-vector4-13","title":"function vector4 [1/3]","text":"<pre><code>atlas::vector4::vector4 () = default\n</code></pre>"},{"location":"References/structatlas_1_1vector4/#function-vector4-23","title":"function vector4 [2/3]","text":"<pre><code>inline atlas::vector4::vector4 (\n    const T &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector4/#function-vector4-33","title":"function vector4 [3/3]","text":"<pre><code>inline atlas::vector4::vector4 (\n    float x,\n    float y,\n    float z,\n    float w\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4/","title":"Struct atlas::vector4&lt; glm::highp_vec4 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; atlas &gt; vector4&lt; glm::highp_vec4 &gt;</p>"},{"location":"References/structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4/#public-functions","title":"Public Functions","text":"Type Name highp_vec4 ()  glm::highp_vec4 operator= (const glm::highp_vec4 &amp; p_other)  bool operator== (const glm::highp_vec4 &amp; p_other)  vector4 () = default vector4 (const glm::highp_vec4 &amp; p_other)"},{"location":"References/structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4/#function-highp_vec4","title":"function highp_vec4","text":"<pre><code>inline atlas::vector4&lt; glm::highp_vec4 &gt;::highp_vec4 () \n</code></pre>"},{"location":"References/structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4/#function-operator","title":"function operator=","text":"<pre><code>inline glm::highp_vec4 atlas::vector4&lt; glm::highp_vec4 &gt;::operator= (\n    const glm::highp_vec4 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool atlas::vector4&lt; glm::highp_vec4 &gt;::operator== (\n    const glm::highp_vec4 &amp; p_other\n) \n</code></pre>"},{"location":"References/structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4/#function-vector4-12","title":"function vector4 [1/2]","text":"<pre><code>atlas::vector4&lt; glm::highp_vec4 &gt;::vector4 () = default\n</code></pre>"},{"location":"References/structatlas_1_1vector4_3_01glm_1_1highp__vec4_01_4/#function-vector4-22","title":"function vector4 [2/2]","text":"<pre><code>inline atlas::vector4&lt; glm::highp_vec4 &gt;::vector4 (\n    const glm::highp_vec4 &amp; p_other\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/structatlas_1_1vertex/","title":"Struct atlas::vertex","text":"<p>ClassList &gt; atlas &gt; vertex</p>"},{"location":"References/structatlas_1_1vertex/#public-attributes","title":"Public Attributes","text":"Type Name glm::vec3 Color glm::vec3 Normals glm::vec3 Position glm::vec2 TexCoords"},{"location":"References/structatlas_1_1vertex/#public-functions","title":"Public Functions","text":"Type Name bool operator== (const vertex &amp; other) const"},{"location":"References/structatlas_1_1vertex/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vertex/#variable-color","title":"variable Color","text":"<pre><code>glm::vec3 atlas::vertex::Color;\n</code></pre>"},{"location":"References/structatlas_1_1vertex/#variable-normals","title":"variable Normals","text":"<pre><code>glm::vec3 atlas::vertex::Normals;\n</code></pre>"},{"location":"References/structatlas_1_1vertex/#variable-position","title":"variable Position","text":"<pre><code>glm::vec3 atlas::vertex::Position;\n</code></pre>"},{"location":"References/structatlas_1_1vertex/#variable-texcoords","title":"variable TexCoords","text":"<pre><code>glm::vec2 atlas::vertex::TexCoords;\n</code></pre>"},{"location":"References/structatlas_1_1vertex/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/structatlas_1_1vertex/#function-operator","title":"function operator==","text":"<pre><code>inline bool atlas::vertex::operator== (\n    const vertex &amp; other\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vertex_buffer.hpp</code></p>"},{"location":"References/classatlas_1_1vertex__buffer/","title":"Class atlas::vertex_buffer","text":"<p>ClassList &gt; atlas &gt; vertex_buffer</p> <p>Inherited by the following classes: atlas::vk::vk_vertex_buffer</p>"},{"location":"References/classatlas_1_1vertex__buffer/#public-functions","title":"Public Functions","text":"Type Name void bind (const VkCommandBuffer &amp; p_command_buffer)  void draw (const VkCommandBuffer &amp; p_command_buffer)  virtual ~vertex_buffer () = default"},{"location":"References/classatlas_1_1vertex__buffer/#public-static-functions","title":"Public Static Functions","text":"Type Name ref&lt; vertex_buffer &gt; create (const std::vector&lt; vertex &gt; &amp; p_vertices)"},{"location":"References/classatlas_1_1vertex__buffer/#protected-functions","title":"Protected Functions","text":"Type Name virtual void bind_vertex_buffer (const VkCommandBuffer &amp; p_command_buffer) = 0 virtual void render_vertex_buffer (const VkCommandBuffer &amp; p_command_buffer) = 0"},{"location":"References/classatlas_1_1vertex__buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vertex__buffer/#function-bind","title":"function bind","text":"<pre><code>void atlas::vertex_buffer::bind (\n    const VkCommandBuffer &amp; p_command_buffer\n) \n</code></pre>"},{"location":"References/classatlas_1_1vertex__buffer/#function-draw","title":"function draw","text":"<pre><code>void atlas::vertex_buffer::draw (\n    const VkCommandBuffer &amp; p_command_buffer\n) \n</code></pre>"},{"location":"References/classatlas_1_1vertex__buffer/#function-vertex_buffer","title":"function ~vertex_buffer","text":"<pre><code>virtual atlas::vertex_buffer::~vertex_buffer () = default\n</code></pre>"},{"location":"References/classatlas_1_1vertex__buffer/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1vertex__buffer/#function-create","title":"function create","text":"<pre><code>static ref&lt; vertex_buffer &gt; atlas::vertex_buffer::create (\n    const std::vector&lt; vertex &gt; &amp; p_vertices\n) \n</code></pre>"},{"location":"References/classatlas_1_1vertex__buffer/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"References/classatlas_1_1vertex__buffer/#function-bind_vertex_buffer","title":"function bind_vertex_buffer","text":"<pre><code>virtual void atlas::vertex_buffer::bind_vertex_buffer (\n    const VkCommandBuffer &amp; p_command_buffer\n) = 0\n</code></pre>"},{"location":"References/classatlas_1_1vertex__buffer/#function-render_vertex_buffer","title":"function render_vertex_buffer","text":"<pre><code>virtual void atlas::vertex_buffer::render_vertex_buffer (\n    const VkCommandBuffer &amp; p_command_buffer\n) = 0\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vertex_buffer.hpp</code></p>"},{"location":"References/namespaceatlas_1_1vk/","title":"Namespace atlas::vk","text":"<p>Namespace List &gt; atlas &gt; vk</p>"},{"location":"References/namespaceatlas_1_1vk/#classes","title":"Classes","text":"Type Name class BufferTutorial class VulkanDescriptorSets class VulkanPipeline class VulkanRenderPass class VulkanUniformBuffer class descriptor_pool class descriptor_set_layout class descriptor_writer struct shader_pipeline_config class vk_context class vk_driver class vk_index_buffer class vk_physical_driver class vk_renderer class vk_shader class vk_swapchain class vk_vertex_buffer class vk_window"},{"location":"References/namespaceatlas_1_1vk/#public-types","title":"Public Types","text":"Type Name enum ImageLayout"},{"location":"References/namespaceatlas_1_1vk/#public-functions","title":"Public Functions","text":"Type Name void BeginCommandBuffer (VkCommandBuffer * p_CommandBuffer)  void EndCommandBuffer (VkCommandBuffer * p_CommandBuffer)  void Submit (const std::function&lt; void()&gt; &amp; Function)  void SubmitResourceFree (const std::function&lt; void()&gt; &amp; Function)  void begin_command_buffer (const VkCommandBuffer &amp; p_command_buffer)  VkCommandBuffer begin_single_time_command_buffer (const VkCommandPool &amp; p_command_pool)  VkCommandBuffer create_command_buffer_and_record (const VkDevice &amp; p_driver, const VkCommandPool &amp; p_command_buffer)  VkCommandPool create_command_pool ()  VkImage create_image (VkFormat p_format, uint32_t p_width, uint32_t p_height)  VkImageView create_image_view (VkImage p_image, VkFormat p_format)  void end_command_buffer (const VkCommandBuffer &amp; p_command_buffer)  void end_single_time_command_buffer (const VkCommandBuffer &amp; p_command_buffer, const VkCommandPool &amp; p_command_pool)  void pipeline_image_barrier (VkCommandBuffer p_command_buffer, VkImage Image, VkAccessFlags srcAccessmask, VkAccessFlags dstAccessMask, VkImageLayout OldImageLayout, VkImageLayout NewImageLayout, VkPipelineStageFlags srcStageFlags, VkPipelineStageFlags dstStageFlags, VkImageSubresourceRange subresourceRange)  void submit (VkQueue p_queue_to_use, const std::span&lt; VkCommandBuffer &gt; &amp; p_command_buffers)  void vk_check (VkResult p_result, const char * p_tag, const char * p_filepath, uint32_t p_line, const char * p_function_name)  void vk_check_format (VkFormat p_format, const char * p_filepath, uint32_t p_line, const char * p_function_name)  std::string vk_queue_flags_to_string (VkQueueFlagBits p_flags)"},{"location":"References/namespaceatlas_1_1vk/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"References/namespaceatlas_1_1vk/#enum-imagelayout","title":"enum ImageLayout","text":"<pre><code>enum atlas::vk::ImageLayout;\n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/namespaceatlas_1_1vk/#function-begincommandbuffer","title":"function BeginCommandBuffer","text":"<pre><code>void atlas::vk::BeginCommandBuffer (\n    VkCommandBuffer * p_CommandBuffer\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-endcommandbuffer","title":"function EndCommandBuffer","text":"<pre><code>void atlas::vk::EndCommandBuffer (\n    VkCommandBuffer * p_CommandBuffer\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-submit","title":"function Submit","text":"<pre><code>void atlas::vk::Submit (\n    const std::function&lt; void()&gt; &amp; Function\n) \n</code></pre> <p>This directly sends our information task directly to the GPU });</p> <p>This directly gets submitted to a queue for handling cleanup for the specific operation Use case is if we wanted to cleanup imgui when at deconstruction for when the application ends, they get called here, and then added to queue for cleanup }); </p>"},{"location":"References/namespaceatlas_1_1vk/#function-submitresourcefree","title":"function SubmitResourceFree","text":"<pre><code>void atlas::vk::SubmitResourceFree (\n    const std::function&lt; void()&gt; &amp; Function\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-begin_command_buffer","title":"function begin_command_buffer","text":"<pre><code>void atlas::vk::begin_command_buffer (\n    const VkCommandBuffer &amp; p_command_buffer\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-begin_single_time_command_buffer","title":"function begin_single_time_command_buffer","text":"<pre><code>VkCommandBuffer atlas::vk::begin_single_time_command_buffer (\n    const VkCommandPool &amp; p_command_pool\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-create_command_buffer_and_record","title":"function create_command_buffer_and_record","text":"<pre><code>VkCommandBuffer atlas::vk::create_command_buffer_and_record (\n    const VkDevice &amp; p_driver,\n    const VkCommandPool &amp; p_command_buffer\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-create_command_pool","title":"function create_command_pool","text":"<pre><code>VkCommandPool atlas::vk::create_command_pool () \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-create_image","title":"function create_image","text":"<pre><code>VkImage atlas::vk::create_image (\n    VkFormat p_format,\n    uint32_t p_width,\n    uint32_t p_height\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-create_image_view","title":"function create_image_view","text":"<pre><code>VkImageView atlas::vk::create_image_view (\n    VkImage p_image,\n    VkFormat p_format\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-end_command_buffer","title":"function end_command_buffer","text":"<pre><code>void atlas::vk::end_command_buffer (\n    const VkCommandBuffer &amp; p_command_buffer\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-end_single_time_command_buffer","title":"function end_single_time_command_buffer","text":"<pre><code>void atlas::vk::end_single_time_command_buffer (\n    const VkCommandBuffer &amp; p_command_buffer,\n    const VkCommandPool &amp; p_command_pool\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-pipeline_image_barrier","title":"function pipeline_image_barrier","text":"<pre><code>void atlas::vk::pipeline_image_barrier (\n    VkCommandBuffer p_command_buffer,\n    VkImage Image,\n    VkAccessFlags srcAccessmask,\n    VkAccessFlags dstAccessMask,\n    VkImageLayout OldImageLayout,\n    VkImageLayout NewImageLayout,\n    VkPipelineStageFlags srcStageFlags,\n    VkPipelineStageFlags dstStageFlags,\n    VkImageSubresourceRange subresourceRange\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-submit_1","title":"function submit","text":"<pre><code>void atlas::vk::submit (\n    VkQueue p_queue_to_use,\n    const std::span&lt; VkCommandBuffer &gt; &amp; p_command_buffers\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-vk_check","title":"function vk_check","text":"<pre><code>void atlas::vk::vk_check (\n    VkResult p_result,\n    const char * p_tag,\n    const char * p_filepath,\n    uint32_t p_line,\n    const char * p_function_name\n) \n</code></pre> <p>Note:</p> <p>Terminates if the result was unsuccessful! </p> <p>Note:</p> <p>TODO  We shouldn't std::terminate, look into alternatives. </p>"},{"location":"References/namespaceatlas_1_1vk/#function-vk_check_format","title":"function vk_check_format","text":"<pre><code>void atlas::vk::vk_check_format (\n    VkFormat p_format,\n    const char * p_filepath,\n    uint32_t p_line,\n    const char * p_function_name\n) \n</code></pre>"},{"location":"References/namespaceatlas_1_1vk/#function-vk_queue_flags_to_string","title":"function vk_queue_flags_to_string","text":"<pre><code>std::string atlas::vk::vk_queue_flags_to_string (\n    VkQueueFlagBits p_flags\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/buffer_tutorial.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/","title":"Class atlas::vk::BufferTutorial","text":"<p>ClassList &gt; atlas &gt; vk &gt; BufferTutorial</p>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#public-functions","title":"Public Functions","text":"Type Name BufferTutorial () = default BufferTutorial (uint64_t p_size, uint32_t p_count, VkBufferUsageFlags p_usage, VkMemoryPropertyFlags p_memory_property_flags, uint64_t p_min_offset_alignment=1)  VkDescriptorBufferInfo descriptor_info (uint64_t p_Size=VK_WHOLE_SIZE, uint64_t p_Offset=0)  VkDescriptorBufferInfo descriptor_info_at_index (int index)  void flush (uint64_t p_Size=VK_WHOLE_SIZE, uint64_t offset=0)  void flush_index (int index)  uint64_t get_alignment_size () const VkBuffer get_buffer_instance ()  uint32_t get_instance_count () const uint64_t get_instance_size () const VkBufferUsageFlags get_usage_flags () const void invalidate (uint64_t p_Size=VK_WHOLE_SIZE, uint64_t p_Offset=0)  void invalidate_index (int index)  void map (VkDeviceSize p_Size=VK_WHOLE_SIZE, uint64_t p_Offset=0)  void * read_mapped_data () const void unmap ()  void write_to_buffer (void * data, uint64_t p_Size=VK_WHOLE_SIZE, uint64_t p_Offset=0)  void write_to_index (void * data, int idx)"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-buffertutorial-12","title":"function BufferTutorial [1/2]","text":"<pre><code>atlas::vk::BufferTutorial::BufferTutorial () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-buffertutorial-22","title":"function BufferTutorial [2/2]","text":"<pre><code>atlas::vk::BufferTutorial::BufferTutorial (\n    uint64_t p_size,\n    uint32_t p_count,\n    VkBufferUsageFlags p_usage,\n    VkMemoryPropertyFlags p_memory_property_flags,\n    uint64_t p_min_offset_alignment=1\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>p_size</code> is the instance size in bytes </li> <li><code>p_count</code> amount of instances </li> <li><code>p_usage</code> VkBufferUsageFlags </li> </ul>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-descriptor_info","title":"function descriptor_info","text":"<pre><code>VkDescriptorBufferInfo atlas::vk::BufferTutorial::descriptor_info (\n    uint64_t p_Size=VK_WHOLE_SIZE,\n    uint64_t p_Offset=0\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-descriptor_info_at_index","title":"function descriptor_info_at_index","text":"<pre><code>VkDescriptorBufferInfo atlas::vk::BufferTutorial::descriptor_info_at_index (\n    int index\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-flush","title":"function flush","text":"<pre><code>void atlas::vk::BufferTutorial::flush (\n    uint64_t p_Size=VK_WHOLE_SIZE,\n    uint64_t offset=0\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-flush_index","title":"function flush_index","text":"<pre><code>void atlas::vk::BufferTutorial::flush_index (\n    int index\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-get_alignment_size","title":"function get_alignment_size","text":"<pre><code>inline uint64_t atlas::vk::BufferTutorial::get_alignment_size () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-get_buffer_instance","title":"function get_buffer_instance","text":"<pre><code>inline VkBuffer atlas::vk::BufferTutorial::get_buffer_instance () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-get_instance_count","title":"function get_instance_count","text":"<pre><code>inline uint32_t atlas::vk::BufferTutorial::get_instance_count () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-get_instance_size","title":"function get_instance_size","text":"<pre><code>inline uint64_t atlas::vk::BufferTutorial::get_instance_size () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-get_usage_flags","title":"function get_usage_flags","text":"<pre><code>inline VkBufferUsageFlags atlas::vk::BufferTutorial::get_usage_flags () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-invalidate","title":"function invalidate","text":"<pre><code>void atlas::vk::BufferTutorial::invalidate (\n    uint64_t p_Size=VK_WHOLE_SIZE,\n    uint64_t p_Offset=0\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-invalidate_index","title":"function invalidate_index","text":"<pre><code>void atlas::vk::BufferTutorial::invalidate_index (\n    int index\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-map","title":"function map","text":"<pre><code>void atlas::vk::BufferTutorial::map (\n    VkDeviceSize p_Size=VK_WHOLE_SIZE,\n    uint64_t p_Offset=0\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-read_mapped_data","title":"function read_mapped_data","text":"<pre><code>inline void * atlas::vk::BufferTutorial::read_mapped_data () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-unmap","title":"function unmap","text":"<pre><code>void atlas::vk::BufferTutorial::unmap () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-write_to_buffer","title":"function write_to_buffer","text":"<pre><code>void atlas::vk::BufferTutorial::write_to_buffer (\n    void * data,\n    uint64_t p_Size=VK_WHOLE_SIZE,\n    uint64_t p_Offset=0\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1BufferTutorial/#function-write_to_index","title":"function write_to_index","text":"<pre><code>void atlas::vk::BufferTutorial::write_to_index (\n    void * data,\n    int idx\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/buffer_tutorial.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1VulkanDescriptorSets/","title":"Class atlas::vk::VulkanDescriptorSets","text":"<p>ClassList &gt; atlas &gt; vk &gt; VulkanDescriptorSets</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_descriptors.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1VulkanPipeline/","title":"Class atlas::vk::VulkanPipeline","text":"<p>ClassList &gt; atlas &gt; vk &gt; VulkanPipeline</p>"},{"location":"References/classatlas_1_1vk_1_1VulkanPipeline/#public-functions","title":"Public Functions","text":"Type Name VulkanPipeline () = default VulkanPipeline (const std::string &amp; p_tag)"},{"location":"References/classatlas_1_1vk_1_1VulkanPipeline/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1VulkanPipeline/#function-vulkanpipeline-12","title":"function VulkanPipeline [1/2]","text":"<pre><code>atlas::vk::VulkanPipeline::VulkanPipeline () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1VulkanPipeline/#function-vulkanpipeline-22","title":"function VulkanPipeline [2/2]","text":"<pre><code>atlas::vk::VulkanPipeline::VulkanPipeline (\n    const std::string &amp; p_tag\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_pipeline.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1VulkanRenderPass/","title":"Class atlas::vk::VulkanRenderPass","text":"<p>ClassList &gt; atlas &gt; vk &gt; VulkanRenderPass</p> <p>Inherits the following classes: atlas::renderpass</p>"},{"location":"References/classatlas_1_1vk_1_1VulkanRenderPass/#public-functions","title":"Public Functions","text":"Type Name VulkanRenderPass (const renderpass_properties &amp; p_Properties)"},{"location":"References/classatlas_1_1vk_1_1VulkanRenderPass/#public-functions-inherited-from-atlasrenderpass","title":"Public Functions inherited from atlas::renderpass","text":"<p>See atlas::renderpass</p> Type Name void Begin ()  void End ()"},{"location":"References/classatlas_1_1vk_1_1VulkanRenderPass/#public-static-functions-inherited-from-atlasrenderpass","title":"Public Static Functions inherited from atlas::renderpass","text":"<p>See atlas::renderpass</p> Type Name ref&lt; renderpass &gt; create (const renderpass_properties &amp; properties)"},{"location":"References/classatlas_1_1vk_1_1VulkanRenderPass/#protected-functions","title":"Protected Functions","text":"Type Name virtual void BeginRenderPass () override virtual void EndRenderPass () override"},{"location":"References/classatlas_1_1vk_1_1VulkanRenderPass/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1VulkanRenderPass/#function-vulkanrenderpass","title":"function VulkanRenderPass","text":"<pre><code>atlas::vk::VulkanRenderPass::VulkanRenderPass (\n    const renderpass_properties &amp; p_Properties\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1VulkanRenderPass/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1VulkanRenderPass/#function-beginrenderpass","title":"function BeginRenderPass","text":"<pre><code>virtual void atlas::vk::VulkanRenderPass::BeginRenderPass () override\n</code></pre> <p>Note:</p> <p>Implementation-detail on when renderpasses begin/end that is graphic-api agnostic </p> <p>Implements atlas::renderpass::BeginRenderPass</p>"},{"location":"References/classatlas_1_1vk_1_1VulkanRenderPass/#function-endrenderpass","title":"function EndRenderPass","text":"<pre><code>virtual void atlas::vk::VulkanRenderPass::EndRenderPass () override\n</code></pre> <p>Implements atlas::renderpass::EndRenderPass</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_renderpass.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1VulkanUniformBuffer/","title":"Class atlas::vk::VulkanUniformBuffer","text":"<p>ClassList &gt; atlas &gt; vk &gt; VulkanUniformBuffer</p>"},{"location":"References/classatlas_1_1vk_1_1VulkanUniformBuffer/#public-functions","title":"Public Functions","text":"Type Name void AllocateUniforms ()  void MapWrite (uint32_t p_size, uint32_t p_offset, const void * p_src)  VulkanUniformBuffer () = default VulkanUniformBuffer (uint32_t p_size, uint32_t p_count)"},{"location":"References/classatlas_1_1vk_1_1VulkanUniformBuffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1VulkanUniformBuffer/#function-allocateuniforms","title":"function AllocateUniforms","text":"<pre><code>void atlas::vk::VulkanUniformBuffer::AllocateUniforms () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1VulkanUniformBuffer/#function-mapwrite","title":"function MapWrite","text":"<pre><code>void atlas::vk::VulkanUniformBuffer::MapWrite (\n    uint32_t p_size,\n    uint32_t p_offset,\n    const void * p_src\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1VulkanUniformBuffer/#function-vulkanuniformbuffer-12","title":"function VulkanUniformBuffer [1/2]","text":"<pre><code>atlas::vk::VulkanUniformBuffer::VulkanUniformBuffer () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1VulkanUniformBuffer/#function-vulkanuniformbuffer-22","title":"function VulkanUniformBuffer [2/2]","text":"<pre><code>atlas::vk::VulkanUniformBuffer::VulkanUniformBuffer (\n    uint32_t p_size,\n    uint32_t p_count\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>p_size</code> is the buffer size </li> <li><code>p_count</code> instance count </li> </ul> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_uniform_buffer.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1descriptor__pool/","title":"Class atlas::vk::descriptor_pool","text":"<p>ClassList &gt; atlas &gt; vk &gt; descriptor_pool</p>"},{"location":"References/classatlas_1_1vk_1_1descriptor__pool/#classes","title":"Classes","text":"Type Name class builder"},{"location":"References/classatlas_1_1vk_1_1descriptor__pool/#public-functions","title":"Public Functions","text":"Type Name bool allocateDescriptor (const VkDescriptorSetLayout descriptor_set_layout, VkDescriptorSet &amp; descriptor) const descriptor_pool (uint32_t maxSets, VkDescriptorPoolCreateFlags poolFlags, const std::vector&lt; VkDescriptorPoolSize &gt; &amp; poolSizes)  descriptor_pool (const descriptor_pool &amp;) = delete void freeDescriptors (std::vector&lt; VkDescriptorSet &gt; &amp; descriptors) const descriptor_pool &amp; operator= (const descriptor_pool &amp;) = delete void resetPool ()  ~descriptor_pool ()"},{"location":"References/classatlas_1_1vk_1_1descriptor__pool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1descriptor__pool/#function-allocatedescriptor","title":"function allocateDescriptor","text":"<pre><code>bool atlas::vk::descriptor_pool::allocateDescriptor (\n    const VkDescriptorSetLayout descriptor_set_layout,\n    VkDescriptorSet &amp; descriptor\n) const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__pool/#function-descriptor_pool-12","title":"function descriptor_pool [1/2]","text":"<pre><code>atlas::vk::descriptor_pool::descriptor_pool (\n    uint32_t maxSets,\n    VkDescriptorPoolCreateFlags poolFlags,\n    const std::vector&lt; VkDescriptorPoolSize &gt; &amp; poolSizes\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__pool/#function-descriptor_pool-22","title":"function descriptor_pool [2/2]","text":"<pre><code>atlas::vk::descriptor_pool::descriptor_pool (\n    const descriptor_pool &amp;\n) = delete\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__pool/#function-freedescriptors","title":"function freeDescriptors","text":"<pre><code>void atlas::vk::descriptor_pool::freeDescriptors (\n    std::vector&lt; VkDescriptorSet &gt; &amp; descriptors\n) const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__pool/#function-operator","title":"function operator=","text":"<pre><code>descriptor_pool &amp; atlas::vk::descriptor_pool::operator= (\n    const descriptor_pool &amp;\n) = delete\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__pool/#function-resetpool","title":"function resetPool","text":"<pre><code>void atlas::vk::descriptor_pool::resetPool () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__pool/#function-descriptor_pool","title":"function ~descriptor_pool","text":"<pre><code>atlas::vk::descriptor_pool::~descriptor_pool () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/descriptor_tutorial.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1descriptor__pool_1_1builder/","title":"Class atlas::vk::descriptor_pool::builder","text":"<p>ClassList &gt; atlas &gt; vk &gt; descriptor_pool &gt; builder</p>"},{"location":"References/classatlas_1_1vk_1_1descriptor__pool_1_1builder/#public-functions","title":"Public Functions","text":"Type Name builder &amp; addPoolSize (VkDescriptorType descriptorType, uint32_t count)  std::unique_ptr&lt; descriptor_pool &gt; build () const builder () = default builder &amp; setMaxSets (uint32_t count)  builder &amp; setPoolFlags (VkDescriptorPoolCreateFlags flags)"},{"location":"References/classatlas_1_1vk_1_1descriptor__pool_1_1builder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1descriptor__pool_1_1builder/#function-addpoolsize","title":"function addPoolSize","text":"<pre><code>builder &amp; atlas::vk::descriptor_pool::builder::addPoolSize (\n    VkDescriptorType descriptorType,\n    uint32_t count\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__pool_1_1builder/#function-build","title":"function build","text":"<pre><code>std::unique_ptr&lt; descriptor_pool &gt; atlas::vk::descriptor_pool::builder::build () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__pool_1_1builder/#function-builder","title":"function builder","text":"<pre><code>atlas::vk::descriptor_pool::builder::builder () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__pool_1_1builder/#function-setmaxsets","title":"function setMaxSets","text":"<pre><code>builder &amp; atlas::vk::descriptor_pool::builder::setMaxSets (\n    uint32_t count\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__pool_1_1builder/#function-setpoolflags","title":"function setPoolFlags","text":"<pre><code>builder &amp; atlas::vk::descriptor_pool::builder::setPoolFlags (\n    VkDescriptorPoolCreateFlags flags\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/descriptor_tutorial.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set__layout/","title":"Class atlas::vk::descriptor_set_layout","text":"<p>ClassList &gt; atlas &gt; vk &gt; descriptor_set_layout</p>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set__layout/#classes","title":"Classes","text":"Type Name class builder"},{"location":"References/classatlas_1_1vk_1_1descriptor__set__layout/#public-functions","title":"Public Functions","text":"Type Name VkDescriptorSetLayoutBinding &amp; Get (uint32_t bind)  descriptor_set_layout (std::unordered_map&lt; uint32_t, VkDescriptorSetLayoutBinding &gt; bindings)  descriptor_set_layout (const descriptor_set_layout &amp;) = delete VkDescriptorSetLayout get_descriptor_set_layout () const descriptor_set_layout &amp; operator= (const descriptor_set_layout &amp;) = delete ~descriptor_set_layout ()"},{"location":"References/classatlas_1_1vk_1_1descriptor__set__layout/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1descriptor__set__layout/#function-get","title":"function Get","text":"<pre><code>inline VkDescriptorSetLayoutBinding &amp; atlas::vk::descriptor_set_layout::Get (\n    uint32_t bind\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set__layout/#function-descriptor_set_layout-12","title":"function descriptor_set_layout [1/2]","text":"<pre><code>atlas::vk::descriptor_set_layout::descriptor_set_layout (\n    std::unordered_map&lt; uint32_t, VkDescriptorSetLayoutBinding &gt; bindings\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set__layout/#function-descriptor_set_layout-22","title":"function descriptor_set_layout [2/2]","text":"<pre><code>atlas::vk::descriptor_set_layout::descriptor_set_layout (\n    const descriptor_set_layout &amp;\n) = delete\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set__layout/#function-get_descriptor_set_layout","title":"function get_descriptor_set_layout","text":"<pre><code>inline VkDescriptorSetLayout atlas::vk::descriptor_set_layout::get_descriptor_set_layout () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set__layout/#function-operator","title":"function operator=","text":"<pre><code>descriptor_set_layout &amp; atlas::vk::descriptor_set_layout::operator= (\n    const descriptor_set_layout &amp;\n) = delete\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set__layout/#function-descriptor_set_layout","title":"function ~descriptor_set_layout","text":"<pre><code>atlas::vk::descriptor_set_layout::~descriptor_set_layout () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/descriptor_tutorial.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set__layout_1_1builder/","title":"Class atlas::vk::descriptor_set_layout::builder","text":"<p>ClassList &gt; atlas &gt; vk &gt; descriptor_set_layout &gt; builder</p>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set__layout_1_1builder/#public-functions","title":"Public Functions","text":"Type Name builder &amp; addBinding (uint32_t binding, VkDescriptorType descriptorType, VkShaderStageFlags stageFlags, uint32_t count=1)  std::unique_ptr&lt; descriptor_set_layout &gt; build () const builder () = default"},{"location":"References/classatlas_1_1vk_1_1descriptor__set__layout_1_1builder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1descriptor__set__layout_1_1builder/#function-addbinding","title":"function addBinding","text":"<pre><code>builder &amp; atlas::vk::descriptor_set_layout::builder::addBinding (\n    uint32_t binding,\n    VkDescriptorType descriptorType,\n    VkShaderStageFlags stageFlags,\n    uint32_t count=1\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set__layout_1_1builder/#function-build","title":"function build","text":"<pre><code>std::unique_ptr&lt; descriptor_set_layout &gt; atlas::vk::descriptor_set_layout::builder::build () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__set__layout_1_1builder/#function-builder","title":"function builder","text":"<pre><code>atlas::vk::descriptor_set_layout::builder::builder () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/descriptor_tutorial.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1descriptor__writer/","title":"Class atlas::vk::descriptor_writer","text":"<p>ClassList &gt; atlas &gt; vk &gt; descriptor_writer</p>"},{"location":"References/classatlas_1_1vk_1_1descriptor__writer/#public-functions","title":"Public Functions","text":"Type Name bool build (VkDescriptorSet &amp; set)  descriptor_writer (descriptor_set_layout &amp; setLayout, descriptor_pool &amp; pool)  void overwrite (VkDescriptorSet &amp; set)  descriptor_writer &amp; writeBuffer (uint32_t binding, VkDescriptorBufferInfo * bufferInfo)  descriptor_writer &amp; writeImage (uint32_t binding, VkDescriptorImageInfo * imageInfo)"},{"location":"References/classatlas_1_1vk_1_1descriptor__writer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1descriptor__writer/#function-build","title":"function build","text":"<pre><code>bool atlas::vk::descriptor_writer::build (\n    VkDescriptorSet &amp; set\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__writer/#function-descriptor_writer","title":"function descriptor_writer","text":"<pre><code>atlas::vk::descriptor_writer::descriptor_writer (\n    descriptor_set_layout &amp; setLayout,\n    descriptor_pool &amp; pool\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__writer/#function-overwrite","title":"function overwrite","text":"<pre><code>void atlas::vk::descriptor_writer::overwrite (\n    VkDescriptorSet &amp; set\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__writer/#function-writebuffer","title":"function writeBuffer","text":"<pre><code>descriptor_writer &amp; atlas::vk::descriptor_writer::writeBuffer (\n    uint32_t binding,\n    VkDescriptorBufferInfo * bufferInfo\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1descriptor__writer/#function-writeimage","title":"function writeImage","text":"<pre><code>descriptor_writer &amp; atlas::vk::descriptor_writer::writeImage (\n    uint32_t binding,\n    VkDescriptorImageInfo * imageInfo\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/descriptor_tutorial.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1shader__pipeline__config/","title":"Struct atlas::vk::shader_pipeline_config","text":"<p>ClassList &gt; atlas &gt; vk &gt; shader_pipeline_config</p> <p>More...</p> <ul> <li><code>#include &lt;vulkan_shader_pipeline_config.hpp&gt;</code></li> </ul>"},{"location":"References/structatlas_1_1vk_1_1shader__pipeline__config/#public-attributes","title":"Public Attributes","text":"Type Name VkPipelineColorBlendAttachmentState PipelineColorBlendAttachments VkPipelineColorBlendStateCreateInfo PipelineColorBlendCreateInfo VkPipelineDepthStencilStateCreateInfo PipelineDepthStencilCreateInfo VkPipelineInputAssemblyStateCreateInfo PipelineInputAsmInfo VkPipelineLayout PipelineLayout VkPipelineMultisampleStateCreateInfo PipelineMultisampleCreateInfo VkPipelineRasterizationStateCreateInfo PipelineRasterizationCreateInfo VkRenderPass PipelineRenderPass VkRect2D Scissor uint32_t SubpassCount VkViewport Viewport"},{"location":"References/structatlas_1_1vk_1_1shader__pipeline__config/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Used for specifying how the shader pipeline configuration may look like. </p> <p>Note:</p> <p>Used by vk_shader </p>"},{"location":"References/structatlas_1_1vk_1_1shader__pipeline__config/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1shader__pipeline__config/#variable-pipelinecolorblendattachments","title":"variable PipelineColorBlendAttachments","text":"<pre><code>VkPipelineColorBlendAttachmentState atlas::vk::shader_pipeline_config::PipelineColorBlendAttachments;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1shader__pipeline__config/#variable-pipelinecolorblendcreateinfo","title":"variable PipelineColorBlendCreateInfo","text":"<pre><code>VkPipelineColorBlendStateCreateInfo atlas::vk::shader_pipeline_config::PipelineColorBlendCreateInfo;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1shader__pipeline__config/#variable-pipelinedepthstencilcreateinfo","title":"variable PipelineDepthStencilCreateInfo","text":"<pre><code>VkPipelineDepthStencilStateCreateInfo atlas::vk::shader_pipeline_config::PipelineDepthStencilCreateInfo;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1shader__pipeline__config/#variable-pipelineinputasminfo","title":"variable PipelineInputAsmInfo","text":"<pre><code>VkPipelineInputAssemblyStateCreateInfo atlas::vk::shader_pipeline_config::PipelineInputAsmInfo;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1shader__pipeline__config/#variable-pipelinelayout","title":"variable PipelineLayout","text":"<pre><code>VkPipelineLayout atlas::vk::shader_pipeline_config::PipelineLayout;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1shader__pipeline__config/#variable-pipelinemultisamplecreateinfo","title":"variable PipelineMultisampleCreateInfo","text":"<pre><code>VkPipelineMultisampleStateCreateInfo atlas::vk::shader_pipeline_config::PipelineMultisampleCreateInfo;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1shader__pipeline__config/#variable-pipelinerasterizationcreateinfo","title":"variable PipelineRasterizationCreateInfo","text":"<pre><code>VkPipelineRasterizationStateCreateInfo atlas::vk::shader_pipeline_config::PipelineRasterizationCreateInfo;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1shader__pipeline__config/#variable-pipelinerenderpass","title":"variable PipelineRenderPass","text":"<pre><code>VkRenderPass atlas::vk::shader_pipeline_config::PipelineRenderPass;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1shader__pipeline__config/#variable-scissor","title":"variable Scissor","text":"<pre><code>VkRect2D atlas::vk::shader_pipeline_config::Scissor;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1shader__pipeline__config/#variable-subpasscount","title":"variable SubpassCount","text":"<pre><code>uint32_t atlas::vk::shader_pipeline_config::SubpassCount;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1shader__pipeline__config/#variable-viewport","title":"variable Viewport","text":"<pre><code>VkViewport atlas::vk::shader_pipeline_config::Viewport;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/shaders/vulkan_shader_pipeline_config.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__context/","title":"Class atlas::vk::vk_context","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_context</p>"},{"location":"References/classatlas_1_1vk_1_1vk__context/#public-static-functions","title":"Public Static Functions","text":"Type Name vk_driver &amp; get_current_driver ()  vk_physical_driver &amp; get_current_selected_physical_driver ()  VkInstance get_vk_instance ()  void initialize ()"},{"location":"References/classatlas_1_1vk_1_1vk__context/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__context/#function-get_current_driver","title":"function get_current_driver","text":"<pre><code>static inline vk_driver &amp; atlas::vk::vk_context::get_current_driver () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__context/#function-get_current_selected_physical_driver","title":"function get_current_selected_physical_driver","text":"<pre><code>static inline vk_physical_driver &amp; atlas::vk::vk_context::get_current_selected_physical_driver () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__context/#function-get_vk_instance","title":"function get_vk_instance","text":"<pre><code>static inline VkInstance atlas::vk::vk_context::get_vk_instance () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__context/#function-initialize","title":"function initialize","text":"<pre><code>static void atlas::vk::vk_context::initialize () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_context.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/","title":"Class atlas::vk::vk_driver","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_driver</p>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#public-functions","title":"Public Functions","text":"Type Name VkQueue get_graphics_queue () const operator VkDevice ()  uint32_t select_memory_type (uint32_t p_type_filter, VkMemoryPropertyFlags p_property_flag)  vk_driver () = default vk_driver (const vk_physical_driver &amp; p_physical)"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__driver/#function-get_graphics_queue","title":"function get_graphics_queue","text":"<pre><code>inline VkQueue atlas::vk::vk_driver::get_graphics_queue () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#function-operator-vkdevice","title":"function operator VkDevice","text":"<pre><code>inline atlas::vk::vk_driver::operator VkDevice () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#function-select_memory_type","title":"function select_memory_type","text":"<pre><code>uint32_t atlas::vk::vk_driver::select_memory_type (\n    uint32_t p_type_filter,\n    VkMemoryPropertyFlags p_property_flag\n) \n</code></pre> <p>Note:</p> <p>Returns -1 if there are no flags available/compatible/valid </p>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#function-vk_driver-12","title":"function vk_driver [1/2]","text":"<pre><code>atlas::vk::vk_driver::vk_driver () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__driver/#function-vk_driver-22","title":"function vk_driver [2/2]","text":"<pre><code>atlas::vk::vk_driver::vk_driver (\n    const vk_physical_driver &amp; p_physical\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_driver.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__index__buffer/","title":"Class atlas::vk::vk_index_buffer","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_index_buffer</p> <p>Inherits the following classes: atlas::index_buffer</p>"},{"location":"References/classatlas_1_1vk_1_1vk__index__buffer/#public-functions","title":"Public Functions","text":"Type Name vk_index_buffer (const std::vector&lt; uint32_t &gt; &amp; p_indices)  ~vk_index_buffer () override"},{"location":"References/classatlas_1_1vk_1_1vk__index__buffer/#public-functions-inherited-from-atlasindex_buffer","title":"Public Functions inherited from atlas::index_buffer","text":"<p>See atlas::index_buffer</p> Type Name void bind (const VkCommandBuffer &amp; p_command_buffer)  void draw (const VkCommandBuffer &amp; p_command_buffer)  bool has_indices () const virtual ~index_buffer () = default"},{"location":"References/classatlas_1_1vk_1_1vk__index__buffer/#public-static-functions-inherited-from-atlasindex_buffer","title":"Public Static Functions inherited from atlas::index_buffer","text":"<p>See atlas::index_buffer</p> Type Name ref&lt; index_buffer &gt; create (const std::vector&lt; uint32_t &gt; &amp; p_indices)"},{"location":"References/classatlas_1_1vk_1_1vk__index__buffer/#protected-functions-inherited-from-atlasindex_buffer","title":"Protected Functions inherited from atlas::index_buffer","text":"<p>See atlas::index_buffer</p> Type Name virtual void bind_to_index_buffer (const VkCommandBuffer &amp; p_command_buffer) = 0 virtual bool contains_indices () const = 0 virtual void render_index_buffer (const VkCommandBuffer &amp; p_command_buffer) = 0"},{"location":"References/classatlas_1_1vk_1_1vk__index__buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__index__buffer/#function-vk_index_buffer","title":"function vk_index_buffer","text":"<pre><code>atlas::vk::vk_index_buffer::vk_index_buffer (\n    const std::vector&lt; uint32_t &gt; &amp; p_indices\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__index__buffer/#function-vk_index_buffer_1","title":"function ~vk_index_buffer","text":"<pre><code>atlas::vk::vk_index_buffer::~vk_index_buffer () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_index_buffer.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/","title":"Class atlas::vk::vk_physical_driver","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_physical_driver</p>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#classes","title":"Classes","text":"Type Name struct queue_family_indices"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#public-functions","title":"Public Functions","text":"Type Name uint32_t get_presentation_index (VkSurfaceKHR p_surface) const VkPhysicalDeviceProperties get_properties () const queue_family_indices get_queue_indices () const operator VkPhysicalDevice ()  operator VkPhysicalDevice () const uint32_t search_memory_type (uint32_t p_type_filter, VkMemoryPropertyFlags p_properties)  vk_physical_driver () = default vk_physical_driver (const VkInstance &amp; p_instance)"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#function-get_presentation_index","title":"function get_presentation_index","text":"<pre><code>uint32_t atlas::vk::vk_physical_driver::get_presentation_index (\n    VkSurfaceKHR p_surface\n) const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#function-get_properties","title":"function get_properties","text":"<pre><code>inline VkPhysicalDeviceProperties atlas::vk::vk_physical_driver::get_properties () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#function-get_queue_indices","title":"function get_queue_indices","text":"<pre><code>inline queue_family_indices atlas::vk::vk_physical_driver::get_queue_indices () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#function-operator-vkphysicaldevice-12","title":"function operator VkPhysicalDevice [1/2]","text":"<pre><code>inline atlas::vk::vk_physical_driver::operator VkPhysicalDevice () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#function-operator-vkphysicaldevice-22","title":"function operator VkPhysicalDevice [2/2]","text":"<pre><code>inline atlas::vk::vk_physical_driver::operator VkPhysicalDevice () const\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#function-search_memory_type","title":"function search_memory_type","text":"<pre><code>uint32_t atlas::vk::vk_physical_driver::search_memory_type (\n    uint32_t p_type_filter,\n    VkMemoryPropertyFlags p_properties\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#function-vk_physical_driver-12","title":"function vk_physical_driver [1/2]","text":"<pre><code>atlas::vk::vk_physical_driver::vk_physical_driver () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__physical__driver/#function-vk_physical_driver-22","title":"function vk_physical_driver [2/2]","text":"<pre><code>atlas::vk::vk_physical_driver::vk_physical_driver (\n    const VkInstance &amp; p_instance\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_physical_driver.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1vk__physical__driver_1_1queue__family__indices/","title":"Struct atlas::vk::vk_physical_driver::queue_family_indices","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_physical_driver &gt; queue_family_indices</p>"},{"location":"References/structatlas_1_1vk_1_1vk__physical__driver_1_1queue__family__indices/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t Compute   = <code>-1</code> uint32_t Graphics   = <code>-1</code> uint32_t Transfer   = <code>-1</code>"},{"location":"References/structatlas_1_1vk_1_1vk__physical__driver_1_1queue__family__indices/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1vk__physical__driver_1_1queue__family__indices/#variable-compute","title":"variable Compute","text":"<pre><code>uint32_t atlas::vk::vk_physical_driver::queue_family_indices::Compute;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__physical__driver_1_1queue__family__indices/#variable-graphics","title":"variable Graphics","text":"<pre><code>uint32_t atlas::vk::vk_physical_driver::queue_family_indices::Graphics;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__physical__driver_1_1queue__family__indices/#variable-transfer","title":"variable Transfer","text":"<pre><code>uint32_t atlas::vk::vk_physical_driver::queue_family_indices::Transfer;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_physical_driver.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__renderer/","title":"Class atlas::vk::vk_renderer","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_renderer</p> <p>Inherits the following classes: atlas::render_context</p>"},{"location":"References/classatlas_1_1vk_1_1vk__renderer/#public-functions","title":"Public Functions","text":"Type Name vk_renderer (const std::string &amp; tag)  ~vk_renderer () override"},{"location":"References/classatlas_1_1vk_1_1vk__renderer/#public-functions-inherited-from-atlasrender_context","title":"Public Functions inherited from atlas::render_context","text":"<p>See atlas::render_context</p> Type Name void begin ()  void end ()  virtual ~render_context () = default"},{"location":"References/classatlas_1_1vk_1_1vk__renderer/#public-static-functions","title":"Public Static Functions","text":"Type Name VkFramebuffer current_frame_buffer ()  VkCommandBuffer get_current_command_buffer ()  uint32_t get_current_command_buffer_index ()"},{"location":"References/classatlas_1_1vk_1_1vk__renderer/#public-static-functions-inherited-from-atlasrender_context","title":"Public Static Functions inherited from atlas::render_context","text":"<p>See atlas::render_context</p> Type Name uint32_t get_current_frame ()  scope&lt; render_context &gt; initialize (const std::string &amp; p_tag)"},{"location":"References/classatlas_1_1vk_1_1vk__renderer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__renderer/#function-vk_renderer","title":"function vk_renderer","text":"<pre><code>atlas::vk::vk_renderer::vk_renderer (\n    const std::string &amp; tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__renderer/#function-vk_renderer_1","title":"function ~vk_renderer","text":"<pre><code>atlas::vk::vk_renderer::~vk_renderer () override\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__renderer/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__renderer/#function-current_frame_buffer","title":"function current_frame_buffer","text":"<pre><code>static VkFramebuffer atlas::vk::vk_renderer::current_frame_buffer () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__renderer/#function-get_current_command_buffer","title":"function get_current_command_buffer","text":"<pre><code>static VkCommandBuffer atlas::vk::vk_renderer::get_current_command_buffer () \n</code></pre> <p>Note:</p> <p>Implementation-details for sending draw calls. </p>"},{"location":"References/classatlas_1_1vk_1_1vk__renderer/#function-get_current_command_buffer_index","title":"function get_current_command_buffer_index","text":"<pre><code>static uint32_t atlas::vk::vk_renderer::get_current_command_buffer_index () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_renderer.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__shader/","title":"Class atlas::vk::vk_shader","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_shader</p> <p>Inherits the following classes: atlas::shader</p>"},{"location":"References/classatlas_1_1vk_1_1vk__shader/#public-functions","title":"Public Functions","text":"Type Name VkPipeline get_graphics_pipeline ()  vk_shader () = default vk_shader (const std::string &amp; p_vertex, const std::string &amp; p_fragment, const shader_pipeline_config &amp; p_config={})  virtual ~vk_shader ()"},{"location":"References/classatlas_1_1vk_1_1vk__shader/#public-functions-inherited-from-atlasshader","title":"Public Functions inherited from atlas::shader","text":"<p>See atlas::shader</p> Type Name VkPipeline get_graphics_pipeline ()  virtual ~shader () = default"},{"location":"References/classatlas_1_1vk_1_1vk__shader/#public-static-functions","title":"Public Static Functions","text":"Type Name shader_pipeline_config shader_configuration (uint32_t p_width, uint32_t p_height)"},{"location":"References/classatlas_1_1vk_1_1vk__shader/#public-static-functions-inherited-from-atlasshader","title":"Public Static Functions inherited from atlas::shader","text":"<p>See atlas::shader</p> Type Name ref&lt; shader &gt; create (const std::string &amp; p_vert_shader, const std::string &amp; p_frag_shader, const vk::shader_pipeline_config &amp; p_config)"},{"location":"References/classatlas_1_1vk_1_1vk__shader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__shader/#function-get_graphics_pipeline","title":"function get_graphics_pipeline","text":"<pre><code>inline VkPipeline atlas::vk::vk_shader::get_graphics_pipeline () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__shader/#function-vk_shader-12","title":"function vk_shader [1/2]","text":"<pre><code>atlas::vk::vk_shader::vk_shader () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__shader/#function-vk_shader-22","title":"function vk_shader [2/2]","text":"<pre><code>atlas::vk::vk_shader::vk_shader (\n    const std::string &amp; p_vertex,\n    const std::string &amp; p_fragment,\n    const shader_pipeline_config &amp; p_config={}\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__shader/#function-vk_shader","title":"function ~vk_shader","text":"<pre><code>inline virtual atlas::vk::vk_shader::~vk_shader () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__shader/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__shader/#function-shader_configuration","title":"function shader_configuration","text":"<pre><code>static shader_pipeline_config atlas::vk::vk_shader::shader_configuration (\n    uint32_t p_width,\n    uint32_t p_height\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/shaders/vulkan_shader.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/","title":"Class atlas::vk::vk_swapchain","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_swapchain</p> <p>Inherits the following classes: atlas::swapchain</p>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint32_t max_frames_in_flight   = <code>2</code>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#public-functions","title":"Public Functions","text":"Type Name vk_swapchain () = default vk_swapchain (const vk_physical_driver &amp; p_physical, const vk_driver &amp; p_driver, const VkSurfaceKHR &amp; p_surface)  ~vk_swapchain () override"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#public-functions-inherited-from-atlasswapchain","title":"Public Functions inherited from atlas::swapchain","text":"<p>See atlas::swapchain</p> Type Name uint32_t acquire_next_image ()  uint32_t get_current_per_tick ()  VkExtent2D get_extent ()  VkFramebuffer get_framebuffer (uint32_t p_index)  VkImageView get_image_view (uint32_t p_index)  uint32_t get_images_size () const VkRenderPass get_renderpass ()  VkFormat &amp; get_swapchain_format ()  VkSwapchainKHR get_vk_swapchain ()  bool is_resized ()  void on_resize (uint32_t p_width, uint32_t p_height)  void set_resize_status (bool p_is_resized_signaled)  void submit_command_buffer (VkCommandBuffer * p_command_buffers)  virtual ~swapchain () = default"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#public-static-functions","title":"Public Static Functions","text":"Type Name bool is_resized ()  void resize_reset ()"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#public-static-functions-inherited-from-atlasswapchain","title":"Public Static Functions inherited from atlas::swapchain","text":"<p>See atlas::swapchain</p> Type Name ref&lt; swapchain &gt; initialize (VkSurfaceKHR p_surface)  bool is_rebuild ()  void reset_build ()"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#variable-max_frames_in_flight","title":"variable max_frames_in_flight","text":"<pre><code>constexpr uint32_t atlas::vk::vk_swapchain::max_frames_in_flight;\n</code></pre> <p>Note:</p> <p>TODO: Change this into RendererConfig </p>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-vk_swapchain-12","title":"function vk_swapchain [1/2]","text":"<pre><code>atlas::vk::vk_swapchain::vk_swapchain () = default\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-vk_swapchain-22","title":"function vk_swapchain [2/2]","text":"<pre><code>atlas::vk::vk_swapchain::vk_swapchain (\n    const vk_physical_driver &amp; p_physical,\n    const vk_driver &amp; p_driver,\n    const VkSurfaceKHR &amp; p_surface\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-vk_swapchain","title":"function ~vk_swapchain","text":"<pre><code>atlas::vk::vk_swapchain::~vk_swapchain () override\n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-is_resized","title":"function is_resized","text":"<pre><code>static bool atlas::vk::vk_swapchain::is_resized () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__swapchain/#function-resize_reset","title":"function resize_reset","text":"<pre><code>static void atlas::vk::vk_swapchain::resize_reset () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_swapchain.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/","title":"Class atlas::vk::vk_vertex_buffer","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_vertex_buffer</p> <p>Inherits the following classes: atlas::vertex_buffer</p>"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#public-functions","title":"Public Functions","text":"Type Name vk_vertex_buffer (const std::vector&lt; vertex &gt; &amp; p_vertices)  virtual ~vk_vertex_buffer ()"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#public-functions-inherited-from-atlasvertex_buffer","title":"Public Functions inherited from atlas::vertex_buffer","text":"<p>See atlas::vertex_buffer</p> Type Name void bind (const VkCommandBuffer &amp; p_command_buffer)  void draw (const VkCommandBuffer &amp; p_command_buffer)  virtual ~vertex_buffer () = default"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#public-static-functions-inherited-from-atlasvertex_buffer","title":"Public Static Functions inherited from atlas::vertex_buffer","text":"<p>See atlas::vertex_buffer</p> Type Name ref&lt; vertex_buffer &gt; create (const std::vector&lt; vertex &gt; &amp; p_vertices)"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#protected-functions","title":"Protected Functions","text":"Type Name virtual void bind_vertex_buffer (const VkCommandBuffer &amp; p_command_buffer) override virtual void render_vertex_buffer (const VkCommandBuffer &amp; p_command_buffer) override"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#protected-functions-inherited-from-atlasvertex_buffer","title":"Protected Functions inherited from atlas::vertex_buffer","text":"<p>See atlas::vertex_buffer</p> Type Name virtual void bind_vertex_buffer (const VkCommandBuffer &amp; p_command_buffer) = 0 virtual void render_vertex_buffer (const VkCommandBuffer &amp; p_command_buffer) = 0"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#function-vk_vertex_buffer","title":"function vk_vertex_buffer","text":"<pre><code>atlas::vk::vk_vertex_buffer::vk_vertex_buffer (\n    const std::vector&lt; vertex &gt; &amp; p_vertices\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#function-vk_vertex_buffer_1","title":"function ~vk_vertex_buffer","text":"<pre><code>inline virtual atlas::vk::vk_vertex_buffer::~vk_vertex_buffer () \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#function-bind_vertex_buffer","title":"function bind_vertex_buffer","text":"<pre><code>virtual void atlas::vk::vk_vertex_buffer::bind_vertex_buffer (\n    const VkCommandBuffer &amp; p_command_buffer\n) override\n</code></pre> <p>Implements atlas::vertex_buffer::bind_vertex_buffer</p>"},{"location":"References/classatlas_1_1vk_1_1vk__vertex__buffer/#function-render_vertex_buffer","title":"function render_vertex_buffer","text":"<pre><code>virtual void atlas::vk::vk_vertex_buffer::render_vertex_buffer (\n    const VkCommandBuffer &amp; p_command_buffer\n) override\n</code></pre> <p>Implements atlas::vertex_buffer::render_vertex_buffer</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_vertex_buffer.hpp</code></p>"},{"location":"References/classatlas_1_1vk_1_1vk__window/","title":"Class atlas::vk::vk_window","text":"<p>ClassList &gt; atlas &gt; vk &gt; vk_window</p> <p>Inherits the following classes: atlas::window</p>"},{"location":"References/classatlas_1_1vk_1_1vk__window/#public-functions","title":"Public Functions","text":"Type Name vk_window (uint32_t p_width, uint32_t p_height, const std::string &amp; p_tag)  ~vk_window () override"},{"location":"References/classatlas_1_1vk_1_1vk__window/#public-functions-inherited-from-atlaswindow","title":"Public Functions inherited from atlas::window","text":"<p>See atlas::window</p> Type Name void close ()  float get_aspect_ratio () const ref&lt; swapchain &gt; get_current_swapchain ()  uint32_t get_height () const GLFWwindow * get_native_window () const uint32_t get_width () const bool is_active () const operator GLFWwindow * ()  virtual ~window () = default"},{"location":"References/classatlas_1_1vk_1_1vk__window/#public-static-functions-inherited-from-atlaswindow","title":"Public Static Functions inherited from atlas::window","text":"<p>See atlas::window</p> Type Name ref&lt; window &gt; create (uint32_t p_width, uint32_t p_height, const std::string &amp; p_tag=\"Undefined Window Title\")"},{"location":"References/classatlas_1_1vk_1_1vk__window/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1vk_1_1vk__window/#function-vk_window","title":"function vk_window","text":"<pre><code>atlas::vk::vk_window::vk_window (\n    uint32_t p_width,\n    uint32_t p_height,\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1vk_1_1vk__window/#function-vk_window_1","title":"function ~vk_window","text":"<pre><code>atlas::vk::vk_window::~vk_window () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_window.hpp</code></p>"},{"location":"References/classatlas_1_1window/","title":"Class atlas::window","text":"<p>ClassList &gt; atlas &gt; window</p> <p>Inherited by the following classes: atlas::vk::vk_window</p>"},{"location":"References/classatlas_1_1window/#public-functions","title":"Public Functions","text":"Type Name void close ()  float get_aspect_ratio () const ref&lt; swapchain &gt; get_current_swapchain ()  uint32_t get_height () const GLFWwindow * get_native_window () const uint32_t get_width () const bool is_active () const operator GLFWwindow * ()  virtual ~window () = default"},{"location":"References/classatlas_1_1window/#public-static-functions","title":"Public Static Functions","text":"Type Name ref&lt; window &gt; create (uint32_t p_width, uint32_t p_height, const std::string &amp; p_tag=\"Undefined Window Title\")"},{"location":"References/classatlas_1_1window/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1window/#function-close","title":"function close","text":"<pre><code>void atlas::window::close () \n</code></pre>"},{"location":"References/classatlas_1_1window/#function-get_aspect_ratio","title":"function get_aspect_ratio","text":"<pre><code>float atlas::window::get_aspect_ratio () const\n</code></pre>"},{"location":"References/classatlas_1_1window/#function-get_current_swapchain","title":"function get_current_swapchain","text":"<pre><code>ref&lt; swapchain &gt; atlas::window::get_current_swapchain () \n</code></pre>"},{"location":"References/classatlas_1_1window/#function-get_height","title":"function get_height","text":"<pre><code>uint32_t atlas::window::get_height () const\n</code></pre>"},{"location":"References/classatlas_1_1window/#function-get_native_window","title":"function get_native_window","text":"<pre><code>GLFWwindow * atlas::window::get_native_window () const\n</code></pre>"},{"location":"References/classatlas_1_1window/#function-get_width","title":"function get_width","text":"<pre><code>uint32_t atlas::window::get_width () const\n</code></pre>"},{"location":"References/classatlas_1_1window/#function-is_active","title":"function is_active","text":"<pre><code>bool atlas::window::is_active () const\n</code></pre>"},{"location":"References/classatlas_1_1window/#function-operator-glfwwindow","title":"function operator GLFWwindow *","text":"<pre><code>inline atlas::window::operator GLFWwindow * () \n</code></pre> <p>Note:</p> <p>This treats our window class to be able to get called like a \"GLFWwindow*\" </p>"},{"location":"References/classatlas_1_1window/#function-window","title":"function ~window","text":"<pre><code>virtual atlas::window::~window () = default\n</code></pre>"},{"location":"References/classatlas_1_1window/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"References/classatlas_1_1window/#function-create","title":"function create","text":"<pre><code>static ref&lt; window &gt; atlas::window::create (\n    uint32_t p_width,\n    uint32_t p_height,\n    const std::string &amp; p_tag=\"Undefined Window Title\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/window.hpp</code></p>"},{"location":"References/classatlas_1_1world__scope/","title":"Class atlas::world_scope","text":"<p>ClassList &gt; atlas &gt; world_scope</p> <p>Lets rethink how world_scope gets created.More...</p> <ul> <li><code>#include &lt;world.hpp&gt;</code></li> </ul> <p>Inherits the following classes: std::enable_shared_from_this&lt; world_scope &gt;</p>"},{"location":"References/classatlas_1_1world__scope/#public-functions","title":"Public Functions","text":"Type Name void add_scene (const ref&lt; scene_scope &gt; &amp; p_scene_context)  ref&lt; world_scope &gt; get ()  ref&lt; scene_scope &gt; get_scene (const std::string &amp; p_tag)  std::string get_tag () const world &amp; ()  world_scope () = default world_scope (const std::string &amp; p_tag)  ~world_scope ()"},{"location":"References/classatlas_1_1world__scope/#detailed-description","title":"Detailed Description","text":"<p>The way this works is system_registry is going to essentially be how we register worlds</p> <p>Only difference is we aren't constructing it like: register_to(this)</p> <p>What WE are going to do is world_handler = system_registry::create(p_tag);</p> <p>What this does is essentially creates a world scope inside your world that you want to create and the system registry will create, manage, and keep track of lifetimes of world_scopes </p>"},{"location":"References/classatlas_1_1world__scope/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/classatlas_1_1world__scope/#function-add_scene","title":"function add_scene","text":"<pre><code>void atlas::world_scope::add_scene (\n    const ref&lt; scene_scope &gt; &amp; p_scene_context\n) \n</code></pre>"},{"location":"References/classatlas_1_1world__scope/#function-get","title":"function get","text":"<pre><code>inline ref&lt; world_scope &gt; atlas::world_scope::get () \n</code></pre>"},{"location":"References/classatlas_1_1world__scope/#function-get_scene","title":"function get_scene","text":"<pre><code>inline ref&lt; scene_scope &gt; atlas::world_scope::get_scene (\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1world__scope/#function-get_tag","title":"function get_tag","text":"<pre><code>inline std::string atlas::world_scope::get_tag () const\n</code></pre>"},{"location":"References/classatlas_1_1world__scope/#function-world","title":"function world &amp;","text":"<pre><code>inline atlas::world_scope::world &amp; () \n</code></pre>"},{"location":"References/classatlas_1_1world__scope/#function-world_scope-12","title":"function world_scope [1/2]","text":"<pre><code>atlas::world_scope::world_scope () = default\n</code></pre>"},{"location":"References/classatlas_1_1world__scope/#function-world_scope-22","title":"function world_scope [2/2]","text":"<pre><code>atlas::world_scope::world_scope (\n    const std::string &amp; p_tag\n) \n</code></pre>"},{"location":"References/classatlas_1_1world__scope/#function-world_scope","title":"function ~world_scope","text":"<pre><code>atlas::world_scope::~world_scope () \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/world.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1vk__swapchain_1_1swapchain__depth__image/","title":"Struct atlas::vk::vk_swapchain::swapchain_depth_image","text":"<p>ClassList &gt; swapchain_depth_image</p>"},{"location":"References/structatlas_1_1vk_1_1vk__swapchain_1_1swapchain__depth__image/#public-attributes","title":"Public Attributes","text":"Type Name VkDeviceMemory DeviceMemory VkImage Image VkImageView ImageView"},{"location":"References/structatlas_1_1vk_1_1vk__swapchain_1_1swapchain__depth__image/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1vk__swapchain_1_1swapchain__depth__image/#variable-devicememory","title":"variable DeviceMemory","text":"<pre><code>VkDeviceMemory atlas::vk::vk_swapchain::swapchain_depth_image::DeviceMemory;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__swapchain_1_1swapchain__depth__image/#variable-image","title":"variable Image","text":"<pre><code>VkImage atlas::vk::vk_swapchain::swapchain_depth_image::Image;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__swapchain_1_1swapchain__depth__image/#variable-imageview","title":"variable ImageView","text":"<pre><code>VkImageView atlas::vk::vk_swapchain::swapchain_depth_image::ImageView;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_swapchain.hpp</code></p>"},{"location":"References/structatlas_1_1vk_1_1vk__swapchain_1_1swapchain__image/","title":"Struct atlas::vk::vk_swapchain::swapchain_image","text":"<p>ClassList &gt; swapchain_image</p>"},{"location":"References/structatlas_1_1vk_1_1vk__swapchain_1_1swapchain__image/#public-attributes","title":"Public Attributes","text":"Type Name VkImage Image VkImageView ImageView"},{"location":"References/structatlas_1_1vk_1_1vk__swapchain_1_1swapchain__image/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/structatlas_1_1vk_1_1vk__swapchain_1_1swapchain__image/#variable-image","title":"variable Image","text":"<pre><code>VkImage atlas::vk::vk_swapchain::swapchain_image::Image;\n</code></pre>"},{"location":"References/structatlas_1_1vk_1_1vk__swapchain_1_1swapchain__image/#variable-imageview","title":"variable ImageView","text":"<pre><code>VkImageView atlas::vk::vk_swapchain::swapchain_image::ImageView;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_swapchain.hpp</code></p>"},{"location":"References/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"References/dir_b67f019f7e2fe784ec01f943d860c92a/","title":"Dir TheAtlasEngine","text":"<p>FileList &gt; TheAtlasEngine</p>"},{"location":"References/dir_b67f019f7e2fe784ec01f943d860c92a/#directories","title":"Directories","text":"Type Name dir atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/</code></p>"},{"location":"References/dir_1e6ffef027cfcf7ded3287660b505c9f/","title":"Dir TheAtlasEngine/atlas","text":"<p>FileList &gt; atlas</p>"},{"location":"References/dir_1e6ffef027cfcf7ded3287660b505c9f/#directories","title":"Directories","text":"Type Name dir core dir drivers dir physics dir renderer dir thread_utils <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/</code></p>"},{"location":"References/dir_ab5f97e7ae27ba905c508150b2df25d1/","title":"Dir TheAtlasEngine/atlas/core","text":"<p>FileList &gt; atlas &gt; core</p>"},{"location":"References/dir_ab5f97e7ae27ba905c508150b2df25d1/#files","title":"Files","text":"Type Name file api.hpp file application.hpp file core.hpp file engine_logger.hpp file timer.hpp file window.hpp"},{"location":"References/dir_ab5f97e7ae27ba905c508150b2df25d1/#directories","title":"Directories","text":"Type Name dir event dir filesystem dir geometry dir image dir math dir scene dir serialize dir system_framework dir threads dir ui dir update_handlers dir utilities <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/</code></p>"},{"location":"References/dir_b27da4b5790a8b0d69c02bcd8b78255a/","title":"Dir TheAtlasEngine/atlas/core/event","text":"<p>FileList &gt; atlas &gt; core &gt; event</p>"},{"location":"References/dir_b27da4b5790a8b0d69c02bcd8b78255a/#files","title":"Files","text":"Type Name file event.hpp file joystick_codes.hpp file key_codes.hpp file mouse_codes.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/event/</code></p>"},{"location":"References/event_8hpp/","title":"File event.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; event &gt; event.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/event/key_codes.hpp&gt;</code></li> <li><code>#include &lt;core/event/mouse_codes.hpp&gt;</code></li> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/event_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace event"},{"location":"References/event_8hpp/#classes","title":"Classes","text":"Type Name struct joystick_button struct joystick_info <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/event/event.hpp</code></p>"},{"location":"References/event_8hpp_source/","title":"File event.hpp","text":"<p>File List &gt; atlas &gt; core &gt; event &gt; event.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/event/key_codes.hpp&gt;\n#include &lt;core/event/mouse_codes.hpp&gt;\n#include &lt;glm/glm.hpp&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n\nnamespace atlas::event {\n    enum input_state { None, Idle, Pressed, Released };\n\n    struct joystick_button {\n        int ID = -1;\n        std::string Name = \"\";\n        input_state ButtonState = input_state::None;\n        input_state PreviousButtonState = input_state::None;\n    };\n\n    struct joystick_info {\n        int ID = -1;\n        std::string JoystickName = \"Default\";\n        std::map&lt;int, joystick_button&gt; Buttons;\n        std::map&lt;int, bool&gt; ButtonsDown;\n        std::map&lt;int, const float*&gt; AxesOfController;\n    };\n\n    bool is_key_pressed(int p_key);\n\n    bool is_key_released(int p_key);\n\n    bool is_mouse_pressed(int p_mouse_code);\n    bool is_mouse_released(int p_mouse_code);\n\n    glm::vec2 cursor_position();\n\n    // joystic-specific functions\n\n    bool is_joystic_present(int p_controller_id);\n\n    const char* is_joystick_guid(int p_controller_id);\n\n    float get_joystic_axis(int p_controller_id, int p_button);\n\n    // bool is_button_pressed(int p_button_id, int p_controller_id);\n\n    // bool is_button_released(int p_button_id, int p_controller_id);\n\n    bool is_joystick_button_pressed(int p_button);\n\n    bool is_joystick_button_released(int p_button);\n\n    // specific for listening events\n    void update_events();\n\n    void wait_for_events();\n}; // namespace atlas::event\n</code></pre>"},{"location":"References/joystick__codes_8hpp/","title":"File joystick_codes.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; event &gt; joystick_codes.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"References/joystick__codes_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace event"},{"location":"References/joystick__codes_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr int joystick_1   = <code>::atlas::event::JoystickCodes::Joystick1</code> constexpr int joystick_10   = <code>::atlas::event::JoystickCodes::Joystick10</code> constexpr int joystick_11   = <code>::atlas::event::JoystickCodes::Joystick11</code> constexpr int joystick_12   = <code>::atlas::event::JoystickCodes::Joystick12</code> constexpr int joystick_13   = <code>::atlas::event::JoystickCodes::Joystick13</code> constexpr int joystick_14   = <code>::atlas::event::JoystickCodes::Joystick14</code> constexpr int joystick_15   = <code>::atlas::event::JoystickCodes::Joystick15</code> constexpr int joystick_16   = <code>::atlas::event::JoystickCodes::Joystick16</code> constexpr int joystick_2   = <code>::atlas::event::JoystickCodes::Joystick2</code> constexpr int joystick_3   = <code>::atlas::event::JoystickCodes::Joystick3</code> constexpr int joystick_4   = <code>::atlas::event::JoystickCodes::Joystick4</code> constexpr int joystick_5   = <code>::atlas::event::JoystickCodes::Joystick5</code> constexpr int joystick_6   = <code>::atlas::event::JoystickCodes::Joystick6</code> constexpr int joystick_7   = <code>::atlas::event::JoystickCodes::Joystick7</code> constexpr int joystick_8   = <code>::atlas::event::JoystickCodes::Joystick8</code> constexpr int joystick_9   = <code>::atlas::event::JoystickCodes::Joystick9</code> constexpr int joystick_last   = <code>/* multi line expression */</code>"},{"location":"References/joystick__codes_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/joystick__codes_8hpp/#variable-joystick_1","title":"variable joystick_1","text":"<pre><code>constexpr int joystick_1;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_10","title":"variable joystick_10","text":"<pre><code>constexpr int joystick_10;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_11","title":"variable joystick_11","text":"<pre><code>constexpr int joystick_11;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_12","title":"variable joystick_12","text":"<pre><code>constexpr int joystick_12;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_13","title":"variable joystick_13","text":"<pre><code>constexpr int joystick_13;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_14","title":"variable joystick_14","text":"<pre><code>constexpr int joystick_14;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_15","title":"variable joystick_15","text":"<pre><code>constexpr int joystick_15;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_16","title":"variable joystick_16","text":"<pre><code>constexpr int joystick_16;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_2","title":"variable joystick_2","text":"<pre><code>constexpr int joystick_2;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_3","title":"variable joystick_3","text":"<pre><code>constexpr int joystick_3;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_4","title":"variable joystick_4","text":"<pre><code>constexpr int joystick_4;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_5","title":"variable joystick_5","text":"<pre><code>constexpr int joystick_5;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_6","title":"variable joystick_6","text":"<pre><code>constexpr int joystick_6;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_7","title":"variable joystick_7","text":"<pre><code>constexpr int joystick_7;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_8","title":"variable joystick_8","text":"<pre><code>constexpr int joystick_8;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_9","title":"variable joystick_9","text":"<pre><code>constexpr int joystick_9;\n</code></pre>"},{"location":"References/joystick__codes_8hpp/#variable-joystick_last","title":"variable joystick_last","text":"<pre><code>constexpr int joystick_last;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/event/joystick_codes.hpp</code></p>"},{"location":"References/joystick__codes_8hpp_source/","title":"File joystick_codes.hpp","text":"<p>File List &gt; atlas &gt; core &gt; event &gt; joystick_codes.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n\nnamespace atlas::event {\n    enum JoystickCodes : int {\n        Joystick1 = 0,\n\n        Joystick2 = 1,\n\n        Joystick3 = 2,\n\n        Joystick4 = 3,\n\n        Joystick5 = 4,\n\n        Joystick6 = 5,\n\n        Joystick7 = 6,\n\n        Joystick8 = 7,\n\n        Joystick9 = 8,\n\n        Joystick10 = 9,\n\n        Joystick11 = 10,\n\n        Joystick12 = 11,\n\n        Joystick13 = 12,\n\n        Joystick14 = 13,\n\n        Joystick15 = 14,\n\n        Joystick16 = 15,\n\n        JoystickLAST = Joystick16,\n    };\n}; // namespace atlas\n\ninline constexpr int joystick_1 = ::atlas::event::JoystickCodes::Joystick1;\ninline constexpr int joystick_2 = ::atlas::event::JoystickCodes::Joystick2;\ninline constexpr int joystick_3 = ::atlas::event::JoystickCodes::Joystick3;\ninline constexpr int joystick_4 = ::atlas::event::JoystickCodes::Joystick4;\ninline constexpr int joystick_5 = ::atlas::event::JoystickCodes::Joystick5;\ninline constexpr int joystick_6 = ::atlas::event::JoystickCodes::Joystick6;\ninline constexpr int joystick_7 = ::atlas::event::JoystickCodes::Joystick7;\ninline constexpr int joystick_8 = ::atlas::event::JoystickCodes::Joystick8;\ninline constexpr int joystick_9 = ::atlas::event::JoystickCodes::Joystick9;\ninline constexpr int joystick_10 = ::atlas::event::JoystickCodes::Joystick10;\ninline constexpr int joystick_11 = ::atlas::event::JoystickCodes::Joystick11;\ninline constexpr int joystick_12 = ::atlas::event::JoystickCodes::Joystick12;\ninline constexpr int joystick_13 = ::atlas::event::JoystickCodes::Joystick13;\ninline constexpr int joystick_14 = ::atlas::event::JoystickCodes::Joystick14;\ninline constexpr int joystick_15 = ::atlas::event::JoystickCodes::Joystick15;\ninline constexpr int joystick_16 = ::atlas::event::JoystickCodes::Joystick16;\ninline constexpr int joystick_last =\n  ::atlas::event::JoystickCodes::JoystickLAST;\n</code></pre>"},{"location":"References/key__codes_8hpp/","title":"File key_codes.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; event &gt; key_codes.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"References/key__codes_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace event"},{"location":"References/key__codes_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr uint32_t key_0   = <code>::atlas::event::Key::D0</code> constexpr uint32_t key_1   = <code>::atlas::event::Key::D1</code> constexpr uint32_t key_2   = <code>::atlas::event::Key::D2</code> constexpr uint32_t key_3   = <code>::atlas::event::Key::D3</code> constexpr uint32_t key_4   = <code>::atlas::event::Key::D4</code> constexpr uint32_t key_5   = <code>::atlas::event::Key::D5</code> constexpr uint32_t key_6   = <code>::atlas::event::Key::D6</code> constexpr uint32_t key_7   = <code>::atlas::event::Key::D7</code> constexpr uint32_t key_8   = <code>::atlas::event::Key::D8</code> constexpr uint32_t key_9   = <code>::atlas::event::Key::D9</code> constexpr uint32_t key_a   = <code>::atlas::event::Key::A</code> constexpr uint32_t key_apostrophe   = <code>/* multi line expression */</code> constexpr uint32_t key_b   = <code>::atlas::event::Key::B</code> constexpr uint32_t key_backslash   = <code>/* multi line expression */</code> constexpr uint32_t key_backspace   = <code>::atlas::event::Key::Backspace</code> constexpr uint32_t key_c   = <code>::atlas::event::Key::C</code> constexpr uint32_t key_caps_lock   = <code>::atlas::event::Key::CapsLock</code> constexpr uint32_t key_comma   = <code>::atlas::event::Key::Comma</code> constexpr uint32_t key_d   = <code>::atlas::event::Key::D</code> constexpr uint32_t key_delete   = <code>::atlas::event::Key::Delete</code> constexpr uint32_t key_down   = <code>::atlas::event::Key::Down</code> constexpr uint32_t key_e   = <code>::atlas::event::Key::E</code> constexpr uint32_t key_end   = <code>::atlas::event::Key::End</code> constexpr uint32_t key_enter   = <code>::atlas::event::Key::Enter</code> constexpr uint32_t key_equal   = <code>::atlas::event::Key::Equal</code> constexpr uint32_t key_escape   = <code>::atlas::event::Key::Escape</code> constexpr uint32_t key_f   = <code>::atlas::event::Key::F</code> constexpr uint32_t key_f1   = <code>::atlas::event::Key::F1</code> constexpr uint32_t key_f10   = <code>::atlas::event::Key::F10</code> constexpr uint32_t key_f11   = <code>::atlas::event::Key::F11</code> constexpr uint32_t key_f12   = <code>::atlas::event::Key::F12</code> constexpr uint32_t key_f13   = <code>::atlas::event::Key::F13</code> constexpr uint32_t key_f14   = <code>::atlas::event::Key::F14</code> constexpr uint32_t key_f15   = <code>::atlas::event::Key::F15</code> constexpr uint32_t key_f16   = <code>::atlas::event::Key::F16</code> constexpr uint32_t key_f17   = <code>::atlas::event::Key::F17</code> constexpr uint32_t key_f18   = <code>::atlas::event::Key::F18</code> constexpr uint32_t key_f19   = <code>::atlas::event::Key::F19</code> constexpr uint32_t key_f2   = <code>::atlas::event::Key::F2</code> constexpr uint32_t key_f20   = <code>::atlas::event::Key::F20</code> constexpr uint32_t key_f21   = <code>::atlas::event::Key::F21</code> constexpr uint32_t key_f22   = <code>::atlas::event::Key::F22</code> constexpr uint32_t key_f23   = <code>::atlas::event::Key::F23</code> constexpr uint32_t key_f24   = <code>::atlas::event::Key::F24</code> constexpr uint32_t key_f25   = <code>::atlas::event::Key::F25</code> constexpr uint32_t key_f3   = <code>::atlas::event::Key::F3</code> constexpr uint32_t key_f4   = <code>::atlas::event::Key::F4</code> constexpr uint32_t key_f5   = <code>::atlas::event::Key::F5</code> constexpr uint32_t key_f6   = <code>::atlas::event::Key::F6</code> constexpr uint32_t key_f7   = <code>::atlas::event::Key::F7</code> constexpr uint32_t key_f8   = <code>::atlas::event::Key::F8</code> constexpr uint32_t key_f9   = <code>::atlas::event::Key::F9</code> constexpr uint32_t key_g   = <code>::atlas::event::Key::G</code> constexpr uint32_t key_gravity_accent   = <code>/* multi line expression */</code> constexpr uint32_t key_h   = <code>::atlas::event::Key::H</code> constexpr uint32_t key_home   = <code>::atlas::event::Key::Home</code> constexpr uint32_t key_i   = <code>::atlas::event::Key::I</code> constexpr uint32_t key_insert   = <code>::atlas::event::Key::Insert</code> constexpr uint32_t key_j   = <code>::atlas::event::Key::J</code> constexpr uint32_t key_k   = <code>::atlas::event::Key::K</code> constexpr uint32_t key_kp_0   = <code>::atlas::event::Key::KP0</code> constexpr uint32_t key_kp_1   = <code>::atlas::event::Key::KP1</code> constexpr uint32_t key_kp_2   = <code>::atlas::event::Key::KP2</code> constexpr uint32_t key_kp_3   = <code>::atlas::event::Key::KP3</code> constexpr uint32_t key_kp_4   = <code>::atlas::event::Key::KP4</code> constexpr uint32_t key_kp_5   = <code>::atlas::event::Key::KP5</code> constexpr uint32_t key_kp_6   = <code>::atlas::event::Key::KP6</code> constexpr uint32_t key_kp_7   = <code>::atlas::event::Key::KP7</code> constexpr uint32_t key_kp_8   = <code>::atlas::event::Key::KP8</code> constexpr uint32_t key_kp_9   = <code>::atlas::event::Key::KP9</code> constexpr uint32_t key_kp_add   = <code>::atlas::event::Key::KPAdd</code> constexpr uint32_t key_kp_decimal   = <code>::atlas::event::Key::KPDecimal</code> constexpr uint32_t key_kp_divide   = <code>::atlas::event::Key::KPDivide</code> constexpr uint32_t key_kp_enter   = <code>::atlas::event::Key::KPEnter</code> constexpr uint32_t key_kp_equal   = <code>::atlas::event::Key::KPEqual</code> constexpr uint32_t key_kp_multiply   = <code>::atlas::event::Key::KPMultiply</code> constexpr uint32_t key_kp_subtract   = <code>::atlas::event::Key::KPSubtract</code> constexpr uint32_t key_l   = <code>::atlas::event::Key::L</code> constexpr uint32_t key_left   = <code>::atlas::event::Key::Left</code> constexpr uint32_t key_left_alt   = <code>::atlas::event::Key::LeftAlt</code> constexpr uint32_t key_left_bracket   = <code>/* multi line expression */</code> constexpr uint32_t key_left_control   = <code>::atlas::event::Key::LeftControl</code> constexpr uint32_t key_left_shift   = <code>::atlas::event::Key::LeftShift</code> constexpr uint32_t key_left_super   = <code>::atlas::event::Key::Leftsuper</code> constexpr uint32_t key_m   = <code>::atlas::event::Key::M</code> constexpr uint32_t key_menu   = <code>::atlas::event::Key::Menu</code> constexpr uint32_t key_minus   = <code>::atlas::event::Key::Minus</code> constexpr uint32_t key_n   = <code>::atlas::event::Key::N</code> constexpr uint32_t key_num_lock   = <code>::atlas::event::Key::NumLock</code> constexpr uint32_t key_o   = <code>::atlas::event::Key::O</code> constexpr uint32_t key_p   = <code>::atlas::event::Key::P</code> constexpr uint32_t key_page_down   = <code>::atlas::event::Key::PageDown</code> constexpr uint32_t key_page_up   = <code>::atlas::event::Key::PageUp</code> constexpr uint32_t key_pause   = <code>::atlas::event::Key::Pause</code> constexpr uint32_t key_period   = <code>::atlas::event::Key::Period</code> constexpr uint32_t key_print_screen   = <code>::atlas::event::Key::PrintScreen</code> constexpr uint32_t key_q   = <code>::atlas::event::Key::Q</code> constexpr uint32_t key_r   = <code>::atlas::event::Key::R</code> constexpr uint32_t key_right   = <code>::atlas::event::Key::Right</code> constexpr uint32_t key_right_alt   = <code>::atlas::event::Key::RightAlt</code> constexpr uint32_t key_right_bracket   = <code>/* multi line expression */</code> constexpr uint32_t key_right_control   = <code>::atlas::event::Key::RightControl</code> constexpr uint32_t key_right_shift   = <code>::atlas::event::Key::RightShift</code> constexpr uint32_t key_right_super   = <code>::atlas::event::Key::Rightsuper</code> constexpr uint32_t key_s   = <code>::atlas::event::Key::S</code> constexpr uint32_t key_scroll_lock   = <code>::atlas::event::Key::ScrollLock</code> constexpr uint32_t key_semicolon   = <code>/* multi line expression */</code> constexpr uint32_t key_slash   = <code>::atlas::event::Key::Slash</code> constexpr uint32_t key_space   = <code>::atlas::event::Key::Space</code> constexpr uint32_t key_tab   = <code>::atlas::event::Key::Tab</code> constexpr uint32_t key_u   = <code>::atlas::event::Key::U</code> constexpr uint32_t key_up   = <code>::atlas::event::Key::Up</code> constexpr uint32_t key_v   = <code>::atlas::event::Key::V</code> constexpr uint32_t key_w   = <code>::atlas::event::Key::W</code> constexpr uint32_t key_world_1   = <code>/* multi line expression */</code> constexpr uint32_t key_world_2   = <code>/* multi line expression */</code> constexpr uint32_t key_x   = <code>::atlas::event::Key::X</code> constexpr uint32_t key_y   = <code>::atlas::event::Key::Y</code> constexpr uint32_t key_z   = <code>::atlas::event::Key::Z</code>"},{"location":"References/key__codes_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/key__codes_8hpp/#variable-key_0","title":"variable key_0","text":"<pre><code>constexpr uint32_t key_0;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_1","title":"variable key_1","text":"<pre><code>constexpr uint32_t key_1;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_2","title":"variable key_2","text":"<pre><code>constexpr uint32_t key_2;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_3","title":"variable key_3","text":"<pre><code>constexpr uint32_t key_3;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_4","title":"variable key_4","text":"<pre><code>constexpr uint32_t key_4;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_5","title":"variable key_5","text":"<pre><code>constexpr uint32_t key_5;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_6","title":"variable key_6","text":"<pre><code>constexpr uint32_t key_6;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_7","title":"variable key_7","text":"<pre><code>constexpr uint32_t key_7;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_8","title":"variable key_8","text":"<pre><code>constexpr uint32_t key_8;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_9","title":"variable key_9","text":"<pre><code>constexpr uint32_t key_9;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_a","title":"variable key_a","text":"<pre><code>constexpr uint32_t key_a;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_apostrophe","title":"variable key_apostrophe","text":"<pre><code>constexpr uint32_t key_apostrophe;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_b","title":"variable key_b","text":"<pre><code>constexpr uint32_t key_b;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_backslash","title":"variable key_backslash","text":"<pre><code>constexpr uint32_t key_backslash;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_backspace","title":"variable key_backspace","text":"<pre><code>constexpr uint32_t key_backspace;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_c","title":"variable key_c","text":"<pre><code>constexpr uint32_t key_c;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_caps_lock","title":"variable key_caps_lock","text":"<pre><code>constexpr uint32_t key_caps_lock;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_comma","title":"variable key_comma","text":"<pre><code>constexpr uint32_t key_comma;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_d","title":"variable key_d","text":"<pre><code>constexpr uint32_t key_d;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_delete","title":"variable key_delete","text":"<pre><code>constexpr uint32_t key_delete;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_down","title":"variable key_down","text":"<pre><code>constexpr uint32_t key_down;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_e","title":"variable key_e","text":"<pre><code>constexpr uint32_t key_e;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_end","title":"variable key_end","text":"<pre><code>constexpr uint32_t key_end;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_enter","title":"variable key_enter","text":"<pre><code>constexpr uint32_t key_enter;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_equal","title":"variable key_equal","text":"<pre><code>constexpr uint32_t key_equal;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_escape","title":"variable key_escape","text":"<pre><code>constexpr uint32_t key_escape;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f","title":"variable key_f","text":"<pre><code>constexpr uint32_t key_f;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f1","title":"variable key_f1","text":"<pre><code>constexpr uint32_t key_f1;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f10","title":"variable key_f10","text":"<pre><code>constexpr uint32_t key_f10;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f11","title":"variable key_f11","text":"<pre><code>constexpr uint32_t key_f11;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f12","title":"variable key_f12","text":"<pre><code>constexpr uint32_t key_f12;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f13","title":"variable key_f13","text":"<pre><code>constexpr uint32_t key_f13;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f14","title":"variable key_f14","text":"<pre><code>constexpr uint32_t key_f14;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f15","title":"variable key_f15","text":"<pre><code>constexpr uint32_t key_f15;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f16","title":"variable key_f16","text":"<pre><code>constexpr uint32_t key_f16;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f17","title":"variable key_f17","text":"<pre><code>constexpr uint32_t key_f17;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f18","title":"variable key_f18","text":"<pre><code>constexpr uint32_t key_f18;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f19","title":"variable key_f19","text":"<pre><code>constexpr uint32_t key_f19;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f2","title":"variable key_f2","text":"<pre><code>constexpr uint32_t key_f2;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f20","title":"variable key_f20","text":"<pre><code>constexpr uint32_t key_f20;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f21","title":"variable key_f21","text":"<pre><code>constexpr uint32_t key_f21;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f22","title":"variable key_f22","text":"<pre><code>constexpr uint32_t key_f22;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f23","title":"variable key_f23","text":"<pre><code>constexpr uint32_t key_f23;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f24","title":"variable key_f24","text":"<pre><code>constexpr uint32_t key_f24;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f25","title":"variable key_f25","text":"<pre><code>constexpr uint32_t key_f25;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f3","title":"variable key_f3","text":"<pre><code>constexpr uint32_t key_f3;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f4","title":"variable key_f4","text":"<pre><code>constexpr uint32_t key_f4;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f5","title":"variable key_f5","text":"<pre><code>constexpr uint32_t key_f5;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f6","title":"variable key_f6","text":"<pre><code>constexpr uint32_t key_f6;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f7","title":"variable key_f7","text":"<pre><code>constexpr uint32_t key_f7;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f8","title":"variable key_f8","text":"<pre><code>constexpr uint32_t key_f8;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_f9","title":"variable key_f9","text":"<pre><code>constexpr uint32_t key_f9;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_g","title":"variable key_g","text":"<pre><code>constexpr uint32_t key_g;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_gravity_accent","title":"variable key_gravity_accent","text":"<pre><code>constexpr uint32_t key_gravity_accent;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_h","title":"variable key_h","text":"<pre><code>constexpr uint32_t key_h;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_home","title":"variable key_home","text":"<pre><code>constexpr uint32_t key_home;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_i","title":"variable key_i","text":"<pre><code>constexpr uint32_t key_i;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_insert","title":"variable key_insert","text":"<pre><code>constexpr uint32_t key_insert;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_j","title":"variable key_j","text":"<pre><code>constexpr uint32_t key_j;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_k","title":"variable key_k","text":"<pre><code>constexpr uint32_t key_k;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_0","title":"variable key_kp_0","text":"<pre><code>constexpr uint32_t key_kp_0;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_1","title":"variable key_kp_1","text":"<pre><code>constexpr uint32_t key_kp_1;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_2","title":"variable key_kp_2","text":"<pre><code>constexpr uint32_t key_kp_2;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_3","title":"variable key_kp_3","text":"<pre><code>constexpr uint32_t key_kp_3;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_4","title":"variable key_kp_4","text":"<pre><code>constexpr uint32_t key_kp_4;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_5","title":"variable key_kp_5","text":"<pre><code>constexpr uint32_t key_kp_5;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_6","title":"variable key_kp_6","text":"<pre><code>constexpr uint32_t key_kp_6;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_7","title":"variable key_kp_7","text":"<pre><code>constexpr uint32_t key_kp_7;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_8","title":"variable key_kp_8","text":"<pre><code>constexpr uint32_t key_kp_8;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_9","title":"variable key_kp_9","text":"<pre><code>constexpr uint32_t key_kp_9;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_add","title":"variable key_kp_add","text":"<pre><code>constexpr uint32_t key_kp_add;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_decimal","title":"variable key_kp_decimal","text":"<pre><code>constexpr uint32_t key_kp_decimal;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_divide","title":"variable key_kp_divide","text":"<pre><code>constexpr uint32_t key_kp_divide;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_enter","title":"variable key_kp_enter","text":"<pre><code>constexpr uint32_t key_kp_enter;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_equal","title":"variable key_kp_equal","text":"<pre><code>constexpr uint32_t key_kp_equal;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_multiply","title":"variable key_kp_multiply","text":"<pre><code>constexpr uint32_t key_kp_multiply;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_kp_subtract","title":"variable key_kp_subtract","text":"<pre><code>constexpr uint32_t key_kp_subtract;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_l","title":"variable key_l","text":"<pre><code>constexpr uint32_t key_l;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_left","title":"variable key_left","text":"<pre><code>constexpr uint32_t key_left;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_left_alt","title":"variable key_left_alt","text":"<pre><code>constexpr uint32_t key_left_alt;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_left_bracket","title":"variable key_left_bracket","text":"<pre><code>constexpr uint32_t key_left_bracket;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_left_control","title":"variable key_left_control","text":"<pre><code>constexpr uint32_t key_left_control;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_left_shift","title":"variable key_left_shift","text":"<pre><code>constexpr uint32_t key_left_shift;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_left_super","title":"variable key_left_super","text":"<pre><code>constexpr uint32_t key_left_super;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_m","title":"variable key_m","text":"<pre><code>constexpr uint32_t key_m;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_menu","title":"variable key_menu","text":"<pre><code>constexpr uint32_t key_menu;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_minus","title":"variable key_minus","text":"<pre><code>constexpr uint32_t key_minus;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_n","title":"variable key_n","text":"<pre><code>constexpr uint32_t key_n;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_num_lock","title":"variable key_num_lock","text":"<pre><code>constexpr uint32_t key_num_lock;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_o","title":"variable key_o","text":"<pre><code>constexpr uint32_t key_o;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_p","title":"variable key_p","text":"<pre><code>constexpr uint32_t key_p;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_page_down","title":"variable key_page_down","text":"<pre><code>constexpr uint32_t key_page_down;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_page_up","title":"variable key_page_up","text":"<pre><code>constexpr uint32_t key_page_up;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_pause","title":"variable key_pause","text":"<pre><code>constexpr uint32_t key_pause;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_period","title":"variable key_period","text":"<pre><code>constexpr uint32_t key_period;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_print_screen","title":"variable key_print_screen","text":"<pre><code>constexpr uint32_t key_print_screen;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_q","title":"variable key_q","text":"<pre><code>constexpr uint32_t key_q;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_r","title":"variable key_r","text":"<pre><code>constexpr uint32_t key_r;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_right","title":"variable key_right","text":"<pre><code>constexpr uint32_t key_right;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_right_alt","title":"variable key_right_alt","text":"<pre><code>constexpr uint32_t key_right_alt;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_right_bracket","title":"variable key_right_bracket","text":"<pre><code>constexpr uint32_t key_right_bracket;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_right_control","title":"variable key_right_control","text":"<pre><code>constexpr uint32_t key_right_control;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_right_shift","title":"variable key_right_shift","text":"<pre><code>constexpr uint32_t key_right_shift;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_right_super","title":"variable key_right_super","text":"<pre><code>constexpr uint32_t key_right_super;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_s","title":"variable key_s","text":"<pre><code>constexpr uint32_t key_s;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_scroll_lock","title":"variable key_scroll_lock","text":"<pre><code>constexpr uint32_t key_scroll_lock;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_semicolon","title":"variable key_semicolon","text":"<pre><code>constexpr uint32_t key_semicolon;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_slash","title":"variable key_slash","text":"<pre><code>constexpr uint32_t key_slash;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_space","title":"variable key_space","text":"<pre><code>constexpr uint32_t key_space;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_tab","title":"variable key_tab","text":"<pre><code>constexpr uint32_t key_tab;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_u","title":"variable key_u","text":"<pre><code>constexpr uint32_t key_u;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_up","title":"variable key_up","text":"<pre><code>constexpr uint32_t key_up;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_v","title":"variable key_v","text":"<pre><code>constexpr uint32_t key_v;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_w","title":"variable key_w","text":"<pre><code>constexpr uint32_t key_w;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_world_1","title":"variable key_world_1","text":"<pre><code>constexpr uint32_t key_world_1;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_world_2","title":"variable key_world_2","text":"<pre><code>constexpr uint32_t key_world_2;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_x","title":"variable key_x","text":"<pre><code>constexpr uint32_t key_x;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_y","title":"variable key_y","text":"<pre><code>constexpr uint32_t key_y;\n</code></pre>"},{"location":"References/key__codes_8hpp/#variable-key_z","title":"variable key_z","text":"<pre><code>constexpr uint32_t key_z;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/event/key_codes.hpp</code></p>"},{"location":"References/key__codes_8hpp_source/","title":"File key_codes.hpp","text":"<p>File List &gt; atlas &gt; core &gt; event &gt; key_codes.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n\nnamespace atlas::event {\n    enum Key : uint32_t {\n        // From glfw3.h\n        Space = 32,\n        Apostrophe = 39, /* ' */\n        Comma = 44,      /* , */\n        Minus = 45,      /* - */\n        Period = 46,     /* . */\n        Slash = 47,      /* / */\n\n        D0 = 48, /* 0 */\n        D1 = 49, /* 1 */\n        D2 = 50, /* 2 */\n        D3 = 51, /* 3 */\n        D4 = 52, /* 4 */\n        D5 = 53, /* 5 */\n        D6 = 54, /* 6 */\n        D7 = 55, /* 7 */\n        D8 = 56, /* 8 */\n        D9 = 57, /* 9 */\n\n        Semicolon = 59, /* ; */\n        Equal = 61,     /* = */\n\n        A = 65,\n        B = 66,\n        C = 67,\n        D = 68,\n        E = 69,\n        F = 70,\n        G = 71,\n        H = 72,\n        I = 73,\n        J = 74,\n        K = 75,\n        L = 76,\n        M = 77,\n        N = 78,\n        O = 79,\n        P = 80,\n        Q = 81,\n        R = 82,\n        S = 83,\n        T = 84,\n        U = 85,\n        V = 86,\n        W = 87,\n        X = 88,\n        Y = 89,\n        Z = 90,\n\n        LeftBracket = 91,  /* [ */\n        Backslash = 92,    /* \\ */\n        RightBracket = 93, /* ] */\n        GraveAccent = 96,  /* ` */\n\n        World1 = 161, /* non-US #1 */\n        World2 = 162, /* non-US #2 */\n\n        /* Function keys */\n        Escape = 256,\n        Enter = 257,\n        Tab = 258,\n        Backspace = 259,\n        Insert = 260,\n        Delete = 261,\n        Right = 262,\n        Left = 263,\n        Down = 264,\n        Up = 265,\n        PageUp = 266,\n        PageDown = 267,\n        Home = 268,\n        End = 269,\n        CapsLock = 280,\n        ScrollLock = 281,\n        NumLock = 282,\n        PrintScreen = 283,\n        Pause = 284,\n        F1 = 290,\n        F2 = 291,\n        F3 = 292,\n        F4 = 293,\n        F5 = 294,\n        F6 = 295,\n        F7 = 296,\n        F8 = 297,\n        F9 = 298,\n        F10 = 299,\n        F11 = 300,\n        F12 = 301,\n        F13 = 302,\n        F14 = 303,\n        F15 = 304,\n        F16 = 305,\n        F17 = 306,\n        F18 = 307,\n        F19 = 308,\n        F20 = 309,\n        F21 = 310,\n        F22 = 311,\n        F23 = 312,\n        F24 = 313,\n        F25 = 314,\n\n        /* Keypad */\n        KP0 = 320,\n        KP1 = 321,\n        KP2 = 322,\n        KP3 = 323,\n        KP4 = 324,\n        KP5 = 325,\n        KP6 = 326,\n        KP7 = 327,\n        KP8 = 328,\n        KP9 = 329,\n        KPDecimal = 330,\n        KPDivide = 331,\n        KPMultiply = 332,\n        KPSubtract = 333,\n        KPAdd = 334,\n        KPEnter = 335,\n        KPEqual = 336,\n\n        LeftShift = 340,\n        LeftControl = 341,\n        LeftAlt = 342,\n        Leftsuper = 343,\n        RightShift = 344,\n        RightControl = 345,\n        RightAlt = 346,\n        Rightsuper = 347,\n        Menu = 348\n    };\n}\n\n// From glfw3.h\n\ninline constexpr uint32_t key_space = ::atlas::event::Key::Space;\ninline constexpr uint32_t key_apostrophe =\n  ::atlas::event::Key::Apostrophe;                                  /* ' */\ninline constexpr uint32_t key_comma = ::atlas::event::Key::Comma;   /* , */\ninline constexpr uint32_t key_minus = ::atlas::event::Key::Minus;   /* - */\ninline constexpr uint32_t key_period = ::atlas::event::Key::Period; /* . */\ninline constexpr uint32_t key_slash = ::atlas::event::Key::Slash;   /* / */\ninline constexpr uint32_t key_0 = ::atlas::event::Key::D0;\ninline constexpr uint32_t key_1 = ::atlas::event::Key::D1;\ninline constexpr uint32_t key_2 = ::atlas::event::Key::D2;\ninline constexpr uint32_t key_3 = ::atlas::event::Key::D3;\ninline constexpr uint32_t key_4 = ::atlas::event::Key::D4;\ninline constexpr uint32_t key_5 = ::atlas::event::Key::D5;\ninline constexpr uint32_t key_6 = ::atlas::event::Key::D6;\ninline constexpr uint32_t key_7 = ::atlas::event::Key::D7;\ninline constexpr uint32_t key_8 = ::atlas::event::Key::D8;\ninline constexpr uint32_t key_9 = ::atlas::event::Key::D9;\ninline constexpr uint32_t key_semicolon =\n  ::atlas::event::Key::Semicolon;                                 /* ; */\ninline constexpr uint32_t key_equal = ::atlas::event::Key::Equal; /* = */\ninline constexpr uint32_t key_a = ::atlas::event::Key::A;\ninline constexpr uint32_t key_b = ::atlas::event::Key::B;\ninline constexpr uint32_t key_c = ::atlas::event::Key::C;\ninline constexpr uint32_t key_d = ::atlas::event::Key::D;\ninline constexpr uint32_t key_e = ::atlas::event::Key::E;\ninline constexpr uint32_t key_f = ::atlas::event::Key::F;\ninline constexpr uint32_t key_g = ::atlas::event::Key::G;\ninline constexpr uint32_t key_h = ::atlas::event::Key::H;\ninline constexpr uint32_t key_i = ::atlas::event::Key::I;\ninline constexpr uint32_t key_j = ::atlas::event::Key::J;\ninline constexpr uint32_t key_k = ::atlas::event::Key::K;\ninline constexpr uint32_t key_l = ::atlas::event::Key::L;\ninline constexpr uint32_t key_m = ::atlas::event::Key::M;\ninline constexpr uint32_t key_n = ::atlas::event::Key::N;\ninline constexpr uint32_t key_o = ::atlas::event::Key::O;\ninline constexpr uint32_t key_p = ::atlas::event::Key::P;\ninline constexpr uint32_t key_q = ::atlas::event::Key::Q;\ninline constexpr uint32_t key_r = ::atlas::event::Key::R;\ninline constexpr uint32_t key_s = ::atlas::event::Key::S;\n// inline constexpr uint32_t key_t = ::atlas::event::Key::T;\ninline constexpr uint32_t key_u = ::atlas::event::Key::U;\ninline constexpr uint32_t key_v = ::atlas::event::Key::V;\ninline constexpr uint32_t key_w = ::atlas::event::Key::W;\ninline constexpr uint32_t key_x = ::atlas::event::Key::X;\ninline constexpr uint32_t key_y = ::atlas::event::Key::Y;\ninline constexpr uint32_t key_z = ::atlas::event::Key::Z;\ninline constexpr uint32_t key_left_bracket =\n  ::atlas::event::Key::LeftBracket; /* [ */\ninline constexpr uint32_t key_backslash =\n  ::atlas::event::Key::Backslash; /* \\ */\ninline constexpr uint32_t key_right_bracket =\n  ::atlas::event::Key::RightBracket; /* ] */\ninline constexpr uint32_t key_gravity_accent =\n  ::atlas::event::Key::GraveAccent; /* ` */\ninline constexpr uint32_t key_world_1 =\n  ::atlas::event::Key::World1; /* non-US #1 */\ninline constexpr uint32_t key_world_2 =\n  ::atlas::event::Key::World2; /* non-US #2 */\n\n/* Function keys */\ninline constexpr uint32_t key_escape = ::atlas::event::Key::Escape;\ninline constexpr uint32_t key_enter = ::atlas::event::Key::Enter;\ninline constexpr uint32_t key_tab = ::atlas::event::Key::Tab;\ninline constexpr uint32_t key_backspace = ::atlas::event::Key::Backspace;\ninline constexpr uint32_t key_insert = ::atlas::event::Key::Insert;\ninline constexpr uint32_t key_delete = ::atlas::event::Key::Delete;\ninline constexpr uint32_t key_right = ::atlas::event::Key::Right;\ninline constexpr uint32_t key_left = ::atlas::event::Key::Left;\ninline constexpr uint32_t key_down = ::atlas::event::Key::Down;\ninline constexpr uint32_t key_up = ::atlas::event::Key::Up;\ninline constexpr uint32_t key_page_up = ::atlas::event::Key::PageUp;\ninline constexpr uint32_t key_page_down = ::atlas::event::Key::PageDown;\ninline constexpr uint32_t key_home = ::atlas::event::Key::Home;\ninline constexpr uint32_t key_end = ::atlas::event::Key::End;\ninline constexpr uint32_t key_caps_lock = ::atlas::event::Key::CapsLock;\ninline constexpr uint32_t key_scroll_lock = ::atlas::event::Key::ScrollLock;\ninline constexpr uint32_t key_num_lock = ::atlas::event::Key::NumLock;\ninline constexpr uint32_t key_print_screen = ::atlas::event::Key::PrintScreen;\ninline constexpr uint32_t key_pause = ::atlas::event::Key::Pause;\ninline constexpr uint32_t key_f1 = ::atlas::event::Key::F1;\ninline constexpr uint32_t key_f2 = ::atlas::event::Key::F2;\ninline constexpr uint32_t key_f3 = ::atlas::event::Key::F3;\ninline constexpr uint32_t key_f4 = ::atlas::event::Key::F4;\ninline constexpr uint32_t key_f5 = ::atlas::event::Key::F5;\ninline constexpr uint32_t key_f6 = ::atlas::event::Key::F6;\ninline constexpr uint32_t key_f7 = ::atlas::event::Key::F7;\ninline constexpr uint32_t key_f8 = ::atlas::event::Key::F8;\ninline constexpr uint32_t key_f9 = ::atlas::event::Key::F9;\ninline constexpr uint32_t key_f10 = ::atlas::event::Key::F10;\ninline constexpr uint32_t key_f11 = ::atlas::event::Key::F11;\ninline constexpr uint32_t key_f12 = ::atlas::event::Key::F12;\ninline constexpr uint32_t key_f13 = ::atlas::event::Key::F13;\ninline constexpr uint32_t key_f14 = ::atlas::event::Key::F14;\ninline constexpr uint32_t key_f15 = ::atlas::event::Key::F15;\ninline constexpr uint32_t key_f16 = ::atlas::event::Key::F16;\ninline constexpr uint32_t key_f17 = ::atlas::event::Key::F17;\ninline constexpr uint32_t key_f18 = ::atlas::event::Key::F18;\ninline constexpr uint32_t key_f19 = ::atlas::event::Key::F19;\ninline constexpr uint32_t key_f20 = ::atlas::event::Key::F20;\ninline constexpr uint32_t key_f21 = ::atlas::event::Key::F21;\ninline constexpr uint32_t key_f22 = ::atlas::event::Key::F22;\ninline constexpr uint32_t key_f23 = ::atlas::event::Key::F23;\ninline constexpr uint32_t key_f24 = ::atlas::event::Key::F24;\ninline constexpr uint32_t key_f25 = ::atlas::event::Key::F25;\n\n/* Keypad */\ninline constexpr uint32_t key_kp_0 = ::atlas::event::Key::KP0;\ninline constexpr uint32_t key_kp_1 = ::atlas::event::Key::KP1;\ninline constexpr uint32_t key_kp_2 = ::atlas::event::Key::KP2;\ninline constexpr uint32_t key_kp_3 = ::atlas::event::Key::KP3;\ninline constexpr uint32_t key_kp_4 = ::atlas::event::Key::KP4;\ninline constexpr uint32_t key_kp_5 = ::atlas::event::Key::KP5;\ninline constexpr uint32_t key_kp_6 = ::atlas::event::Key::KP6;\ninline constexpr uint32_t key_kp_7 = ::atlas::event::Key::KP7;\ninline constexpr uint32_t key_kp_8 = ::atlas::event::Key::KP8;\ninline constexpr uint32_t key_kp_9 = ::atlas::event::Key::KP9;\ninline constexpr uint32_t key_kp_decimal = ::atlas::event::Key::KPDecimal;\ninline constexpr uint32_t key_kp_divide = ::atlas::event::Key::KPDivide;\ninline constexpr uint32_t key_kp_multiply = ::atlas::event::Key::KPMultiply;\ninline constexpr uint32_t key_kp_subtract = ::atlas::event::Key::KPSubtract;\ninline constexpr uint32_t key_kp_add = ::atlas::event::Key::KPAdd;\ninline constexpr uint32_t key_kp_enter = ::atlas::event::Key::KPEnter;\ninline constexpr uint32_t key_kp_equal = ::atlas::event::Key::KPEqual;\n\ninline constexpr uint32_t key_left_shift = ::atlas::event::Key::LeftShift;\ninline constexpr uint32_t key_left_control = ::atlas::event::Key::LeftControl;\ninline constexpr uint32_t key_left_alt = ::atlas::event::Key::LeftAlt;\ninline constexpr uint32_t key_left_super = ::atlas::event::Key::Leftsuper;\ninline constexpr uint32_t key_right_shift = ::atlas::event::Key::RightShift;\ninline constexpr uint32_t key_right_control = ::atlas::event::Key::RightControl;\ninline constexpr uint32_t key_right_alt = ::atlas::event::Key::RightAlt;\ninline constexpr uint32_t key_right_super = ::atlas::event::Key::Rightsuper;\ninline constexpr uint32_t key_menu = ::atlas::event::Key::Menu;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/","title":"File mouse_codes.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; event &gt; mouse_codes.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"References/mouse__codes_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace event"},{"location":"References/mouse__codes_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr uint32_t mouse_button_0   = <code>::atlas::event::Mouse::Button0</code> constexpr uint32_t mouse_button_1   = <code>::atlas::event::Mouse::Button1</code> constexpr uint32_t mouse_button_2   = <code>::atlas::event::Mouse::Button2</code> constexpr uint32_t mouse_button_3   = <code>::atlas::event::Mouse::Button3</code> constexpr uint32_t mouse_button_4   = <code>::atlas::event::Mouse::Button4</code> constexpr uint32_t mouse_button_5   = <code>::atlas::event::Mouse::Button5</code> constexpr uint32_t mouse_button_6   = <code>::atlas::event::Mouse::Button6</code> constexpr uint32_t mouse_button_7   = <code>::atlas::event::Mouse::Button7</code> constexpr uint32_t mouse_button_last   = <code>::atlas::event::Mouse::ButtonLast</code> constexpr uint32_t mouse_button_left   = <code>::atlas::event::Mouse::ButtonLeft</code> constexpr uint32_t mouse_button_middle   = <code>/* multi line expression */</code> constexpr uint32_t mouse_button_right   = <code>/* multi line expression */</code>"},{"location":"References/mouse__codes_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_0","title":"variable mouse_button_0","text":"<pre><code>constexpr uint32_t mouse_button_0;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_1","title":"variable mouse_button_1","text":"<pre><code>constexpr uint32_t mouse_button_1;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_2","title":"variable mouse_button_2","text":"<pre><code>constexpr uint32_t mouse_button_2;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_3","title":"variable mouse_button_3","text":"<pre><code>constexpr uint32_t mouse_button_3;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_4","title":"variable mouse_button_4","text":"<pre><code>constexpr uint32_t mouse_button_4;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_5","title":"variable mouse_button_5","text":"<pre><code>constexpr uint32_t mouse_button_5;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_6","title":"variable mouse_button_6","text":"<pre><code>constexpr uint32_t mouse_button_6;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_7","title":"variable mouse_button_7","text":"<pre><code>constexpr uint32_t mouse_button_7;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_last","title":"variable mouse_button_last","text":"<pre><code>constexpr uint32_t mouse_button_last;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_left","title":"variable mouse_button_left","text":"<pre><code>constexpr uint32_t mouse_button_left;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_middle","title":"variable mouse_button_middle","text":"<pre><code>constexpr uint32_t mouse_button_middle;\n</code></pre>"},{"location":"References/mouse__codes_8hpp/#variable-mouse_button_right","title":"variable mouse_button_right","text":"<pre><code>constexpr uint32_t mouse_button_right;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/event/mouse_codes.hpp</code></p>"},{"location":"References/mouse__codes_8hpp_source/","title":"File mouse_codes.hpp","text":"<p>File List &gt; atlas &gt; core &gt; event &gt; mouse_codes.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n\nnamespace atlas::event {\n    enum Mouse : uint32_t {\n        // From glfw3.h\n        Button0 = 0,\n        Button1 = 1,\n        Button2 = 2,\n        Button3 = 3,\n        Button4 = 4,\n        Button5 = 5,\n        Button6 = 6,\n        Button7 = 7,\n\n        ButtonLast = Button7,\n        ButtonLeft = Button0,\n        ButtonRight = Button1,\n        ButtonMiddle = Button2\n    };\n\n} // namespace atlas\n\ninline constexpr uint32_t mouse_button_0 = ::atlas::event::Mouse::Button0;\ninline constexpr uint32_t mouse_button_1 = ::atlas::event::Mouse::Button1;\ninline constexpr uint32_t mouse_button_2 = ::atlas::event::Mouse::Button2;\ninline constexpr uint32_t mouse_button_3 = ::atlas::event::Mouse::Button3;\ninline constexpr uint32_t mouse_button_4 = ::atlas::event::Mouse::Button4;\ninline constexpr uint32_t mouse_button_5 = ::atlas::event::Mouse::Button5;\ninline constexpr uint32_t mouse_button_6 = ::atlas::event::Mouse::Button6;\ninline constexpr uint32_t mouse_button_7 = ::atlas::event::Mouse::Button7;\ninline constexpr uint32_t mouse_button_last = ::atlas::event::Mouse::ButtonLast;\ninline constexpr uint32_t mouse_button_left = ::atlas::event::Mouse::ButtonLeft;\ninline constexpr uint32_t mouse_button_right =\n  ::atlas::event::Mouse::ButtonRight;\ninline constexpr uint32_t mouse_button_middle =\n  ::atlas::event::Mouse::ButtonMiddle;\n</code></pre>"},{"location":"References/dir_27ba7cf633e68cf06fb2d9a5a7eda525/","title":"Dir TheAtlasEngine/atlas/core/filesystem","text":"<p>FileList &gt; atlas &gt; core &gt; filesystem</p>"},{"location":"References/dir_27ba7cf633e68cf06fb2d9a5a7eda525/#files","title":"Files","text":"Type Name file file_dialog.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/filesystem/</code></p>"},{"location":"References/file__dialog_8hpp/","title":"File file_dialog.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; filesystem &gt; file_dialog.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/file__dialog_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace filesystem <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/filesystem/file_dialog.hpp</code></p>"},{"location":"References/file__dialog_8hpp_source/","title":"File file_dialog.hpp","text":"<p>File List &gt; atlas &gt; core &gt; filesystem &gt; file_dialog.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n\nnamespace atlas::filesystem {\n    std::string load_from_file_dialog(const std::string&amp; p_filter);\n\n    std::string save_to_file(const std::string&amp; p_filter);\n}; // namespace atlas::filesystem\n</code></pre>"},{"location":"References/dir_b5becf243c0000df8fbe7c991f964f21/","title":"Dir TheAtlasEngine/atlas/core/geometry","text":"<p>FileList &gt; atlas &gt; core &gt; geometry</p>"},{"location":"References/dir_b5becf243c0000df8fbe7c991f964f21/#files","title":"Files","text":"Type Name file mesh.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/geometry/</code></p>"},{"location":"References/mesh_8hpp/","title":"File mesh.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; geometry &gt; mesh.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;drivers/index_buffer.hpp&gt;</code></li> <li><code>#include &lt;drivers/vertex_buffer.hpp&gt;</code></li> <li><code>#include &lt;tiny_obj_loader.h&gt;</code></li> </ul>"},{"location":"References/mesh_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/mesh_8hpp/#classes","title":"Classes","text":"Type Name class mesh"},{"location":"References/mesh_8hpp/#macros","title":"Macros","text":"Type Name define TINYOBJLOADER_IMPLEMENTATION"},{"location":"References/mesh_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"References/mesh_8hpp/#define-tinyobjloader_implementation","title":"define TINYOBJLOADER_IMPLEMENTATION","text":"<pre><code>#define TINYOBJLOADER_IMPLEMENTATION \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/geometry/mesh.hpp</code></p>"},{"location":"References/mesh_8hpp_source/","title":"File mesh.hpp","text":"<p>File List &gt; atlas &gt; core &gt; geometry &gt; mesh.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;drivers/index_buffer.hpp&gt;\n#include &lt;drivers/vertex_buffer.hpp&gt;\n\n#define TINYOBJLOADER_IMPLEMENTATION\n#include &lt;tiny_obj_loader.h&gt;\n\nnamespace atlas {\n\n    class mesh {\n    public:\n        mesh() = default;\n        mesh(const std::string&amp; p_filepath);\n        mesh(const ref&lt;vertex_buffer&gt;&amp; p_vertex_buffer,\n             const ref&lt;index_buffer&gt;&amp; p_index_buffer);\n        [[nodiscard]] bool is_loaded() const;\n        static mesh load(const std::string&amp; p_filepath);\n        // bool load_from_file(const std::string&amp; p_filepath);\n\n        ref&lt;vertex_buffer&gt;&amp; get_vertex_buffer() { return m_vertex_buffer; }\n\n        ref&lt;index_buffer&gt;&amp; get_index_buffer() { return m_index_buffer; }\n\n    private:\n        ref&lt;vertex_buffer&gt; m_vertex_buffer;\n        ref&lt;index_buffer&gt; m_index_buffer;\n    };\n\n}; // namespace atlas\n</code></pre>"},{"location":"References/dir_3050860d9c50f9f4f11f08b3bfb0b023/","title":"Dir TheAtlasEngine/atlas/core/image","text":"<p>FileList &gt; atlas &gt; core &gt; image</p>"},{"location":"References/dir_3050860d9c50f9f4f11f08b3bfb0b023/#files","title":"Files","text":"Type Name file stb_image.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/image/</code></p>"},{"location":"References/stb__image_8hpp/","title":"File stb_image.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; image &gt; stb_image.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;stb_image.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/image/stb_image.hpp</code></p>"},{"location":"References/stb__image_8hpp_source/","title":"File stb_image.hpp","text":"<p>File List &gt; atlas &gt; core &gt; image &gt; stb_image.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;stb_image.h&gt;\n</code></pre>"},{"location":"References/dir_cd513ce3e965767955df67d416f47de6/","title":"Dir TheAtlasEngine/atlas/core/math","text":"<p>FileList &gt; atlas &gt; core &gt; math</p>"},{"location":"References/dir_cd513ce3e965767955df67d416f47de6/#files","title":"Files","text":"Type Name file math.hpp file types.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/</code></p>"},{"location":"References/math_8hpp/","title":"File math.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; math &gt; math.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;glm/detail/qualifier.hpp&gt;</code></li> <li><code>#include &lt;glm/fwd.hpp&gt;</code></li> </ul>"},{"location":"References/math_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/math_8hpp/#classes","title":"Classes","text":"Type Name class interpolation <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/math.hpp</code></p>"},{"location":"References/math_8hpp_source/","title":"File math.hpp","text":"<p>File List &gt; atlas &gt; core &gt; math &gt; math.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;functional&gt;\n#include &lt;glm/detail/qualifier.hpp&gt;\n#include &lt;glm/fwd.hpp&gt;\n\nnamespace atlas {\n\n    class interpolation {\n    public:\n        template&lt;typename T&gt;\n        static T linear_interpolate(T start,\n                                    T end,\n                                    const std::function&lt;float(float)&gt;&amp; function,\n                                    float t) {\n            float l_adjusted_time = 0.0f;\n            if (!function) {\n                l_adjusted_time = t;\n            }\n            else {\n                const float f = function(t);\n                l_adjusted_time = f;\n            }\n            if (l_adjusted_time &lt; 0) {\n                l_adjusted_time = 0.0f;\n            }\n            if (l_adjusted_time &gt; 1.0f) {\n                l_adjusted_time = 1.0f;\n            }\n\n            float time_dif = 1.0f - l_adjusted_time;\n\n            return start * time_dif + end * l_adjusted_time;\n        }\n\n    private:\n        interpolation() = default;\n    };\n}; // namespace atlas\n</code></pre>"},{"location":"References/core_2math_2types_8hpp/","title":"File types.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; math &gt; types.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> <li><code>#include &lt;initializer_list&gt;</code></li> </ul>"},{"location":"References/core_2math_2types_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/core_2math_2types_8hpp/#classes","title":"Classes","text":"Type Name struct vector2&lt; glm::highp_vec2 &gt; &lt;&gt; struct vector3 &lt;typename T&gt; struct vector3&lt; glm::highp_vec3 &gt; &lt;&gt; struct vector4 &lt;typename T&gt; struct vector4&lt; glm::highp_vec4 &gt; &lt;&gt; <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/math/types.hpp</code></p>"},{"location":"References/core_2math_2types_8hpp_source/","title":"File types.hpp","text":"<p>File List &gt; atlas &gt; core &gt; math &gt; types.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;glm/glm.hpp&gt;\n#include &lt;initializer_list&gt;\n\nnamespace atlas {\n\n    /*\n    Will not be handling it like this, my reasons for changing it is within the\n    test cases I made that uses the new approach to doing this template&lt;typename\n    T&gt; concept IsVec2 = requires(T vec2){ { vec2.x } -&gt;\n    std::convertible_to&lt;float&gt;; { vec2.y } -&gt; std::convertible_to&lt;float&gt;;\n    };\n\n    template&lt;typename T&gt;\n    concept IsVec3 = requires(T vec3){\n        { vec3.x } -&gt; std::convertible_to&lt;float&gt;;\n        { vec3.y } -&gt; std::convertible_to&lt;float&gt;;\n        { vec3.z } -&gt; std::convertible_to&lt;float&gt;;\n    };\n\n    template&lt;typename T&gt;\n    concept IsVec4 = requires(T vec4){\n        { vec4.x } -&gt; std::convertible_to&lt;float&gt;;\n        { vec4.y } -&gt; std::convertible_to&lt;float&gt;;\n        { vec4.z } -&gt; std::convertible_to&lt;float&gt;;\n        { vec4.w } -&gt; std::convertible_to&lt;float&gt;;\n    };\n    */\n\n    template&lt;typename T&gt;\n    struct vector2;\n\n    template&lt;typename T&gt;\n    struct vector3 {\n        vector3() = default;\n\n        vector3(const T&amp; p_other)\n          : m_value(p_other) {}\n\n        vector3(float x, float y, float z)\n          : m_value(x, y, z) {}\n        vector3(const std::initializer_list&lt;float&gt;&amp; values)\n          : m_value(*values.begin(), *values.begin() + 1, *values.begin() + 2) {\n        }\n\n        operator glm::vec3() { return m_value; }\n\n        glm::vec3 operator=(const T&amp; p_other) { return p_other; }\n\n        bool operator==(const glm::vec3&amp; p_other) {\n            return (m_value.x == p_other.x and m_value.y == p_other.y and\n                    m_value.z == p_other.z);\n        }\n\n    private:\n        glm::vec3 m_value;\n    };\n\n    template&lt;typename T&gt;\n    struct vector4 {\n        vector4() = default;\n\n        vector4(const T&amp; p_other)\n          : m_value(p_other) {}\n\n        vector4(float x, float y, float z, float w)\n          : m_value(x, y, z, w) {}\n\n        operator glm::vec4() { return m_value; }\n\n        glm::vec4 operator=(const T&amp; p_other) { return p_other; }\n\n        bool operator==(const glm::vec4&amp; p_other) {\n            return (m_value.x == p_other.x and m_value.y == p_other.y and\n                    m_value.z == p_other.z and m_value.w == p_other.w);\n        }\n\n    private:\n        glm::vec4 m_value;\n    };\n\n    template&lt;&gt;\n    struct vector2&lt;glm::highp_vec2&gt; {\n        vector2() = default;\n\n        vector2(const glm::highp_vec2&amp; p_other)\n          : m_value(p_other) {}\n\n        operator glm::highp_vec2() { return m_value; }\n\n        glm::highp_vec2 operator=(const glm::highp_vec2&amp; p_other) {\n            return p_other;\n        }\n\n        bool operator==(const glm::vec4&amp; p_other) {\n            return (m_value.x == p_other.x and m_value.y == p_other.y);\n        }\n\n    private:\n        glm::highp_vec2 m_value;\n    };\n\n    template&lt;&gt;\n    struct vector3&lt;glm::highp_vec3&gt; {\n        vector3() = default;\n\n        vector3(const glm::highp_vec3&amp; p_other)\n          : m_value(p_other) {}\n\n        operator glm::highp_vec3() { return m_value; }\n\n        glm::highp_vec3 operator=(const glm::highp_vec3&amp; p_other) {\n            return p_other;\n        }\n\n        bool operator==(const glm::highp_vec3&amp; p_other) {\n            return (m_value.x == p_other.x and m_value.y == p_other.y and\n                    m_value.z == p_other.z);\n        }\n\n    private:\n        glm::highp_vec3 m_value;\n    };\n\n    template&lt;&gt;\n    struct vector4&lt;glm::highp_vec4&gt; {\n        vector4() = default;\n\n        vector4(const glm::highp_vec4&amp; p_other)\n          : m_value(p_other) {}\n\n        operator glm::highp_vec4() { return m_value; }\n\n        glm::highp_vec4 operator=(const glm::highp_vec4&amp; p_other) {\n            return p_other;\n        }\n\n        bool operator==(const glm::highp_vec4&amp; p_other) {\n            return (m_value.x == p_other.x and m_value.y == p_other.y and\n                    m_value.z == p_other.z and m_value.w == p_other.w);\n        }\n\n    private:\n        glm::highp_vec4 m_value;\n    };\n\n    template&lt;typename T&gt;\n    struct math_generic;\n\n    template&lt;typename T&gt;\n    struct matrix2;\n\n    template&lt;typename T&gt;\n    struct matrix3;\n\n    template&lt;typename T&gt;\n    struct matrix4;\n\n    template&lt;size_t Size, typename T&gt;\n    using vec = math_generic&lt;glm::vec&lt;Size, T&gt;&gt;;\n    using vec2 = vector2&lt;glm::vec2&gt;;\n    using vec3 = vector3&lt;glm::vec3&gt;;\n    using vec4 = vector4&lt;glm::vec4&gt;;\n\n    using highp_vec2 = vector2&lt;glm::highp_vec2&gt;;\n    using highp_vec3 = vector3&lt;glm::highp_vec3&gt;;\n    using highp_vec4 = vector4&lt;glm::highp_vec4&gt;;\n\n    template&lt;size_t C, size_t R, typename T&gt;\n    using mat = math_generic&lt;glm::mat&lt;C, R, T&gt;&gt;;\n\n    using mat2 = matrix2&lt;glm::mat2&gt;;\n    using mat3 = matrix3&lt;glm::mat3&gt;;\n    using mat4 = matrix4&lt;glm::mat4&gt;;\n}; // namespace atlas\n</code></pre>"},{"location":"References/dir_50632568389acd88e20d4049896804e3/","title":"Dir TheAtlasEngine/atlas/core/scene","text":"<p>FileList &gt; atlas &gt; core &gt; scene</p>"},{"location":"References/dir_50632568389acd88e20d4049896804e3/#files","title":"Files","text":"Type Name file components.hpp file entity.hpp file scene.hpp file scene_object.hpp file world.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/</code></p>"},{"location":"References/components_8hpp/","title":"File components.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; scene &gt; components.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/application.hpp&gt;</code></li> <li><code>#include &lt;core/geometry/mesh.hpp&gt;</code></li> <li><code>#include &lt;glm/ext/quaternion_transform.hpp&gt;</code></li> <li><code>#include &lt;glm/gtx/quaternion.hpp&gt;</code></li> <li><code>#include &lt;glm/gtc/matrix_transform.hpp&gt;</code></li> <li><code>#include &lt;glm/gtc/type_ptr.hpp&gt;</code></li> <li><code>#include &lt;glm/gtx/matrix_decompose.hpp&gt;</code></li> </ul>"},{"location":"References/components_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/components_8hpp/#classes","title":"Classes","text":"Type Name struct box_collider3d class camera struct light TODO: Make this better (when we do lighting) struct rendertarget3d struct rigidbody3d struct tag struct transform"},{"location":"References/components_8hpp/#macros","title":"Macros","text":"Type Name define GLM_ENABLE_EXPERIMENTAL"},{"location":"References/components_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"References/components_8hpp/#define-glm_enable_experimental","title":"define GLM_ENABLE_EXPERIMENTAL","text":"<pre><code>#define GLM_ENABLE_EXPERIMENTAL \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/components.hpp</code></p>"},{"location":"References/components_8hpp_source/","title":"File components.hpp","text":"<p>File List &gt; atlas &gt; core &gt; scene &gt; components.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/application.hpp&gt;\n#include &lt;core/geometry/mesh.hpp&gt;\n#include &lt;glm/ext/quaternion_transform.hpp&gt;\n\n#define GLM_ENABLE_EXPERIMENTAL\n#include &lt;glm/gtx/quaternion.hpp&gt;\n\n#include &lt;glm/gtc/matrix_transform.hpp&gt;\n#include &lt;glm/gtc/type_ptr.hpp&gt;\n#include &lt;glm/gtx/matrix_decompose.hpp&gt;\n\nnamespace atlas {\n    struct tag {\n        std::string TagMetadata = \"\";\n    };\n\n    struct transform {\n        glm::highp_vec3 Position{ 0.f };\n        glm::highp_vec3 QuaternionRotation{ 0.f };\n        glm::highp_vec3 Rotation{ 0.f };\n        glm::highp_vec3 Scale{ 1.f };\n        glm::highp_vec4 Color{ 1.f };\n    };\n\n    struct rigidbody3d {\n        rigidbody3d() = default;\n\n        enum class BodyType { STATIC = 0, DYNAMIC = 1, KINEMATIC = 2 };\n\n        BodyType Type = BodyType::STATIC;\n        bool HasFixation = false;\n        void* BodyAtRuntime =\n          nullptr; // for storing the actual data of the body\n    };\n\n    struct box_collider3d {\n        box_collider3d() = default;\n        box_collider3d(const box_collider3d&amp;) = default;\n\n        float density = 1.0f;\n        float friction = 0.5f;\n        float restitution = 0.0f;\n        float restitutionThreshold = 0.5f;\n\n        glm::vec3 offset = { 0.f, 0.f, 0.f };\n        glm::vec3 size = { 0.5f, 0.5f, 0.5f };\n    };\n\n    // Defines several possible options for camera movement. Used as abstraction\n    // to stay away from window-system specific input methods\n    enum CameraMovement { Forward, Backward, Left, Right, Up, Down };\n\n    // An abstract camera class that processes input and calculates the\n    // corresponding Euler Angles, Vectors and Matrices for use in OpenGL\n\n    struct light {\n        glm::vec3 Position{ 1.f };\n    };\n\n    struct rendertarget3d {\n        rendertarget3d() = default;\n        rendertarget3d(const std::string&amp; p_filepath)\n          : Filepath(p_filepath)\n          , MeshMetaData(p_filepath) {}\n\n        std::string Filepath;\n        mesh MeshMetaData{};\n        glm::mat4 Model{ 1.f };\n    };\n\n    // An abstract camera class that processes input and calculates the\n    // corresponding Euler Angles, Vectors and Matrices for use in OpenGL\n\n    class camera {\n        // Default camera values\n        // const float yaw = -90.0f;\n        // const float PITCH = 0.0f;\n        // const float ZOOM = 45.0f;\n    public:\n        // constructor with vectors\n        camera(glm::vec3 position = glm::vec3(0.0f, 1.50f, 0.0f),\n               glm::vec3 up = glm::vec3(0.0f, -1.0f, 0.0f),\n               float yaw = -90.0f,\n               float pitch = 0.0f)\n          : MovementSpeed(5.f)\n          , MouseSensitivity(0.1f)\n          , Zoom(45.0f)\n          , camera_mouse_sensitivity(0.1f) {\n            Position = position;\n            WorldUp = up;\n            EulerRotation = { yaw, pitch, 1.f };\n            AspectRatio = (float)application::get_aspect_ratio();\n            update_camera();\n        }\n\n        // returns the view matrix calculated using Euler Angles and the LookAt\n        // Matrix\n        [[nodiscard]] glm::mat4 get_view() const { return View; }\n        [[nodiscard]] glm::mat4 get_projection() const { return Projection; }\n\n        // processes input received from any keyboard-like input system. Accepts\n        // input parameter in the form of camera defined ENUM (to abstract it\n        // from windowing systems)\n        void process_keyboard(CameraMovement p_direction, float p_delta_time) {\n            float velocity = MovementSpeed * p_delta_time;\n\n            if (p_direction == CameraMovement::Forward)\n                Position += get_front() * velocity;\n            if (p_direction == CameraMovement::Backward)\n                Position -= get_front() * velocity;\n            if (p_direction == CameraMovement::Left)\n                Position -= Right * velocity;\n            if (p_direction == CameraMovement::Right)\n                Position += Right * velocity;\n\n            if (p_direction == CameraMovement::Up) {\n                Position += Up * velocity;\n            }\n\n            if (p_direction == CameraMovement::Down) {\n                Position -= Up * velocity;\n            }\n        }\n\n        // processes input received from a mouse input system. Expects the\n        // offset value in both the x and y direction.\n        void process_mouse_movement(float p_x,\n                                    float p_y,\n                                    bool p_constraint_pitch = true) {\n\n            p_x *= MouseSensitivity;\n            p_y *= MouseSensitivity;\n\n            EulerRotation.x += p_x;\n            EulerRotation.y += p_y;\n\n            // make sure that when pitch is out of bounds, screen doesn't get\n            // flipped\n            if (p_constraint_pitch) {\n                if (EulerRotation.y &gt; 89.0f) {\n                    EulerRotation.y = 89.0f;\n                }\n                if (EulerRotation.y &lt; -89.0f) {\n                    EulerRotation.y = -89.0f;\n                }\n            }\n\n            // update Front, Right and Up Vectors using the updated Euler angles\n            update_camera();\n        }\n\n        // processes input received from a mouse scroll-wheel event. Only\n        // requires input on the vertical wheel-axis\n        void process_mouse_scroll(float yoffset) {\n            Zoom -= (float)yoffset;\n\n            if (Zoom &lt; 1.0f) {\n                Zoom = 1.0f;\n            }\n\n            if (Zoom &gt; 45.0f) {\n                Zoom = 45.0f;\n            }\n        }\n\n        void set_movement_speed(float p_sensitivity) {\n            camera_movement_sensitivity = p_sensitivity;\n            MovementSpeed = camera_movement_sensitivity;\n        }\n\n        void set_mouse_speed(float p_sensitivity) {\n            camera_mouse_sensitivity = p_sensitivity;\n        }\n\n        [[nodiscard]] float camera_sensitivity() const {\n            return camera_mouse_sensitivity;\n        }\n\n    private:\n        // calculates the front vector from the Camera's (updated) Euler Angles\n        void update_camera() {\n            // calculate the new Front vector\n            // glm::vec3 front;\n            // front.x = cos(glm::radians(EulerRotation.x)) *\n            // cos(glm::radians(EulerRotation.y)); front.y =\n            // sin(glm::radians(EulerRotation.y)); front.z =\n            // sin(glm::radians(EulerRotation.x)) *\n            // cos(glm::radians(EulerRotation.y)); Front =\n            // glm::normalize(front); also re-calculate the Right and Up vector\n            Right = glm::normalize(glm::cross(\n              get_front(),\n              WorldUp)); // normalize the vectors, because their length\n                         // gets closer to 0 the more you look up or\n                         // down which results in slower movement.\n            Left = glm::normalize(glm::cross(-get_front(), WorldUp));\n            Up = glm::normalize(glm::cross(Right, get_front()));\n            Down = glm::normalize(glm::cross(-Right, WorldUp));\n        }\n\n    public:\n        void update_proj_view() {\n            Projection =\n              glm::perspective(glm::radians(Zoom), AspectRatio, .1f, 50000.f);\n            View = glm::lookAt(Position, Position + get_front(), Up);\n        }\n\n        [[nodiscard]] glm::vec3 get_front() const {\n            glm::vec3 front_values;\n            front_values.x = cos(glm::radians(EulerRotation.x)) *\n                             cos(glm::radians(EulerRotation.y));\n            front_values.y = sin(glm::radians(EulerRotation.y));\n            front_values.z = sin(glm::radians(EulerRotation.x)) *\n                             cos(glm::radians(EulerRotation.y));\n            return glm::normalize(front_values);\n        }\n\n    public:\n        // camera Attributes\n        glm::vec3 Position;\n        // glm::vec3 Front;\n        glm::vec3 Up;\n        glm::vec3 Down;\n        glm::vec3 Right;\n        glm::vec3 Left;\n        glm::vec3 WorldUp;\n\n        glm::mat4 Projection;\n        glm::mat4 View;\n\n        float AspectRatio = 0.f;\n\n        // euler Angles\n        // {x: Yaw, y: Pitch, z: Roll}\n        glm::vec3 EulerRotation;\n        // camera options\n        float MovementSpeed{};\n        float MouseSensitivity{};\n        float Zoom{};\n\n        // float camera_mouse_sensitivity = 0.1f;\n        float camera_mouse_sensitivity = 2.5f;\n        float camera_movement_sensitivity = 2.5f;\n\n        // toggling between cameras and checking if our current\n        bool IsMainCamera = false;\n    };\n}; // namespace atlas\n</code></pre>"},{"location":"References/entity_8hpp/","title":"File entity.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; scene &gt; entity.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;core/scene/world.hpp&gt;</code></li> <li><code>#include &lt;flecs.h&gt;</code></li> </ul>"},{"location":"References/entity_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/entity_8hpp/#classes","title":"Classes","text":"Type Name class entity_t <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/entity.hpp</code></p>"},{"location":"References/entity_8hpp_source/","title":"File entity.hpp","text":"<p>File List &gt; atlas &gt; core &gt; scene &gt; entity.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n#include &lt;core/scene/world.hpp&gt;\n#include &lt;flecs.h&gt;\n\nnamespace atlas {\n    class entity_t {\n    public:\n        entity_t() = default;\n        entity_t(flecs::world* p_registry, const std::string&amp; p_tag);\n        entity_t(const flecs::entity&amp; p_entity)\n          : m_entity_id(p_entity) {}\n\n        ~entity_t();\n\n        [[nodiscard]] bool is_alive() const { return m_entity_id.is_alive(); }\n\n        void on_destruction() { m_entity_id.destruct(); }\n\n        template&lt;typename UComponent&gt;\n        void add() {\n            m_entity_id.add&lt;UComponent&gt;();\n        }\n\n        template&lt;typename UComponent&gt;\n        const UComponent* get() const {\n            return m_entity_id.get&lt;UComponent&gt;();\n        }\n\n        template&lt;typename UComponent&gt;\n        UComponent* get_mut() const {\n            return m_entity_id.get_mut&lt;UComponent&gt;();\n        }\n\n        template&lt;typename UComponent&gt;\n        [[nodiscard]] bool has() const {\n            return m_entity_id.has&lt;UComponent&gt;();\n        }\n\n\n        template&lt;typename UComponent&gt;\n        void set(const UComponent&amp; p_component) {\n            m_entity_id.set&lt;UComponent&gt;(p_component);\n        }\n\n        template&lt;typename UComponent1, typename UComponent2&gt;\n        void set(const UComponent1&amp; p_component1,\n                 const UComponent2&amp; p_component2) {\n            m_entity_id.set&lt;UComponent1, UComponent2&gt;(p_component1)\n              .set(p_component2);\n        }\n\n        template&lt;typename UComponent&gt;\n        void remove() {\n            m_entity_id.remove&lt;UComponent&gt;();\n        }\n\n        operator flecs::entity() const { return m_entity_id; }\n\n        operator flecs::entity() { return m_entity_id; }\n\n    private:\n        // Keep in mind that an entity just represent a 64-bit number\n        flecs::entity m_entity_id;\n    };\n}; // namespace atlas\n</code></pre>"},{"location":"References/scene_8hpp/","title":"File scene.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; scene &gt; scene.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;core/scene/scene_object.hpp&gt;</code></li> <li><code>#include &lt;core/scene/world.hpp&gt;</code></li> <li><code>#include &lt;core/system_framework/system_registry.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/scene_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/scene_8hpp/#classes","title":"Classes","text":"Type Name class scene_scope <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/scene.hpp</code></p>"},{"location":"References/scene_8hpp_source/","title":"File scene.hpp","text":"<p>File List &gt; atlas &gt; core &gt; scene &gt; scene.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;core/scene/scene_object.hpp&gt;\n#include &lt;core/scene/world.hpp&gt;\n#include &lt;core/system_framework/system_registry.hpp&gt;\n#include &lt;string&gt;\n\nnamespace atlas {\n    class scene_scope {\n    public:\n        scene_scope()\n          : m_tag(\"Undefined\") {}\n        scene_scope(const std::string&amp; p_tag)\n          : m_tag(p_tag) {}\n\n        ref&lt;scene_object&gt; create_new_object(const std::string&amp; p_tag) {\n            return create_ref&lt;scene_object&gt;(&amp;m_registry, p_tag);\n        }\n\n        template&lt;typename... Comps, typename... Args&gt;\n        flecs::query_builder&lt;Comps...&gt; query_builder(Args&amp;&amp;... args) const {\n            return flecs::query_builder&lt;Comps...&gt;(m_registry,\n                                                  std::forward(args)...);\n        }\n\n        virtual ~scene_scope() = default;\n\n        std::string get_tag() { return m_tag; }\n\n        operator flecs::world() const { return m_registry; }\n        operator flecs::world() { return m_registry; }\n\n    private:\n        flecs::world m_registry;\n        std::string m_tag = \"Undefined Tag\";\n    };\n}; // namespace atlas\n</code></pre>"},{"location":"References/scene__object_8hpp/","title":"File scene_object.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; scene &gt; scene_object.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;core/scene/components.hpp&gt;</code></li> <li><code>#include &lt;core/scene/entity.hpp&gt;</code></li> <li><code>#include &lt;variant&gt;</code></li> </ul>"},{"location":"References/scene__object_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/scene__object_8hpp/#classes","title":"Classes","text":"Type Name class scene_object <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/scene_object.hpp</code></p>"},{"location":"References/scene__object_8hpp_source/","title":"File scene_object.hpp","text":"<p>File List &gt; atlas &gt; core &gt; scene &gt; scene_object.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;core/scene/components.hpp&gt;\n#include &lt;core/scene/entity.hpp&gt;\n#include &lt;variant&gt;\n\nnamespace atlas {\n    class scene_object {\n    public:\n        scene_object() = default;\n        scene_object(flecs::world* p_registry, const std::string&amp; p_tag)\n          : m_entity(p_registry, p_tag) {\n            m_model = glm::mat4(1.0f);\n        }\n\n        scene_object(const flecs::entity&amp; p_entity)\n          : m_entity(p_entity) {}\n\n        ~scene_object() {\n            console_log_fatal(\"Scene Object Tag = {} HAS DESTRUCTED!!!\",\n                              m_entity.get&lt;tag&gt;()-&gt;TagMetadata);\n            if (m_entity.is_alive()) {\n                m_entity.on_destruction();\n            }\n        }\n\n        template&lt;typename UComponent&gt;\n        void add() {\n            m_entity.add&lt;UComponent&gt;();\n        }\n\n        template&lt;typename UComponent&gt;\n        void add(UComponent&amp; p_component_value) {\n            m_entity.add&lt;UComponent&gt;(p_component_value);\n        }\n\n        template&lt;typename... Args&gt;\n        void add_query() {\n            using tuple_variadic = std::tuple&lt;Args...&gt;;\n            std::variant&lt;tuple_variadic&gt; conditions;\n            std::visit(\n              [&amp;]([[maybe_unused]] const auto&amp; p_component) {\n                  std::apply(\n                    [&amp;](auto&amp;... p_placeholder) {\n                        (m_entity.add&lt;std::decay_t&lt;decltype(p_placeholder)&gt;&gt;(),\n                         ...);\n                    },\n                    p_component);\n              },\n              conditions);\n        }\n\n        template&lt;typename UComponent&gt;\n        [[nodiscard]] const UComponent* get() const {\n            return m_entity.get&lt;UComponent&gt;();\n        }\n\n        template&lt;typename UComponent&gt;\n        [[nodiscard]] UComponent* get_mut() {\n            return m_entity.get_mut&lt;UComponent&gt;();\n        }\n\n        template&lt;typename UComponent&gt;\n        bool has() {\n            return m_entity.has&lt;UComponent&gt;();\n        }\n\n        template&lt;typename UComponent&gt;\n        void set(const UComponent&amp; p_component) {\n            m_entity.set&lt;UComponent&gt;(p_component);\n        }\n\n        template&lt;typename UComponent, typename UComponent2&gt;\n        void set(const UComponent&amp; p_component,\n                 const UComponent2&amp; p_component2) {\n            m_entity.set&lt;UComponent&gt;(p_component, p_component2);\n        }\n\n        template&lt;typename UComponent&gt;\n        void remove() {\n            return m_entity.remove&lt;UComponent&gt;();\n        }\n\n        [[nodiscard]] glm::mat4 get_model() {\n            const transform* transform_component = get&lt;transform&gt;();\n            m_model = glm::mat4(1.f);\n\n            m_model = glm::translate(m_model, transform_component-&gt;Position);\n            m_model = glm::scale(m_model, transform_component-&gt;Scale);\n\n            auto rotation_mat4 =\n              glm::mat4(glm::quat(transform_component-&gt;Rotation));\n            m_model *= rotation_mat4;\n\n            return m_model;\n        }\n\n        operator flecs::entity() const { return m_entity; }\n\n        operator flecs::entity() { return m_entity; }\n\n    private:\n        entity_t m_entity;\n        glm::mat4 m_model;\n        float m_angle = glm::radians(90.0f);\n    };\n}; // namespace atlas\n</code></pre>"},{"location":"References/world_8hpp/","title":"File world.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; scene &gt; world.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;deque&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;flecs.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/world_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/world_8hpp/#classes","title":"Classes","text":"Type Name class world_scope Lets rethink how world_scope gets created. <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/scene/world.hpp</code></p>"},{"location":"References/world_8hpp_source/","title":"File world.hpp","text":"<p>File List &gt; atlas &gt; core &gt; scene &gt; world.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;deque&gt;\n#include &lt;map&gt;\n#include &lt;flecs.h&gt;\n#include &lt;string&gt;\n\nnamespace atlas {\n\n    class scene_scope;\n    // enable_shared_from cppreference link:\n    // https://en.cppreference.com/w/cpp/memory/enable_shared_from_this\n    class world_scope : public std::enable_shared_from_this&lt;world_scope&gt; {\n    public:\n        world_scope() = default;\n        world_scope(const std::string&amp; p_tag);\n        ~world_scope();\n\n        [[nodiscard]] std::string get_tag() const { return m_tag; }\n\n        void add_scene(const ref&lt;scene_scope&gt;&amp; p_scene_context);\n\n        // flecs::world* get_registry() { return &amp;m_scene_registry; }\n        ref&lt;scene_scope&gt; get_scene(const std::string&amp; p_tag) {\n            if (m_scene_container.contains(p_tag)) {\n                return m_scene_container[p_tag];\n            }\n\n            return nullptr;\n        }\n\n        ref&lt;world_scope&gt; get() { return shared_from_this(); }\n\n        operator flecs::world&amp;() { return m_scene_registry; }\n\n    private:\n        flecs::world m_scene_registry;\n        std::map&lt;std::string, ref&lt;scene_scope&gt;&gt; m_scene_container;\n        // ref&lt;scene_scope&gt; m_current_scene;\n        ref&lt;world_scope&gt; m_world_shared_instance = nullptr;\n        std::string m_tag = \"Undefined Tag\";\n    };\n}; // namespace atlas\n</code></pre>"},{"location":"References/dir_58a1ea337b9d91821031c085f16f9af8/","title":"Dir TheAtlasEngine/atlas/core/serialize","text":"<p>FileList &gt; atlas &gt; core &gt; serialize</p>"},{"location":"References/dir_58a1ea337b9d91821031c085f16f9af8/#files","title":"Files","text":"Type Name file serializer.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/serialize/</code></p>"},{"location":"References/serializer_8hpp/","title":"File serializer.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; serialize &gt; serializer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;core/scene/scene.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/serializer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/serializer_8hpp/#classes","title":"Classes","text":"Type Name class serializer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/serialize/serializer.hpp</code></p>"},{"location":"References/serializer_8hpp_source/","title":"File serializer.hpp","text":"<p>File List &gt; atlas &gt; core &gt; serialize &gt; serializer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;core/scene/scene.hpp&gt;\n#include &lt;string&gt;\n\nnamespace atlas {\n    class serializer {\n    public:\n        serializer(const scene_scope* p_scene_ctx);\n\n        void save_as(const std::string&amp; p_filepath);\n\n    private:\n        ref&lt;scene_scope&gt; m_current_scene_ctx;\n    };\n\n}; // namespace atlas\n</code></pre>"},{"location":"References/dir_95144a79d2a75258fa60dac31330b761/","title":"Dir TheAtlasEngine/atlas/core/system_framework","text":"<p>FileList &gt; atlas &gt; core &gt; system_framework</p>"},{"location":"References/dir_95144a79d2a75258fa60dac31330b761/#files","title":"Files","text":"Type Name file system_registry.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/system_framework/</code></p>"},{"location":"References/system__registry_8hpp/","title":"File system_registry.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; system_framework &gt; system_registry.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;core/scene/world.hpp&gt;</code></li> </ul>"},{"location":"References/system__registry_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/system__registry_8hpp/#classes","title":"Classes","text":"Type Name class system_registry <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/system_framework/system_registry.hpp</code></p>"},{"location":"References/system__registry_8hpp_source/","title":"File system_registry.hpp","text":"<p>File List &gt; atlas &gt; core &gt; system_framework &gt; system_registry.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;map&gt;\n#include &lt;core/scene/world.hpp&gt;\n\nnamespace atlas {\n    class system_registry {\n    public:\n        system_registry(const std::string&amp; p_tag);\n\n        ~system_registry();\n\n        static ref&lt;world_scope&gt; create_world(const std::string&amp; p_tag);\n\n        static ref&lt;world_scope&gt; get_world(const std::string&amp; p_tag);\n\n    private:\n        ref&lt;world_scope&gt; search_world(const std::string&amp; p_tag);\n\n        void append_world(const ref&lt;world_scope&gt;&amp; p_world);\n\n        ref&lt;world_scope&gt; append_world_scope(const ref&lt;world_scope&gt;&amp; p_world);\n\n    private:\n        static system_registry* s_instance;\n        std::string m_tag = \"Undefined\";\n        std::map&lt;std::string, ref&lt;world_scope&gt;&gt; m_world_registered;\n    };\n};\n</code></pre>"},{"location":"References/dir_3d5429f92b5f302f4e9406c3e899f86b/","title":"Dir TheAtlasEngine/atlas/core/threads","text":"<p>FileList &gt; atlas &gt; core &gt; threads</p>"},{"location":"References/dir_3d5429f92b5f302f4e9406c3e899f86b/#files","title":"Files","text":"Type Name file thread.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/threads/</code></p>"},{"location":"References/core_2threads_2thread_8hpp/","title":"File thread.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; threads &gt; thread.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/core_2threads_2thread_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/core_2threads_2thread_8hpp/#classes","title":"Classes","text":"Type Name class thread <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/threads/thread.hpp</code></p>"},{"location":"References/core_2threads_2thread_8hpp_source/","title":"File thread.hpp","text":"<p>File List &gt; atlas &gt; core &gt; threads &gt; thread.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n\nnamespace atlas {\n    class thread {\n    public:\n        thread(const std::string&amp; p_tag);\n\n        template&lt;typename T&gt;\n        void dispatch([[maybe_unused]] const T&amp; p_function) {}\n    };\n};\n</code></pre>"},{"location":"References/dir_ec4014881addefdc5691f44c9e98b9f4/","title":"Dir TheAtlasEngine/atlas/core/ui","text":"<p>FileList &gt; atlas &gt; core &gt; ui</p>"},{"location":"References/dir_ec4014881addefdc5691f44c9e98b9f4/#files","title":"Files","text":"Type Name file widgets.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/ui/</code></p>"},{"location":"References/widgets_8hpp/","title":"File widgets.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; ui &gt; widgets.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;imgui.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;core/filesystem/file_dialog.hpp&gt;</code></li> </ul>"},{"location":"References/widgets_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace ui"},{"location":"References/widgets_8hpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const std::filesystem::path g_asset_path   = <code>\"3d\\_models\"</code>"},{"location":"References/widgets_8hpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"References/widgets_8hpp/#variable-g_asset_path","title":"variable g_asset_path","text":"<pre><code>const std::filesystem::path g_asset_path;\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/ui/widgets.hpp</code></p>"},{"location":"References/widgets_8hpp_source/","title":"File widgets.hpp","text":"<p>File List &gt; atlas &gt; core &gt; ui &gt; widgets.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;imgui.h&gt;\n#include &lt;string&gt;\n#include &lt;glm/glm.hpp&gt;\n#include &lt;GLFW/glfw3.h&gt;\n#include &lt;filesystem&gt;\n#include &lt;core/filesystem/file_dialog.hpp&gt;\n#include &lt;filesystem&gt;\n\nstatic const std::filesystem::path g_asset_path = \"3d_models\";\n\n// namespace ImGui {\n//     //! @note We need to see if this works\n//     //! @note Because imgui implements this but the header file for some\n//     reason\n//     //! does not contain this implementation...\n//     void PushMultiItemsWidths(int components, float w_full);\n// };\n\nnamespace atlas::ui {\n\n    bool begin_popup_context_window(const char* p_str_id,\n                                    ImGuiMouseButton p_mb,\n                                    bool p_over_items);\n\n    /* Rendering glm::vec3's as a UI widget */\n    void draw_vec3(const std::string&amp; p_tag,\n                   glm::vec3&amp; p_value,\n                   float p_reset_value = 0.f);\n\n    void draw_vec4(const std::string&amp; p_tag,\n                   glm::vec4&amp; p_value,\n                   float p_reset_value = 0.f);\n\n    /* Rendering float as a UI widget with default reset values */\n    void draw_float(const std::string&amp; p_tag,\n                    float&amp; p_value,\n                    float p_reset_value = 0.f);\n\n    /*\n        draw panel component\n\n        - is used to group widgets into specific panels\n\n        Parameters\n        T = is the type the component we want to draw to the UI\n        UFunction = callback that defines what data in the component to be\n       displayed in this panel that handles the UI layout of that component\n\n        USAGE:\n\n        draw_panel_component&lt;UComponent&gt;(\"Transform\", [](){\n            DrawVec3(\"Position\", position_value);\n            // etc....\n        });\n    */\n    template&lt;typename T, typename UFunction&gt;\n    static void draw_panel_component(const std::string&amp; p_tag,\n                                     const UFunction&amp; p_callable) {\n        const ImGuiTreeNodeFlags tree_node_flags =\n          ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_Framed |\n          ImGuiTreeNodeFlags_SpanAvailWidth |\n          ImGuiTreeNodeFlags_AllowItemOverlap | ImGuiTreeNodeFlags_FramePadding;\n\n        ImVec2 content_region = ImGui::GetContentRegionAvail();\n        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2{ 4, 4 });\n\n        float line_height =\n          ImGui::GetFontSize() + ImGui::GetStyle().FramePadding.y * 2.0f;\n        ImGui::Separator();\n\n        bool opened = ImGui::TreeNodeEx(\n          (void*)typeid(T).hash_code(), tree_node_flags, \"%s\", p_tag.c_str());\n        ImGui::PopStyleVar();\n\n        ImGui::SameLine(content_region.x - line_height * 0.05f);\n\n        if (ImGui::Button(\"+\", ImVec2(line_height, line_height))) {\n            ImGui::OpenPopup(\"ComponentSettings\");\n        }\n\n        // bool isRemovedComponent = false; // @note for deferring when to\n        // delete component.\n        if (ImGui::BeginPopup(\"ComponentSettings\")) {\n            if (ImGui::MenuItem(\"Remove Component\")) {\n            }\n            //     isRemovedComponent = true;\n\n            ImGui::EndPopup();\n        }\n\n        if (opened) {\n            p_callable();\n            ImGui::TreePop();\n        }\n    }\n\n    void dockspace_window(GLFWwindow* p_window);\n\n    void button_open_file_dialog(const std::string&amp; p_tag,\n                                 std::string&amp; p_filepath,\n                                 const std::string&amp; p_filter = \"obj;glftf;fbx\");\n};\n</code></pre>"},{"location":"References/dir_e4a875ec04a9822d1a20b5830cf2827b/","title":"Dir TheAtlasEngine/atlas/core/update_handlers","text":"<p>FileList &gt; atlas &gt; core &gt; update_handlers</p>"},{"location":"References/dir_e4a875ec04a9822d1a20b5830cf2827b/#files","title":"Files","text":"Type Name file global_update.hpp file parallel_update_manager.hpp file sync_update.hpp file thread_manager.hpp file timer.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/update_handlers/</code></p>"},{"location":"References/global__update_8hpp/","title":"File global_update.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; update_handlers &gt; global_update.hpp</p> <p>Go to the source code of this file</p>"},{"location":"References/global__update_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/update_handlers/global_update.hpp</code></p>"},{"location":"References/global__update_8hpp_source/","title":"File global_update.hpp","text":"<p>File List &gt; atlas &gt; core &gt; update_handlers &gt; global_update.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n// #include &lt;core/update_handlers/thread_manager.hpp&gt;\n// #include &lt;core/update_handlers/timer.hpp&gt;\n\nnamespace atlas {\n    /*\n    class global_update {\n    public:\n        global_update() = delete;\n        ~global_update() = delete;\n        global_update(const global_update&amp;) = delete;\n        global_update&amp; operator=(const global_update&amp;) = delete;\n\n        static void initialize();\n        static void cleanup();\n\n        // Manages the sync of each updateManager if required\n        static void tick_update_frequency();\n\n        // Maintains a const fps if possible\n        static void wait_next_frame();\n\n        static void IncrementCounter();\n\n    private:\n    };\n    */\n};\n</code></pre>"},{"location":"References/parallel__update__manager_8hpp/","title":"File parallel_update_manager.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; update_handlers &gt; parallel_update_manager.hpp</p> <p>Go to the source code of this file</p>"},{"location":"References/parallel__update__manager_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/parallel__update__manager_8hpp/#classes","title":"Classes","text":"Type Name class ParallelUpdateManager <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/update_handlers/parallel_update_manager.hpp</code></p>"},{"location":"References/parallel__update__manager_8hpp_source/","title":"File parallel_update_manager.hpp","text":"<p>File List &gt; atlas &gt; core &gt; update_handlers &gt; parallel_update_manager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace atlas {\n    class ParallelUpdateManager {\n    public:\n        ParallelUpdateManager() = delete;\n\n        static void InitializeParallel();\n    };\n};\n</code></pre>"},{"location":"References/sync__update_8hpp/","title":"File sync_update.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; update_handlers &gt; sync_update.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;deque&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> </ul>"},{"location":"References/sync__update_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace sync_update <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/update_handlers/sync_update.hpp</code></p>"},{"location":"References/sync__update_8hpp_source/","title":"File sync_update.hpp","text":"<p>File List &gt; atlas &gt; core &gt; update_handlers &gt; sync_update.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;deque&gt;\n#include &lt;functional&gt;\n\nnamespace atlas {\n    namespace sync_update {\n\n        void initialize();\n\n        float delta_time();\n\n        // Called by thread_manager\n        // void run_update(float deltaTime);\n\n        inline std::deque&lt;std::function&lt;void()&gt;&gt; s_update;\n        inline std::deque&lt;std::function&lt;void()&gt;&gt; s_late_update;\n        inline std::deque&lt;std::function&lt;void()&gt;&gt; s_ui_update;\n        inline std::deque&lt;std::function&lt;void()&gt;&gt; s_physica_update;\n\n        template&lt;typename UObject, typename UFunction&gt;\n        void sync(UObject* p_instance, const UFunction&amp; p_callable) {\n            static_assert(std::is_member_pointer_v&lt;UFunction&gt;,\n                          \"Invalid sync function\");\n\n            s_update.push_back(\n              [p_instance, p_callable]() { (p_instance-&gt;*p_callable)(); });\n        }\n\n        template&lt;typename UObject, typename UFunction&gt;\n        void sync_physics(UObject* p_instance, const UFunction&amp; p_callable) {\n            static_assert(std::is_member_pointer_v&lt;UFunction&gt;,\n                          \"Invalid sync function\");\n\n            s_physica_update.push_back(\n              [p_instance, p_callable]() { (p_instance-&gt;*p_callable)(); });\n        }\n\n        template&lt;typename UObject, typename UCallable&gt;\n        inline void post(UObject* p_instance, const UCallable&amp; p_callable) {\n            static_assert(std::is_member_pointer_v&lt;UCallable&gt;,\n                          \"Invalid post function\");\n\n            s_late_update.push_back(\n              [p_instance, p_callable]() { (p_instance-&gt;*p_callable)(); });\n        }\n\n        template&lt;typename UObject, typename UCallable&gt;\n        void attach(UObject* p_instance, const UCallable&amp; p_callable) {\n            // UI returns a boolean because this can be used to indicate whether\n            // specific callable functions are activated\n            static_assert(std::is_member_pointer_v&lt;UCallable&gt;,\n                          \"Invalid attach function\");\n\n            s_ui_update.push_back(\n              [p_instance, p_callable]() { (p_instance-&gt;*p_callable)(); });\n        }\n\n        void on_update();\n\n        void on_physics_update();\n\n        void on_ui_update();\n\n        void on_late_update();\n\n    };\n\n    template&lt;typename UObject, typename UCallable&gt;\n    void sync(UObject* p_instance, const UCallable&amp; p_callable) {\n        sync_update::sync(p_instance, p_callable);\n    }\n\n    template&lt;typename UObject, typename UCallable&gt;\n    void sync_physics(UObject* p_instance, const UCallable&amp; p_callable) {\n        sync_update::sync_physics(p_instance, p_callable);\n    }\n\n    template&lt;typename UObject, typename UCallable&gt;\n    void post(UObject* p_instance, const UCallable&amp; p_callable) {\n        sync_update::post(p_instance, p_callable);\n    }\n\n    template&lt;typename UObject, typename UCallable&gt;\n    void attach(UObject* p_instance, const UCallable&amp; p_callable) {\n        sync_update::attach(p_instance, p_callable);\n    }\n\n};\n</code></pre>"},{"location":"References/thread__manager_8hpp/","title":"File thread_manager.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; update_handlers &gt; thread_manager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;thread_utils/thread.hpp&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"References/thread__manager_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/update_handlers/thread_manager.hpp</code></p>"},{"location":"References/thread__manager_8hpp_source/","title":"File thread_manager.hpp","text":"<p>File List &gt; atlas &gt; core &gt; update_handlers &gt; thread_manager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;thread_utils/thread.hpp&gt;\n#include &lt;vector&gt;\n\nnamespace atlas {\n    /*\n    class thread_manager {\n    public:\n        thread_manager();\n        ~thread_manager();\n\n        void on_run(float p_delta_time);\n        void on_stop();\n\n        // static uint32_t GetMaxThreads();\n    private:\n        void update_sync_function();\n        void update_parallel_function();\n\n    private:\n        bool m_thread_stop = false;\n        thread m_sync_update_thread;\n        // Thread m_render_thread;\n\n        std::vector&lt;scope&lt;thread&gt;&gt; m_parallel_threads;\n        float m_delta_time = 0.0f;\n    };\n    */\n};\n</code></pre>"},{"location":"References/update__handlers_2timer_8hpp/","title":"File timer.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; update_handlers &gt; timer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> </ul>"},{"location":"References/update__handlers_2timer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/update__handlers_2timer_8hpp/#classes","title":"Classes","text":"Type Name class timer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/update_handlers/timer.hpp</code></p>"},{"location":"References/update__handlers_2timer_8hpp_source/","title":"File timer.hpp","text":"<p>File List &gt; atlas &gt; core &gt; update_handlers &gt; timer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;chrono&gt;\n\nnamespace atlas {\n    class timer {\n\n    public:\n        timer();\n\n        void reset();\n\n        float elapsed();\n\n        float seconds();\n\n        std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt;\n        current_time();\n\n    private:\n        std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt;\n          m_stop_watch;\n    };\n};\n</code></pre>"},{"location":"References/dir_5ecaaba7e34420a87db9680718b1325e/","title":"Dir TheAtlasEngine/atlas/core/utilities","text":"<p>FileList &gt; atlas &gt; core &gt; utilities</p>"},{"location":"References/dir_5ecaaba7e34420a87db9680718b1325e/#files","title":"Files","text":"Type Name file hash.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/utilities/</code></p>"},{"location":"References/hash_8hpp/","title":"File hash.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; utilities &gt; hash.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> </ul>"},{"location":"References/hash_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/utilities/hash.hpp</code></p>"},{"location":"References/hash_8hpp_source/","title":"File hash.hpp","text":"<p>File List &gt; atlas &gt; core &gt; utilities &gt; hash.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n#include &lt;unordered_map&gt;\n\nnamespace atlas {\n    template&lt;typename T, typename... Rest&gt;\n    void hash_combine(size_t&amp; seed, const T&amp; v, const Rest&amp;... rest) {\n        seed ^= std::hash&lt;T&gt;()(v) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &lt;&lt; 2);\n        (hash_combine(seed, rest), ...);\n    }\n\n};\n</code></pre>"},{"location":"References/api_8hpp/","title":"File api.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; api.hpp</p> <p>Go to the source code of this file</p>"},{"location":"References/api_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/api.hpp</code></p>"},{"location":"References/api_8hpp_source/","title":"File api.hpp","text":"<p>File List &gt; atlas &gt; core &gt; api.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace atlas {\n    enum API { VULKAN, DIRECTX11, DIRECTX12, UNSPECIFIED };\n\n};\n</code></pre>"},{"location":"References/application_8hpp/","title":"File application.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; application.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/api.hpp&gt;</code></li> <li><code>#include &lt;core/window.hpp&gt;</code></li> <li><code>#include &lt;drivers/swapchain.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/application_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/application_8hpp/#classes","title":"Classes","text":"Type Name class application struct application_settings <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/application.hpp</code></p>"},{"location":"References/application_8hpp_source/","title":"File application.hpp","text":"<p>File List &gt; atlas &gt; core &gt; application.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/api.hpp&gt;\n#include &lt;core/window.hpp&gt;\n#include &lt;drivers/swapchain.hpp&gt;\n#include &lt;string&gt;\n\nnamespace atlas {\n\n    struct application_settings {\n        std::string Name = \"Undefined\";\n        uint32_t Width = 0;\n        uint32_t Height = 0;\n    };\n\n    class application {\n    public:\n        application(const application_settings&amp; p_settings);\n        ~application();\n\n        static float delta_time();\n\n        static float physics_step();\n\n        /* executes the application's mainloop */\n        void execute();\n\n        /* Returns the current window selected in the application */\n        static window&amp; get_window() { return *s_instance-&gt;m_window; }\n\n        /* Retrieves the current selected graphics API */\n        static API current_api();\n\n        /* Returns the currently selected swapchain */\n        ref&lt;swapchain&gt; get_current_swapchain();\n\n        /* Destroys the application */\n        static void destroy();\n\n        static uint32_t get_aspect_ratio();\n\n    private:\n        void set_current_api(API api);\n\n    private:\n        ref&lt;window&gt; m_window;\n        static application* s_instance;\n    };\n\n    ref&lt;application&gt; initialize_application();\n};\n</code></pre>"},{"location":"References/core_8hpp/","title":"File core.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; core.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;spdlog/common.h&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> </ul>"},{"location":"References/core_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/core_8hpp/#macros","title":"Macros","text":"Type Name define ENGINE_API <code>\\_\\_attribute\\_\\_((visibility(\"default\")))</code>"},{"location":"References/core_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"References/core_8hpp/#define-engine_api","title":"define ENGINE_API","text":"<pre><code>#define ENGINE_API `__attribute__((visibility(\"default\")))`\n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/core.hpp</code></p>"},{"location":"References/core_8hpp_source/","title":"File core.hpp","text":"<p>File List &gt; atlas &gt; core &gt; core.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cassert&gt;\n#include &lt;memory&gt;\n#include &lt;spdlog/common.h&gt;\n#include &lt;spdlog/spdlog.h&gt;\n\nnamespace atlas {\n#ifdef ENGINE_PLATFORM_WINDOWS\n#ifdef ENGINE_BUILD_DLL\n#define ENGINE_API __declspec(dllexport)\n#else\n#define ENGINE_API __declspec(dllimport)\n#endif\n#else // If we are on either Linux/Mac OS, since they use __attributes__\n#define ENGINE_API __attribute__((visibility(\"default\")))\n#endif\n\n#ifdef ATLAS_DEBUG_BUILD\n#define ATLAS_DEBUG_BUILD\n#endif\n\n    template&lt;typename... T&gt;\n    static void core_assert(bool x, T&amp;&amp;... args) {\n        // const char* filename = __FILE__;\n        // auto line = __LINE__;\n        if (!x) {\n            // spdlog::critical(\"assertion: {}\", fmt, std::forward&lt;T&gt;(args)...,\n            // filename, line);\n            spdlog::critical(\"assertion failed: {}\", std::forward&lt;T&gt;(args)...);\n        }\n    }\n\n    template&lt;typename T&gt;\n    using ref = std::shared_ptr&lt;T&gt;;\n\n    template&lt;typename T, typename... Args&gt;\n    constexpr ref&lt;T&gt; create_ref(Args&amp;&amp;... args) {\n        return std::make_shared&lt;T&gt;(std::forward&lt;Args&gt;(args)...);\n    }\n\n    template&lt;typename T&gt;\n    using scope = std::unique_ptr&lt;T&gt;;\n\n    template&lt;typename T, typename... Args&gt;\n    constexpr scope&lt;T&gt; create_scope(Args&amp;&amp;... args) {\n        return std::make_unique&lt;T&gt;(std::forward&lt;Args&gt;(args)...);\n    }\n\n    template&lt;typename T&gt;\n    using weak_ptr = std::weak_ptr&lt;T&gt;;\n\n    template&lt;typename T, typename... Args&gt;\n    constexpr weak_ptr&lt;T&gt; create_weak_ptr(Args&amp;&amp;... args) {\n        return std::weak_ptr&lt;T&gt;(std::forward&lt;Args&gt;(args)...);\n    }\n\n    template&lt;typename T, typename U&gt;\n    weak_ptr&lt;T&gt; to_weak_ptr(const U&amp; p_value) {\n        return CreateWeakPtr&lt;T&gt;(p_value);\n    }\n};\n</code></pre>"},{"location":"References/engine__logger_8hpp/","title":"File engine_logger.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; engine_logger.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;fmt/os.h&gt;</code></li> <li><code>#include &lt;fmt/ostream.h&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;spdlog/common.h&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> </ul>"},{"location":"References/engine__logger_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/engine__logger_8hpp/#classes","title":"Classes","text":"Type Name class console_log_manager"},{"location":"References/engine__logger_8hpp/#public-functions","title":"Public Functions","text":"Type Name void console_log_error (spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_error_tagged (const std::string &amp; p_tag, spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_fatal (spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_fatal_tagged (const std::string &amp; p_tag, spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_info (spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_info_tagged (const std::string &amp; p_tag, spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_trace (spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_trace_tagged (const std::string &amp; p_tag, spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_warn (spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)  void console_log_warn_tagged (const std::string &amp; p_tag, spdlog::format_string_t&lt; T... &gt; fmt, T &amp;&amp;... args)"},{"location":"References/engine__logger_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"References/engine__logger_8hpp/#function-console_log_error","title":"function console_log_error","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_error (\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/engine__logger_8hpp/#function-console_log_error_tagged","title":"function console_log_error_tagged","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_error_tagged (\n    const std::string &amp; p_tag,\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/engine__logger_8hpp/#function-console_log_fatal","title":"function console_log_fatal","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_fatal (\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/engine__logger_8hpp/#function-console_log_fatal_tagged","title":"function console_log_fatal_tagged","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_fatal_tagged (\n    const std::string &amp; p_tag,\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/engine__logger_8hpp/#function-console_log_info","title":"function console_log_info","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_info (\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/engine__logger_8hpp/#function-console_log_info_tagged","title":"function console_log_info_tagged","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_info_tagged (\n    const std::string &amp; p_tag,\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/engine__logger_8hpp/#function-console_log_trace","title":"function console_log_trace","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_trace (\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre> <p>Note:</p> <p>Console Loggers (These are loggers that write specifically to the console, terminal console) </p> <p>Note:</p> <p>TODO  Specify that engine3d will have it's own console terminal that these will be written to. </p>"},{"location":"References/engine__logger_8hpp/#function-console_log_trace_tagged","title":"function console_log_trace_tagged","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_trace_tagged (\n    const std::string &amp; p_tag,\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/engine__logger_8hpp/#function-console_log_warn","title":"function console_log_warn","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_warn (\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre>"},{"location":"References/engine__logger_8hpp/#function-console_log_warn_tagged","title":"function console_log_warn_tagged","text":"<pre><code>template&lt;typename... T&gt;\ninline void console_log_warn_tagged (\n    const std::string &amp; p_tag,\n    spdlog::format_string_t&lt; T... &gt; fmt,\n    T &amp;&amp;... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/engine_logger.hpp</code></p>"},{"location":"References/engine__logger_8hpp_source/","title":"File engine_logger.hpp","text":"<p>File List &gt; atlas &gt; core &gt; engine_logger.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;fmt/os.h&gt;\n#include &lt;fmt/ostream.h&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;spdlog/common.h&gt;\n#include &lt;spdlog/spdlog.h&gt;\n\nnamespace atlas {\n    class console_log_manager {\n    public:\n        static void initialize_logger_manager(\n          const std::string&amp; pattern = \"%^[%T] %n: %v%$\");\n\n        static void set_current_logger(\n          const std::string&amp; p_tag = \"Undefined g_Tag in console_logger\");\n        static void create_new_logger(\n          const std::string&amp; p_tag = \"Undefined Tag\");\n        static ref&lt;spdlog::logger&gt; get(const std::string&amp; p_tag);\n\n    private:\n        static std::unordered_map&lt;std::string, ref&lt;spdlog::logger&gt;&gt; s_loggers;\n    };\n};\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_trace(spdlog::format_string_t&lt;T...&gt; fmt, T&amp;&amp;... args) {\n    atlas::console_log_manager::get(\"engine3d\")\n      -&gt;trace(fmt, std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_warn(spdlog::format_string_t&lt;T...&gt; fmt, T&amp;&amp;... args) {\n    atlas::console_log_manager::get(\"engine3d\")\n      -&gt;warn(fmt, std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_info(spdlog::format_string_t&lt;T...&gt; fmt, T&amp;&amp;... args) {\n    atlas::console_log_manager::get(\"engine3d\")\n      -&gt;info(fmt, std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_error(spdlog::format_string_t&lt;T...&gt; fmt, T&amp;&amp;... args) {\n    atlas::console_log_manager::get(\"engine3d\")\n      -&gt;error(fmt, std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_fatal(spdlog::format_string_t&lt;T...&gt; fmt, T&amp;&amp;... args) {\n    atlas::console_log_manager::get(\"engine3d\")\n      -&gt;critical(fmt, std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_trace_tagged(const std::string&amp; p_tag,\n                         spdlog::format_string_t&lt;T...&gt; fmt,\n                         T&amp;&amp;... args) {\n    atlas::console_log_manager::get(p_tag)-&gt;trace(fmt,\n                                                  std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_info_tagged(const std::string&amp; p_tag,\n                        spdlog::format_string_t&lt;T...&gt; fmt,\n                        T&amp;&amp;... args) {\n    atlas::console_log_manager::get(p_tag)-&gt;info(fmt, std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_warn_tagged(const std::string&amp; p_tag,\n                        spdlog::format_string_t&lt;T...&gt; fmt,\n                        T&amp;&amp;... args) {\n    atlas::console_log_manager::get(p_tag)-&gt;warn(fmt, std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_error_tagged(const std::string&amp; p_tag,\n                         spdlog::format_string_t&lt;T...&gt; fmt,\n                         T&amp;&amp;... args) {\n    atlas::console_log_manager::get(p_tag)-&gt;error(fmt,\n                                                  std::forward&lt;T&gt;(args)...);\n}\n\ntemplate&lt;typename... T&gt;\ninline void\nconsole_log_fatal_tagged(const std::string&amp; p_tag,\n                         spdlog::format_string_t&lt;T...&gt; fmt,\n                         T&amp;&amp;... args) {\n    atlas::console_log_manager::get(p_tag)-&gt;critical(fmt,\n                                                     std::forward&lt;T&gt;(args)...);\n}\n</code></pre>"},{"location":"References/timer_8hpp/","title":"File timer.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; timer.hpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/timer.hpp</code></p>"},{"location":"References/timer_8hpp_source/","title":"File timer.hpp","text":"<p>File List &gt; atlas &gt; core &gt; timer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\nDelete this file\n- Only exists to prevent merge conflicts in CMakeLists.txt\n*/\n</code></pre>"},{"location":"References/window_8hpp/","title":"File window.hpp","text":"<p>FileList &gt; atlas &gt; core &gt; window.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;drivers/swapchain.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/window_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/window_8hpp/#classes","title":"Classes","text":"Type Name class window <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/core/window.hpp</code></p>"},{"location":"References/window_8hpp_source/","title":"File window.hpp","text":"<p>File List &gt; atlas &gt; core &gt; window.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;GLFW/glfw3.h&gt;\n#include &lt;core/core.hpp&gt;\n#include &lt;drivers/swapchain.hpp&gt;\n#include &lt;string&gt;\n\nnamespace atlas {\n\n    class window {\n    public:\n        virtual ~window() = default;\n        static ref&lt;window&gt; create(\n          uint32_t p_width,\n          uint32_t p_height,\n          const std::string&amp; p_tag = \"Undefined Window Title\");\n\n        [[nodiscard]] GLFWwindow* get_native_window() const;\n\n        [[nodiscard]] uint32_t get_width() const;\n        [[nodiscard]] uint32_t get_height() const;\n\n        [[nodiscard]] bool is_active() const;\n\n        [[nodiscard]] float get_aspect_ratio() const;\n\n        ref&lt;swapchain&gt; get_current_swapchain();\n\n        operator GLFWwindow*() { return get_native_window(); }\n\n        void close();\n\n    private:\n        [[nodiscard]] virtual uint32_t read_width() const = 0;\n        [[nodiscard]] virtual uint32_t read_height() const = 0;\n        [[nodiscard]] virtual GLFWwindow* native_window() const = 0;\n        virtual ref&lt;swapchain&gt; current_swapchain() = 0;\n    };\n};\n</code></pre>"},{"location":"References/dir_1605561db8076fbb4262fa758aa3edc0/","title":"Dir TheAtlasEngine/atlas/drivers","text":"<p>FileList &gt; atlas &gt; drivers</p>"},{"location":"References/dir_1605561db8076fbb4262fa758aa3edc0/#files","title":"Files","text":"Type Name file descriptor_sets.hpp file frame_buffer.hpp file image.hpp file index_buffer.hpp file pipeline.hpp file render_pass.hpp file renderer_backend.hpp file shader.hpp file swapchain.hpp file uniform.hpp file uniform_buffer.hpp file vertex_buffer.hpp"},{"location":"References/dir_1605561db8076fbb4262fa758aa3edc0/#directories","title":"Directories","text":"Type Name dir ui dir vulkan <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/</code></p>"},{"location":"References/dir_ff140d359ab74e0fd6356ef2a8a2700b/","title":"Dir TheAtlasEngine/atlas/drivers/ui","text":"<p>FileList &gt; atlas &gt; drivers &gt; ui</p>"},{"location":"References/dir_ff140d359ab74e0fd6356ef2a8a2700b/#files","title":"Files","text":"Type Name file imgui_backend.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/ui/</code></p>"},{"location":"References/imgui__backend_8hpp/","title":"File imgui_backend.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; ui &gt; imgui_backend.hpp</p> <p>Go to the source code of this file</p>"},{"location":"References/imgui__backend_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/imgui__backend_8hpp/#classes","title":"Classes","text":"Type Name class imgui_backend <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/ui/imgui_backend.hpp</code></p>"},{"location":"References/imgui__backend_8hpp_source/","title":"File imgui_backend.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; ui &gt; imgui_backend.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace atlas {\n    class imgui_backend {\n    public:\n        static void initialize();\n\n        static void begin();\n        static void end();\n    };\n};\n</code></pre>"},{"location":"References/dir_d1501d70e56e021a40f9d93dd0e2ca19/","title":"Dir TheAtlasEngine/atlas/drivers/vulkan","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan</p>"},{"location":"References/dir_d1501d70e56e021a40f9d93dd0e2ca19/#files","title":"Files","text":"Type Name file buffer_tutorial.hpp file descriptor_tutorial.hpp file helper_functions.hpp file types.hpp file utility.hpp file vulkan-imports.hpp file vulkan_context.hpp file vulkan_core.hpp file vulkan_descriptors.hpp file vulkan_driver.hpp file vulkan_gpu.hpp file vulkan_imgui.hpp file vulkan_index_buffer.hpp file vulkan_physical_driver.hpp file vulkan_pipeline.hpp file vulkan_renderer.hpp file vulkan_renderpass.hpp file vulkan_swapchain.hpp file vulkan_uniform_buffer.hpp file vulkan_vertex_buffer.hpp file vulkan_window.hpp"},{"location":"References/dir_d1501d70e56e021a40f9d93dd0e2ca19/#directories","title":"Directories","text":"Type Name dir shaders <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/</code></p>"},{"location":"References/dir_9b3214b9b707733a210e487fc36953eb/","title":"Dir TheAtlasEngine/atlas/drivers/vulkan/shaders","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; shaders</p>"},{"location":"References/dir_9b3214b9b707733a210e487fc36953eb/#files","title":"Files","text":"Type Name file vulkan_shader.hpp file vulkan_shader_pipeline_config.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/shaders/</code></p>"},{"location":"References/vulkan__shader_8hpp/","title":"File vulkan_shader.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; shaders &gt; vulkan_shader.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/shader.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> </ul>"},{"location":"References/vulkan__shader_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vulkan__shader_8hpp/#classes","title":"Classes","text":"Type Name class vk_shader <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/shaders/vulkan_shader.hpp</code></p>"},{"location":"References/vulkan__shader_8hpp_source/","title":"File vulkan_shader.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; shaders &gt; vulkan_shader.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;drivers/shader.hpp&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;vulkan/vulkan_core.h&gt;\n\nnamespace atlas::vk {\n    class vk_shader : public shader {\n    public:\n        vk_shader() = default;\n        vk_shader(const std::string&amp; p_vertex,\n                  const std::string&amp; p_fragment,\n                  const shader_pipeline_config&amp; p_config = {});\n        virtual ~vk_shader() {}\n\n        static shader_pipeline_config shader_configuration(uint32_t p_width,\n                                                           uint32_t p_height);\n\n        VkPipeline get_graphics_pipeline() { return m_graphics_pipeline; }\n\n    private:\n        VkPipeline graphics_pipeline() override { return m_graphics_pipeline; }\n\n    private:\n        std::vector&lt;VkVertexInputBindingDescription&gt;\n        get_vertex_input_bind_description();\n        std::vector&lt;VkVertexInputAttributeDescription&gt;\n        get_vertex_attribute_description();\n\n        std::vector&lt;char&gt; read_file(const std::string&amp; p_filepath);\n\n        void initialize_graphics_pipeline(\n          const std::string&amp; p_vertex,\n          const std::string&amp; p_fragment,\n          const shader_pipeline_config&amp; p_config);\n        void initialize_shader_module(const std::vector&lt;char&gt;&amp; p_binary,\n                                      VkShaderModule&amp; p_shader_module);\n\n    private:\n        VkPipeline m_graphics_pipeline;\n        VkShaderModule m_vertex_shader_module;\n        VkShaderModule m_fragment_shader_module;\n    };\n};\n</code></pre>"},{"location":"References/vulkan__shader__pipeline__config_8hpp/","title":"File vulkan_shader_pipeline_config.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; shaders &gt; vulkan_shader_pipeline_config.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> </ul>"},{"location":"References/vulkan__shader__pipeline__config_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vulkan__shader__pipeline__config_8hpp/#classes","title":"Classes","text":"Type Name struct shader_pipeline_config <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/shaders/vulkan_shader_pipeline_config.hpp</code></p>"},{"location":"References/vulkan__shader__pipeline__config_8hpp_source/","title":"File vulkan_shader_pipeline_config.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; shaders &gt; vulkan_shader_pipeline_config.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;vulkan/vulkan.h&gt;\n\nnamespace atlas::vk {\n    struct shader_pipeline_config {\n        VkViewport Viewport;\n        VkRect2D Scissor;\n        // VkPipelineViewportStateCreateInfo PipelineViewportCreateInfo;\n        VkPipelineInputAssemblyStateCreateInfo PipelineInputAsmInfo;\n        VkPipelineRasterizationStateCreateInfo PipelineRasterizationCreateInfo;\n        VkPipelineMultisampleStateCreateInfo PipelineMultisampleCreateInfo;\n        VkPipelineColorBlendAttachmentState PipelineColorBlendAttachments;\n        VkPipelineColorBlendStateCreateInfo PipelineColorBlendCreateInfo;\n        VkPipelineDepthStencilStateCreateInfo PipelineDepthStencilCreateInfo;\n        VkPipelineLayout PipelineLayout;\n        VkRenderPass PipelineRenderPass;\n        uint32_t SubpassCount;\n    };\n};\n</code></pre>"},{"location":"References/buffer__tutorial_8hpp/","title":"File buffer_tutorial.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; buffer_tutorial.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> </ul>"},{"location":"References/buffer__tutorial_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/buffer__tutorial_8hpp/#classes","title":"Classes","text":"Type Name class BufferTutorial <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/buffer_tutorial.hpp</code></p>"},{"location":"References/buffer__tutorial_8hpp_source/","title":"File buffer_tutorial.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; buffer_tutorial.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;vulkan/vulkan_core.h&gt;\nnamespace atlas::vk {\n    class BufferTutorial {\n    public:\n        BufferTutorial() = default;\n        BufferTutorial(uint64_t p_size,\n                       uint32_t p_count,\n                       VkBufferUsageFlags p_usage,\n                       VkMemoryPropertyFlags p_memory_property_flags,\n                       uint64_t p_min_offset_alignment = 1);\n\n        void map(VkDeviceSize p_Size = VK_WHOLE_SIZE, uint64_t p_Offset = 0);\n        void unmap();\n\n        void write_to_buffer(void* data,\n                             uint64_t p_Size = VK_WHOLE_SIZE,\n                             uint64_t p_Offset = 0);\n        void flush(uint64_t p_Size = VK_WHOLE_SIZE, uint64_t offset = 0);\n        VkDescriptorBufferInfo descriptor_info(uint64_t p_Size = VK_WHOLE_SIZE,\n                                               uint64_t p_Offset = 0);\n        void invalidate(uint64_t p_Size = VK_WHOLE_SIZE, uint64_t p_Offset = 0);\n\n        void write_to_index(void* data, int idx);\n\n        void flush_index(int index);\n        VkDescriptorBufferInfo descriptor_info_at_index(int index);\n        void invalidate_index(int index);\n\n        VkBuffer get_buffer_instance() { return m_buffer_handler; }\n\n        void* read_mapped_data() const { return m_mapped; }\n        uint32_t get_instance_count() const { return m_count; }\n\n        uint64_t get_instance_size() const { return m_instances_size; }\n        uint64_t get_alignment_size() const { return m_alignment_size; }\n\n        VkBufferUsageFlags get_usage_flags() const { return m_usage; }\n\n    private:\n        VkBuffer m_buffer_handler = nullptr;\n        VkDeviceMemory m_buffer_device_memory = nullptr;\n        void* m_mapped = nullptr;\n        uint64_t m_size;\n        uint32_t m_count;\n        uint64_t m_instances_size;\n        uint64_t m_alignment_size;\n        VkBufferUsageFlags m_usage;\n        VkMemoryPropertyFlags m_memory_property_flags;\n    };\n};\n</code></pre>"},{"location":"References/descriptor__tutorial_8hpp/","title":"File descriptor_tutorial.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; descriptor_tutorial.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"core.hpp\"</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> </ul>"},{"location":"References/descriptor__tutorial_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/descriptor__tutorial_8hpp/#classes","title":"Classes","text":"Type Name class descriptor_pool class builder class descriptor_set_layout class builder class descriptor_writer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/descriptor_tutorial.hpp</code></p>"},{"location":"References/descriptor__tutorial_8hpp_source/","title":"File descriptor_tutorial.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; descriptor_tutorial.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"core.hpp\"\n#include &lt;unordered_map&gt;\n#include &lt;vulkan/vulkan.h&gt;\n#include &lt;vulkan/vulkan_core.h&gt;\n\nnamespace atlas::vk {\n    class descriptor_set_layout {\n    public:\n        class builder {\n        public:\n            builder() = default;\n\n            builder&amp; addBinding(uint32_t binding,\n                                VkDescriptorType descriptorType,\n                                VkShaderStageFlags stageFlags,\n                                uint32_t count = 1);\n            std::unique_ptr&lt;descriptor_set_layout&gt; build() const;\n\n        private:\n            std::unordered_map&lt;uint32_t, VkDescriptorSetLayoutBinding&gt;\n              bindings{};\n        };\n\n        descriptor_set_layout(\n          std::unordered_map&lt;uint32_t, VkDescriptorSetLayoutBinding&gt; bindings);\n        ~descriptor_set_layout();\n        descriptor_set_layout(const descriptor_set_layout&amp;) = delete;\n        descriptor_set_layout&amp; operator=(const descriptor_set_layout&amp;) = delete;\n\n        VkDescriptorSetLayout get_descriptor_set_layout() const {\n            return m_descriptor_set_layout;\n        }\n\n        VkDescriptorSetLayoutBinding&amp; Get(uint32_t bind) {\n            return bindings.at(bind);\n        }\n\n    private:\n        VkDescriptorSetLayout m_descriptor_set_layout;\n        std::unordered_map&lt;uint32_t, VkDescriptorSetLayoutBinding&gt; bindings;\n    };\n\n    class descriptor_pool {\n    public:\n        class builder {\n        public:\n            builder() = default;\n\n            builder&amp; addPoolSize(VkDescriptorType descriptorType,\n                                 uint32_t count);\n            builder&amp; setPoolFlags(VkDescriptorPoolCreateFlags flags);\n            builder&amp; setMaxSets(uint32_t count);\n            std::unique_ptr&lt;descriptor_pool&gt; build() const;\n\n        private:\n            std::vector&lt;VkDescriptorPoolSize&gt; poolSizes{};\n            uint32_t maxSets = 1000;\n            VkDescriptorPoolCreateFlags poolFlags = 0;\n        };\n\n        descriptor_pool(uint32_t maxSets,\n                        VkDescriptorPoolCreateFlags poolFlags,\n                        const std::vector&lt;VkDescriptorPoolSize&gt;&amp; poolSizes);\n        ~descriptor_pool();\n        descriptor_pool(const descriptor_pool&amp;) = delete;\n        descriptor_pool&amp; operator=(const descriptor_pool&amp;) = delete;\n\n        bool allocateDescriptor(\n          const VkDescriptorSetLayout descriptor_set_layout,\n          VkDescriptorSet&amp; descriptor) const;\n\n        void freeDescriptors(std::vector&lt;VkDescriptorSet&gt;&amp; descriptors) const;\n\n        void resetPool();\n\n    private:\n        VkDescriptorPool m_descriptor_pool;\n    };\n\n    class descriptor_writer {\n    public:\n        descriptor_writer(descriptor_set_layout&amp; setLayout,\n                          descriptor_pool&amp; pool);\n\n        descriptor_writer&amp; writeBuffer(uint32_t binding,\n                                       VkDescriptorBufferInfo* bufferInfo);\n        descriptor_writer&amp; writeImage(uint32_t binding,\n                                      VkDescriptorImageInfo* imageInfo);\n\n        bool build(VkDescriptorSet&amp; set);\n        void overwrite(VkDescriptorSet&amp; set);\n\n    private:\n        descriptor_set_layout&amp; setLayout;\n        descriptor_pool&amp; pool;\n        std::vector&lt;VkWriteDescriptorSet&gt; writes;\n    };\n};\n</code></pre>"},{"location":"References/drivers_2vulkan_2helper__functions_8hpp/","title":"File helper_functions.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; helper_functions.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> </ul>"},{"location":"References/drivers_2vulkan_2helper__functions_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/helper_functions.hpp</code></p>"},{"location":"References/drivers_2vulkan_2helper__functions_8hpp_source/","title":"File helper_functions.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; helper_functions.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n#include &lt;vulkan/vulkan_core.h&gt;\n\nnamespace atlas::vk {\n    // const char* vk_to_string(VkResult res);\n    void vk_check(VkResult p_result,\n                  const char* p_tag,\n                  const char* p_filepath,\n                  uint32_t p_line,\n                  const char* p_function_name);\n\n    void vk_check_format(VkFormat p_format,\n                         const char* p_filepath,\n                         uint32_t p_line,\n                         const char* p_function_name);\n\n    std::string vk_queue_flags_to_string(VkQueueFlagBits p_flags);\n};\n</code></pre>"},{"location":"References/drivers_2vulkan_2types_8hpp/","title":"File types.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; types.hpp</p> <p>Go to the source code of this file</p>"},{"location":"References/drivers_2vulkan_2types_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/types.hpp</code></p>"},{"location":"References/drivers_2vulkan_2types_8hpp_source/","title":"File types.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; types.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace atlas::vk {\n    enum class ImageLayout {};\n};\n</code></pre>"},{"location":"References/utility_8hpp/","title":"File utility.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; utility.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> </ul>"},{"location":"References/utility_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/utility.hpp</code></p>"},{"location":"References/utility_8hpp_source/","title":"File utility.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; utility.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;vulkan/vulkan_core.h&gt;\nnamespace atlas::vk {\n\n    void BeginCommandBuffer(VkCommandBuffer* p_CommandBuffer);\n    void EndCommandBuffer(VkCommandBuffer* p_CommandBuffer);\n};\n</code></pre>"},{"location":"References/vulkan-imports_8hpp/","title":"File vulkan-imports.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan-imports.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> </ul>"},{"location":"References/vulkan-imports_8hpp/#macros","title":"Macros","text":"Type Name define GLFW_INCLUDE_VULKAN"},{"location":"References/vulkan-imports_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"References/vulkan-imports_8hpp/#define-glfw_include_vulkan","title":"define GLFW_INCLUDE_VULKAN","text":"<pre><code>#define GLFW_INCLUDE_VULKAN \n</code></pre> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan-imports.hpp</code></p>"},{"location":"References/vulkan-imports_8hpp_source/","title":"File vulkan-imports.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan-imports.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#define GLFW_INCLUDE_VULKAN\n#if _WIN32\n#define VK_USE_PLATFORM_WIN32_KHR\n#include &lt;GLFW/glfw3.h&gt;\n#define GLFW_EXPOSE_NATIVE_WIN32\n#include &lt;GLFW/glfw3native.h&gt;\n#include &lt;vulkan/vulkan.h&gt;\n#else\n#include &lt;GLFW/glfw3.h&gt;\n#include &lt;vulkan/vulkan.h&gt;\n#endif\n</code></pre>"},{"location":"References/vulkan__context_8hpp/","title":"File vulkan_context.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_context.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/vulkan/vulkan_driver.hpp&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.hpp&gt;</code></li> </ul>"},{"location":"References/vulkan__context_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vulkan__context_8hpp/#classes","title":"Classes","text":"Type Name class vk_context <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_context.hpp</code></p>"},{"location":"References/vulkan__context_8hpp_source/","title":"File vulkan_context.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_context.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;drivers/vulkan/vulkan_driver.hpp&gt;\n#include &lt;vulkan/vulkan.hpp&gt;\n\nnamespace atlas::vk {\n    class vk_context {\n    public:\n        static void initialize();\n        static VkInstance get_vk_instance() { return s_instance; }\n\n        static vk_physical_driver&amp; get_current_selected_physical_driver() {\n            return s_physical_driver;\n        }\n\n        static vk_driver&amp; get_current_driver() { return s_driver; }\n\n    private:\n        static std::vector&lt;const char*&gt; initialization_validation_layers();\n\n        static std::vector&lt;const char*&gt; initialize_instance_extensions();\n\n    private:\n        static VkInstance s_instance;\n        static vk_physical_driver s_physical_driver;\n        static vk_driver s_driver;\n    };\n};\n</code></pre>"},{"location":"References/vulkan__core_8hpp/","title":"File vulkan_core.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_core.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> </ul>"},{"location":"References/vulkan__core_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_core.hpp</code></p>"},{"location":"References/vulkan__core_8hpp_source/","title":"File vulkan_core.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_core.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;span&gt;\n#include &lt;type_traits&gt;\n#include &lt;vulkan/vulkan.h&gt;\n#include &lt;vulkan/vulkan_core.h&gt;\n\nnamespace atlas::vk {\n\n    template&lt;typename Type&gt;\n    concept ReturnInvoke = std::is_same_v&lt;std::span&lt;VkCommandBuffer&gt;, Type&gt;;\n\n    VkCommandBuffer create_command_buffer_and_record(\n      const VkDevice&amp; p_driver,\n      const VkCommandPool&amp; p_command_buffer);\n\n    void begin_command_buffer(const VkCommandBuffer&amp; p_command_buffer);\n\n    void end_command_buffer(const VkCommandBuffer&amp; p_command_buffer);\n\n    void submit(VkQueue p_queue_to_use,\n                const std::span&lt;VkCommandBuffer&gt;&amp; p_command_buffers);\n\n    VkImage create_image(VkFormat p_format,\n                         uint32_t p_width,\n                         uint32_t p_height);\n    VkImageView create_image_view(VkImage p_image, VkFormat p_format);\n\n    VkCommandBuffer begin_single_time_command_buffer(\n      const VkCommandPool&amp; p_command_pool);\n    void end_single_time_command_buffer(const VkCommandBuffer&amp; p_command_buffer,\n                                        const VkCommandPool&amp; p_command_pool);\n\n    VkCommandPool create_command_pool();\n\n    void pipeline_image_barrier(VkCommandBuffer p_command_buffer,\n                                VkImage Image,\n                                VkAccessFlags srcAccessmask,\n                                VkAccessFlags dstAccessMask,\n                                VkImageLayout OldImageLayout,\n                                VkImageLayout NewImageLayout,\n                                VkPipelineStageFlags srcStageFlags,\n                                VkPipelineStageFlags dstStageFlags,\n                                VkImageSubresourceRange subresourceRange);\n};\n</code></pre>"},{"location":"References/vulkan__descriptors_8hpp/","title":"File vulkan_descriptors.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_descriptors.hpp</p> <p>Go to the source code of this file</p>"},{"location":"References/vulkan__descriptors_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vulkan__descriptors_8hpp/#classes","title":"Classes","text":"Type Name class VulkanDescriptorSets <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_descriptors.hpp</code></p>"},{"location":"References/vulkan__descriptors_8hpp_source/","title":"File vulkan_descriptors.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_descriptors.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace atlas::vk {\n\n    class VulkanDescriptorSets {\n    public:\n    };\n};\n</code></pre>"},{"location":"References/vulkan__driver_8hpp/","title":"File vulkan_driver.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_driver.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/vulkan/vulkan_physical_driver.hpp&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.hpp&gt;</code></li> </ul>"},{"location":"References/vulkan__driver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vulkan__driver_8hpp/#classes","title":"Classes","text":"Type Name class vk_driver <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_driver.hpp</code></p>"},{"location":"References/vulkan__driver_8hpp_source/","title":"File vulkan_driver.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_driver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;drivers/vulkan/vulkan_physical_driver.hpp&gt;\n#include &lt;vulkan/vulkan.hpp&gt;\n\nnamespace atlas::vk {\n    class vk_driver {\n    public:\n        vk_driver() = default;\n        vk_driver(const vk_physical_driver&amp; p_physical);\n\n        VkQueue get_graphics_queue() const { return m_graphics_queue; }\n\n        operator VkDevice() { return m_driver; }\n\n        uint32_t select_memory_type(uint32_t p_type_filter,\n                                    VkMemoryPropertyFlags p_property_flag);\n\n    private:\n        VkDevice m_driver;\n        VkQueue m_graphics_queue;\n    };\n};\n</code></pre>"},{"location":"References/vulkan__gpu_8hpp/","title":"File vulkan_gpu.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_gpu.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;functional&gt;</code></li> </ul>"},{"location":"References/vulkan__gpu_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_gpu.hpp</code></p>"},{"location":"References/vulkan__gpu_8hpp_source/","title":"File vulkan_gpu.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_gpu.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;functional&gt;\n\nnamespace atlas::vk {\n    void Submit(const std::function&lt;void()&gt;&amp; Function);\n\n    void SubmitResourceFree(const std::function&lt;void()&gt;&amp; Function);\n\n};\n</code></pre>"},{"location":"References/vulkan__imgui_8hpp/","title":"File vulkan_imgui.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_imgui.hpp</p> <p>Go to the source code of this file</p>"},{"location":"References/vulkan__imgui_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/vulkan__imgui_8hpp/#classes","title":"Classes","text":"Type Name class VulkanImGui <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_imgui.hpp</code></p>"},{"location":"References/vulkan__imgui_8hpp_source/","title":"File vulkan_imgui.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_imgui.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace atlas {\n    class VulkanImGui {\n    public:\n    private:\n    };\n};\n</code></pre>"},{"location":"References/vulkan__index__buffer_8hpp/","title":"File vulkan_index_buffer.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_index_buffer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/index_buffer.hpp&gt;</code></li> </ul>"},{"location":"References/vulkan__index__buffer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vulkan__index__buffer_8hpp/#classes","title":"Classes","text":"Type Name class vk_index_buffer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_index_buffer.hpp</code></p>"},{"location":"References/vulkan__index__buffer_8hpp_source/","title":"File vulkan_index_buffer.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_index_buffer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;drivers/index_buffer.hpp&gt;\n\nnamespace atlas::vk {\n    class vk_index_buffer : public index_buffer {\n    public:\n        vk_index_buffer(const std::vector&lt;uint32_t&gt;&amp; p_indices);\n        ~vk_index_buffer() override = default;\n\n    private:\n        void bind_to_index_buffer(\n          const VkCommandBuffer&amp; p_command_buffer) override;\n        void render_index_buffer(\n          const VkCommandBuffer&amp; p_command_buffer) override;\n        [[nodiscard]] bool contains_indices() const override;\n\n    private:\n        VkBuffer m_index_buffer_handler;\n        VkDeviceMemory m_index_device_buffer_memory;\n        uint32_t m_indices_count;\n        bool m_has_indices = false;\n    };\n};\n</code></pre>"},{"location":"References/vulkan__physical__driver_8hpp/","title":"File vulkan_physical_driver.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_physical_driver.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.hpp&gt;</code></li> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> </ul>"},{"location":"References/vulkan__physical__driver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vulkan__physical__driver_8hpp/#classes","title":"Classes","text":"Type Name class vk_physical_driver struct queue_family_indices <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_physical_driver.hpp</code></p>"},{"location":"References/vulkan__physical__driver_8hpp_source/","title":"File vulkan_physical_driver.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_physical_driver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n#include &lt;vulkan/vulkan.hpp&gt;\n#include &lt;vulkan/vulkan_core.h&gt;\n\nnamespace atlas::vk {\n    class vk_physical_driver {\n    public:\n        struct queue_family_indices {\n            uint32_t Graphics = -1;\n            uint32_t Compute = -1;\n            uint32_t Transfer = -1;\n        };\n\n        vk_physical_driver() = default;\n        vk_physical_driver(const VkInstance&amp; p_instance);\n\n        uint32_t get_presentation_index(VkSurfaceKHR p_surface) const;\n\n        uint32_t search_memory_type(uint32_t p_type_filter,\n                                    VkMemoryPropertyFlags p_properties);\n\n        queue_family_indices get_queue_indices() const {\n            return m_queue_family_indices;\n        }\n\n        VkPhysicalDeviceProperties get_properties() const {\n            return m_physical_properties;\n        }\n\n        operator VkPhysicalDevice() { return m_physical; }\n\n        operator VkPhysicalDevice() const { return m_physical; }\n\n    private:\n        queue_family_indices select_queue_family_indices();\n\n    private:\n        VkPhysicalDevice m_physical;\n        VkPhysicalDeviceProperties m_physical_properties;\n        std::vector&lt;VkQueueFamilyProperties&gt; m_queue_family_properties;\n\n        // checking if queue families have queues and they are graphical,\n        // compute (optional atm), transfer(optional atm)\n        queue_family_indices m_queue_family_indices;\n    };\n};\n</code></pre>"},{"location":"References/vulkan__pipeline_8hpp/","title":"File vulkan_pipeline.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_pipeline.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/vulkan__pipeline_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vulkan__pipeline_8hpp/#classes","title":"Classes","text":"Type Name class VulkanPipeline <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_pipeline.hpp</code></p>"},{"location":"References/vulkan__pipeline_8hpp_source/","title":"File vulkan_pipeline.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_pipeline.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n\nnamespace atlas::vk {\n    class VulkanPipeline {\n    public:\n        VulkanPipeline() = default;\n        VulkanPipeline(const std::string&amp; p_tag);\n\n    private:\n    };\n};\n</code></pre>"},{"location":"References/vulkan__renderer_8hpp/","title":"File vulkan_renderer.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_renderer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/renderer_backend.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> </ul>"},{"location":"References/vulkan__renderer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vulkan__renderer_8hpp/#classes","title":"Classes","text":"Type Name class vk_renderer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_renderer.hpp</code></p>"},{"location":"References/vulkan__renderer_8hpp_source/","title":"File vulkan_renderer.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_renderer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;drivers/renderer_backend.hpp&gt;\n#include &lt;string&gt;\n#include &lt;vulkan/vulkan_core.h&gt;\n\n// #include &lt;drivers/vulkan/buffer_tutorial.hpp&gt;\n// #include &lt;drivers/vulkan/descriptor_tutorial.hpp&gt;\n\nnamespace atlas::vk {\n    class vk_renderer : public render_context {\n    public:\n        vk_renderer(const std::string&amp; tag);\n        ~vk_renderer() override;\n\n        static VkCommandBuffer get_current_command_buffer();\n        // static VkCommandBuffer current_command_buffer();\n        static VkFramebuffer current_frame_buffer();\n        static uint32_t get_current_command_buffer_index();\n\n    private:\n        void begin_frame() override;\n        void end_frame() override;\n\n    private:\n        void initialize_pipeline();\n\n    private:\n        VkCommandPool m_command_pool;\n        // std::atomic&lt;uint32_t&gt; g_current_frame_index = -1;\n        bool m_is_frame_started = false;\n        VkPipelineLayout m_pipeline_layout;\n        std::vector&lt;ref&lt;scene_object&gt;&gt; m_scene_object_queue;\n\n        std::deque&lt;std::function&lt;void()&gt;&gt; m_main_deletion_queue;\n        VkDevice m_driver = nullptr;\n\n        // ref&lt;descriptor_pool&gt; m_global_pool;\n        // std::vector&lt;BufferTutorial&gt; m_global_ubo_list;\n        // scope&lt;descriptor_set_layout&gt; m_global_set_layout;\n        // std::vector&lt;VkDescriptorSet&gt; m_global_descriptor_set;\n\n        camera m_current_camera_component;\n    };\n};\n</code></pre>"},{"location":"References/vulkan__renderpass_8hpp/","title":"File vulkan_renderpass.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_renderpass.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/render_pass.hpp&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.hpp&gt;</code></li> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> </ul>"},{"location":"References/vulkan__renderpass_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vulkan__renderpass_8hpp/#classes","title":"Classes","text":"Type Name class VulkanRenderPass <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_renderpass.hpp</code></p>"},{"location":"References/vulkan__renderpass_8hpp_source/","title":"File vulkan_renderpass.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_renderpass.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;drivers/render_pass.hpp&gt;\n#include &lt;vulkan/vulkan.hpp&gt;\n#include &lt;vulkan/vulkan_core.h&gt;\n\nnamespace atlas::vk {\n    class VulkanRenderPass : public renderpass {\n    public:\n        VulkanRenderPass(const renderpass_properties&amp; p_Properties);\n\n    protected:\n        void BeginRenderPass() override;\n        void EndRenderPass() override;\n\n    private:\n        VkRenderPass m_RenderPassHandler;\n    };\n};\n</code></pre>"},{"location":"References/vulkan__swapchain_8hpp/","title":"File vulkan_swapchain.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_swapchain.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/swapchain.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan/vulkan_driver.hpp&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.hpp&gt;</code></li> </ul>"},{"location":"References/vulkan__swapchain_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vulkan__swapchain_8hpp/#classes","title":"Classes","text":"Type Name class vk_swapchain <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_swapchain.hpp</code></p>"},{"location":"References/vulkan__swapchain_8hpp_source/","title":"File vulkan_swapchain.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_swapchain.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;drivers/swapchain.hpp&gt;\n#include &lt;drivers/vulkan/vulkan_driver.hpp&gt;\n#include &lt;vulkan/vulkan.hpp&gt;\n\nnamespace atlas::vk {\n    class vk_swapchain : public swapchain {\n    public:\n        ~vk_swapchain() override = default;\n        static constexpr uint32_t max_frames_in_flight = 2;\n\n        vk_swapchain() = default;\n        vk_swapchain(const vk_physical_driver&amp; p_physical,\n                     const vk_driver&amp; p_driver,\n                     const VkSurfaceKHR&amp; p_surface);\n\n        static void resize_reset();\n        static bool is_resized();\n\n    private:\n        void on_create(uint32_t p_width, const uint32_t p_height);\n\n    private:\n        void resize_status(bool p_is_resized_signaled) override;\n\n        bool swapchain_resized() override;\n        void recreate_swapchain(uint32_t p_width, uint32_t p_height) override;\n        VkSwapchainKHR vk_swapchain_handler() override;\n        VkRenderPass read_swapchain_renderpass() override;\n        VkFormat&amp; read_swapchain_format() override;\n\n        [[nodiscard]] uint32_t images_size() const override;\n        VkFramebuffer read_framebuffer(uint32_t idx) override;\n        VkImageView read_image_view(uint32_t index) override;\n        VkExtent2D read_swapchain_extent() override;\n        void submit_and_write_command_buffer(\n          VkCommandBuffer* p_command_buffers) override;\n        uint32_t read_acquire_next_frame() override;\n        uint32_t current_frame_per_tick() override;\n\n    private:\n        VkPresentModeKHR select_compatible_present_mode(\n          const VkPresentModeKHR&amp; p_request_mode,\n          const std::vector&lt;VkPresentModeKHR&gt;&amp; p_modes);\n        VkExtent2D select_valid_extent(\n          const VkSurfaceCapabilitiesKHR&amp; p_surface_capabilities);\n\n        uint32_t select_memory_type(\n          VkPhysicalDeviceMemoryProperties p_memory_properties,\n          uint32_t p_type_filter,\n          VkMemoryPropertyFlags p_property_flag);\n\n        VkFormat select_depth_format(const VkPhysicalDevice&amp; p_physical);\n\n        VkFormat select_supported_format(VkPhysicalDevice p_physical,\n                                         const std::vector&lt;VkFormat&gt;&amp; p_formats,\n                                         VkImageTiling p_tiling,\n                                         VkFormatFeatureFlags p_feature_flags);\n\n    private:\n        uint32_t m_width = -1;\n        uint32_t m_height = -1;\n        bool m_is_resized_requested = false;\n        VkQueue m_presentation_queue = nullptr;\n        VkSurfaceKHR m_current_surface = nullptr;\n\n        struct swapchain_image {\n            VkImage Image;\n            VkImageView ImageView;\n        };\n\n        struct swapchain_depth_image {\n            VkImage Image;\n            VkImageView ImageView;\n            VkDeviceMemory DeviceMemory;\n        };\n\n        std::vector&lt;swapchain_image&gt; m_swapchain_images;\n        std::vector&lt;swapchain_depth_image&gt; m_swapchain_depth_images;\n        std::vector&lt;VkFramebuffer&gt; m_swapchain_framebuffers;\n\n        VkSwapchainKHR m_swapchain = nullptr;\n        VkSurfaceFormatKHR m_surface_format;\n        VkPresentModeKHR m_presentation_mode;\n        uint32_t m_presentation_index = -1;\n        VkExtent2D m_swapchain_extent;\n\n        // VkCommandBuffer m_CommandBufferForSwapchain;\n        std::vector&lt;VkCommandBuffer&gt;\n          m_swapchain_command_buffers; // command buffers per swapchain\n        VkCommandPool m_swapchain_command_pool;\n\n        VkRenderPass m_swapchain_renderpass;\n\n        std::vector&lt;VkSemaphore&gt;\n          m_semaphores_images_available; // semaphores for when images are\n                                         // available\n        std::vector&lt;VkSemaphore&gt;\n          m_semaphores_render_completed; // semaphores when working on the\n                                         // current frame has been completed\n\n        std::vector&lt;VkFence&gt;\n          m_swapchain_fences; // fences for when frames in flight\n        std::vector&lt;VkFence&gt;\n          m_swapchain_in_flight_fences; // images fences for when we currently\n                                        // have images currently in flight\n\n        vk_physical_driver m_physical;\n        vk_driver m_driver;\n\n        size_t m_current_frame_index = 0;\n\n        uint32_t m_current_image_index =\n          0; // contains the index of the image we are currently working through\n    };\n};\n</code></pre>"},{"location":"References/vulkan__uniform__buffer_8hpp/","title":"File vulkan_uniform_buffer.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_uniform_buffer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> </ul>"},{"location":"References/vulkan__uniform__buffer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vulkan__uniform__buffer_8hpp/#classes","title":"Classes","text":"Type Name class VulkanUniformBuffer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_uniform_buffer.hpp</code></p>"},{"location":"References/vulkan__uniform__buffer_8hpp_source/","title":"File vulkan_uniform_buffer.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_uniform_buffer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;vulkan/vulkan_core.h&gt;\n\nnamespace atlas::vk {\n\n    class VulkanUniformBuffer {\n    public:\n        VulkanUniformBuffer() = default;\n        VulkanUniformBuffer(uint32_t p_size, uint32_t p_count);\n\n        void AllocateUniforms();\n        void MapWrite(uint32_t p_size, uint32_t p_offset, const void* p_src);\n\n    private:\n        VkBuffer m_BufferObject;\n        VkDeviceMemory m_BufferMemory;\n    };\n};\n</code></pre>"},{"location":"References/vulkan__vertex__buffer_8hpp/","title":"File vulkan_vertex_buffer.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_vertex_buffer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;drivers/vertex_buffer.hpp&gt;</code></li> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> </ul>"},{"location":"References/vulkan__vertex__buffer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vulkan__vertex__buffer_8hpp/#classes","title":"Classes","text":"Type Name class vk_vertex_buffer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_vertex_buffer.hpp</code></p>"},{"location":"References/vulkan__vertex__buffer_8hpp_source/","title":"File vulkan_vertex_buffer.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_vertex_buffer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;drivers/vertex_buffer.hpp&gt;\n#include &lt;vulkan/vulkan_core.h&gt;\n\nnamespace atlas::vk {\n    class vk_vertex_buffer : public vertex_buffer {\n    public:\n        vk_vertex_buffer(const std::vector&lt;vertex&gt;&amp; p_vertices);\n        virtual ~vk_vertex_buffer() {}\n\n    protected:\n        void bind_vertex_buffer(\n          const VkCommandBuffer&amp; p_command_buffer) override;\n\n        void render_vertex_buffer(\n          const VkCommandBuffer&amp; p_command_buffer) override;\n\n    private:\n        VkBuffer m_vertex_buffer_handler;\n        VkDeviceMemory m_vertex_buffer_device_memory;\n        uint32_t m_count; // count of vertices\n    };\n};\n</code></pre>"},{"location":"References/vulkan__window_8hpp/","title":"File vulkan_window.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_window.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include &lt;core/window.hpp&gt;</code></li> <li><code>#include &lt;drivers/swapchain.hpp&gt;</code></li> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> </ul>"},{"location":"References/vulkan__window_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace vk"},{"location":"References/vulkan__window_8hpp/#classes","title":"Classes","text":"Type Name class vk_window <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vulkan/vulkan_window.hpp</code></p>"},{"location":"References/vulkan__window_8hpp_source/","title":"File vulkan_window.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vulkan &gt; vulkan_window.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;GLFW/glfw3.h&gt;\n#include &lt;core/window.hpp&gt;\n#include &lt;drivers/swapchain.hpp&gt;\n#include &lt;vulkan/vulkan_core.h&gt;\n\nnamespace atlas::vk {\n    class vk_window : public window {\n    public:\n        vk_window(uint32_t p_width,\n                  uint32_t p_height,\n                  const std::string&amp; p_tag);\n        ~vk_window() override = default;\n\n    private:\n        [[nodiscard]] uint32_t read_width() const override;\n        [[nodiscard]] uint32_t read_height() const override;\n\n    private:\n        static void on_resize();\n\n    private:\n        ref&lt;swapchain&gt; current_swapchain() override { return m_swapchain; }\n        [[nodiscard]] GLFWwindow* native_window() const override;\n\n    private:\n        GLFWwindow* m_window;\n        ref&lt;swapchain&gt; m_swapchain;\n        VkSurfaceKHR m_surface;\n    };\n};\n</code></pre>"},{"location":"References/descriptor__sets_8hpp/","title":"File descriptor_sets.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; descriptor_sets.hpp</p> <p>Go to the source code of this file</p>"},{"location":"References/descriptor__sets_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/descriptor__sets_8hpp/#classes","title":"Classes","text":"Type Name struct DescriptorSet struct DescriptorSetLayout <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/descriptor_sets.hpp</code></p>"},{"location":"References/descriptor__sets_8hpp_source/","title":"File descriptor_sets.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; descriptor_sets.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace atlas {\n    /*\n        DescriptorSetLayout\n            - Setting the layout of our descriptors\n            - Uniform binding, order of which uniform buffers are accessed\n            - What order these data are accessed\n    */\n    struct DescriptorSetLayout {\n    public:\n        DescriptorSetLayout();\n    };\n\n    class DescriptorSet {\n    public:\n    private:\n    };\n};\n</code></pre>"},{"location":"References/frame__buffer_8hpp/","title":"File frame_buffer.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; frame_buffer.hpp</p> <p>Go to the source code of this file</p>"},{"location":"References/frame__buffer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/frame__buffer_8hpp/#classes","title":"Classes","text":"Type Name class Framebuffer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/frame_buffer.hpp</code></p>"},{"location":"References/frame__buffer_8hpp_source/","title":"File frame_buffer.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; frame_buffer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace atlas {\n    /*\n\n    Framebuffer is our api-agnostic abstraction for how multiple graphics API\n    may handle framebuffers\n\n    */\n    class Framebuffer {\n    public:\n    };\n};\n</code></pre>"},{"location":"References/image_8hpp/","title":"File image.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; image.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/image_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/image_8hpp/#classes","title":"Classes","text":"Type Name class Image struct ImageSampler <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/image.hpp</code></p>"},{"location":"References/image_8hpp_source/","title":"File image.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; image.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n\n/*\n\nWhat we could do is for world and scenes\n\nIs having a hash tag that is associated to the world.\n- This can be used to allow users not have to worry about selecting which world\nthey want to register_to their scene to\n- system_registry::get_world()-&gt;register_to(this)\n- Where get_world() fetches the world_hashID where this can be stored in a\nbitset\n    - Where we can probably set the first 8-bits in an integer to the hash is\nthe ID of the world the scene is associated with\n    - While the last 8-bits tell what the actual scene's hash ID itself\n    - These hashes are something added to the scene when they get added to the\nworld\n    - When the world is constructed, the system_registry will associate a unique\nhash to that world\n*/\n\nnamespace atlas {\n    struct ImageSampler {};\n\n    class Image {\n    public:\n        Image(const std::string&amp; p_filepath);\n\n    private:\n    };\n};\n</code></pre>"},{"location":"References/index__buffer_8hpp/","title":"File index_buffer.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; index_buffer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.hpp&gt;</code></li> </ul>"},{"location":"References/index__buffer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/index__buffer_8hpp/#classes","title":"Classes","text":"Type Name class index_buffer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/index_buffer.hpp</code></p>"},{"location":"References/index__buffer_8hpp_source/","title":"File index_buffer.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; index_buffer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;vector&gt;\n#include &lt;vulkan/vulkan.hpp&gt;\n\nnamespace atlas {\n    class index_buffer {\n    public:\n        virtual ~index_buffer() = default;\n        static ref&lt;index_buffer&gt; create(const std::vector&lt;uint32_t&gt;&amp; p_indices);\n\n        void bind(const VkCommandBuffer&amp; p_command_buffer);\n        void draw(const VkCommandBuffer&amp; p_command_buffer);\n\n        bool has_indices() const;\n\n    protected:\n        virtual void bind_to_index_buffer(\n          const VkCommandBuffer&amp; p_command_buffer) = 0;\n        virtual void render_index_buffer(\n          const VkCommandBuffer&amp; p_command_buffer) = 0;\n        virtual bool contains_indices() const = 0;\n    };\n};\n</code></pre>"},{"location":"References/pipeline_8hpp/","title":"File pipeline.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; pipeline.hpp</p> <p>Go to the source code of this file</p>"},{"location":"References/pipeline_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/pipeline_8hpp/#classes","title":"Classes","text":"Type Name class Pipeline <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/pipeline.hpp</code></p>"},{"location":"References/pipeline_8hpp_source/","title":"File pipeline.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; pipeline.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace atlas {\n    class Pipeline {\n    public:\n        Pipeline() = default;\n    };\n};\n</code></pre>"},{"location":"References/render__pass_8hpp/","title":"File render_pass.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; render_pass.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;initializer_list&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"References/render__pass_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/render__pass_8hpp/#classes","title":"Classes","text":"Type Name class renderpass struct renderpass_properties <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/render_pass.hpp</code></p>"},{"location":"References/render__pass_8hpp_source/","title":"File render_pass.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; render_pass.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;initializer_list&gt;\n#include &lt;span&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace atlas {\n    /*\n    Each render pass may have a framebuffer corresponding to it\n\n    This allows us to specify specific post-processing effects\n\n\n    // Here are information the render pass needs to know that are required for\n    the driver to handle our images\n    - attachment reference\n        - Used to inform\n    - attachment description\n    - subpass description\n    - subpass dependency\n\n    // Here are parameters for the user on what they may want to only modify\n\n    - types of attachments per render pass\n    - width, height per render pass\n    - specify usable attachments per render pass (use-case post-processing)\n\n    Usage: This is how we would be passing the data to our abstraction layer for\n    specifying multiple different render passes RenderPassSpecifications\n    main_spec = { .width = 1, .height = 1, .attachments = { RED, RGBA8, RGBA16,\n            DEPTH24_STENCIL8\n        }\n    };\n\n    renderpass main_pass = renderpass(main_spec);\n\n\n    // Now lets say we wanted to apply lighting\n    // There can be a render pass for that too\n    renderpass lighting_pass = renderpass({\n        .width = 1,\n        .height = 1,\n        .attachments = {\n            RGBA8,\n            RGBA16,\n            DEPTH24_STENCIL8,\n        }\n    });\n\n    // In this context, lets say we want to apply shadow-mapping using a depth\n    property renderpass lighting_pass = renderpass({ .width = 1, .height = 1,\n        .attachments = {\n            RGBA8,\n            RGBA16,\n            DEPTH24_STENCIL8,\n        }\n    });\n    */\n\n    /*\n\n        // using depth buffer as a depth-stencil attachment\n        VkAttachmentReference (depth attachment)\n            attachment = 1\n            layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL\n\n            layout is VkImageLayout\n                - which is an enumeration thats used for specifying how image (a\n       texture) should be accessed by GPU\n                - Defining pixel data in memory and what operations are allowed\n       on it, such as reading from color attachment in the render-pass or\n       sampling it in a shader\n\n\n        VkAttachmentDescription (color_attachment) Handles the Following:\n            format = get_swapchain_format()\n            samples = VK_SAMPLE_COUNT_1_BIT\n            loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR\n            store_op = VK_ATTACHMENT_STORE_OP_STORE\n            stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE\n            stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE\n            initialLayout = VK_IMAGE_LAYOUT_UNDEFINED\n            finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR\n\n\n\n\n    */\n\n    enum class ImageFormat {\n        RED,\n        RGBA8,\n        RGBA16,\n        DEPTH24_STENCIL8,\n        DEFAULT = DEPTH24_STENCIL8\n    };\n\n    enum class ShaderAccessOperation {\n        DONT_CARE,\n        LOAD,\n        STORE,\n        DEFAULT = DONT_CARE\n    };\n\n    /*\n\n    Image Layout\n\n    COLOR_ATTACHMENT\n        - Only be used as a color or resolve attachment in\n    VkFramebuffer/Framebuffer\n\n    DEPTH_STENCIL_ATTACHMENT_READ_WRITE\n        - Layout for bothj depth/stencil aspects of a depth/stencil format image\n    allowing read/write access as depth/stencil attachment\n        - Equivalent to, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL and\n    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL.\n\n    DEPTH_STENCIL_READ\n        - Specifies layout both depth/stencil to only have read-only access or\n    shaders as sampled image, combined imagef/sampler, or input attachment\n        - Equivalent to VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL and\n    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL\n\n    TRANSFER_SRC\n        - MUST only be used as src image of transfer command (for vulkan check\n    definitions of VK_PIPELINE_STAGE_TRANSFER_BIT)\n\n    TRANSFER_DST\n        - MUST only be used as destination image of transfer command.\n        - Layout is invalid only for image subresources of images created with\n    VK_IMAGE_USAGE_TRANSFER_DST_BIT (TRANSAFER_DST_BIT)\n\n    PREINITIALIZED\n        - Specifies image's memory defined layout and can be populated by data,\n    but that it has not been initialized by driver yet\n        - Image memory cannot be transitioned into this layout.\n        - Layout can be used as `initialLayout` in vulkan's context of\n    VkImageCreateInfo\n\n    STENCIL_READ_WRITE\n        - Specifies read/write access to stencil aspect as stencil attachment\n        - Read-only depth attachment\n        - Equivalent to VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL and\n    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL\n\n    DEPTH_READ_WRITE\n        - Specifies layout for depth/stencil format images allowing read/write\n    access to depth aspect as depth attachment\n        - Read only access to stencil aspect as stencil attachment\n        - Equivalent to VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL and\n    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL\n\n    */\n    enum class ImageLayout {\n        UNDEFINED,\n        IMAGE_OPTIMAL,\n        COLOR_ATTACHMENT, // VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL\n        DEPTH_STENCIL_ATTACHMENT_READ_WRITE, // VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL\n        DEPTH_STENCIL_READ, // VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL\n        TRANSFER_SRC,       // VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL\n        TRANSFER_DST,       // VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL\n        PREINITIALIZED,     // VK_IMAGE_LAYOUT_PREINITIALIZED\n        STENCIL_READ_WRITE_DEPTH_READ_ONLY, // VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL\n        DEPTH_READ_WRITE_STENCIL_READ_ONLY, // VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL\n    };\n\n    enum class SubpassContents : int {\n        INLINE = 0,\n        SECONDARY_COMMAND_BUFFERS = 1,\n        INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR = 2,\n        INLINE_AND_COMMAND_BUFFERS_EXT = 3\n    };\n\n    enum class PipelineStageFlags {\n        COLOR_ATTACHMENT,\n    };\n\n    /*\n\n    \"Color Buffer\": {\n        .width = 10,\n        .height = 10,\n        .attachments = {\n            RGBA_U32 // equivalent to R8G8B8_UNORM\n        }\n    };\n\n    */\n    struct renderpass_properties {\n        uint32_t width;\n        uint32_t height;\n\n        std::span&lt;ImageFormat&gt; attachments;\n        std::span&lt;ShaderAccessOperation&gt; operations;\n    };\n\n    class renderpass {\n    public:\n        // renderpass();\n\n        // graphics-agnostic implementation of a render pass creation\n        static ref&lt;renderpass&gt; create(const renderpass_properties&amp; properties);\n\n        void Begin() { return BeginRenderPass(); }\n\n        void End() { return EndRenderPass(); }\n\n    private:\n        virtual void BeginRenderPass() = 0;\n        virtual void EndRenderPass() = 0;\n    };\n};\n</code></pre>"},{"location":"References/renderer__backend_8hpp/","title":"File renderer_backend.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; renderer_backend.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;core/scene/components.hpp&gt;</code></li> <li><code>#include &lt;core/scene/scene.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"References/renderer__backend_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/renderer__backend_8hpp/#classes","title":"Classes","text":"Type Name class render_context <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/renderer_backend.hpp</code></p>"},{"location":"References/renderer__backend_8hpp_source/","title":"File renderer_backend.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; renderer_backend.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;core/scene/components.hpp&gt;\n#include &lt;core/scene/scene.hpp&gt;\n#include &lt;string&gt;\n\nnamespace atlas {\n    class scene_object;\n    class render_context {\n    public:\n        static scope&lt;render_context&gt; initialize(const std::string&amp; p_tag);\n        virtual ~render_context() = default;\n\n        void begin();\n        void end();\n\n        static uint32_t get_current_frame();\n\n    private:\n        virtual void begin_frame() = 0;\n        virtual void end_frame() = 0;\n    };\n}; // namespace atlas\n</code></pre>"},{"location":"References/shader_8hpp/","title":"File shader.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; shader.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;drivers/vulkan/shaders/vulkan_shader_pipeline_config.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> </ul>"},{"location":"References/shader_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/shader_8hpp/#classes","title":"Classes","text":"Type Name class shader <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/shader.hpp</code></p>"},{"location":"References/shader_8hpp_source/","title":"File shader.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; shader.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;drivers/vulkan/shaders/vulkan_shader_pipeline_config.hpp&gt;\n#include &lt;string&gt;\n#include &lt;vulkan/vulkan.h&gt;\n\nnamespace atlas {\n    class shader {\n    public:\n        virtual ~shader() = default;\n        static ref&lt;shader&gt; create(const std::string&amp; p_vert_shader,\n                                  const std::string&amp; p_frag_shader,\n                                  const vk::shader_pipeline_config&amp; p_config);\n\n        VkPipeline get_graphics_pipeline();\n\n    private:\n        virtual VkPipeline graphics_pipeline() = 0;\n    };\n};\n</code></pre>"},{"location":"References/swapchain_8hpp/","title":"File swapchain.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; swapchain.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> </ul>"},{"location":"References/swapchain_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/swapchain_8hpp/#classes","title":"Classes","text":"Type Name class swapchain <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/swapchain.hpp</code></p>"},{"location":"References/swapchain_8hpp_source/","title":"File swapchain.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; swapchain.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;vulkan/vulkan_core.h&gt;\n\nnamespace atlas {\n    class swapchain {\n    public:\n        static bool is_rebuild();\n        static void reset_build();\n        virtual ~swapchain() = default;\n        static ref&lt;swapchain&gt; initialize(VkSurfaceKHR p_surface);\n\n        void on_resize(uint32_t p_width, uint32_t p_height);\n\n        uint32_t get_images_size() const;\n\n        VkFramebuffer get_framebuffer(uint32_t p_index);\n\n        VkImageView get_image_view(uint32_t p_index);\n\n        VkSwapchainKHR get_vk_swapchain();\n\n        VkExtent2D get_extent();\n\n        void submit_command_buffer(VkCommandBuffer* p_command_buffers);\n\n        uint32_t acquire_next_image();\n\n        uint32_t get_current_per_tick();\n\n        VkFormat&amp; get_swapchain_format();\n\n        VkRenderPass get_renderpass();\n\n        bool is_resized();\n        void set_resize_status(bool p_is_resized_signaled);\n\n    private:\n        virtual void resize_status(bool) = 0;\n        virtual bool swapchain_resized() = 0;\n        virtual void recreate_swapchain(uint32_t p_width,\n                                        uint32_t p_height) = 0;\n        virtual VkSwapchainKHR vk_swapchain_handler() = 0;\n        virtual VkRenderPass read_swapchain_renderpass() = 0;\n        virtual VkFormat&amp; read_swapchain_format() = 0;\n        virtual uint32_t images_size() const = 0;\n        virtual VkFramebuffer read_framebuffer(uint32_t idx) = 0;\n        virtual VkImageView read_image_view(uint32_t index) = 0;\n        virtual VkExtent2D read_swapchain_extent() = 0;\n        virtual void submit_and_write_command_buffer(\n          VkCommandBuffer* p_command_buffers) = 0;\n        virtual uint32_t read_acquire_next_frame() = 0;\n        virtual uint32_t current_frame_per_tick() = 0;\n    };\n};\n</code></pre>"},{"location":"References/uniform_8hpp/","title":"File uniform.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; uniform.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> </ul>"},{"location":"References/uniform_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/uniform_8hpp/#classes","title":"Classes","text":"Type Name struct DirectionalLightUbo struct PointLightUbo struct SpotLightUbo struct camera_ubo <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/uniform.hpp</code></p>"},{"location":"References/uniform_8hpp_source/","title":"File uniform.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; uniform.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;glm/glm.hpp&gt;\n\nnamespace atlas {\n\n    struct camera_ubo {\n        glm::mat4 Projection;\n        glm::mat4 View;\n    };\n\n    /*\n    Each Uniform object will have a descriptor set associated with them\n    - Per descriptor set contains the following\n        - DescriptorWrite\n        - DescriptorRead\n        - DescriptorLayout\n\n    - Per vertex (In Shader)\n        - VertexAttribute\n        - VertexAttributeLayout = {ShaderFloat3, \"aPos\"}\n    */\n    struct PointLightUbo {\n        glm::vec3 Position;\n\n        float Constant;\n        float Linear;\n        float Quadratic;\n\n        glm::vec3 ambient;\n        glm::vec3 diffuse;\n        glm::vec3 specular;\n    };\n\n    struct DirectionalLightUbo {\n        glm::vec3 Direction = { -0.2f, -1.0f, -0.3f };\n\n        glm::vec3 ambient = { 0.05f, 0.05f, 0.05f };\n        glm::vec3 diffuse = { 0.4f, 0.4f, 0.4f };\n        glm::vec3 specular = { 0.5f, 0.5f, 0.5f };\n    };\n\n    struct SpotLightUbo {\n        glm::vec3 Position;\n        glm::vec3 Direction{ 1.f, 0.f, 0.f };\n        float cut_off;\n        float outer_cut_off;\n\n        float constant{ 1.f };\n        float linear{ 0.09f };\n        float quadratic{ 0.032f };\n\n        glm::vec3 ambient{ 0.0f, 0.0f, 0.0f };\n        glm::vec3 diffuse{ 1.0f, 1.0f, 1.0f };\n        glm::vec3 specular{ 1.0f, 1.0f, 1.0f };\n    };\n};\n</code></pre>"},{"location":"References/uniform__buffer_8hpp/","title":"File uniform_buffer.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; uniform_buffer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> </ul>"},{"location":"References/uniform__buffer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/uniform__buffer_8hpp/#classes","title":"Classes","text":"Type Name struct DescriptorSet class UniformBuffer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/uniform_buffer.hpp</code></p>"},{"location":"References/uniform__buffer_8hpp_source/","title":"File uniform_buffer.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; uniform_buffer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n#include &lt;vulkan/vulkan_core.h&gt;\n\nnamespace atlas {\n\n    struct DescriptorSet {\n        VkDescriptorSetLayoutBinding Binding;\n        VkDescriptorSet Set;\n    };\n\n    /*\n        camera_ubo global_ubo = camera_ubo(...);\n\n        // Structure that you see with the uniform buffer's constructor takes\n       the following struct\n        // Descriptor set configuration to set groups for you shader bindnig by\n       update frequency struct UniformConfiguration{ uint32_t Binding = -1; //\n       specify where in the binding that we want to assign our descriptor set to\n            ShaderStage Stage = ShaderStage::NOT_DEFINED;       // specify which\n       shader stage to use this uniform buffers descriptor set bool\n       HasSamples=false;                              // Checks if we want to\n       use immutable samples\n        };\n\n\n\n        UniformBuffer ubo = UniformBuffer({\n            {.binding = 0, .shaderStage = STAGE_TYPE_GRAPHICS, .hasSamples =\n       true}\n        });\n\n\n        - These do the following for VkDescriptorSetlayoutCreateInfo\n            - Sets binding count to the binding structure we specify\n            - Set the data of that binding (setting up\n       VkDescriptorSetLayoutBinding)\n            -\n\n\n    */\n    class UniformBuffer {\n    public:\n        UniformBuffer(uint32_t p_BindingIndex);\n    };\n};\n</code></pre>"},{"location":"References/vertex__buffer_8hpp/","title":"File vertex_buffer.hpp","text":"<p>FileList &gt; atlas &gt; drivers &gt; vertex_buffer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.hpp&gt;</code></li> </ul>"},{"location":"References/vertex__buffer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/vertex__buffer_8hpp/#classes","title":"Classes","text":"Type Name struct vertex class vertex_buffer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/drivers/vertex_buffer.hpp</code></p>"},{"location":"References/vertex__buffer_8hpp_source/","title":"File vertex_buffer.hpp","text":"<p>File List &gt; atlas &gt; drivers &gt; vertex_buffer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;glm/glm.hpp&gt;\n#include &lt;vector&gt;\n#include &lt;vulkan/vulkan.hpp&gt;\n\nnamespace atlas {\n    /*\n        @name vertex_buffer\n        @note Contains vertices and does backend API stuff.\n    */\n    struct vertex {\n        glm::vec3 Position;\n        glm::vec3 Color;\n        glm::vec3 Normals;\n        glm::vec2 TexCoords;\n\n        bool operator==(const vertex&amp; other) const {\n            return (Position == other.Position and Color == other.Color and\n                    Normals == other.Normals and TexCoords == other.TexCoords);\n        }\n    };\n\n    class vertex_buffer {\n    public:\n        virtual ~vertex_buffer() = default;\n\n        static ref&lt;vertex_buffer&gt; create(const std::vector&lt;vertex&gt;&amp; p_vertices);\n\n        void bind(const VkCommandBuffer&amp; p_command_buffer);\n\n        void draw(const VkCommandBuffer&amp; p_command_buffer);\n\n    protected:\n        virtual void bind_vertex_buffer(\n          const VkCommandBuffer&amp; p_command_buffer) = 0;\n        virtual void render_vertex_buffer(\n          const VkCommandBuffer&amp; p_command_buffer) = 0;\n    };\n};\n</code></pre>"},{"location":"References/dir_40e4880a491f87475db52b6f14fdb765/","title":"Dir TheAtlasEngine/atlas/physics","text":"<p>FileList &gt; atlas &gt; physics</p>"},{"location":"References/dir_40e4880a491f87475db52b6f14fdb765/#files","title":"Files","text":"Type Name file types.hpp"},{"location":"References/dir_40e4880a491f87475db52b6f14fdb765/#directories","title":"Directories","text":"Type Name dir jolt-cpp dir physics_3d <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/</code></p>"},{"location":"References/dir_4275702edcca8362402a3c9bf0161df7/","title":"Dir TheAtlasEngine/atlas/physics/jolt-cpp","text":"<p>FileList &gt; atlas &gt; physics &gt; jolt-cpp</p>"},{"location":"References/dir_4275702edcca8362402a3c9bf0161df7/#files","title":"Files","text":"Type Name file helper_functions.hpp file jolt-imports.hpp file jolt_api.hpp file jolt_body.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/</code></p>"},{"location":"References/physics_2jolt-cpp_2helper__functions_8hpp/","title":"File helper_functions.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; jolt-cpp &gt; helper_functions.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;Jolt/Jolt.h&gt;</code></li> <li><code>#include &lt;core/math/types.hpp&gt;</code></li> <li><code>#include &lt;glm/fwd.hpp&gt;</code></li> </ul>"},{"location":"References/physics_2jolt-cpp_2helper__functions_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics"},{"location":"References/physics_2jolt-cpp_2helper__functions_8hpp/#classes","title":"Classes","text":"Type Name struct vector3&lt; JPH::Vec3 &gt; &lt;&gt; <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/helper_functions.hpp</code></p>"},{"location":"References/physics_2jolt-cpp_2helper__functions_8hpp_source/","title":"File helper_functions.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; jolt-cpp &gt; helper_functions.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;Jolt/Jolt.h&gt;\n#include &lt;core/math/types.hpp&gt;\n#include &lt;glm/fwd.hpp&gt;\n\nnamespace atlas {\n    template&lt;&gt;\n    struct vector3&lt;JPH::Vec3&gt; {\n        vector3() = default;\n\n        vector3(const JPH::Vec3&amp; p_other) {\n            value = { p_other.GetX(), p_other.GetY(), p_other.GetZ() };\n        }\n\n        operator glm::vec3() { return value; }\n\n        glm::vec3 operator=(const JPH::Vec3&amp; p_other) {\n            return { p_other.GetX(), p_other.GetY(), p_other.GetZ() };\n        }\n\n        bool operator==(const glm::vec3&amp; p_other) {\n            return (value.x == p_other.x and value.y == p_other.y and\n                    value.z == p_other.z);\n        }\n\n    private:\n        glm::vec3 value;\n    };\n};\n\nnamespace atlas::physics {\n    /* Converting from glm::vec3 to a jolt's vec3 math data type */\n    JPH::RVec3 to_rvec3(const glm::vec3&amp; p_Value);\n\n    JPH::Vec3 to_vec3(const glm::vec3&amp; p_Value);\n\n    /* Converting jolt's vec3 back to a glm::vec3 */\n    glm::vec3 to_vec3(const JPH::Vec3&amp; p_Value);\n\n    /* Converting Jolt's quaternion to glm's quaternion */\n    glm::quat to_quat(const JPH::Quat&amp; p_Value);\n\n    JPH::Quat to_quat(glm::quat&amp; p_Value);\n};\n</code></pre>"},{"location":"References/jolt-imports_8hpp/","title":"File jolt-imports.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt-imports.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;Jolt/Jolt.h&gt;</code></li> <li><code>#include &lt;Jolt/Core/Core.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Body/BodyInterface.h&gt;</code></li> <li><code>#include &lt;Jolt/Core/JobSystemThreadPool.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/PhysicsSettings.h&gt;</code></li> <li><code>#include &lt;Jolt/Core/IssueReporting.h&gt;</code></li> <li><code>#include &lt;Jolt/Core/TempAllocator.h&gt;</code></li> <li><code>#include &lt;Jolt/RegisterTypes.h&gt;</code></li> <li><code>#include &lt;Jolt/Core/Factory.h&gt;</code></li> <li><code>#include &lt;Jolt/Core/Memory.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/ContactListener.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/PhysicsSystem.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/ObjectLayer.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/BroadPhase/BroadPhaseLayer.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Body/BodyCreationSettings.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/Shape/Shape.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/Shape/BoxShape.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/Shape/ConvexShape.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/Shape/ScaledShape.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/Shape/SphereShape.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/EActivation.h&gt;</code></li> <li><code>#include &lt;Jolt/Math/MathTypes.h&gt;</code></li> <li><code>#include &lt;Jolt/Math/Real.h&gt;</code></li> <li><code>#include &lt;Jolt/Math/Quat.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt-imports.hpp</code></p>"},{"location":"References/jolt-imports_8hpp_source/","title":"File jolt-imports.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt-imports.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;type_traits&gt;\n#include &lt;Jolt/Jolt.h&gt;\n#include &lt;Jolt/Core/Core.h&gt;\n#include &lt;Jolt/Physics/Body/BodyInterface.h&gt;\n#include &lt;Jolt/Core/JobSystemThreadPool.h&gt;\n#include &lt;Jolt/Physics/PhysicsSettings.h&gt;\n#include &lt;Jolt/Core/IssueReporting.h&gt;\n#include &lt;Jolt/Core/TempAllocator.h&gt;\n#include &lt;Jolt/RegisterTypes.h&gt;\n#include &lt;Jolt/Core/Factory.h&gt;\n#include &lt;Jolt/Core/Memory.h&gt;\n#include &lt;Jolt/Physics/Collision/ContactListener.h&gt;\n#include &lt;Jolt/Physics/PhysicsSystem.h&gt;\n#include &lt;Jolt/Physics/Collision/ObjectLayer.h&gt;\n#include &lt;Jolt/Physics/Collision/BroadPhase/BroadPhaseLayer.h&gt;\n#include &lt;Jolt/Core/IssueReporting.h&gt;\n\n#include &lt;Jolt/Physics/Body/BodyCreationSettings.h&gt;\n\n#include &lt;Jolt/Physics/Collision/Shape/Shape.h&gt;\n#include &lt;Jolt/Physics/Collision/Shape/BoxShape.h&gt;\n#include &lt;Jolt/Physics/Collision/Shape/ConvexShape.h&gt;\n#include &lt;Jolt/Physics/Collision/Shape/ScaledShape.h&gt;\n#include &lt;Jolt/Physics/Collision/Shape/SphereShape.h&gt;\n\n#include &lt;Jolt/Physics/EActivation.h&gt;\n\n// jolt's math includes\n#include &lt;Jolt/Math/MathTypes.h&gt;\n#include &lt;Jolt/Math/Real.h&gt;\n#include &lt;Jolt/Math/Quat.h&gt;\n</code></pre>"},{"location":"References/jolt-cpp_2jolt__api_8hpp/","title":"File jolt_api.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt_api.hpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_api.hpp</code></p>"},{"location":"References/jolt-cpp_2jolt__api_8hpp_source/","title":"File jolt_api.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt_api.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// #pragma once\n// #include &lt;physics/jolt-cpp/jolt-imports.hpp&gt;\n// #include &lt;Jolt/Physics/Collision/ObjectLayer.h&gt;\n// #include &lt;Jolt/Physics/Body/BodyManager.h&gt;\n// #include &lt;Jolt/Physics/Body/BodyActivationListener.h&gt;\n// #include &lt;Jolt/Physics/Collision/ContactListener.h&gt;\n// #include &lt;array&gt;\n\n// namespace atlas::physics {\n\n//     namespace phase_layer {\n//         static constexpr JPH::BroadPhaseLayer STATIC(0);\n//     };\n\n//     //! @note Physics settings per physic scene\n//     struct setting {\n//         float gravity = -10.f;\n//     };\n\n//     // enum class BodyTypeTest : int8_t {\n//     //     UNDEFINED = -1,\n//     //     STATIC = 0,\n//     //     KINEMATIC = 1,\n//     //     DYNAMIC = 2\n//     // };\n\n//     namespace BodyTypeTest {\n//         static constexpr JPH::ObjectLayer STATIC = 0;\n//         static constexpr JPH::ObjectLayer KINEMATIC = 1;\n//         static constexpr JPH::ObjectLayer DYNAMIC = 2;\n//     };\n\n//     namespace BroadPhaseLayers {\n//         static constexpr JPH::BroadPhaseLayer STATIC(0);\n//         static constexpr JPH::BroadPhaseLayer KINEMATIC(1);\n//         static constexpr JPH::BroadPhaseLayer DYNAMIC(2);\n//     };\n\n//     class BPLayerInterfaceHandler : public JPH::BroadPhaseLayerInterface {\n//     public:\n//         BPLayerInterfaceHandler() {\n//             m_ToBroadPhase[BodyTypeTest::STATIC] = BroadPhaseLayers::STATIC;\n//             m_ToBroadPhase[BodyTypeTest::DYNAMIC] =\n//             BroadPhaseLayers::DYNAMIC;\n//             m_ToBroadPhase[BodyTypeTest::KINEMATIC] =\n//               BroadPhaseLayers::KINEMATIC;\n//         }\n\n//         JPH::uint GetNumBroadPhaseLayers() const override { return 3; }\n\n//         JPH::BroadPhaseLayer GetBroadPhaseLayer(\n//           JPH::ObjectLayer inLayer) const override {\n//             // 3 = num of layers\n//             JPH_ASSERT(inLayer &lt; 3);\n//             return m_ToBroadPhase[inLayer];\n//         }\n// #if defined(JPH_EXTERNAL_PROFILE) || defined(JPH_PROFILE_ENABLED)\n//         const char* GetBroadPhaseLayerName(\n//           [[maybe_unused]] JPH::BroadPhaseLayer inLayer) const override {\n//             return \"Test\";\n//         }\n// #endif\n\n//     private:\n//         std::array&lt;JPH::BroadPhaseLayer, 3&gt; m_ToBroadPhase;\n//         // JPH::BroadPhaseLayer m_ToBroadPhase[3];\n//     };\n\n//     class ObjectLayerPairFilterInterface : public JPH::ObjectLayerPairFilter\n//     { public:\n//         bool ShouldCollide(JPH::ObjectLayer inObject1,\n//                            JPH::ObjectLayer inObject2) const override {\n//             switch (inObject1) {\n//                 case BodyTypeTest::STATIC: {\n//                     return (inObject2 == BodyTypeTest::DYNAMIC ||\n//                             inObject2 == BodyTypeTest::KINEMATIC);\n//                 }\n//                 case BodyTypeTest::KINEMATIC:\n//                     return true;\n//                 case BodyTypeTest::DYNAMIC:\n//                     return true;\n//                 default:\n//                     return false;\n//             }\n//         }\n//     };\n\n//     class ObjectVsBPLayerFilterInterface\n//       : public JPH::ObjectVsBroadPhaseLayerFilter {\n//     public:\n//         bool ShouldCollide(JPH::ObjectLayer inObject1,\n//                            JPH::BroadPhaseLayer inObject2) const override {\n//             switch (inObject1) {\n//                 case BodyTypeTest::STATIC: {\n//                     return (inObject2 == BroadPhaseLayers::DYNAMIC ||\n//                             inObject2 == BroadPhaseLayers::KINEMATIC);\n//                 }\n//                 case BodyTypeTest::KINEMATIC:\n//                     return true;\n//                 case BodyTypeTest::DYNAMIC:\n//                     return true;\n//                 default:\n//                     return false;\n//             }\n//         }\n//     };\n\n//     class ActivationListener : public JPH::BodyActivationListener {\n//     public:\n//         void OnBodyActivated(\n//           [[maybe_unused]] const JPH::BodyID&amp; inBodyID,\n//           [[maybe_unused]] JPH::uint64 inBodyUserData) override {\n//             // console_log_trace(\"\");\n//             printf(\"FROM ActivationListener Class --- Body was\n//             activated!\\n\");\n//         }\n\n//         void OnBodyDeactivated(\n//           [[maybe_unused]] const JPH::BodyID&amp; inBodyID,\n//           [[maybe_unused]] JPH::uint64 inBodyUserData) override {\n//             // std::print(\"Body is asleep...\\n\");\n//             printf(\"FROM ActivationListener Class --- Body is asleep...\\n\");\n//         }\n//     };\n\n//     class ContactListener : public JPH::ContactListener {\n//     public:\n//         JPH::ValidateResult OnContactValidate(\n//           [[maybe_unused]] const JPH::Body&amp; inBody1,\n//           [[maybe_unused]] const JPH::Body&amp; inBody2,\n//           [[maybe_unused]] JPH::RVec3Arg inBaseOffset,\n//           [[maybe_unused]] const JPH::CollideShapeResult&amp; inCollisionResult)\n//           override {\n//             printf(\"FROM ContactListener Class --- Validating...\\n\");\n\n//             // Allows you to ignore a contact before it is created (using\n//             layers\n//             // to not make objects collide is cheaper!)\n//             return JPH::ValidateResult::AcceptAllContactsForThisBodyPair;\n//         }\n\n//         void OnContactAdded(\n//           [[maybe_unused]] const JPH::Body&amp; inBody1,\n//           [[maybe_unused]] const JPH::Body&amp; inBody2,\n//           [[maybe_unused]] const JPH::ContactManifold&amp; inManifold,\n//           [[maybe_unused]] JPH::ContactSettings&amp; ioSettings) override {\n//             printf(\"FROM ContactListener Class --- Contact was added!\\n\");\n//         }\n\n//         void OnContactPersisted(\n//           [[maybe_unused]] const JPH::Body&amp; inBody1,\n//           [[maybe_unused]] const JPH::Body&amp; inBody2,\n//           [[maybe_unused]] const JPH::ContactManifold&amp; inManifold,\n//           [[maybe_unused]] JPH::ContactSettings&amp; ioSettings) override {\n//             printf(\"FROM ContactListener Class --- Contact was\n//             persisted!\\n\");\n//         }\n\n//         void OnContactRemoved(\n//           [[maybe_unused]] const JPH::SubShapeIDPair&amp; inSubShapePair)\n//           override {\n//             printf(\"FROM ContactListener Class --- Contact was removed!\\n\");\n//         }\n//     };\n\n//     //! @note Screw it, I dont have enough time. Just gonna implement physics\n//     as\n//     //! I see it currently.\n//     /**/\n//     class JoltAPI {\n//     public:\n//         //! @note Used for initializing the physic's system API backend\n//         static void InitializeJoltAPI();\n\n//         static JPH::PhysicsSystem&amp; GetSystem();\n\n//         static JPH::BodyInterface* GetBodyInterface();\n//     };\n// };\n</code></pre>"},{"location":"References/jolt__body_8hpp/","title":"File jolt_body.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt_body.hpp</p> <p>Go to the source code of this file</p>"},{"location":"References/jolt__body_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics"},{"location":"References/jolt__body_8hpp/#classes","title":"Classes","text":"Type Name class JoltPhysicBody <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/jolt-cpp/jolt_body.hpp</code></p>"},{"location":"References/jolt__body_8hpp_source/","title":"File jolt_body.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; jolt-cpp &gt; jolt_body.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace atlas::physics {\n    class JoltPhysicBody {\n    public:\n    };\n};\n</code></pre>"},{"location":"References/dir_ab5034a21b7aebf79f76e5e8638ac885/","title":"Dir TheAtlasEngine/atlas/physics/physics_3d","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d</p>"},{"location":"References/dir_ab5034a21b7aebf79f76e5e8638ac885/#files","title":"Files","text":"Type Name file physics_api.hpp file physics_engine.hpp"},{"location":"References/dir_ab5034a21b7aebf79f76e5e8638ac885/#directories","title":"Directories","text":"Type Name dir data dir jolt <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/</code></p>"},{"location":"References/dir_979e5e81d6b989d5f059c91b3771cf0a/","title":"Dir TheAtlasEngine/atlas/physics/physics_3d/data","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; data</p>"},{"location":"References/dir_979e5e81d6b989d5f059c91b3771cf0a/#files","title":"Files","text":"Type Name file jolt_config.hpp file jolt_settings.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/data/</code></p>"},{"location":"References/jolt__config_8hpp/","title":"File jolt_config.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; data &gt; jolt_config.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> </ul>"},{"location":"References/jolt__config_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics"},{"location":"References/jolt__config_8hpp/#classes","title":"Classes","text":"Type Name struct jolt_config Used to keep global data for player access and use. Tells how physics bodies should act within a given scene by default. <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/data/jolt_config.hpp</code></p>"},{"location":"References/jolt__config_8hpp_source/","title":"File jolt_config.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; physics_3d &gt; data &gt; jolt_config.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;cstdint&gt;\n#include &lt;glm/glm.hpp&gt;\n\nnamespace atlas::physics {\n    struct jolt_config {\n        // Global gravity vector for all in scene\n        glm::vec3 gravity = glm::vec3(0.0f, -9.80665f, 0.0f);\n\n        // Time step for fps within the physics\n        // If false set to 1/maxFps\n        float fixed_time_step = 1.0f / 60.0f;\n        bool use_fixed_timestep = false;\n\n        // solver for velocity and position\n        uint32_t position_iterations = 6;\n        uint32_t velocity_iterations = 6;\n\n        // When to turn objects on and off depending on speed\n        float sleep_velocity_threshold = 0.05f;\n        float sleep_angular_velocity_threshold = 0.05f;\n\n        float time_before_sleep = 5.0f;\n\n        // What 1 unit refers to in meters\n        float world_unit_scale = 1.0f;\n\n        // Helps stop the lauching of objects during numerical/flaoting point\n        // errors when collision happen bertween to objects.\n        float contact_bias_factor = 0.2f;\n        float restitution_threshold = 1.0f;\n\n        bool enable_constraints = true;\n        bool enable_contacts = true;\n        bool enable_collision_callbacks = true;\n    };\n};\n</code></pre>"},{"location":"References/jolt__settings_8hpp/","title":"File jolt_settings.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; data &gt; jolt_settings.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"References/jolt__settings_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics"},{"location":"References/jolt__settings_8hpp/#classes","title":"Classes","text":"Type Name struct jolt_settings A data structure to give to flecs and get the physics. <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/data/jolt_settings.hpp</code></p>"},{"location":"References/jolt__settings_8hpp_source/","title":"File jolt_settings.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; physics_3d &gt; data &gt; jolt_settings.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;cstdint&gt;\n#include &lt;glm/glm.hpp&gt;\n#include &lt;thread&gt;\nnamespace atlas::physics {\n\n    struct jolt_settings {\n\n        // For job system\n        uint32_t physics_threads = std::thread::hardware_concurrency();\n        bool is_multithreaded = true;\n\n        // Collision detection\n        float broadphase_scale = 1.0f;\n        bool use_4_layer_broadphase = true;\n        uint32_t default_collision_group = 0;\n\n        // Filtering out specifica collisions\n        uint32_t collision_filter_layer_count = 32;\n        uint32_t default_filter_mask = 0xFFFFFFFF;\n\n        // Scene position in the world\n        glm::vec3 physics_scene_position = glm::vec3(0.0f, 0.0f, 0.0f);\n\n        glm::vec3 world_bounds_min = glm::vec3(-500.0f, -500.0f, -500.0f);\n\n        glm::vec3 world_bounds_max = glm::vec3(500.0f, 500.0f, 500.0f);\n        // Max memory size per scene\n        uint32_t max_bodies = 16384;\n        uint32_t max_body_pairs = 32768;\n        uint32_t max_contact_constraints = 8192;\n\n    };\n};\n</code></pre>"},{"location":"References/dir_3d876be8cd66de39c1e103aa97223d9b/","title":"Dir TheAtlasEngine/atlas/physics/physics_3d/jolt","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; jolt</p>"},{"location":"References/dir_3d876be8cd66de39c1e103aa97223d9b/#files","title":"Files","text":"Type Name file jolt_api.hpp file jolt_physics_engine.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/jolt/</code></p>"},{"location":"References/physics__3d_2jolt_2jolt__api_8hpp/","title":"File jolt_api.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; jolt &gt; jolt_api.hpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/jolt/jolt_api.hpp</code></p>"},{"location":"References/physics__3d_2jolt_2jolt__api_8hpp_source/","title":"File jolt_api.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; physics_3d &gt; jolt &gt; jolt_api.hpp</p> <p>Go to the documentation of this file</p>"},{"location":"References/jolt__physics__engine_8hpp/","title":"File jolt_physics_engine.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; jolt &gt; jolt_physics_engine.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;physics/physics_3d/data/jolt_settings.hpp&gt;</code></li> <li><code>#include &lt;physics/physics_3d/data/jolt_config.hpp&gt;</code></li> </ul>"},{"location":"References/jolt__physics__engine_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/jolt/jolt_physics_engine.hpp</code></p>"},{"location":"References/jolt__physics__engine_8hpp_source/","title":"File jolt_physics_engine.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; physics_3d &gt; jolt &gt; jolt_physics_engine.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;physics/physics_3d/data/jolt_settings.hpp&gt;\n#include &lt;physics/physics_3d/data/jolt_config.hpp&gt;\n\nnamespace atlas::physics {\n\n    void create_engine(const jolt_settings&amp; settings);\n\n}\n</code></pre>"},{"location":"References/physics__api_8hpp/","title":"File physics_api.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; physics_api.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/scene/scene_object.hpp&gt;</code></li> </ul>"},{"location":"References/physics__api_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/physics_api.hpp</code></p>"},{"location":"References/physics__api_8hpp_source/","title":"File physics_api.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; physics_3d &gt; physics_api.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;core/scene/scene_object.hpp&gt;\n\nnamespace atlas::physics {\n\n    void create(ref&lt;atlas::scene_object&gt; physics_object);\n\n}\n</code></pre>"},{"location":"References/physics__engine_8hpp/","title":"File physics_engine.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; physics_3d &gt; physics_engine.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;physics/jolt-cpp/jolt-imports.hpp&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/ObjectLayer.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Body/BodyManager.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Body/BodyActivationListener.h&gt;</code></li> <li><code>#include &lt;Jolt/Physics/Collision/ContactListener.h&gt;</code></li> </ul>"},{"location":"References/physics__engine_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics"},{"location":"References/physics__engine_8hpp/#classes","title":"Classes","text":"Type Name class physics_engine <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/physics_3d/physics_engine.hpp</code></p>"},{"location":"References/physics__engine_8hpp_source/","title":"File physics_engine.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; physics_3d &gt; physics_engine.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;physics/jolt-cpp/jolt-imports.hpp&gt;\n#include &lt;Jolt/Physics/Collision/ObjectLayer.h&gt;\n#include &lt;Jolt/Physics/Body/BodyManager.h&gt;\n#include &lt;Jolt/Physics/Body/BodyActivationListener.h&gt;\n#include &lt;Jolt/Physics/Collision/ContactListener.h&gt;\n\nnamespace atlas::physics {\n\n    // struct setting{\n    //     float gravity = -10.f;\n    // };\n\n\n    // class PhysicSystem{\n    // public:\n    //     //! @note Constructor will instantiate the physics sysytem\n    //     //! @note NOTE: Apply dedicated threads for this physic system\n    //     // PhysicSystem(const setting&amp; p_Settings = {});\n\n    //     static JPH::PhysicsSystem&amp; GetInstance();\n\n    //     // static ref&lt;JPH::Body&gt; CreateBody(const JPH::BodyCreationSettings&amp;\n    //     settings); static JPH::BodyInterface&amp; CreateBodyInterface();\n\n    //     static void OptimizeBroadPhase();\n    //     // void Init();\n    // };\n\n    class physics_engine {};\n};\n</code></pre>"},{"location":"References/physics_2types_8hpp/","title":"File types.hpp","text":"<p>FileList &gt; atlas &gt; physics &gt; types.hpp</p> <p>Go to the source code of this file</p>"},{"location":"References/physics_2types_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas namespace physics <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/physics/types.hpp</code></p>"},{"location":"References/physics_2types_8hpp_source/","title":"File types.hpp","text":"<p>File List &gt; atlas &gt; physics &gt; types.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace atlas::physics {};\n</code></pre>"},{"location":"References/dir_8ab98dc538dea21b0c00575cec6c8f5c/","title":"Dir TheAtlasEngine/atlas/renderer","text":"<p>FileList &gt; atlas &gt; renderer</p>"},{"location":"References/dir_8ab98dc538dea21b0c00575cec6c8f5c/#files","title":"Files","text":"Type Name file renderer.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/renderer/</code></p>"},{"location":"References/renderer_8hpp/","title":"File renderer.hpp","text":"<p>FileList &gt; atlas &gt; renderer &gt; renderer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/core.hpp&gt;</code></li> <li><code>#include &lt;core/scene/scene.hpp&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.hpp&gt;</code></li> </ul>"},{"location":"References/renderer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/renderer_8hpp/#classes","title":"Classes","text":"Type Name class renderer <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/renderer/renderer.hpp</code></p>"},{"location":"References/renderer_8hpp_source/","title":"File renderer.hpp","text":"<p>File List &gt; atlas &gt; renderer &gt; renderer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/core.hpp&gt;\n#include &lt;core/scene/scene.hpp&gt;\n#include &lt;vulkan/vulkan.hpp&gt;\n\nnamespace atlas {\n    class scene_object;\n    class renderer {\n    public:\n        static void initialize();\n\n        static uint32_t get_current_frame();\n\n        static void begin();\n        static void end();\n    };\n};\n</code></pre>"},{"location":"References/dir_2d188042b35c07e13e36a6d5b630b30a/","title":"Dir TheAtlasEngine/atlas/thread_utils","text":"<p>FileList &gt; atlas &gt; thread_utils</p>"},{"location":"References/dir_2d188042b35c07e13e36a6d5b630b30a/#files","title":"Files","text":"Type Name file thread.hpp file thread_utils.hpp <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/thread_utils/</code></p>"},{"location":"References/thread__utils_2thread_8hpp/","title":"File thread.hpp","text":"<p>FileList &gt; atlas &gt; thread_utils &gt; thread.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;core/engine_logger.hpp&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"References/thread__utils_2thread_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas"},{"location":"References/thread__utils_2thread_8hpp/#classes","title":"Classes","text":"Type Name class thread <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/thread_utils/thread.hpp</code></p>"},{"location":"References/thread__utils_2thread_8hpp_source/","title":"File thread.hpp","text":"<p>File List &gt; atlas &gt; thread_utils &gt; thread.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;core/engine_logger.hpp&gt;\n#include &lt;thread&gt;\n\nnamespace atlas {\n    class thread {\n    public:\n        thread() = delete;\n        thread(const std::string&amp; p_tag = \"Undefined\")\n          : m_tag(p_tag) {}\n\n        ~thread() {\n            console_log_info(\"Are you destructed!\");\n            if (this-&gt;Joinable()) {\n                this-&gt;Join();\n            }\n        }\n\n        template&lt;typename T, typename... Args&gt;\n        void dispatch(T&amp;&amp; func, Args&amp;&amp;... args) {\n            m_thread = std::thread(func, std::forward&lt;Args&gt;(args)...);\n        }\n\n        bool Joinable() { return m_thread.joinable(); }\n\n        void Join() { m_thread.join(); }\n\n    private:\n        std::string m_tag;\n        std::thread m_thread;\n    };\n};\n</code></pre>"},{"location":"References/thread__utils_8hpp/","title":"File thread_utils.hpp","text":"<p>FileList &gt; atlas &gt; thread_utils &gt; thread_utils.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"References/thread__utils_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace atlas <p>The documentation for this class was generated from the following file <code>TheAtlasEngine/atlas/thread_utils/thread_utils.hpp</code></p>"},{"location":"References/thread__utils_8hpp_source/","title":"File thread_utils.hpp","text":"<p>File List &gt; atlas &gt; thread_utils &gt; thread_utils.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n\nnamespace atlas {\n    uint32_t get_thread_count();\n};\n</code></pre>"},{"location":"References/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace atlas <ul> <li>namespace event </li> <li>namespace filesystem </li> <li>namespace physics </li> <li>namespace sync_update </li> <li>namespace ui </li> <li>namespace vk </li> </ul> </li> <li>namespace std </li> </ul>"},{"location":"References/classes/","title":"Class Index","text":""},{"location":"References/classes/#a","title":"a","text":"<ul> <li>application (atlas)</li> <li>application_settings (atlas)</li> </ul>"},{"location":"References/classes/#b","title":"b","text":"<ul> <li>box_collider3d (atlas)</li> <li>BufferTutorial (atlas::vk)</li> <li>builder (atlas::vk::descriptor_pool)</li> <li>builder (atlas::vk::descriptor_set_layout)</li> </ul>"},{"location":"References/classes/#c","title":"c","text":"<ul> <li>camera (atlas)</li> <li>camera_ubo (atlas)</li> <li>console_log_manager (atlas)</li> </ul>"},{"location":"References/classes/#d","title":"d","text":"<ul> <li>descriptor_pool (atlas::vk)</li> <li>descriptor_set_layout (atlas::vk)</li> <li>descriptor_writer (atlas::vk)</li> <li>DescriptorSet (atlas)</li> <li>DescriptorSetLayout (atlas)</li> <li>DirectionalLightUbo (atlas)</li> </ul>"},{"location":"References/classes/#e","title":"e","text":"<ul> <li>entity_t (atlas)</li> </ul>"},{"location":"References/classes/#f","title":"f","text":"<ul> <li>Framebuffer (atlas)</li> </ul>"},{"location":"References/classes/#i","title":"i","text":"<ul> <li>Image (atlas)</li> <li>ImageSampler (atlas)</li> <li>imgui_backend (atlas)</li> <li>index_buffer (atlas)</li> <li>interpolation (atlas)</li> </ul>"},{"location":"References/classes/#j","title":"j","text":"<ul> <li>jolt_config (atlas::physics)</li> <li>jolt_settings (atlas::physics)</li> <li>JoltPhysicBody (atlas::physics)</li> <li>joystick_button (atlas::event)</li> <li>joystick_info (atlas::event)</li> </ul>"},{"location":"References/classes/#l","title":"l","text":"<ul> <li>light (atlas)</li> </ul>"},{"location":"References/classes/#m","title":"m","text":"<ul> <li>math_generic (atlas)</li> <li>matrix2 (atlas)</li> <li>matrix3 (atlas)</li> <li>matrix4 (atlas)</li> <li>mesh (atlas)</li> </ul>"},{"location":"References/classes/#p","title":"p","text":"<ul> <li>ParallelUpdateManager (atlas)</li> <li>physics_engine (atlas::physics)</li> <li>Pipeline (atlas)</li> <li>PointLightUbo (atlas)</li> </ul>"},{"location":"References/classes/#q","title":"q","text":"<ul> <li>queue_family_indices (atlas::vk::vk_physical_driver)</li> </ul>"},{"location":"References/classes/#r","title":"r","text":"<ul> <li>render_context (atlas)</li> <li>renderer (atlas)</li> <li>renderpass (atlas)</li> <li>renderpass_properties (atlas)</li> <li>rendertarget3d (atlas)</li> <li>rigidbody3d (atlas)</li> </ul>"},{"location":"References/classes/#s","title":"s","text":"<ul> <li>scene_object (atlas)</li> <li>scene_scope (atlas)</li> <li>serializer (atlas)</li> <li>shader (atlas)</li> <li>shader_pipeline_config (atlas::vk)</li> <li>SpotLightUbo (atlas)</li> <li>swapchain (atlas)</li> <li>swapchain_depth_image</li> <li>swapchain_image</li> <li>system_registry (atlas)</li> </ul>"},{"location":"References/classes/#t","title":"t","text":"<ul> <li>tag (atlas)</li> <li>thread (atlas)</li> <li>timer (atlas)</li> <li>transform (atlas)</li> </ul>"},{"location":"References/classes/#u","title":"u","text":"<ul> <li>UniformBuffer (atlas)</li> </ul>"},{"location":"References/classes/#v","title":"v","text":"<ul> <li>vector2 (atlas)</li> <li>vector2&lt; glm::highp_vec2 &gt; (atlas)</li> <li>vector3 (atlas)</li> <li>vector3&lt; glm::highp_vec3 &gt; (atlas)</li> <li>vector3&lt; JPH::Vec3 &gt; (atlas)</li> <li>vector4 (atlas)</li> <li>vector4&lt; glm::highp_vec4 &gt; (atlas)</li> <li>vertex (atlas)</li> <li>vertex_buffer (atlas)</li> <li>vk_context (atlas::vk)</li> <li>vk_driver (atlas::vk)</li> <li>vk_index_buffer (atlas::vk)</li> <li>vk_physical_driver (atlas::vk)</li> <li>vk_renderer (atlas::vk)</li> <li>vk_shader (atlas::vk)</li> <li>vk_swapchain (atlas::vk)</li> <li>vk_vertex_buffer (atlas::vk)</li> <li>vk_window (atlas::vk)</li> <li>VulkanDescriptorSets (atlas::vk)</li> <li>VulkanImGui (atlas)</li> <li>VulkanPipeline (atlas::vk)</li> <li>VulkanRenderPass (atlas::vk)</li> <li>VulkanUniformBuffer (atlas::vk)</li> </ul>"},{"location":"References/classes/#w","title":"w","text":"<ul> <li>window (atlas)</li> <li>world_scope (atlas)</li> </ul>"},{"location":"References/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class atlas::Framebuffer </li> <li>class atlas::Image </li> <li>class atlas::ParallelUpdateManager </li> <li>class atlas::Pipeline </li> <li>class atlas::UniformBuffer </li> <li>class atlas::VulkanImGui </li> <li>class atlas::application </li> <li>class atlas::camera </li> <li>class atlas::console_log_manager </li> <li>class atlas::entity_t </li> <li>class atlas::imgui_backend </li> <li>class atlas::index_buffer <ul> <li>class atlas::vk::vk_index_buffer </li> </ul> </li> <li>class atlas::interpolation </li> <li>class atlas::mesh </li> <li>class atlas::physics::JoltPhysicBody </li> <li>class atlas::physics::physics_engine </li> <li>class atlas::render_context <ul> <li>class atlas::vk::vk_renderer </li> </ul> </li> <li>class atlas::renderer </li> <li>class atlas::renderpass <ul> <li>class atlas::vk::VulkanRenderPass </li> </ul> </li> <li>class atlas::scene_object </li> <li>class atlas::scene_scope </li> <li>class atlas::serializer </li> <li>class atlas::shader <ul> <li>class atlas::vk::vk_shader </li> </ul> </li> <li>class atlas::swapchain <ul> <li>class atlas::vk::vk_swapchain </li> </ul> </li> <li>class atlas::system_registry </li> <li>class atlas::thread </li> <li>class atlas::timer </li> <li>class atlas::vertex_buffer <ul> <li>class atlas::vk::vk_vertex_buffer </li> </ul> </li> <li>class atlas::vk::BufferTutorial </li> <li>class atlas::vk::VulkanDescriptorSets </li> <li>class atlas::vk::VulkanPipeline </li> <li>class atlas::vk::VulkanUniformBuffer </li> <li>class atlas::vk::descriptor_pool </li> <li>class atlas::vk::descriptor_pool::builder </li> <li>class atlas::vk::descriptor_set_layout </li> <li>class atlas::vk::descriptor_set_layout::builder </li> <li>class atlas::vk::descriptor_writer </li> <li>class atlas::vk::vk_context </li> <li>class atlas::vk::vk_driver </li> <li>class atlas::vk::vk_physical_driver </li> <li>class atlas::window <ul> <li>class atlas::vk::vk_window </li> </ul> </li> <li>struct atlas::DescriptorSet </li> <li>struct atlas::DescriptorSetLayout </li> <li>struct atlas::DirectionalLightUbo </li> <li>struct atlas::ImageSampler </li> <li>struct atlas::PointLightUbo </li> <li>struct atlas::SpotLightUbo </li> <li>struct atlas::application_settings </li> <li>struct atlas::box_collider3d </li> <li>struct atlas::camera_ubo </li> <li>struct atlas::event::joystick_button </li> <li>struct atlas::event::joystick_info </li> <li>struct atlas::light TODO: Make this better (when we do lighting) </li> <li>struct atlas::math_generic </li> <li>struct atlas::matrix2 </li> <li>struct atlas::matrix3 </li> <li>struct atlas::matrix4 </li> <li>struct atlas::physics::jolt_config Used to keep global data for player access and use. Tells how physics bodies should act within a given scene by default. </li> <li>struct atlas::physics::jolt_settings A data structure to give to flecs and get the physics. </li> <li>struct atlas::renderpass_properties </li> <li>struct atlas::rendertarget3d </li> <li>struct atlas::rigidbody3d </li> <li>struct atlas::tag </li> <li>struct atlas::transform </li> <li>struct atlas::vector2 </li> <li>struct atlas::vector2&lt; glm::highp_vec2 &gt; </li> <li>struct atlas::vector3 </li> <li>struct atlas::vector3&lt; JPH::Vec3 &gt; </li> <li>struct atlas::vector3&lt; glm::highp_vec3 &gt; </li> <li>struct atlas::vector4 </li> <li>struct atlas::vector4&lt; glm::highp_vec4 &gt; </li> <li>struct atlas::vertex </li> <li>struct atlas::vk::shader_pipeline_config </li> <li>struct atlas::vk::vk_physical_driver::queue_family_indices </li> <li>struct atlas::vk::vk_swapchain::swapchain_depth_image </li> <li>struct atlas::vk::vk_swapchain::swapchain_image </li> <li>class std::enable_shared_from_this&lt; world_scope &gt; <ul> <li>class atlas::world_scope Lets rethink how world_scope gets created.</li> </ul> </li> </ul>"},{"location":"References/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"References/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"References/class_members/","title":"Class Members","text":""},{"location":"References/class_members/#a","title":"a","text":"<ul> <li>ambient (atlas::DirectionalLightUbo, atlas::PointLightUbo, atlas::SpotLightUbo)</li> <li>application (atlas::application)</li> <li>AspectRatio (atlas::camera)</li> <li>add (atlas::entity_t, atlas::scene_object)</li> <li>AxesOfController (atlas::event::joystick_info)</li> <li>attachments (atlas::renderpass_properties)</li> <li>add_query (atlas::scene_object)</li> <li>acquire_next_image (atlas::swapchain)</li> <li>append_world (atlas::system_registry)</li> <li>append_world_scope (atlas::system_registry)</li> <li>AllocateUniforms (atlas::vk::VulkanUniformBuffer)</li> <li>allocateDescriptor (atlas::vk::descriptor_pool)</li> <li>addPoolSize (atlas::vk::descriptor_pool::builder)</li> <li>addBinding (atlas::vk::descriptor_set_layout::builder)</li> <li>add_scene (atlas::world_scope)</li> </ul>"},{"location":"References/class_members/#b","title":"b","text":"<ul> <li>Binding (atlas::DescriptorSet)</li> <li>box_collider3d (atlas::box_collider3d)</li> <li>ButtonState (atlas::event::joystick_button)</li> <li>Buttons (atlas::event::joystick_info)</li> <li>ButtonsDown (atlas::event::joystick_info)</li> <li>begin (atlas::imgui_backend, atlas::render_context, atlas::renderer)</li> <li>bind (atlas::index_buffer, atlas::vertex_buffer)</li> <li>bind_to_index_buffer (atlas::index_buffer, atlas::vk::vk_index_buffer)</li> <li>broadphase_scale (atlas::physics::jolt_settings)</li> <li>begin_frame (atlas::render_context, atlas::vk::vk_renderer)</li> <li>Begin (atlas::renderpass)</li> <li>BeginRenderPass (atlas::renderpass, atlas::vk::VulkanRenderPass)</li> <li>BodyAtRuntime (atlas::rigidbody3d)</li> <li>BodyType (atlas::rigidbody3d)</li> <li>bind_vertex_buffer (atlas::vertex_buffer, atlas::vk::vk_vertex_buffer)</li> <li>BufferTutorial (atlas::vk::BufferTutorial)</li> <li>build (atlas::vk::descriptor_pool::builder, atlas::vk::descriptor_set_layout::builder, atlas::vk::descriptor_writer)</li> <li>builder (atlas::vk::descriptor_pool::builder, atlas::vk::descriptor_set_layout::builder)</li> <li>bindings (atlas::vk::descriptor_set_layout::builder, atlas::vk::descriptor_set_layout)</li> </ul>"},{"location":"References/class_members/#c","title":"c","text":"<ul> <li>Constant (atlas::PointLightUbo)</li> <li>constant (atlas::SpotLightUbo)</li> <li>cut_off (atlas::SpotLightUbo)</li> <li>current_api (atlas::application)</li> <li>camera (atlas::camera)</li> <li>camera_mouse_sensitivity (atlas::camera)</li> <li>camera_movement_sensitivity (atlas::camera)</li> <li>camera_sensitivity (atlas::camera)</li> <li>create_new_logger (atlas::console_log_manager)</li> <li>contains_indices (atlas::index_buffer, atlas::vk::vk_index_buffer)</li> <li>create (atlas::index_buffer, atlas::renderpass, atlas::shader, atlas::vertex_buffer, atlas::window)</li> <li>contact_bias_factor (atlas::physics::jolt_config)</li> <li>collision_filter_layer_count (atlas::physics::jolt_settings)</li> <li>create_new_object (atlas::scene_scope)</li> <li>current_frame_per_tick (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>create_world (atlas::system_registry)</li> <li>current_time (atlas::timer)</li> <li>Color (atlas::transform, atlas::vertex)</li> <li>Compute (atlas::vk::vk_physical_driver::queue_family_indices)</li> <li>current_frame_buffer (atlas::vk::vk_renderer)</li> <li>current_swapchain (atlas::vk::vk_window, atlas::window)</li> <li>close (atlas::window)</li> </ul>"},{"location":"References/class_members/#d","title":"d","text":"<ul> <li>DescriptorSetLayout (atlas::DescriptorSetLayout)</li> <li>Direction (atlas::DirectionalLightUbo, atlas::SpotLightUbo)</li> <li>diffuse (atlas::DirectionalLightUbo, atlas::PointLightUbo, atlas::SpotLightUbo)</li> <li>delta_time (atlas::application)</li> <li>destroy (atlas::application)</li> <li>density (atlas::box_collider3d)</li> <li>Down (atlas::camera)</li> <li>draw (atlas::index_buffer, atlas::vertex_buffer)</li> <li>default_collision_group (atlas::physics::jolt_settings)</li> <li>default_filter_mask (atlas::physics::jolt_settings)</li> <li>dispatch (atlas::thread)</li> <li>descriptor_info (atlas::vk::BufferTutorial)</li> <li>descriptor_info_at_index (atlas::vk::BufferTutorial)</li> <li>descriptor_pool (atlas::vk::descriptor_pool)</li> <li>descriptor_set_layout (atlas::vk::descriptor_set_layout)</li> <li>descriptor_writer (atlas::vk::descriptor_writer)</li> <li>DeviceMemory (atlas::vk::vk_swapchain::swapchain_depth_image)</li> </ul>"},{"location":"References/class_members/#e","title":"e","text":"<ul> <li>execute (atlas::application)</li> <li>EulerRotation (atlas::camera)</li> <li>entity_t (atlas::entity_t)</li> <li>entity (atlas::entity_t, atlas::scene_object)</li> <li>end (atlas::imgui_backend, atlas::render_context, atlas::renderer)</li> <li>enable_collision_callbacks (atlas::physics::jolt_config)</li> <li>enable_constraints (atlas::physics::jolt_config)</li> <li>enable_contacts (atlas::physics::jolt_config)</li> <li>end_frame (atlas::render_context, atlas::vk::vk_renderer)</li> <li>End (atlas::renderpass)</li> <li>EndRenderPass (atlas::renderpass, atlas::vk::VulkanRenderPass)</li> <li>elapsed (atlas::timer)</li> </ul>"},{"location":"References/class_members/#f","title":"f","text":"<ul> <li>friction (atlas::box_collider3d)</li> <li>fixed_time_step (atlas::physics::jolt_config)</li> <li>Filepath (atlas::rendertarget3d)</li> <li>flush (atlas::vk::BufferTutorial)</li> <li>flush_index (atlas::vk::BufferTutorial)</li> <li>freeDescriptors (atlas::vk::descriptor_pool)</li> </ul>"},{"location":"References/class_members/#g","title":"g","text":"<ul> <li>get_aspect_ratio (atlas::application, atlas::window)</li> <li>get_current_swapchain (atlas::application, atlas::window)</li> <li>get_window (atlas::application)</li> <li>get_front (atlas::camera)</li> <li>get_projection (atlas::camera)</li> <li>get_view (atlas::camera)</li> <li>get (atlas::console_log_manager, atlas::entity_t, atlas::scene_object, atlas::world_scope)</li> <li>get_mut (atlas::entity_t, atlas::scene_object)</li> <li>get_index_buffer (atlas::mesh)</li> <li>get_vertex_buffer (atlas::mesh)</li> <li>gravity (atlas::physics::jolt_config)</li> <li>get_current_frame (atlas::render_context, atlas::renderer)</li> <li>get_model (atlas::scene_object)</li> <li>get_tag (atlas::scene_scope, atlas::world_scope)</li> <li>get_graphics_pipeline (atlas::shader, atlas::vk::vk_shader)</li> <li>graphics_pipeline (atlas::shader, atlas::vk::vk_shader)</li> <li>get_current_per_tick (atlas::swapchain)</li> <li>get_extent (atlas::swapchain)</li> <li>get_framebuffer (atlas::swapchain)</li> <li>get_image_view (atlas::swapchain)</li> <li>get_images_size (atlas::swapchain)</li> <li>get_renderpass (atlas::swapchain)</li> <li>get_swapchain_format (atlas::swapchain)</li> <li>get_vk_swapchain (atlas::swapchain)</li> <li>get_world (atlas::system_registry)</li> <li>get_alignment_size (atlas::vk::BufferTutorial)</li> <li>get_buffer_instance (atlas::vk::BufferTutorial)</li> <li>get_instance_count (atlas::vk::BufferTutorial)</li> <li>get_instance_size (atlas::vk::BufferTutorial)</li> <li>get_usage_flags (atlas::vk::BufferTutorial)</li> <li>Get (atlas::vk::descriptor_set_layout)</li> <li>get_descriptor_set_layout (atlas::vk::descriptor_set_layout)</li> <li>get_current_driver (atlas::vk::vk_context)</li> <li>get_current_selected_physical_driver (atlas::vk::vk_context)</li> <li>get_vk_instance (atlas::vk::vk_context)</li> <li>get_graphics_queue (atlas::vk::vk_driver)</li> <li>Graphics (atlas::vk::vk_physical_driver::queue_family_indices)</li> <li>get_presentation_index (atlas::vk::vk_physical_driver)</li> <li>get_properties (atlas::vk::vk_physical_driver)</li> <li>get_queue_indices (atlas::vk::vk_physical_driver)</li> <li>get_current_command_buffer (atlas::vk::vk_renderer)</li> <li>get_current_command_buffer_index (atlas::vk::vk_renderer)</li> <li>get_vertex_attribute_description (atlas::vk::vk_shader)</li> <li>get_vertex_input_bind_description (atlas::vk::vk_shader)</li> <li>get_height (atlas::window)</li> <li>get_native_window (atlas::window)</li> <li>get_width (atlas::window)</li> <li>get_scene (atlas::world_scope)</li> </ul>"},{"location":"References/class_members/#h","title":"h","text":"<ul> <li>Height (atlas::application_settings)</li> <li>has (atlas::entity_t, atlas::scene_object)</li> <li>has_indices (atlas::index_buffer)</li> <li>height (atlas::renderpass_properties)</li> <li>HasFixation (atlas::rigidbody3d)</li> <li>highp_vec2 (atlas::vector2&lt; glm::highp_vec2 &gt;)</li> <li>highp_vec3 (atlas::vector3&lt; glm::highp_vec3 &gt;)</li> <li>highp_vec4 (atlas::vector4&lt; glm::highp_vec4 &gt;)</li> </ul>"},{"location":"References/class_members/#i","title":"i","text":"<ul> <li>Image (atlas::Image, atlas::vk::vk_swapchain::swapchain_depth_image, atlas::vk::vk_swapchain::swapchain_image)</li> <li>InitializeParallel (atlas::ParallelUpdateManager)</li> <li>IsMainCamera (atlas::camera)</li> <li>initialize_logger_manager (atlas::console_log_manager)</li> <li>is_alive (atlas::entity_t)</li> <li>ID (atlas::event::joystick_button, atlas::event::joystick_info)</li> <li>initialize (atlas::imgui_backend, atlas::render_context, atlas::renderer, atlas::swapchain, atlas::vk::vk_context)</li> <li>interpolation (atlas::interpolation)</li> <li>is_loaded (atlas::mesh)</li> <li>is_multithreaded (atlas::physics::jolt_settings)</li> <li>images_size (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>is_rebuild (atlas::swapchain)</li> <li>is_resized (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>invalidate (atlas::vk::BufferTutorial)</li> <li>invalidate_index (atlas::vk::BufferTutorial)</li> <li>initialization_validation_layers (atlas::vk::vk_context)</li> <li>initialize_instance_extensions (atlas::vk::vk_context)</li> <li>initialize_pipeline (atlas::vk::vk_renderer)</li> <li>initialize_graphics_pipeline (atlas::vk::vk_shader)</li> <li>initialize_shader_module (atlas::vk::vk_shader)</li> <li>is_active (atlas::window)</li> <li>ImageView (atlas::vk::vk_swapchain::swapchain_depth_image, atlas::vk::vk_swapchain::swapchain_image)</li> </ul>"},{"location":"References/class_members/#j","title":"j","text":"<ul> <li>JoystickName (atlas::event::joystick_info)</li> <li>Join (atlas::thread)</li> <li>Joinable (atlas::thread)</li> </ul>"},{"location":"References/class_members/#l","title":"l","text":"<ul> <li>Linear (atlas::PointLightUbo)</li> <li>linear (atlas::SpotLightUbo)</li> <li>Left (atlas::camera)</li> <li>linear_interpolate (atlas::interpolation)</li> <li>load (atlas::mesh)</li> </ul>"},{"location":"References/class_members/#m","title":"m","text":"<ul> <li>m_window (atlas::application, atlas::vk::vk_window)</li> <li>MouseSensitivity (atlas::camera)</li> <li>MovementSpeed (atlas::camera)</li> <li>m_entity_id (atlas::entity_t)</li> <li>m_index_buffer (atlas::mesh)</li> <li>m_vertex_buffer (atlas::mesh)</li> <li>mesh (atlas::mesh)</li> <li>max_bodies (atlas::physics::jolt_settings)</li> <li>max_body_pairs (atlas::physics::jolt_settings)</li> <li>max_contact_constraints (atlas::physics::jolt_settings)</li> <li>MeshMetaData (atlas::rendertarget3d)</li> <li>Model (atlas::rendertarget3d)</li> <li>m_angle (atlas::scene_object)</li> <li>m_entity (atlas::scene_object)</li> <li>m_model (atlas::scene_object)</li> <li>m_registry (atlas::scene_scope)</li> <li>m_tag (atlas::scene_scope, atlas::system_registry, atlas::thread, atlas::world_scope)</li> <li>m_current_scene_ctx (atlas::serializer)</li> <li>m_world_registered (atlas::system_registry)</li> <li>m_thread (atlas::thread)</li> <li>m_stop_watch (atlas::timer)</li> <li>m_value (atlas::vector2&lt; glm::highp_vec2 &gt;, atlas::vector3, atlas::vector3&lt; glm::highp_vec3 &gt;, atlas::vector4, atlas::vector4&lt; glm::highp_vec4 &gt;)</li> <li>m_alignment_size (atlas::vk::BufferTutorial)</li> <li>m_buffer_device_memory (atlas::vk::BufferTutorial)</li> <li>m_buffer_handler (atlas::vk::BufferTutorial)</li> <li>m_count (atlas::vk::BufferTutorial, atlas::vk::vk_vertex_buffer)</li> <li>m_instances_size (atlas::vk::BufferTutorial)</li> <li>m_mapped (atlas::vk::BufferTutorial)</li> <li>m_memory_property_flags (atlas::vk::BufferTutorial)</li> <li>m_size (atlas::vk::BufferTutorial)</li> <li>m_usage (atlas::vk::BufferTutorial)</li> <li>map (atlas::vk::BufferTutorial)</li> <li>m_RenderPassHandler (atlas::vk::VulkanRenderPass)</li> <li>MapWrite (atlas::vk::VulkanUniformBuffer)</li> <li>m_BufferMemory (atlas::vk::VulkanUniformBuffer)</li> <li>m_BufferObject (atlas::vk::VulkanUniformBuffer)</li> <li>maxSets (atlas::vk::descriptor_pool::builder)</li> <li>m_descriptor_pool (atlas::vk::descriptor_pool)</li> <li>m_descriptor_set_layout (atlas::vk::descriptor_set_layout)</li> <li>m_driver (atlas::vk::vk_driver, atlas::vk::vk_renderer, atlas::vk::vk_swapchain)</li> <li>m_graphics_queue (atlas::vk::vk_driver)</li> <li>m_has_indices (atlas::vk::vk_index_buffer)</li> <li>m_index_buffer_handler (atlas::vk::vk_index_buffer)</li> <li>m_index_device_buffer_memory (atlas::vk::vk_index_buffer)</li> <li>m_indices_count (atlas::vk::vk_index_buffer)</li> <li>m_physical (atlas::vk::vk_physical_driver, atlas::vk::vk_swapchain)</li> <li>m_physical_properties (atlas::vk::vk_physical_driver)</li> <li>m_queue_family_indices (atlas::vk::vk_physical_driver)</li> <li>m_queue_family_properties (atlas::vk::vk_physical_driver)</li> <li>m_command_pool (atlas::vk::vk_renderer)</li> <li>m_current_camera_component (atlas::vk::vk_renderer)</li> <li>m_is_frame_started (atlas::vk::vk_renderer)</li> <li>m_main_deletion_queue (atlas::vk::vk_renderer)</li> <li>m_pipeline_layout (atlas::vk::vk_renderer)</li> <li>m_scene_object_queue (atlas::vk::vk_renderer)</li> <li>m_fragment_shader_module (atlas::vk::vk_shader)</li> <li>m_graphics_pipeline (atlas::vk::vk_shader)</li> <li>m_vertex_shader_module (atlas::vk::vk_shader)</li> <li>m_current_frame_index (atlas::vk::vk_swapchain)</li> <li>m_current_image_index (atlas::vk::vk_swapchain)</li> <li>m_current_surface (atlas::vk::vk_swapchain)</li> <li>m_height (atlas::vk::vk_swapchain)</li> <li>m_is_resized_requested (atlas::vk::vk_swapchain)</li> <li>m_presentation_index (atlas::vk::vk_swapchain)</li> <li>m_presentation_mode (atlas::vk::vk_swapchain)</li> <li>m_presentation_queue (atlas::vk::vk_swapchain)</li> <li>m_semaphores_images_available (atlas::vk::vk_swapchain)</li> <li>m_semaphores_render_completed (atlas::vk::vk_swapchain)</li> <li>m_surface_format (atlas::vk::vk_swapchain)</li> <li>m_swapchain (atlas::vk::vk_swapchain, atlas::vk::vk_window)</li> <li>m_swapchain_command_buffers (atlas::vk::vk_swapchain)</li> <li>m_swapchain_command_pool (atlas::vk::vk_swapchain)</li> <li>m_swapchain_depth_images (atlas::vk::vk_swapchain)</li> <li>m_swapchain_extent (atlas::vk::vk_swapchain)</li> <li>m_swapchain_fences (atlas::vk::vk_swapchain)</li> <li>m_swapchain_framebuffers (atlas::vk::vk_swapchain)</li> <li>m_swapchain_images (atlas::vk::vk_swapchain)</li> <li>m_swapchain_in_flight_fences (atlas::vk::vk_swapchain)</li> <li>m_swapchain_renderpass (atlas::vk::vk_swapchain)</li> <li>m_width (atlas::vk::vk_swapchain)</li> <li>max_frames_in_flight (atlas::vk::vk_swapchain)</li> <li>m_vertex_buffer_device_memory (atlas::vk::vk_vertex_buffer)</li> <li>m_vertex_buffer_handler (atlas::vk::vk_vertex_buffer)</li> <li>m_surface (atlas::vk::vk_window)</li> <li>m_scene_container (atlas::world_scope)</li> <li>m_scene_registry (atlas::world_scope)</li> <li>m_world_shared_instance (atlas::world_scope)</li> </ul>"},{"location":"References/class_members/#n","title":"n","text":"<ul> <li>Name (atlas::application_settings, atlas::event::joystick_button)</li> <li>Normals (atlas::vertex)</li> <li>native_window (atlas::vk::vk_window, atlas::window)</li> </ul>"},{"location":"References/class_members/#o","title":"o","text":"<ul> <li>outer_cut_off (atlas::SpotLightUbo)</li> <li>offset (atlas::box_collider3d)</li> <li>on_destruction (atlas::entity_t)</li> <li>operations (atlas::renderpass_properties)</li> <li>on_resize (atlas::swapchain, atlas::vk::vk_window)</li> <li>operator= (atlas::vector2&lt; glm::highp_vec2 &gt;, atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;, atlas::vector3&lt; glm::highp_vec3 &gt;, atlas::vector4, atlas::vector4&lt; glm::highp_vec4 &gt;, atlas::vk::descriptor_pool, atlas::vk::descriptor_set_layout)</li> <li>operator== (atlas::vector2&lt; glm::highp_vec2 &gt;, atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;, atlas::vector3&lt; glm::highp_vec3 &gt;, atlas::vector4, atlas::vector4&lt; glm::highp_vec4 &gt;, atlas::vertex)</li> <li>overwrite (atlas::vk::descriptor_writer)</li> <li>operator VkDevice (atlas::vk::vk_driver)</li> <li>operator VkPhysicalDevice (atlas::vk::vk_physical_driver)</li> <li>on_create (atlas::vk::vk_swapchain)</li> <li>operator GLFWwindow * (atlas::window)</li> </ul>"},{"location":"References/class_members/#p","title":"p","text":"<ul> <li>ParallelUpdateManager (atlas::ParallelUpdateManager)</li> <li>Pipeline (atlas::Pipeline)</li> <li>Position (atlas::PointLightUbo, atlas::SpotLightUbo, atlas::camera, atlas::light, atlas::transform, atlas::vertex)</li> <li>physics_step (atlas::application)</li> <li>Projection (atlas::camera, atlas::camera_ubo)</li> <li>process_keyboard (atlas::camera)</li> <li>process_mouse_movement (atlas::camera)</li> <li>process_mouse_scroll (atlas::camera)</li> <li>PreviousButtonState (atlas::event::joystick_button)</li> <li>position_iterations (atlas::physics::jolt_config)</li> <li>physics_scene_position (atlas::physics::jolt_settings)</li> <li>physics_threads (atlas::physics::jolt_settings)</li> <li>poolFlags (atlas::vk::descriptor_pool::builder)</li> <li>poolSizes (atlas::vk::descriptor_pool::builder)</li> <li>pool (atlas::vk::descriptor_writer)</li> <li>PipelineColorBlendAttachments (atlas::vk::shader_pipeline_config)</li> <li>PipelineColorBlendCreateInfo (atlas::vk::shader_pipeline_config)</li> <li>PipelineDepthStencilCreateInfo (atlas::vk::shader_pipeline_config)</li> <li>PipelineInputAsmInfo (atlas::vk::shader_pipeline_config)</li> <li>PipelineLayout (atlas::vk::shader_pipeline_config)</li> <li>PipelineMultisampleCreateInfo (atlas::vk::shader_pipeline_config)</li> <li>PipelineRasterizationCreateInfo (atlas::vk::shader_pipeline_config)</li> <li>PipelineRenderPass (atlas::vk::shader_pipeline_config)</li> </ul>"},{"location":"References/class_members/#q","title":"q","text":"<ul> <li>Quadratic (atlas::PointLightUbo)</li> <li>quadratic (atlas::SpotLightUbo)</li> <li>query_builder (atlas::scene_scope)</li> <li>QuaternionRotation (atlas::transform)</li> </ul>"},{"location":"References/class_members/#r","title":"r","text":"<ul> <li>restitution (atlas::box_collider3d)</li> <li>restitutionThreshold (atlas::box_collider3d)</li> <li>Right (atlas::camera)</li> <li>remove (atlas::entity_t, atlas::scene_object)</li> <li>render_index_buffer (atlas::index_buffer, atlas::vk::vk_index_buffer)</li> <li>restitution_threshold (atlas::physics::jolt_config)</li> <li>rendertarget3d (atlas::rendertarget3d)</li> <li>rigidbody3d (atlas::rigidbody3d)</li> <li>read_acquire_next_frame (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>read_framebuffer (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>read_image_view (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>read_swapchain_extent (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>read_swapchain_format (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>read_swapchain_renderpass (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>recreate_swapchain (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>reset_build (atlas::swapchain)</li> <li>resize_status (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>reset (atlas::timer)</li> <li>Rotation (atlas::transform)</li> <li>render_vertex_buffer (atlas::vertex_buffer, atlas::vk::vk_vertex_buffer)</li> <li>read_mapped_data (atlas::vk::BufferTutorial)</li> <li>resetPool (atlas::vk::descriptor_pool)</li> <li>read_file (atlas::vk::vk_shader)</li> <li>resize_reset (atlas::vk::vk_swapchain)</li> <li>read_height (atlas::vk::vk_window, atlas::window)</li> <li>read_width (atlas::vk::vk_window, atlas::window)</li> </ul>"},{"location":"References/class_members/#s","title":"s","text":"<ul> <li>Set (atlas::DescriptorSet)</li> <li>specular (atlas::DirectionalLightUbo, atlas::PointLightUbo, atlas::SpotLightUbo)</li> <li>s_instance (atlas::application, atlas::system_registry, atlas::vk::vk_context)</li> <li>set_current_api (atlas::application)</li> <li>size (atlas::box_collider3d)</li> <li>set_mouse_speed (atlas::camera)</li> <li>set_movement_speed (atlas::camera)</li> <li>s_loggers (atlas::console_log_manager)</li> <li>set_current_logger (atlas::console_log_manager)</li> <li>set (atlas::entity_t, atlas::scene_object)</li> <li>sleep_angular_velocity_threshold (atlas::physics::jolt_config)</li> <li>sleep_velocity_threshold (atlas::physics::jolt_config)</li> <li>scene_object (atlas::scene_object)</li> <li>scene_scope (atlas::scene_scope)</li> <li>save_as (atlas::serializer)</li> <li>serializer (atlas::serializer)</li> <li>set_resize_status (atlas::swapchain)</li> <li>submit_and_write_command_buffer (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>submit_command_buffer (atlas::swapchain)</li> <li>swapchain_resized (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>search_world (atlas::system_registry)</li> <li>system_registry (atlas::system_registry)</li> <li>seconds (atlas::timer)</li> <li>Scale (atlas::transform)</li> <li>setMaxSets (atlas::vk::descriptor_pool::builder)</li> <li>setPoolFlags (atlas::vk::descriptor_pool::builder)</li> <li>setLayout (atlas::vk::descriptor_writer)</li> <li>Scissor (atlas::vk::shader_pipeline_config)</li> <li>SubpassCount (atlas::vk::shader_pipeline_config)</li> <li>s_driver (atlas::vk::vk_context)</li> <li>s_physical_driver (atlas::vk::vk_context)</li> <li>select_memory_type (atlas::vk::vk_driver, atlas::vk::vk_swapchain)</li> <li>search_memory_type (atlas::vk::vk_physical_driver)</li> <li>select_queue_family_indices (atlas::vk::vk_physical_driver)</li> <li>shader_configuration (atlas::vk::vk_shader)</li> <li>select_compatible_present_mode (atlas::vk::vk_swapchain)</li> <li>select_depth_format (atlas::vk::vk_swapchain)</li> <li>select_supported_format (atlas::vk::vk_swapchain)</li> <li>select_valid_extent (atlas::vk::vk_swapchain)</li> </ul>"},{"location":"References/class_members/#t","title":"t","text":"<ul> <li>time_before_sleep (atlas::physics::jolt_config)</li> <li>Type (atlas::rigidbody3d)</li> <li>TagMetadata (atlas::tag)</li> <li>thread (atlas::thread)</li> <li>timer (atlas::timer)</li> <li>TexCoords (atlas::vertex)</li> <li>Transfer (atlas::vk::vk_physical_driver::queue_family_indices)</li> </ul>"},{"location":"References/class_members/#u","title":"u","text":"<ul> <li>UniformBuffer (atlas::UniformBuffer)</li> <li>Up (atlas::camera)</li> <li>update_camera (atlas::camera)</li> <li>update_proj_view (atlas::camera)</li> <li>use_fixed_timestep (atlas::physics::jolt_config)</li> <li>use_4_layer_broadphase (atlas::physics::jolt_settings)</li> <li>unmap (atlas::vk::BufferTutorial)</li> </ul>"},{"location":"References/class_members/#v","title":"v","text":"<ul> <li>View (atlas::camera, atlas::camera_ubo)</li> <li>velocity_iterations (atlas::physics::jolt_config)</li> <li>vk_swapchain_handler (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>vector2 (atlas::vector2&lt; glm::highp_vec2 &gt;)</li> <li>vec3 (atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;)</li> <li>vector3 (atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;, atlas::vector3&lt; glm::highp_vec3 &gt;)</li> <li>value (atlas::vector3&lt; JPH::Vec3 &gt;)</li> <li>vec4 (atlas::vector4)</li> <li>vector4 (atlas::vector4, atlas::vector4&lt; glm::highp_vec4 &gt;)</li> <li>VulkanPipeline (atlas::vk::VulkanPipeline)</li> <li>VulkanRenderPass (atlas::vk::VulkanRenderPass)</li> <li>VulkanUniformBuffer (atlas::vk::VulkanUniformBuffer)</li> <li>Viewport (atlas::vk::shader_pipeline_config)</li> <li>vk_driver (atlas::vk::vk_driver)</li> <li>vk_index_buffer (atlas::vk::vk_index_buffer)</li> <li>vk_physical_driver (atlas::vk::vk_physical_driver)</li> <li>vk_renderer (atlas::vk::vk_renderer)</li> <li>vk_shader (atlas::vk::vk_shader)</li> <li>vk_swapchain (atlas::vk::vk_swapchain)</li> <li>vk_vertex_buffer (atlas::vk::vk_vertex_buffer)</li> <li>vk_window (atlas::vk::vk_window)</li> </ul>"},{"location":"References/class_members/#w","title":"w","text":"<ul> <li>Width (atlas::application_settings)</li> <li>WorldUp (atlas::camera)</li> <li>world_unit_scale (atlas::physics::jolt_config)</li> <li>world_bounds_max (atlas::physics::jolt_settings)</li> <li>world_bounds_min (atlas::physics::jolt_settings)</li> <li>width (atlas::renderpass_properties)</li> <li>world (atlas::scene_scope)</li> <li>write_to_buffer (atlas::vk::BufferTutorial)</li> <li>write_to_index (atlas::vk::BufferTutorial)</li> <li>writeBuffer (atlas::vk::descriptor_writer)</li> <li>writeImage (atlas::vk::descriptor_writer)</li> <li>writes (atlas::vk::descriptor_writer)</li> <li>world &amp; (atlas::world_scope)</li> <li>world_scope (atlas::world_scope)</li> </ul>"},{"location":"References/class_members/#z","title":"z","text":"<ul> <li>Zoom (atlas::camera)</li> </ul>"},{"location":"References/class_members/#_1","title":"~","text":"<ul> <li>~application (atlas::application)</li> <li>~entity_t (atlas::entity_t)</li> <li>~index_buffer (atlas::index_buffer)</li> <li>~render_context (atlas::render_context)</li> <li>~scene_object (atlas::scene_object)</li> <li>~scene_scope (atlas::scene_scope)</li> <li>~shader (atlas::shader)</li> <li>~swapchain (atlas::swapchain)</li> <li>~system_registry (atlas::system_registry)</li> <li>~thread (atlas::thread)</li> <li>~vertex_buffer (atlas::vertex_buffer)</li> <li>~descriptor_pool (atlas::vk::descriptor_pool)</li> <li>~descriptor_set_layout (atlas::vk::descriptor_set_layout)</li> <li>~vk_index_buffer (atlas::vk::vk_index_buffer)</li> <li>~vk_renderer (atlas::vk::vk_renderer)</li> <li>~vk_shader (atlas::vk::vk_shader)</li> <li>~vk_swapchain (atlas::vk::vk_swapchain)</li> <li>~vk_vertex_buffer (atlas::vk::vk_vertex_buffer)</li> <li>~vk_window (atlas::vk::vk_window)</li> <li>~window (atlas::window)</li> <li>~world_scope (atlas::world_scope)</li> </ul>"},{"location":"References/class_member_functions/","title":"Class Member Functions","text":""},{"location":"References/class_member_functions/#a","title":"a","text":"<ul> <li>application (atlas::application)</li> <li>add (atlas::entity_t, atlas::scene_object)</li> <li>add_query (atlas::scene_object)</li> <li>acquire_next_image (atlas::swapchain)</li> <li>append_world (atlas::system_registry)</li> <li>append_world_scope (atlas::system_registry)</li> <li>AllocateUniforms (atlas::vk::VulkanUniformBuffer)</li> <li>allocateDescriptor (atlas::vk::descriptor_pool)</li> <li>addPoolSize (atlas::vk::descriptor_pool::builder)</li> <li>addBinding (atlas::vk::descriptor_set_layout::builder)</li> <li>add_scene (atlas::world_scope)</li> </ul>"},{"location":"References/class_member_functions/#b","title":"b","text":"<ul> <li>box_collider3d (atlas::box_collider3d)</li> <li>begin (atlas::imgui_backend, atlas::render_context, atlas::renderer)</li> <li>bind (atlas::index_buffer, atlas::vertex_buffer)</li> <li>bind_to_index_buffer (atlas::index_buffer, atlas::vk::vk_index_buffer)</li> <li>begin_frame (atlas::render_context, atlas::vk::vk_renderer)</li> <li>Begin (atlas::renderpass)</li> <li>BeginRenderPass (atlas::renderpass, atlas::vk::VulkanRenderPass)</li> <li>bind_vertex_buffer (atlas::vertex_buffer, atlas::vk::vk_vertex_buffer)</li> <li>BufferTutorial (atlas::vk::BufferTutorial)</li> <li>build (atlas::vk::descriptor_pool::builder, atlas::vk::descriptor_set_layout::builder, atlas::vk::descriptor_writer)</li> <li>builder (atlas::vk::descriptor_pool::builder, atlas::vk::descriptor_set_layout::builder)</li> </ul>"},{"location":"References/class_member_functions/#c","title":"c","text":"<ul> <li>current_api (atlas::application)</li> <li>camera (atlas::camera)</li> <li>camera_sensitivity (atlas::camera)</li> <li>create_new_logger (atlas::console_log_manager)</li> <li>contains_indices (atlas::index_buffer, atlas::vk::vk_index_buffer)</li> <li>create (atlas::index_buffer, atlas::renderpass, atlas::shader, atlas::vertex_buffer, atlas::window)</li> <li>create_new_object (atlas::scene_scope)</li> <li>current_frame_per_tick (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>create_world (atlas::system_registry)</li> <li>current_time (atlas::timer)</li> <li>current_frame_buffer (atlas::vk::vk_renderer)</li> <li>current_swapchain (atlas::vk::vk_window, atlas::window)</li> <li>close (atlas::window)</li> </ul>"},{"location":"References/class_member_functions/#d","title":"d","text":"<ul> <li>DescriptorSetLayout (atlas::DescriptorSetLayout)</li> <li>delta_time (atlas::application)</li> <li>destroy (atlas::application)</li> <li>draw (atlas::index_buffer, atlas::vertex_buffer)</li> <li>dispatch (atlas::thread)</li> <li>descriptor_info (atlas::vk::BufferTutorial)</li> <li>descriptor_info_at_index (atlas::vk::BufferTutorial)</li> <li>descriptor_pool (atlas::vk::descriptor_pool)</li> <li>descriptor_set_layout (atlas::vk::descriptor_set_layout)</li> <li>descriptor_writer (atlas::vk::descriptor_writer)</li> </ul>"},{"location":"References/class_member_functions/#e","title":"e","text":"<ul> <li>execute (atlas::application)</li> <li>entity_t (atlas::entity_t)</li> <li>entity (atlas::entity_t, atlas::scene_object)</li> <li>end (atlas::imgui_backend, atlas::render_context, atlas::renderer)</li> <li>end_frame (atlas::render_context, atlas::vk::vk_renderer)</li> <li>End (atlas::renderpass)</li> <li>EndRenderPass (atlas::renderpass, atlas::vk::VulkanRenderPass)</li> <li>elapsed (atlas::timer)</li> </ul>"},{"location":"References/class_member_functions/#f","title":"f","text":"<ul> <li>flush (atlas::vk::BufferTutorial)</li> <li>flush_index (atlas::vk::BufferTutorial)</li> <li>freeDescriptors (atlas::vk::descriptor_pool)</li> </ul>"},{"location":"References/class_member_functions/#g","title":"g","text":"<ul> <li>get_aspect_ratio (atlas::application, atlas::window)</li> <li>get_current_swapchain (atlas::application, atlas::window)</li> <li>get_window (atlas::application)</li> <li>get_front (atlas::camera)</li> <li>get_projection (atlas::camera)</li> <li>get_view (atlas::camera)</li> <li>get (atlas::console_log_manager, atlas::entity_t, atlas::scene_object, atlas::world_scope)</li> <li>get_mut (atlas::entity_t, atlas::scene_object)</li> <li>get_index_buffer (atlas::mesh)</li> <li>get_vertex_buffer (atlas::mesh)</li> <li>get_current_frame (atlas::render_context, atlas::renderer)</li> <li>get_model (atlas::scene_object)</li> <li>get_tag (atlas::scene_scope, atlas::world_scope)</li> <li>get_graphics_pipeline (atlas::shader, atlas::vk::vk_shader)</li> <li>graphics_pipeline (atlas::shader, atlas::vk::vk_shader)</li> <li>get_current_per_tick (atlas::swapchain)</li> <li>get_extent (atlas::swapchain)</li> <li>get_framebuffer (atlas::swapchain)</li> <li>get_image_view (atlas::swapchain)</li> <li>get_images_size (atlas::swapchain)</li> <li>get_renderpass (atlas::swapchain)</li> <li>get_swapchain_format (atlas::swapchain)</li> <li>get_vk_swapchain (atlas::swapchain)</li> <li>get_world (atlas::system_registry)</li> <li>get_alignment_size (atlas::vk::BufferTutorial)</li> <li>get_buffer_instance (atlas::vk::BufferTutorial)</li> <li>get_instance_count (atlas::vk::BufferTutorial)</li> <li>get_instance_size (atlas::vk::BufferTutorial)</li> <li>get_usage_flags (atlas::vk::BufferTutorial)</li> <li>Get (atlas::vk::descriptor_set_layout)</li> <li>get_descriptor_set_layout (atlas::vk::descriptor_set_layout)</li> <li>get_current_driver (atlas::vk::vk_context)</li> <li>get_current_selected_physical_driver (atlas::vk::vk_context)</li> <li>get_vk_instance (atlas::vk::vk_context)</li> <li>get_graphics_queue (atlas::vk::vk_driver)</li> <li>get_presentation_index (atlas::vk::vk_physical_driver)</li> <li>get_properties (atlas::vk::vk_physical_driver)</li> <li>get_queue_indices (atlas::vk::vk_physical_driver)</li> <li>get_current_command_buffer (atlas::vk::vk_renderer)</li> <li>get_current_command_buffer_index (atlas::vk::vk_renderer)</li> <li>get_vertex_attribute_description (atlas::vk::vk_shader)</li> <li>get_vertex_input_bind_description (atlas::vk::vk_shader)</li> <li>get_height (atlas::window)</li> <li>get_native_window (atlas::window)</li> <li>get_width (atlas::window)</li> <li>get_scene (atlas::world_scope)</li> </ul>"},{"location":"References/class_member_functions/#h","title":"h","text":"<ul> <li>has (atlas::entity_t, atlas::scene_object)</li> <li>has_indices (atlas::index_buffer)</li> <li>highp_vec2 (atlas::vector2&lt; glm::highp_vec2 &gt;)</li> <li>highp_vec3 (atlas::vector3&lt; glm::highp_vec3 &gt;)</li> <li>highp_vec4 (atlas::vector4&lt; glm::highp_vec4 &gt;)</li> </ul>"},{"location":"References/class_member_functions/#i","title":"i","text":"<ul> <li>Image (atlas::Image)</li> <li>InitializeParallel (atlas::ParallelUpdateManager)</li> <li>initialize_logger_manager (atlas::console_log_manager)</li> <li>is_alive (atlas::entity_t)</li> <li>initialize (atlas::imgui_backend, atlas::render_context, atlas::renderer, atlas::swapchain, atlas::vk::vk_context)</li> <li>interpolation (atlas::interpolation)</li> <li>is_loaded (atlas::mesh)</li> <li>images_size (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>is_rebuild (atlas::swapchain)</li> <li>is_resized (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>invalidate (atlas::vk::BufferTutorial)</li> <li>invalidate_index (atlas::vk::BufferTutorial)</li> <li>initialization_validation_layers (atlas::vk::vk_context)</li> <li>initialize_instance_extensions (atlas::vk::vk_context)</li> <li>initialize_pipeline (atlas::vk::vk_renderer)</li> <li>initialize_graphics_pipeline (atlas::vk::vk_shader)</li> <li>initialize_shader_module (atlas::vk::vk_shader)</li> <li>is_active (atlas::window)</li> </ul>"},{"location":"References/class_member_functions/#j","title":"j","text":"<ul> <li>Join (atlas::thread)</li> <li>Joinable (atlas::thread)</li> </ul>"},{"location":"References/class_member_functions/#l","title":"l","text":"<ul> <li>linear_interpolate (atlas::interpolation)</li> <li>load (atlas::mesh)</li> </ul>"},{"location":"References/class_member_functions/#m","title":"m","text":"<ul> <li>mesh (atlas::mesh)</li> <li>map (atlas::vk::BufferTutorial)</li> <li>MapWrite (atlas::vk::VulkanUniformBuffer)</li> </ul>"},{"location":"References/class_member_functions/#n","title":"n","text":"<ul> <li>native_window (atlas::vk::vk_window, atlas::window)</li> </ul>"},{"location":"References/class_member_functions/#o","title":"o","text":"<ul> <li>on_destruction (atlas::entity_t)</li> <li>on_resize (atlas::swapchain, atlas::vk::vk_window)</li> <li>operator= (atlas::vector2&lt; glm::highp_vec2 &gt;, atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;, atlas::vector3&lt; glm::highp_vec3 &gt;, atlas::vector4, atlas::vector4&lt; glm::highp_vec4 &gt;, atlas::vk::descriptor_pool, atlas::vk::descriptor_set_layout)</li> <li>operator== (atlas::vector2&lt; glm::highp_vec2 &gt;, atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;, atlas::vector3&lt; glm::highp_vec3 &gt;, atlas::vector4, atlas::vector4&lt; glm::highp_vec4 &gt;, atlas::vertex)</li> <li>overwrite (atlas::vk::descriptor_writer)</li> <li>operator VkDevice (atlas::vk::vk_driver)</li> <li>operator VkPhysicalDevice (atlas::vk::vk_physical_driver)</li> <li>on_create (atlas::vk::vk_swapchain)</li> <li>operator GLFWwindow * (atlas::window)</li> </ul>"},{"location":"References/class_member_functions/#p","title":"p","text":"<ul> <li>ParallelUpdateManager (atlas::ParallelUpdateManager)</li> <li>Pipeline (atlas::Pipeline)</li> <li>physics_step (atlas::application)</li> <li>process_keyboard (atlas::camera)</li> <li>process_mouse_movement (atlas::camera)</li> <li>process_mouse_scroll (atlas::camera)</li> </ul>"},{"location":"References/class_member_functions/#q","title":"q","text":"<ul> <li>query_builder (atlas::scene_scope)</li> </ul>"},{"location":"References/class_member_functions/#r","title":"r","text":"<ul> <li>remove (atlas::entity_t, atlas::scene_object)</li> <li>render_index_buffer (atlas::index_buffer, atlas::vk::vk_index_buffer)</li> <li>rendertarget3d (atlas::rendertarget3d)</li> <li>rigidbody3d (atlas::rigidbody3d)</li> <li>read_acquire_next_frame (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>read_framebuffer (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>read_image_view (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>read_swapchain_extent (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>read_swapchain_format (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>read_swapchain_renderpass (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>recreate_swapchain (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>reset_build (atlas::swapchain)</li> <li>resize_status (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>reset (atlas::timer)</li> <li>render_vertex_buffer (atlas::vertex_buffer, atlas::vk::vk_vertex_buffer)</li> <li>read_mapped_data (atlas::vk::BufferTutorial)</li> <li>resetPool (atlas::vk::descriptor_pool)</li> <li>read_file (atlas::vk::vk_shader)</li> <li>resize_reset (atlas::vk::vk_swapchain)</li> <li>read_height (atlas::vk::vk_window, atlas::window)</li> <li>read_width (atlas::vk::vk_window, atlas::window)</li> </ul>"},{"location":"References/class_member_functions/#s","title":"s","text":"<ul> <li>set_current_api (atlas::application)</li> <li>set_mouse_speed (atlas::camera)</li> <li>set_movement_speed (atlas::camera)</li> <li>set_current_logger (atlas::console_log_manager)</li> <li>set (atlas::entity_t, atlas::scene_object)</li> <li>scene_object (atlas::scene_object)</li> <li>scene_scope (atlas::scene_scope)</li> <li>save_as (atlas::serializer)</li> <li>serializer (atlas::serializer)</li> <li>set_resize_status (atlas::swapchain)</li> <li>submit_and_write_command_buffer (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>submit_command_buffer (atlas::swapchain)</li> <li>swapchain_resized (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>search_world (atlas::system_registry)</li> <li>system_registry (atlas::system_registry)</li> <li>seconds (atlas::timer)</li> <li>setMaxSets (atlas::vk::descriptor_pool::builder)</li> <li>setPoolFlags (atlas::vk::descriptor_pool::builder)</li> <li>select_memory_type (atlas::vk::vk_driver, atlas::vk::vk_swapchain)</li> <li>search_memory_type (atlas::vk::vk_physical_driver)</li> <li>select_queue_family_indices (atlas::vk::vk_physical_driver)</li> <li>shader_configuration (atlas::vk::vk_shader)</li> <li>select_compatible_present_mode (atlas::vk::vk_swapchain)</li> <li>select_depth_format (atlas::vk::vk_swapchain)</li> <li>select_supported_format (atlas::vk::vk_swapchain)</li> <li>select_valid_extent (atlas::vk::vk_swapchain)</li> </ul>"},{"location":"References/class_member_functions/#t","title":"t","text":"<ul> <li>thread (atlas::thread)</li> <li>timer (atlas::timer)</li> </ul>"},{"location":"References/class_member_functions/#u","title":"u","text":"<ul> <li>UniformBuffer (atlas::UniformBuffer)</li> <li>update_camera (atlas::camera)</li> <li>update_proj_view (atlas::camera)</li> <li>unmap (atlas::vk::BufferTutorial)</li> </ul>"},{"location":"References/class_member_functions/#v","title":"v","text":"<ul> <li>vk_swapchain_handler (atlas::swapchain, atlas::vk::vk_swapchain)</li> <li>vector2 (atlas::vector2&lt; glm::highp_vec2 &gt;)</li> <li>vec3 (atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;)</li> <li>vector3 (atlas::vector3, atlas::vector3&lt; JPH::Vec3 &gt;, atlas::vector3&lt; glm::highp_vec3 &gt;)</li> <li>vec4 (atlas::vector4)</li> <li>vector4 (atlas::vector4, atlas::vector4&lt; glm::highp_vec4 &gt;)</li> <li>VulkanPipeline (atlas::vk::VulkanPipeline)</li> <li>VulkanRenderPass (atlas::vk::VulkanRenderPass)</li> <li>VulkanUniformBuffer (atlas::vk::VulkanUniformBuffer)</li> <li>vk_driver (atlas::vk::vk_driver)</li> <li>vk_index_buffer (atlas::vk::vk_index_buffer)</li> <li>vk_physical_driver (atlas::vk::vk_physical_driver)</li> <li>vk_renderer (atlas::vk::vk_renderer)</li> <li>vk_shader (atlas::vk::vk_shader)</li> <li>vk_swapchain (atlas::vk::vk_swapchain)</li> <li>vk_vertex_buffer (atlas::vk::vk_vertex_buffer)</li> <li>vk_window (atlas::vk::vk_window)</li> </ul>"},{"location":"References/class_member_functions/#w","title":"w","text":"<ul> <li>world (atlas::scene_scope)</li> <li>write_to_buffer (atlas::vk::BufferTutorial)</li> <li>write_to_index (atlas::vk::BufferTutorial)</li> <li>writeBuffer (atlas::vk::descriptor_writer)</li> <li>writeImage (atlas::vk::descriptor_writer)</li> <li>world &amp; (atlas::world_scope)</li> <li>world_scope (atlas::world_scope)</li> </ul>"},{"location":"References/class_member_functions/#_1","title":"~","text":"<ul> <li>~application (atlas::application)</li> <li>~entity_t (atlas::entity_t)</li> <li>~index_buffer (atlas::index_buffer)</li> <li>~render_context (atlas::render_context)</li> <li>~scene_object (atlas::scene_object)</li> <li>~scene_scope (atlas::scene_scope)</li> <li>~shader (atlas::shader)</li> <li>~swapchain (atlas::swapchain)</li> <li>~system_registry (atlas::system_registry)</li> <li>~thread (atlas::thread)</li> <li>~vertex_buffer (atlas::vertex_buffer)</li> <li>~descriptor_pool (atlas::vk::descriptor_pool)</li> <li>~descriptor_set_layout (atlas::vk::descriptor_set_layout)</li> <li>~vk_index_buffer (atlas::vk::vk_index_buffer)</li> <li>~vk_renderer (atlas::vk::vk_renderer)</li> <li>~vk_shader (atlas::vk::vk_shader)</li> <li>~vk_swapchain (atlas::vk::vk_swapchain)</li> <li>~vk_vertex_buffer (atlas::vk::vk_vertex_buffer)</li> <li>~vk_window (atlas::vk::vk_window)</li> <li>~window (atlas::window)</li> <li>~world_scope (atlas::world_scope)</li> </ul>"},{"location":"References/class_member_variables/","title":"Class Member Variables","text":""},{"location":"References/class_member_variables/#a","title":"a","text":"<ul> <li>ambient (atlas::DirectionalLightUbo, atlas::PointLightUbo, atlas::SpotLightUbo)</li> <li>AspectRatio (atlas::camera)</li> <li>AxesOfController (atlas::event::joystick_info)</li> <li>attachments (atlas::renderpass_properties)</li> </ul>"},{"location":"References/class_member_variables/#b","title":"b","text":"<ul> <li>Binding (atlas::DescriptorSet)</li> <li>ButtonState (atlas::event::joystick_button)</li> <li>Buttons (atlas::event::joystick_info)</li> <li>ButtonsDown (atlas::event::joystick_info)</li> <li>broadphase_scale (atlas::physics::jolt_settings)</li> <li>BodyAtRuntime (atlas::rigidbody3d)</li> <li>bindings (atlas::vk::descriptor_set_layout::builder, atlas::vk::descriptor_set_layout)</li> </ul>"},{"location":"References/class_member_variables/#c","title":"c","text":"<ul> <li>Constant (atlas::PointLightUbo)</li> <li>constant (atlas::SpotLightUbo)</li> <li>cut_off (atlas::SpotLightUbo)</li> <li>camera_mouse_sensitivity (atlas::camera)</li> <li>camera_movement_sensitivity (atlas::camera)</li> <li>contact_bias_factor (atlas::physics::jolt_config)</li> <li>collision_filter_layer_count (atlas::physics::jolt_settings)</li> <li>Color (atlas::transform, atlas::vertex)</li> <li>Compute (atlas::vk::vk_physical_driver::queue_family_indices)</li> </ul>"},{"location":"References/class_member_variables/#d","title":"d","text":"<ul> <li>Direction (atlas::DirectionalLightUbo, atlas::SpotLightUbo)</li> <li>diffuse (atlas::DirectionalLightUbo, atlas::PointLightUbo, atlas::SpotLightUbo)</li> <li>density (atlas::box_collider3d)</li> <li>Down (atlas::camera)</li> <li>default_collision_group (atlas::physics::jolt_settings)</li> <li>default_filter_mask (atlas::physics::jolt_settings)</li> <li>DeviceMemory (atlas::vk::vk_swapchain::swapchain_depth_image)</li> </ul>"},{"location":"References/class_member_variables/#e","title":"e","text":"<ul> <li>EulerRotation (atlas::camera)</li> <li>enable_collision_callbacks (atlas::physics::jolt_config)</li> <li>enable_constraints (atlas::physics::jolt_config)</li> <li>enable_contacts (atlas::physics::jolt_config)</li> </ul>"},{"location":"References/class_member_variables/#f","title":"f","text":"<ul> <li>friction (atlas::box_collider3d)</li> <li>fixed_time_step (atlas::physics::jolt_config)</li> <li>Filepath (atlas::rendertarget3d)</li> </ul>"},{"location":"References/class_member_variables/#g","title":"g","text":"<ul> <li>gravity (atlas::physics::jolt_config)</li> <li>Graphics (atlas::vk::vk_physical_driver::queue_family_indices)</li> </ul>"},{"location":"References/class_member_variables/#h","title":"h","text":"<ul> <li>Height (atlas::application_settings)</li> <li>height (atlas::renderpass_properties)</li> <li>HasFixation (atlas::rigidbody3d)</li> </ul>"},{"location":"References/class_member_variables/#i","title":"i","text":"<ul> <li>IsMainCamera (atlas::camera)</li> <li>ID (atlas::event::joystick_button, atlas::event::joystick_info)</li> <li>is_multithreaded (atlas::physics::jolt_settings)</li> <li>Image (atlas::vk::vk_swapchain::swapchain_depth_image, atlas::vk::vk_swapchain::swapchain_image)</li> <li>ImageView (atlas::vk::vk_swapchain::swapchain_depth_image, atlas::vk::vk_swapchain::swapchain_image)</li> </ul>"},{"location":"References/class_member_variables/#j","title":"j","text":"<ul> <li>JoystickName (atlas::event::joystick_info)</li> </ul>"},{"location":"References/class_member_variables/#l","title":"l","text":"<ul> <li>Linear (atlas::PointLightUbo)</li> <li>linear (atlas::SpotLightUbo)</li> <li>Left (atlas::camera)</li> </ul>"},{"location":"References/class_member_variables/#m","title":"m","text":"<ul> <li>m_window (atlas::application, atlas::vk::vk_window)</li> <li>MouseSensitivity (atlas::camera)</li> <li>MovementSpeed (atlas::camera)</li> <li>m_entity_id (atlas::entity_t)</li> <li>m_index_buffer (atlas::mesh)</li> <li>m_vertex_buffer (atlas::mesh)</li> <li>max_bodies (atlas::physics::jolt_settings)</li> <li>max_body_pairs (atlas::physics::jolt_settings)</li> <li>max_contact_constraints (atlas::physics::jolt_settings)</li> <li>MeshMetaData (atlas::rendertarget3d)</li> <li>Model (atlas::rendertarget3d)</li> <li>m_angle (atlas::scene_object)</li> <li>m_entity (atlas::scene_object)</li> <li>m_model (atlas::scene_object)</li> <li>m_registry (atlas::scene_scope)</li> <li>m_tag (atlas::scene_scope, atlas::system_registry, atlas::thread, atlas::world_scope)</li> <li>m_current_scene_ctx (atlas::serializer)</li> <li>m_world_registered (atlas::system_registry)</li> <li>m_thread (atlas::thread)</li> <li>m_stop_watch (atlas::timer)</li> <li>m_value (atlas::vector2&lt; glm::highp_vec2 &gt;, atlas::vector3, atlas::vector3&lt; glm::highp_vec3 &gt;, atlas::vector4, atlas::vector4&lt; glm::highp_vec4 &gt;)</li> <li>m_alignment_size (atlas::vk::BufferTutorial)</li> <li>m_buffer_device_memory (atlas::vk::BufferTutorial)</li> <li>m_buffer_handler (atlas::vk::BufferTutorial)</li> <li>m_count (atlas::vk::BufferTutorial, atlas::vk::vk_vertex_buffer)</li> <li>m_instances_size (atlas::vk::BufferTutorial)</li> <li>m_mapped (atlas::vk::BufferTutorial)</li> <li>m_memory_property_flags (atlas::vk::BufferTutorial)</li> <li>m_size (atlas::vk::BufferTutorial)</li> <li>m_usage (atlas::vk::BufferTutorial)</li> <li>m_RenderPassHandler (atlas::vk::VulkanRenderPass)</li> <li>m_BufferMemory (atlas::vk::VulkanUniformBuffer)</li> <li>m_BufferObject (atlas::vk::VulkanUniformBuffer)</li> <li>maxSets (atlas::vk::descriptor_pool::builder)</li> <li>m_descriptor_pool (atlas::vk::descriptor_pool)</li> <li>m_descriptor_set_layout (atlas::vk::descriptor_set_layout)</li> <li>m_driver (atlas::vk::vk_driver, atlas::vk::vk_renderer, atlas::vk::vk_swapchain)</li> <li>m_graphics_queue (atlas::vk::vk_driver)</li> <li>m_has_indices (atlas::vk::vk_index_buffer)</li> <li>m_index_buffer_handler (atlas::vk::vk_index_buffer)</li> <li>m_index_device_buffer_memory (atlas::vk::vk_index_buffer)</li> <li>m_indices_count (atlas::vk::vk_index_buffer)</li> <li>m_physical (atlas::vk::vk_physical_driver, atlas::vk::vk_swapchain)</li> <li>m_physical_properties (atlas::vk::vk_physical_driver)</li> <li>m_queue_family_indices (atlas::vk::vk_physical_driver)</li> <li>m_queue_family_properties (atlas::vk::vk_physical_driver)</li> <li>m_command_pool (atlas::vk::vk_renderer)</li> <li>m_current_camera_component (atlas::vk::vk_renderer)</li> <li>m_is_frame_started (atlas::vk::vk_renderer)</li> <li>m_main_deletion_queue (atlas::vk::vk_renderer)</li> <li>m_pipeline_layout (atlas::vk::vk_renderer)</li> <li>m_scene_object_queue (atlas::vk::vk_renderer)</li> <li>m_fragment_shader_module (atlas::vk::vk_shader)</li> <li>m_graphics_pipeline (atlas::vk::vk_shader)</li> <li>m_vertex_shader_module (atlas::vk::vk_shader)</li> <li>m_current_frame_index (atlas::vk::vk_swapchain)</li> <li>m_current_image_index (atlas::vk::vk_swapchain)</li> <li>m_current_surface (atlas::vk::vk_swapchain)</li> <li>m_height (atlas::vk::vk_swapchain)</li> <li>m_is_resized_requested (atlas::vk::vk_swapchain)</li> <li>m_presentation_index (atlas::vk::vk_swapchain)</li> <li>m_presentation_mode (atlas::vk::vk_swapchain)</li> <li>m_presentation_queue (atlas::vk::vk_swapchain)</li> <li>m_semaphores_images_available (atlas::vk::vk_swapchain)</li> <li>m_semaphores_render_completed (atlas::vk::vk_swapchain)</li> <li>m_surface_format (atlas::vk::vk_swapchain)</li> <li>m_swapchain (atlas::vk::vk_swapchain, atlas::vk::vk_window)</li> <li>m_swapchain_command_buffers (atlas::vk::vk_swapchain)</li> <li>m_swapchain_command_pool (atlas::vk::vk_swapchain)</li> <li>m_swapchain_depth_images (atlas::vk::vk_swapchain)</li> <li>m_swapchain_extent (atlas::vk::vk_swapchain)</li> <li>m_swapchain_fences (atlas::vk::vk_swapchain)</li> <li>m_swapchain_framebuffers (atlas::vk::vk_swapchain)</li> <li>m_swapchain_images (atlas::vk::vk_swapchain)</li> <li>m_swapchain_in_flight_fences (atlas::vk::vk_swapchain)</li> <li>m_swapchain_renderpass (atlas::vk::vk_swapchain)</li> <li>m_width (atlas::vk::vk_swapchain)</li> <li>max_frames_in_flight (atlas::vk::vk_swapchain)</li> <li>m_vertex_buffer_device_memory (atlas::vk::vk_vertex_buffer)</li> <li>m_vertex_buffer_handler (atlas::vk::vk_vertex_buffer)</li> <li>m_surface (atlas::vk::vk_window)</li> <li>m_scene_container (atlas::world_scope)</li> <li>m_scene_registry (atlas::world_scope)</li> <li>m_world_shared_instance (atlas::world_scope)</li> </ul>"},{"location":"References/class_member_variables/#n","title":"n","text":"<ul> <li>Name (atlas::application_settings, atlas::event::joystick_button)</li> <li>Normals (atlas::vertex)</li> </ul>"},{"location":"References/class_member_variables/#o","title":"o","text":"<ul> <li>outer_cut_off (atlas::SpotLightUbo)</li> <li>offset (atlas::box_collider3d)</li> <li>operations (atlas::renderpass_properties)</li> </ul>"},{"location":"References/class_member_variables/#p","title":"p","text":"<ul> <li>Position (atlas::PointLightUbo, atlas::SpotLightUbo, atlas::camera, atlas::light, atlas::transform, atlas::vertex)</li> <li>Projection (atlas::camera, atlas::camera_ubo)</li> <li>PreviousButtonState (atlas::event::joystick_button)</li> <li>position_iterations (atlas::physics::jolt_config)</li> <li>physics_scene_position (atlas::physics::jolt_settings)</li> <li>physics_threads (atlas::physics::jolt_settings)</li> <li>poolFlags (atlas::vk::descriptor_pool::builder)</li> <li>poolSizes (atlas::vk::descriptor_pool::builder)</li> <li>pool (atlas::vk::descriptor_writer)</li> <li>PipelineColorBlendAttachments (atlas::vk::shader_pipeline_config)</li> <li>PipelineColorBlendCreateInfo (atlas::vk::shader_pipeline_config)</li> <li>PipelineDepthStencilCreateInfo (atlas::vk::shader_pipeline_config)</li> <li>PipelineInputAsmInfo (atlas::vk::shader_pipeline_config)</li> <li>PipelineLayout (atlas::vk::shader_pipeline_config)</li> <li>PipelineMultisampleCreateInfo (atlas::vk::shader_pipeline_config)</li> <li>PipelineRasterizationCreateInfo (atlas::vk::shader_pipeline_config)</li> <li>PipelineRenderPass (atlas::vk::shader_pipeline_config)</li> </ul>"},{"location":"References/class_member_variables/#q","title":"q","text":"<ul> <li>Quadratic (atlas::PointLightUbo)</li> <li>quadratic (atlas::SpotLightUbo)</li> <li>QuaternionRotation (atlas::transform)</li> </ul>"},{"location":"References/class_member_variables/#r","title":"r","text":"<ul> <li>restitution (atlas::box_collider3d)</li> <li>restitutionThreshold (atlas::box_collider3d)</li> <li>Right (atlas::camera)</li> <li>restitution_threshold (atlas::physics::jolt_config)</li> <li>Rotation (atlas::transform)</li> </ul>"},{"location":"References/class_member_variables/#s","title":"s","text":"<ul> <li>Set (atlas::DescriptorSet)</li> <li>specular (atlas::DirectionalLightUbo, atlas::PointLightUbo, atlas::SpotLightUbo)</li> <li>s_instance (atlas::application, atlas::system_registry, atlas::vk::vk_context)</li> <li>size (atlas::box_collider3d)</li> <li>s_loggers (atlas::console_log_manager)</li> <li>sleep_angular_velocity_threshold (atlas::physics::jolt_config)</li> <li>sleep_velocity_threshold (atlas::physics::jolt_config)</li> <li>Scale (atlas::transform)</li> <li>setLayout (atlas::vk::descriptor_writer)</li> <li>Scissor (atlas::vk::shader_pipeline_config)</li> <li>SubpassCount (atlas::vk::shader_pipeline_config)</li> <li>s_driver (atlas::vk::vk_context)</li> <li>s_physical_driver (atlas::vk::vk_context)</li> </ul>"},{"location":"References/class_member_variables/#t","title":"t","text":"<ul> <li>time_before_sleep (atlas::physics::jolt_config)</li> <li>Type (atlas::rigidbody3d)</li> <li>TagMetadata (atlas::tag)</li> <li>TexCoords (atlas::vertex)</li> <li>Transfer (atlas::vk::vk_physical_driver::queue_family_indices)</li> </ul>"},{"location":"References/class_member_variables/#u","title":"u","text":"<ul> <li>Up (atlas::camera)</li> <li>use_fixed_timestep (atlas::physics::jolt_config)</li> <li>use_4_layer_broadphase (atlas::physics::jolt_settings)</li> </ul>"},{"location":"References/class_member_variables/#v","title":"v","text":"<ul> <li>View (atlas::camera, atlas::camera_ubo)</li> <li>velocity_iterations (atlas::physics::jolt_config)</li> <li>value (atlas::vector3&lt; JPH::Vec3 &gt;)</li> <li>Viewport (atlas::vk::shader_pipeline_config)</li> </ul>"},{"location":"References/class_member_variables/#w","title":"w","text":"<ul> <li>Width (atlas::application_settings)</li> <li>WorldUp (atlas::camera)</li> <li>world_unit_scale (atlas::physics::jolt_config)</li> <li>world_bounds_max (atlas::physics::jolt_settings)</li> <li>world_bounds_min (atlas::physics::jolt_settings)</li> <li>width (atlas::renderpass_properties)</li> <li>writes (atlas::vk::descriptor_writer)</li> </ul>"},{"location":"References/class_member_variables/#z","title":"z","text":"<ul> <li>Zoom (atlas::camera)</li> </ul>"},{"location":"References/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"References/class_member_enums/","title":"Class Member Enums","text":""},{"location":"References/class_member_enums/#b","title":"b","text":"<ul> <li>BodyType (atlas::rigidbody3d)</li> </ul>"},{"location":"References/namespace_members/","title":"Namespace Members","text":""},{"location":"References/namespace_members/#a","title":"a","text":"<ul> <li>API (atlas)</li> <li>attach (atlas::sync_update, atlas)</li> </ul>"},{"location":"References/namespace_members/#b","title":"b","text":"<ul> <li>begin_popup_context_window (atlas::ui)</li> <li>button_open_file_dialog (atlas::ui)</li> <li>BeginCommandBuffer (atlas::vk)</li> <li>begin_command_buffer (atlas::vk)</li> <li>begin_single_time_command_buffer (atlas::vk)</li> </ul>"},{"location":"References/namespace_members/#c","title":"c","text":"<ul> <li>CameraMovement (atlas)</li> <li>cursor_position (atlas::event)</li> <li>create (atlas::physics)</li> <li>create_engine (atlas::physics)</li> <li>create_command_buffer_and_record (atlas::vk)</li> <li>create_command_pool (atlas::vk)</li> <li>create_image (atlas::vk)</li> <li>create_image_view (atlas::vk)</li> <li>core_assert (atlas)</li> <li>create_ref (atlas)</li> <li>create_scope (atlas)</li> <li>create_weak_ptr (atlas)</li> </ul>"},{"location":"References/namespace_members/#d","title":"d","text":"<ul> <li>delta_time (atlas::sync_update)</li> <li>dockspace_window (atlas::ui)</li> <li>draw_float (atlas::ui)</li> <li>draw_panel_component (atlas::ui)</li> <li>draw_vec3 (atlas::ui)</li> <li>draw_vec4 (atlas::ui)</li> </ul>"},{"location":"References/namespace_members/#e","title":"e","text":"<ul> <li>EndCommandBuffer (atlas::vk)</li> <li>end_command_buffer (atlas::vk)</li> <li>end_single_time_command_buffer (atlas::vk)</li> </ul>"},{"location":"References/namespace_members/#g","title":"g","text":"<ul> <li>get_joystic_axis (atlas::event)</li> <li>get_thread_count (atlas)</li> </ul>"},{"location":"References/namespace_members/#h","title":"h","text":"<ul> <li>hash_combine (atlas)</li> <li>highp_vec2 (atlas)</li> <li>highp_vec3 (atlas)</li> <li>highp_vec4 (atlas)</li> </ul>"},{"location":"References/namespace_members/#i","title":"i","text":"<ul> <li>ImageFormat (atlas)</li> <li>ImageLayout (atlas, atlas::vk)</li> <li>input_state (atlas::event)</li> <li>is_joystic_present (atlas::event)</li> <li>is_joystick_button_pressed (atlas::event)</li> <li>is_joystick_button_released (atlas::event)</li> <li>is_joystick_guid (atlas::event)</li> <li>is_key_pressed (atlas::event)</li> <li>is_key_released (atlas::event)</li> <li>is_mouse_pressed (atlas::event)</li> <li>is_mouse_released (atlas::event)</li> <li>initialize (atlas::sync_update)</li> <li>initialize_application (atlas)</li> </ul>"},{"location":"References/namespace_members/#j","title":"j","text":"<ul> <li>JoystickCodes (atlas::event)</li> </ul>"},{"location":"References/namespace_members/#k","title":"k","text":"<ul> <li>Key (atlas::event)</li> </ul>"},{"location":"References/namespace_members/#l","title":"l","text":"<ul> <li>load_from_file_dialog (atlas::filesystem)</li> </ul>"},{"location":"References/namespace_members/#m","title":"m","text":"<ul> <li>Mouse (atlas::event)</li> <li>mat (atlas)</li> <li>mat2 (atlas)</li> <li>mat3 (atlas)</li> <li>mat4 (atlas)</li> </ul>"},{"location":"References/namespace_members/#o","title":"o","text":"<ul> <li>on_late_update (atlas::sync_update)</li> <li>on_physics_update (atlas::sync_update)</li> <li>on_ui_update (atlas::sync_update)</li> <li>on_update (atlas::sync_update)</li> </ul>"},{"location":"References/namespace_members/#p","title":"p","text":"<ul> <li>PipelineStageFlags (atlas)</li> <li>post (atlas::sync_update, atlas)</li> <li>pipeline_image_barrier (atlas::vk)</li> </ul>"},{"location":"References/namespace_members/#r","title":"r","text":"<ul> <li>ref (atlas)</li> </ul>"},{"location":"References/namespace_members/#s","title":"s","text":"<ul> <li>ShaderAccessOperation (atlas)</li> <li>SubpassContents (atlas)</li> <li>save_to_file (atlas::filesystem)</li> <li>s_late_update (atlas::sync_update)</li> <li>s_physica_update (atlas::sync_update)</li> <li>s_ui_update (atlas::sync_update)</li> <li>s_update (atlas::sync_update)</li> <li>sync (atlas::sync_update, atlas)</li> <li>sync_physics (atlas::sync_update, atlas)</li> <li>Submit (atlas::vk)</li> <li>SubmitResourceFree (atlas::vk)</li> <li>submit (atlas::vk)</li> <li>scope (atlas)</li> </ul>"},{"location":"References/namespace_members/#t","title":"t","text":"<ul> <li>to_quat (atlas::physics)</li> <li>to_rvec3 (atlas::physics)</li> <li>to_vec3 (atlas::physics)</li> <li>to_weak_ptr (atlas)</li> </ul>"},{"location":"References/namespace_members/#u","title":"u","text":"<ul> <li>update_events (atlas::event)</li> </ul>"},{"location":"References/namespace_members/#v","title":"v","text":"<ul> <li>vk_check (atlas::vk)</li> <li>vk_check_format (atlas::vk)</li> <li>vk_queue_flags_to_string (atlas::vk)</li> <li>vec (atlas)</li> <li>vec2 (atlas)</li> <li>vec3 (atlas)</li> <li>vec4 (atlas)</li> </ul>"},{"location":"References/namespace_members/#w","title":"w","text":"<ul> <li>wait_for_events (atlas::event)</li> <li>weak_ptr (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"References/namespace_member_functions/#a","title":"a","text":"<ul> <li>attach (atlas::sync_update, atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#b","title":"b","text":"<ul> <li>begin_popup_context_window (atlas::ui)</li> <li>button_open_file_dialog (atlas::ui)</li> <li>BeginCommandBuffer (atlas::vk)</li> <li>begin_command_buffer (atlas::vk)</li> <li>begin_single_time_command_buffer (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_functions/#c","title":"c","text":"<ul> <li>cursor_position (atlas::event)</li> <li>create (atlas::physics)</li> <li>create_engine (atlas::physics)</li> <li>create_command_buffer_and_record (atlas::vk)</li> <li>create_command_pool (atlas::vk)</li> <li>create_image (atlas::vk)</li> <li>create_image_view (atlas::vk)</li> <li>core_assert (atlas)</li> <li>create_ref (atlas)</li> <li>create_scope (atlas)</li> <li>create_weak_ptr (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#d","title":"d","text":"<ul> <li>delta_time (atlas::sync_update)</li> <li>dockspace_window (atlas::ui)</li> <li>draw_float (atlas::ui)</li> <li>draw_panel_component (atlas::ui)</li> <li>draw_vec3 (atlas::ui)</li> <li>draw_vec4 (atlas::ui)</li> </ul>"},{"location":"References/namespace_member_functions/#e","title":"e","text":"<ul> <li>EndCommandBuffer (atlas::vk)</li> <li>end_command_buffer (atlas::vk)</li> <li>end_single_time_command_buffer (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_functions/#g","title":"g","text":"<ul> <li>get_joystic_axis (atlas::event)</li> <li>get_thread_count (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#h","title":"h","text":"<ul> <li>hash_combine (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#i","title":"i","text":"<ul> <li>is_joystic_present (atlas::event)</li> <li>is_joystick_button_pressed (atlas::event)</li> <li>is_joystick_button_released (atlas::event)</li> <li>is_joystick_guid (atlas::event)</li> <li>is_key_pressed (atlas::event)</li> <li>is_key_released (atlas::event)</li> <li>is_mouse_pressed (atlas::event)</li> <li>is_mouse_released (atlas::event)</li> <li>initialize (atlas::sync_update)</li> <li>initialize_application (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#l","title":"l","text":"<ul> <li>load_from_file_dialog (atlas::filesystem)</li> </ul>"},{"location":"References/namespace_member_functions/#o","title":"o","text":"<ul> <li>on_late_update (atlas::sync_update)</li> <li>on_physics_update (atlas::sync_update)</li> <li>on_ui_update (atlas::sync_update)</li> <li>on_update (atlas::sync_update)</li> </ul>"},{"location":"References/namespace_member_functions/#p","title":"p","text":"<ul> <li>post (atlas::sync_update, atlas)</li> <li>pipeline_image_barrier (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_functions/#s","title":"s","text":"<ul> <li>save_to_file (atlas::filesystem)</li> <li>sync (atlas::sync_update, atlas)</li> <li>sync_physics (atlas::sync_update, atlas)</li> <li>Submit (atlas::vk)</li> <li>SubmitResourceFree (atlas::vk)</li> <li>submit (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_functions/#t","title":"t","text":"<ul> <li>to_quat (atlas::physics)</li> <li>to_rvec3 (atlas::physics)</li> <li>to_vec3 (atlas::physics)</li> <li>to_weak_ptr (atlas)</li> </ul>"},{"location":"References/namespace_member_functions/#u","title":"u","text":"<ul> <li>update_events (atlas::event)</li> </ul>"},{"location":"References/namespace_member_functions/#v","title":"v","text":"<ul> <li>vk_check (atlas::vk)</li> <li>vk_check_format (atlas::vk)</li> <li>vk_queue_flags_to_string (atlas::vk)</li> </ul>"},{"location":"References/namespace_member_functions/#w","title":"w","text":"<ul> <li>wait_for_events (atlas::event)</li> </ul>"},{"location":"References/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"References/namespace_member_variables/#s","title":"s","text":"<ul> <li>s_late_update (atlas::sync_update)</li> <li>s_physica_update (atlas::sync_update)</li> <li>s_ui_update (atlas::sync_update)</li> <li>s_update (atlas::sync_update)</li> </ul>"},{"location":"References/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"References/namespace_member_typedefs/#h","title":"h","text":"<ul> <li>highp_vec2 (atlas)</li> <li>highp_vec3 (atlas)</li> <li>highp_vec4 (atlas)</li> </ul>"},{"location":"References/namespace_member_typedefs/#m","title":"m","text":"<ul> <li>mat (atlas)</li> <li>mat2 (atlas)</li> <li>mat3 (atlas)</li> <li>mat4 (atlas)</li> </ul>"},{"location":"References/namespace_member_typedefs/#r","title":"r","text":"<ul> <li>ref (atlas)</li> </ul>"},{"location":"References/namespace_member_typedefs/#s","title":"s","text":"<ul> <li>scope (atlas)</li> </ul>"},{"location":"References/namespace_member_typedefs/#v","title":"v","text":"<ul> <li>vec (atlas)</li> <li>vec2 (atlas)</li> <li>vec3 (atlas)</li> <li>vec4 (atlas)</li> </ul>"},{"location":"References/namespace_member_typedefs/#w","title":"w","text":"<ul> <li>weak_ptr (atlas)</li> </ul>"},{"location":"References/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"References/namespace_member_enums/#a","title":"a","text":"<ul> <li>API (atlas)</li> </ul>"},{"location":"References/namespace_member_enums/#c","title":"c","text":"<ul> <li>CameraMovement (atlas)</li> </ul>"},{"location":"References/namespace_member_enums/#i","title":"i","text":"<ul> <li>ImageFormat (atlas)</li> <li>ImageLayout (atlas, atlas::vk)</li> <li>input_state (atlas::event)</li> </ul>"},{"location":"References/namespace_member_enums/#j","title":"j","text":"<ul> <li>JoystickCodes (atlas::event)</li> </ul>"},{"location":"References/namespace_member_enums/#k","title":"k","text":"<ul> <li>Key (atlas::event)</li> </ul>"},{"location":"References/namespace_member_enums/#m","title":"m","text":"<ul> <li>Mouse (atlas::event)</li> </ul>"},{"location":"References/namespace_member_enums/#p","title":"p","text":"<ul> <li>PipelineStageFlags (atlas)</li> </ul>"},{"location":"References/namespace_member_enums/#s","title":"s","text":"<ul> <li>ShaderAccessOperation (atlas)</li> <li>SubpassContents (atlas)</li> </ul>"},{"location":"References/functions/","title":"Functions","text":""},{"location":"References/functions/#c","title":"c","text":"<ul> <li>console_log_error (engine_logger.hpp)</li> <li>console_log_error_tagged (engine_logger.hpp)</li> <li>console_log_fatal (engine_logger.hpp)</li> <li>console_log_fatal_tagged (engine_logger.hpp)</li> <li>console_log_info (engine_logger.hpp)</li> <li>console_log_info_tagged (engine_logger.hpp)</li> <li>console_log_trace (engine_logger.hpp)</li> <li>console_log_trace_tagged (engine_logger.hpp)</li> <li>console_log_warn (engine_logger.hpp)</li> <li>console_log_warn_tagged (engine_logger.hpp)</li> </ul>"},{"location":"References/macros/","title":"Macros","text":""},{"location":"References/macros/#e","title":"e","text":"<ul> <li>ENGINE_API (core.hpp)</li> </ul>"},{"location":"References/macros/#g","title":"g","text":"<ul> <li>GLM_ENABLE_EXPERIMENTAL (components.hpp)</li> <li>GLFW_INCLUDE_VULKAN (vulkan-imports.hpp)</li> </ul>"},{"location":"References/macros/#t","title":"t","text":"<ul> <li>TINYOBJLOADER_IMPLEMENTATION (mesh.hpp)</li> </ul>"},{"location":"References/variables/","title":"Variables","text":""},{"location":"References/variables/#g","title":"g","text":"<ul> <li>g_asset_path (widgets.hpp)</li> </ul>"},{"location":"References/variables/#j","title":"j","text":"<ul> <li>joystick_1 (joystick_codes.hpp)</li> <li>joystick_10 (joystick_codes.hpp)</li> <li>joystick_11 (joystick_codes.hpp)</li> <li>joystick_12 (joystick_codes.hpp)</li> <li>joystick_13 (joystick_codes.hpp)</li> <li>joystick_14 (joystick_codes.hpp)</li> <li>joystick_15 (joystick_codes.hpp)</li> <li>joystick_16 (joystick_codes.hpp)</li> <li>joystick_2 (joystick_codes.hpp)</li> <li>joystick_3 (joystick_codes.hpp)</li> <li>joystick_4 (joystick_codes.hpp)</li> <li>joystick_5 (joystick_codes.hpp)</li> <li>joystick_6 (joystick_codes.hpp)</li> <li>joystick_7 (joystick_codes.hpp)</li> <li>joystick_8 (joystick_codes.hpp)</li> <li>joystick_9 (joystick_codes.hpp)</li> <li>joystick_last (joystick_codes.hpp)</li> </ul>"},{"location":"References/variables/#k","title":"k","text":"<ul> <li>key_0 (key_codes.hpp)</li> <li>key_1 (key_codes.hpp)</li> <li>key_2 (key_codes.hpp)</li> <li>key_3 (key_codes.hpp)</li> <li>key_4 (key_codes.hpp)</li> <li>key_5 (key_codes.hpp)</li> <li>key_6 (key_codes.hpp)</li> <li>key_7 (key_codes.hpp)</li> <li>key_8 (key_codes.hpp)</li> <li>key_9 (key_codes.hpp)</li> <li>key_a (key_codes.hpp)</li> <li>key_apostrophe (key_codes.hpp)</li> <li>key_b (key_codes.hpp)</li> <li>key_backslash (key_codes.hpp)</li> <li>key_backspace (key_codes.hpp)</li> <li>key_c (key_codes.hpp)</li> <li>key_caps_lock (key_codes.hpp)</li> <li>key_comma (key_codes.hpp)</li> <li>key_d (key_codes.hpp)</li> <li>key_delete (key_codes.hpp)</li> <li>key_down (key_codes.hpp)</li> <li>key_e (key_codes.hpp)</li> <li>key_end (key_codes.hpp)</li> <li>key_enter (key_codes.hpp)</li> <li>key_equal (key_codes.hpp)</li> <li>key_escape (key_codes.hpp)</li> <li>key_f (key_codes.hpp)</li> <li>key_f1 (key_codes.hpp)</li> <li>key_f10 (key_codes.hpp)</li> <li>key_f11 (key_codes.hpp)</li> <li>key_f12 (key_codes.hpp)</li> <li>key_f13 (key_codes.hpp)</li> <li>key_f14 (key_codes.hpp)</li> <li>key_f15 (key_codes.hpp)</li> <li>key_f16 (key_codes.hpp)</li> <li>key_f17 (key_codes.hpp)</li> <li>key_f18 (key_codes.hpp)</li> <li>key_f19 (key_codes.hpp)</li> <li>key_f2 (key_codes.hpp)</li> <li>key_f20 (key_codes.hpp)</li> <li>key_f21 (key_codes.hpp)</li> <li>key_f22 (key_codes.hpp)</li> <li>key_f23 (key_codes.hpp)</li> <li>key_f24 (key_codes.hpp)</li> <li>key_f25 (key_codes.hpp)</li> <li>key_f3 (key_codes.hpp)</li> <li>key_f4 (key_codes.hpp)</li> <li>key_f5 (key_codes.hpp)</li> <li>key_f6 (key_codes.hpp)</li> <li>key_f7 (key_codes.hpp)</li> <li>key_f8 (key_codes.hpp)</li> <li>key_f9 (key_codes.hpp)</li> <li>key_g (key_codes.hpp)</li> <li>key_gravity_accent (key_codes.hpp)</li> <li>key_h (key_codes.hpp)</li> <li>key_home (key_codes.hpp)</li> <li>key_i (key_codes.hpp)</li> <li>key_insert (key_codes.hpp)</li> <li>key_j (key_codes.hpp)</li> <li>key_k (key_codes.hpp)</li> <li>key_kp_0 (key_codes.hpp)</li> <li>key_kp_1 (key_codes.hpp)</li> <li>key_kp_2 (key_codes.hpp)</li> <li>key_kp_3 (key_codes.hpp)</li> <li>key_kp_4 (key_codes.hpp)</li> <li>key_kp_5 (key_codes.hpp)</li> <li>key_kp_6 (key_codes.hpp)</li> <li>key_kp_7 (key_codes.hpp)</li> <li>key_kp_8 (key_codes.hpp)</li> <li>key_kp_9 (key_codes.hpp)</li> <li>key_kp_add (key_codes.hpp)</li> <li>key_kp_decimal (key_codes.hpp)</li> <li>key_kp_divide (key_codes.hpp)</li> <li>key_kp_enter (key_codes.hpp)</li> <li>key_kp_equal (key_codes.hpp)</li> <li>key_kp_multiply (key_codes.hpp)</li> <li>key_kp_subtract (key_codes.hpp)</li> <li>key_l (key_codes.hpp)</li> <li>key_left (key_codes.hpp)</li> <li>key_left_alt (key_codes.hpp)</li> <li>key_left_bracket (key_codes.hpp)</li> <li>key_left_control (key_codes.hpp)</li> <li>key_left_shift (key_codes.hpp)</li> <li>key_left_super (key_codes.hpp)</li> <li>key_m (key_codes.hpp)</li> <li>key_menu (key_codes.hpp)</li> <li>key_minus (key_codes.hpp)</li> <li>key_n (key_codes.hpp)</li> <li>key_num_lock (key_codes.hpp)</li> <li>key_o (key_codes.hpp)</li> <li>key_p (key_codes.hpp)</li> <li>key_page_down (key_codes.hpp)</li> <li>key_page_up (key_codes.hpp)</li> <li>key_pause (key_codes.hpp)</li> <li>key_period (key_codes.hpp)</li> <li>key_print_screen (key_codes.hpp)</li> <li>key_q (key_codes.hpp)</li> <li>key_r (key_codes.hpp)</li> <li>key_right (key_codes.hpp)</li> <li>key_right_alt (key_codes.hpp)</li> <li>key_right_bracket (key_codes.hpp)</li> <li>key_right_control (key_codes.hpp)</li> <li>key_right_shift (key_codes.hpp)</li> <li>key_right_super (key_codes.hpp)</li> <li>key_s (key_codes.hpp)</li> <li>key_scroll_lock (key_codes.hpp)</li> <li>key_semicolon (key_codes.hpp)</li> <li>key_slash (key_codes.hpp)</li> <li>key_space (key_codes.hpp)</li> <li>key_tab (key_codes.hpp)</li> <li>key_u (key_codes.hpp)</li> <li>key_up (key_codes.hpp)</li> <li>key_v (key_codes.hpp)</li> <li>key_w (key_codes.hpp)</li> <li>key_world_1 (key_codes.hpp)</li> <li>key_world_2 (key_codes.hpp)</li> <li>key_x (key_codes.hpp)</li> <li>key_y (key_codes.hpp)</li> <li>key_z (key_codes.hpp)</li> </ul>"},{"location":"References/variables/#m","title":"m","text":"<ul> <li>mouse_button_0 (mouse_codes.hpp)</li> <li>mouse_button_1 (mouse_codes.hpp)</li> <li>mouse_button_2 (mouse_codes.hpp)</li> <li>mouse_button_3 (mouse_codes.hpp)</li> <li>mouse_button_4 (mouse_codes.hpp)</li> <li>mouse_button_5 (mouse_codes.hpp)</li> <li>mouse_button_6 (mouse_codes.hpp)</li> <li>mouse_button_7 (mouse_codes.hpp)</li> <li>mouse_button_last (mouse_codes.hpp)</li> <li>mouse_button_left (mouse_codes.hpp)</li> <li>mouse_button_middle (mouse_codes.hpp)</li> <li>mouse_button_right (mouse_codes.hpp)</li> </ul>"},{"location":"References/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}