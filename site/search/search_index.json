{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udfe1 HomeWelcome to Engine3D","text":""},{"location":"#overview","title":"Overview","text":"<p>Engine3D is a cross-platform 3D game engine. That strives to be powerful with no restrictions to the user. Allowing to be used for educational, creative, and commerical purpose games.</p> <p>Engine3D's design rules should be:</p> <ol> <li>Portable and Cross-platform</li> <li>Easy to Build</li> <li>Graphics API-agnostic Rendering</li> <li>Safe, Reliable, and Testable or can be Tested</li> </ol>"},{"location":"about/","title":"About","text":""},{"location":"about/#engine3d","title":"Engine3D","text":"<p>Engine3D is an interactive 3D cross-platform application - otherwise a game engine. Engine3D was a project that I had started towards the end of 2023, developed by Aaron (SpinnerX). Deciding on this project to become open-source starting Fall 2024. </p> <p>Engine3D-Dev is the organization that helps maintain the Engine3D project, working to build engine3d to enable users to make commercialized games, artwork for assets, animations, and other forms of engine capabilities. Aaron created Engine3D for students who are passionate about both making games and interested in being part of a community in developing a game engine. Where you can make commercialized games using our internal toolings that Engine3D would provide.</p>"},{"location":"about/#why-make-a-game-engine-what-started-this-project","title":"Why make a Game Engine? What started this project?","text":"<p>To describe simply: because of having a passion for engine development and the curiosity to get better at designing APIs architecturally, thinking outside the box.</p> <p>To explain further, Aaron started this project building a game engine for a few reasons: passion creativity, and curiosity in how various technologies operate in an engine. This is because when looking at a game engine. There is a wide variety of subsystems that are involved to making an engine work. Meaning there is always room to continue learning and growing from both technical and design standpoints.</p>"},{"location":"about/#plans-for-the-future","title":"Plans for the future","text":"<ul> <li> <p>Continue developing for Engine3D to build very interesting projects.</p> </li> <li> <p>Open-source project for users and developers to have a tool to develop games with familiar API.</p> </li> <li> <p>Develop commercialized games that can be used to export in game jams having a sense of satisfaction on a project they know they've worked on.</p> </li> </ul>"},{"location":"getting_started/","title":"\ud83d\udef8 Getting Started","text":""},{"location":"getting_started/#prerequisites","title":"\u2705 Prerequisites","text":"<p>These are needed before working to get engine3d building successfully on your platform.</p> <ul> <li><code>python</code>: 3.12 or above</li> <li><code>conan</code>: 2.10.0 or above</li> <li><code>llvm</code>: 17 or above</li> <li><code>make</code>: CMake downloaded using conan to build Engine3D</li> <li><code>git</code>: (only needs to be installed via installer on Windows)</li> <li><code>Visual Studio Installer</code>: (Installer is for MSBuild to get C++ working on Windows)</li> </ul> WindowsUbuntuMac OS <p>Info</p> <p>Needs to install Visual Studio's installer before using the <code>winget</code> command</p> <p>Run this <code>winget</code> command to setup C++ with Visual Studio installer in powershell (in admin mode)</p> <pre><code>winget install Microsoft.VisualStudio.2022.BuildTools --override \"--add Microsoft.VisualStudio.Workload.VCTools --includeRecommended -p --installWhileDownloading\"\n</code></pre> <p>It is recommended to use Choco for an easy installation process on Windows.</p> <p>To install <code>choco</code>, open powershell with admin access and run the following command in your terminal (powershell must be admin):</p> <pre><code>Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n</code></pre> <p>Tip</p> <p>If <code>choco</code> command does not work after running this script try closing and reopening powershell again. When <code>choco</code> prompts you to run install scripts from the commands below, enter <code>all</code> so it can install everything.</p> <p>Install <code>git</code> (powershell must be admin): <pre><code>choco install git\n</code></pre></p> <p>Install <code>python</code> (powershell must be admin): <pre><code>choco install python --version=3.12.0\n</code></pre></p> <p>Install <code>llvm</code> (powershell must be admin):</p> <p>Error</p> <p>If you get this error make sure that your environment variable is set to LLVM's clang.exe and clang++.exe filepath.</p> <p>While also making sure </p> <pre><code>CMake Error at CMakeLists.txt:2 (project):\nThe CMAKE_CXX_COMPILER:\n\n    C:/Program Files/LLVM/bin/clang++.exe\n\nis not a full path to an existing compiler tool.\n</code></pre> <pre><code>choco install llvm\n</code></pre> <p>Install <code>conan</code> (powershell must be admin) <pre><code>pip install \"conan&gt;=2.10.2\"\n</code></pre></p> <p>Install cmake and make</p> <p>Error</p> <p>you can get this error if you DO NOT have 'make' installed via choco</p> <pre><code>CMake Error: CMake was unable to find a build program corresponding to \"Unix Makefiles\".  CMAKE_MAKE_PROGRAM is not set.  You probably need to select a different build tool.\n</code></pre> <p>Error</p> <p>you can get this error if you DO NOT have 'mingw' installed via choco</p> <p>CMake Error: CMake was unable to find a build program corresponding to \"MinGW Makefiles\".  CMAKE_MAKE_PROGRAM is not set.  You probably need to select a different build tool.</p> <pre><code>choco install make cmake\n</code></pre> <p>Info</p> <p>mingw is installed because we need <code>mingw32-make.exe</code> as dependencies will default to using \"MinGW Makefiles\" generator specified. which means that their CMake will look for <code>mingw32-make.exe</code> specific make executables instead of <code>make.exe</code></p> <p>Install mingw <pre><code>choco install mingw\n</code></pre></p> <p>Info</p> <p>Using this <code>winget</code> command will install Vulkan's installer, set it up for you, and set the environment path variable.</p> <p>Installing Vulkan's installer from the terminal in powershell. (in admin mode) <pre><code>winget install --id=KhronosGroup.VulkanSDK -e\n</code></pre></p> <p>Tip</p> <p>Once you have completely finish installing. DONT FORGET to refresh your powershell before building the engine3d project.</p> <p>Install wget if it isn't already on your system</p> <p><code>sudo apt-get install wget</code></p> <p>Install the latest version of <code>llvm</code></p> <pre><code>wget https://apt.llvm.org/llvm.sh\nchmod +x llvm.sh\nsudo ./llvm.sh\n</code></pre> <p>Info</p> <p>If your using 20.04, you have to upgrade Python to 3.10</p> <pre><code>sudo apt update\nsudo apt install software-properties-common -y\nsudo add-apt-repository ppa:deadsnakes/ppa\nsudo apt install Python3.10\n</code></pre> <p>Installing Conan <pre><code>python -m pip install -U \"conan&gt;=2.2.2\"\n</code></pre></p> <p>On Linux vulkan does not need </p> <p>Install Homebrew:</p> <p><pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> Install latest version of Python &amp;&amp; llvm:</p> <pre><code>brew install python\nbrew install llvm@17\n</code></pre> <p>Install conan:</p> <p>Tip</p> <p>If using the conan command does not work after pip installing.</p> <p>Type the <code>brew install conan</code> command, instead.</p> <pre><code>python3 -m pip install \"conan&gt;=2.2.2\"\n</code></pre> <p>Make <code>clang-tidy</code> available on the command line:</p> <pre><code>sudo ln -s $(brew --prefix llvm)/bin/clang-tidy /usr/local/bin/\n</code></pre> <p>Install Rosetta (only required for M1 macs):</p> <pre><code>/usr/sbin/softwareupdate --install-rosetta --agree-to-license\n</code></pre> <pre><code>curl -O https://sdk.lunarg.com/sdk/download/1.3.290.0/mac/vulkansdk-macos-1.3.290.0.dmg ${HOME}/Downloads\n</code></pre> <p>During the installation select the checkbox's shown below.</p> <p></p> <p>Once vulkan's installed apply the following export commands into your mac's <code>.zshrc</code> file</p> <pre><code>    export VULKAN_SDK=\"${HOME}/VulkanSDK/1.3.290.0/macOS\"\n    export DYLD_LIBRARY_PATH=\"${VULKAN_SDK}/lib/libvulkan.1.3.290.dylib\"\n    export VK_ICD_FILENAMES=\"$VULKAN_SDK/share/vulkan/icd.d/MoltenVK_icd.json\"\n    export VK_LAYER_PATH=\"$VULKAN_SDK/share/vulkan/explicit_layer.d\"\n</code></pre> <p>Note</p> <p>To check if vulkan is installed, you should be able to type the following command <code>vkvia</code></p> <p>This runs the vulkan basic cube program validating vulkan's been installed correctly.</p> <p>After adding these exports, refresh your <code>.zshrc</code> by doing <code>source ~/.zshrc</code></p>"},{"location":"getting_started/#setting-up-conan","title":"Setting up Conan","text":"<p>Now continue and setup conan</p> <p>Setting up conan platform-dependent profile.</p> WindowsX86 LinuxM1 Mac <p>If you are on an x86 architecture for Windows.</p> <pre><code>conan config install -sf profiles/x86_64/Windows/ -tf profiles https://github.com/engine3d-dev/conan-config.git\n</code></pre> <p>If you are on a linux platform that uses an x86 architecture.</p> <pre><code>conan config install -sf profiles/x86_64/linux/ -tf profiles https://github.com/engine3d-dev/conan-config.git\n</code></pre> <p>If you are on an M1 Mac OS.</p> <pre><code>conan config install -sf profiles/armv8/mac/ -tf profiles https://github.com/engine3d-dev/conan-config.git\n</code></pre>"},{"location":"getting_started/#getting-engine3d-conan-packages","title":"Getting engine3d conan packages","text":"<p>Add the engine3d-conan repository to your system. This repository holds all of the engine3d packages.</p> <pre><code>conan remote add engine3d-conan https://libhal.jfrog.io/artifactory/api/conan/engine3d-conan\n</code></pre>"},{"location":"getting_started/#contributing-to-engine3d","title":"Contributing to Engine3D","text":"<p>If you want to contribute to Engine3D, create either a new branch to the engine3d repository.</p> <pre><code>git clone https://github.com/engine3d-dev/engine3d\ncd engine3d/\n\nconan build . -b missing\n</code></pre> <p>Tip</p> <p><code>-b missing</code> will build and install any missing binaries of your dependencies into conan cache</p> <p>Info</p> <p><code>conan build .</code> will build the entire project</p> <p>The editor executable can be found in the path <code>build/Release/Editor/Editor.exe</code></p>"},{"location":"getting_started/#different-build-types","title":"Different Build Types","text":"<p>There are two different build types that you can build engine3d in, <code>Release</code> and <code>Debug</code>.</p> <p><code>Release</code> will be turning on optimization and making your code size.</p> <p><code>Debug</code> is much slower than <code>Release</code>. Not recommended because used for testing and enabling debugging information.</p>"},{"location":"summary/","title":"Summary","text":"<p>home</p>"},{"location":"contributors_guide/code/","title":"Code Design","text":"<p>The following guidelines desribe what should be kept in mind when creating interfaces, library code, or core engine3d code.</p>"},{"location":"contributors_guide/code/#smallest-possible-vtable","title":"Smallest Possible VTable","text":"<p>When designing either game application or core engine3d API's, or engine3d library code. Minimize least number of virtual functions, if possible.</p>"},{"location":"contributors_guide/code/#why","title":"Why?","text":"<p>Each virtual function in the interface will require a v-table entry (pointer) in the v-table of each implementation of that interface. Each entry takes up space in the <code>.text</code> or <code>.rodata</code> sections of the binary. The more you you have the more space is taken up.</p>"},{"location":"contributors_guide/code/#consider","title":"Consider:","text":"<p>Combining API's if possible. For example lets consider <code>engine3d::world</code>.</p> <p><code>engine3d::world</code> could have different <code>OnUpdate*</code> functions that may be needed to update at different points in the game. Such as phyiscs may not be updated every frame while rendering may be done every frame.</p> <p><code>Engine3D</code> uses a method calls subscription. Where we have update managers that know how to handle when scenes should update their scene objects.</p> <p>Example: <pre><code>#include &lt;engine3d/world.hpp&gt;\n\nclass game_world : public engine3d::world{\npublic:\n    game_world(){\n        subscribe(this, &amp;game_world::on_update);\n        subscribe(this, &amp;game_world::on_update_physics);\n    }\n\n    void on_update() { /* .. */ }\n\n    void on_update_physics() { /* ... */ }\n};\n</code></pre></p>"},{"location":"contributors_guide/code/#make-virtual-functions-pure-virtual","title":"Make virtual functions pure virtual","text":"<p>Interfaces API implementations are responsible to the user of the implementation</p>"},{"location":"contributors_guide/code/#why_1","title":"Why?","text":"<p>In almost all cases, default behavior does not make sense.</p>"},{"location":"contributors_guide/code/#eliminate-viral-behavior","title":"Eliminate Viral Behavior","text":"<p>Another way of phrasing this is, \"Consider the overhead by the developer\". This can be space and time overhead in the game application or simply overhead required by the developer to using our API's correctly.</p>"},{"location":"contributors_guide/code/#private-virtual-functions","title":"Private Virtual Functions","text":"<p>Making virtual functions private. Make them callable via public interfaces like:</p> <pre><code>class VertexBuffer{\npublic:\n    void SetDaa(std::vector&lt;Vertex&gt;&amp; p_Vertices){\n        return WriteData(p_Vertices);\n    }\n\nprotected:\n    virtual void WriteData(const std::string&amp; p_Filename) = 0;\n};\n</code></pre>"},{"location":"contributors_guide/code/#why_2","title":"Why?","text":"<p>If in the event we need to modify calling conventions of virtual API's, we can do so by altering the public API that calls our virtual API.</p>"},{"location":"contributors_guide/code/#consider-stack-ram-and-rom-requirements-of-an-api","title":"Consider Stack, RAM, and ROM requirements of an API.","text":"<p>Some API designs have unwanted side effects of causing the user to provide or allocate a large buffer in order to operate. For example:</p> <pre><code>class SomeDataStructure{\npublic:\n    struct Properties{\n        std::vector&lt;T&gt; SomeBuffer\n    };\n\n    void OnInitialize(SomeDataStructure) = 0;\n\nprotected:\n    virtual void Initialize() = 0;\n};\n</code></pre>"},{"location":"contributors_guide/code/#why_3","title":"Why?","text":"<p>If we have some interface that has some struct would make interfaces and API's difficult to use because now every other user who calls our API now has to use up a lot of resources when making a call to this interface.</p>"},{"location":"contributors_guide/code/#consider_1","title":"Consider:","text":"<p>If the struct or inputs have to be so large? What pieces in which those structures should be separated? Are there ways around implementing it differently?</p>"},{"location":"contributors_guide/code/#should-contain-no-members","title":"Should contain NO members.","text":"<p>Interfaces should only have public member functions and private member functions. Nothing more.</p>"},{"location":"contributors_guide/code/#why_4","title":"Why?","text":"<p>Primary purpose of interfaces is to define an abstract layer to communicate between parts of a program. Interfaces should ideally be agnostic of how their contracts are fullfilled. Including member fields implied by certain level of implementation detail that detracts from abstraction.</p> <p>By adding fields to an interfacfes lead to tighter coupling between interface and its implementation. This can complicate design and increase difficulty in the future. Implementations are forced to manage these state in a specific way, which can reduce flexibility in how they are manage their internal states and behaviors.</p> <p>Consider:</p> <p>YOU DO NOT need to add data members to interfaces.</p>"},{"location":"contributors_guide/code/#must-not-be-a-template","title":"Must not be a template","text":"<p>A templated interface is a class that is an interface like the following example:</p> <pre><code>template&lt;typename Type&gt;\nclass AgnosticInterface{\nprivate:\n    virtual void OnCreate(Type p_Type) = 0;\n};\n</code></pre>"},{"location":"contributors_guide/code/#why_5","title":"Why?","text":"<p>The above code seems like a great way to broaden an interface to unlimited scale, but that is the problem.</p> <p>Template interfaces widen the scope and number of interfaces available in <code>engine3d</code> in an unbounded way. Which can lead to result in additional v-tables for each implementation.</p> <p>Interface instances with different template types are not compatible with each other. Meaning an adaptor of sources would be needed to convert one to another.</p>"},{"location":"contributors_guide/code/#consider_2","title":"Consider:","text":"<p>That's not necessary. Consider there exists a generic and specific implementation of an interface. Considering making two interfaces if a single interface would not suffice.</p>"},{"location":"contributors_guide/code/#prefer-wide-api-contracts","title":"Prefer Wide API contracts.","text":"<p>A wide contract for an API means that an API can take any type of input for all input parameters set to the API. Meaning that API is well-defined for all possible inputs that could be pasesed. That does not mean that implementation fo API will accept all possible inputs. The API could throw an erro if input is beyond what it is capable of working with. But simply means that API is well defined for whole range of inputs.</p>"},{"location":"contributors_guide/code/#why_6","title":"Why?","text":"<p>It eliminates viral behavior and tends to eliminate undefined behavior.</p>"},{"location":"contributors_guide/code/#consider_3","title":"Consider:","text":"<p>Cost of an API having a wide contract? Would this result in viral behavior or eliminate it? Woulkd it result in worse performance? Would it result in increased RAM oir increased ROM utilization? Would it potentially save in all of these. If possible try and gurantee wide contracts if possible and only consider a narrow contract as a last resort.</p>"},{"location":"contributors_guide/code/#do-not-break-abi","title":"Do NOT break ABI","text":"<p>ABI means \"Application Binary Interface\".  A breakaage to an ABI is not easy for C++ or other languages to determine. ABI break can be in many forms, usually comes at a change between version of code compiled previously and a version of code compiled currently. Such a break can result in memory corruption, invalid input to a function and overall undefined behavior.</p>"},{"location":"contributors_guide/code/#why_7","title":"Why?","text":"<p>Don't do it! Its bad! Honestly, if all hell breaks loose if we allow ABI breaks. If we MUST break ABI we must update the major version number of Engine3D.</p>"},{"location":"contributors_guide/code/#consider_4","title":"Consider:","text":"<p>Regarding interfaces, given other rules, there is really only the following possible ABI breakjing changes can occur:</p> <ol> <li> <p>Changing return value of a virtual function.</p> </li> <li> <p>Changing function calling conventions.</p> </li> <li> <p>Reordering of virtual API within an interface.</p> </li> <li> <p>Reordering of members within a returned <code>struct</code> or <code>class</code>.</p> </li> </ol> <p>These are not allowed due to how they effect programs generate assembly for each function call. What we are allowed to do is the following:</p> <ol> <li> <p>Add additional non-virtual public functions.</p> </li> <li> <p>Add additional overloads for public functions (we should [[deprecate]] old API's we know to be harmful).</p> </li> <li> <p>Add additional non-pure virtual API's below current set of virtual API's (avoid this)</p> </li> <li> <p>Add additional fields to a setting <code>struct</code> that is passed by reference.</p> </li> </ol>"},{"location":"contributors_guide/code/#interface-independence-principle","title":"Interface Independence Principle","text":"<p>Interfaces should not be designed to have a relationship with each other outside of an IS-A or inheritance relationship. An allowed relationship is one where an interface inherits from another. Such as <code>GraphicContext</code> and <code>VulkanContext</code> because it has the same requirements and some additional ones.</p> <p>An example of a relationship that is not acceptable would be if there existed a <code>VertexBuffer</code> interface and a <code>Buffer</code> interface. Technically they have a relationship between these two interfaces. One could even consider that the VertexBuffer could be a \"producer\" or \"provider\" of vertices that is established by this interface. Such as that if VertexBuffer interface returns a reference to an available Buffer interface. This can complicate implementations of these interfaces, as well coupling them. The memory and lifetime of that Buffer than becomes a concern of <code>wifi</code> as well any of its users.</p> <p>Overall this results in VERY much complex code and more coupling then necessary. Better option is to keep everything independent from each other.</p> <p>To follow this rule, refrain from:</p> <ol> <li> <p>Returning an interface from function in any way.</p> </li> <li> <p>Taking another interface as an input parameter.</p> </li> </ol> <p>Instead there needs to be some sort of relationship between interfaces, then this type of relationship should be managed by concrete classes that can take dependent objects with a relationship and manage that relationship.</p>"},{"location":"contributors_guide/code/#templates-in-utility","title":"Templates in Utility","text":"<p>In the case that we need to deal with multiple data types from various frameworks. Refrain from adding them into a single class.</p> <p>Consider the following:</p> <pre><code>class Vector3{\npublic:\n    template&lt;JPH::Vector3 Type&gt;\n    void SetPosition(Type p_Position){\n        m_Position = {p_Position.GetX(), p_Position.GetY(), p_Position.GetZ()};\n    }\n\n    template&lt;typename T&gt;\n    T GetPosition(){\n        if constexpr (std::is_same_v&lt;T, JPH::Vector3&gt;){\n            return static_cast&lt;T&gt;(m_Position);\n        }\n    }\n\nprivate:    \n    glm::vec3 m_Position;\n};\n</code></pre>"},{"location":"contributors_guide/code/#why_8","title":"Why?","text":"<p>This code may seem like a way to broaden Vec3 to work with different variations of Vector data types. That is the problem.</p> <p>By having Vector3 take in templates for SetPosition and GetPosition may complicate things because there are different variations of how other frameworks define their vector data type's.</p> <p>If we a single function gets more complicated because there are variations of the same type, then separate those functions. By making a single generic function that handles converting those functions can overcomplicate things.</p>"},{"location":"contributors_guide/code/#consider_5","title":"Consider:","text":"<p>Is there a way we can implement around this? Why not just separate the functions to explicitly handle those functions? If we generically have a single function to do this how can we ensure this works across all data types.</p>"},{"location":"contributors_guide/design/","title":"Code Design Philosophy","text":"<p>These are core designs that Engine3D and other Engine3D libraries should seek to achieve with every design decision, line written, and architectural design changes made.</p> <p>Design.1 Multi Targeted</p> <p><code>Engine3D</code> and other Engine3D libraries should work on all platforms Windows, Linux, and Mac. As long the appropriate compiler or cross-compiler is used.</p> <p>Design 2 - Light Weight</p> <p><code>Engine3D</code> drivers, core, and utility code should be kept lightweight. Meaning ensuring that if things need to be allocated that they are only decided if no other option is proposed. Ensure that when doing allocations that YOU DO NOT use raw pointers. If you have to use pointers ask yourself the reason to use pointers.  If you need to use pointers, specifically use smart pointers (shared_ptr, unique_ptr).</p> <p>Design 3 - Minimalist</p> <p><code>Engine3D</code> strives to be as simple and no simpler. Core, utility, and libraries should be straight forward to the programmers to understand with added complexity when no other option exists.</p> <p>Design 4 - Safe and Reliability</p> <p><code>Engine3D</code> and it's style guide aim to use patterns, techniques, documentation to help reduce safety issues and improve reliability.</p>"},{"location":"contributors_guide/style/","title":"Style Guide","text":"<p>Style 0 - Code Guidelines</p> <p>All guides followm the C++ Core Guidelines</p> <p>Style 1 - Formatting</p> <ul> <li> <p>Code shall follow engine3d's <code>.clang-format</code> file, which uses the Mozilla C++ style format as a base with some adjustments.</p> </li> <li> <p>Code shall use PacalCase for classes to indicate unique class names and template arguments.</p> </li> <li> <p>CAP_CASE for MACROs (avoid using macros entirely)</p> </li> <li> <p>prefix <code>p_</code> for function parameters</p> </li> <li> <p>prefix <code>m_</code> for private/protected class member variables.</p> </li> <li> <p>Refrain from abbreviated variable name. Dont do <code>m_cnt</code> and just write out <code>m_count</code>.</p> </li> <li> <p>Use <code>#pragma once</code> as the include guard in headers.</p> </li> <li> <p>Every file should end with new character.</p> </li> <li> <p>Every line in a file must stay within 80-character limit.</p> </li> <li> <p>Every public API need to be documented with doxygen style comments.</p> </li> <li> <p>Include C++ header versions of C headers such as <code>&lt;cstdint&gt;</code> vs <code>&lt;stdint.h&gt;</code></p> </li> </ul>"}]}